//  -*- Mode: Java -*-
//
// _StartupPli.java

/*
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2017      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
*/

package edu.isi.powerloom;

import edu.isi.stella.javalib.Native;
import edu.isi.stella.javalib.StellaSpecialVariable;
import edu.isi.powerloom.logic.*;
import edu.isi.stella.*;

public class _StartupPli {
  static void helpStartupPli1() {
    {
      PLI.SGT_PLI_ENVIRONMENT = ((Surrogate)(GeneralizedSymbol.internRigidSymbolWrtModule("ENVIRONMENT", null, 1)));
      PLI.SYM_LOGIC_LEVEL = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("LEVEL", Stella.getStellaModule("/LOGIC", true), 0)));
      PLI.SGT_PLI_PL_ITERATOR = ((Surrogate)(GeneralizedSymbol.internRigidSymbolWrtModule("PL-ITERATOR", null, 1)));
      PLI.SYM_PLI_pR = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("?R", null, 0)));
      PLI.SYM_PLI_pI = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("?I", null, 0)));
      PLI.SYM_PLI_pV = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("?V", null, 0)));
      PLI.SYM_PLI_F_GET_INFERRED_BINARY_PROPOSITION_VALUES_QUERY_000 = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("F-GET-INFERRED-BINARY-PROPOSITION-VALUES-QUERY-000", null, 0)));
      PLI.SYM_PLI_PROPER_SUBRELATION = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("PROPER-SUBRELATION", null, 0)));
      PLI.KWD_CASE_SENSITIVEp = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("CASE-SENSITIVE?", null, 2)));
      PLI.KWD_SUBSET_OF = ((Keyword)(GeneralizedSymbol.internRigidSymbolWrtModule("SUBSET-OF", null, 2)));
      PLI.SGT_PL_KERNEL_KB_NTH_DOMAIN = ((Surrogate)(GeneralizedSymbol.internRigidSymbolWrtModule("NTH-DOMAIN", Stella.getStellaModule("/PL-KERNEL-KB", true), 1)));
      PLI.SYM_PLI_STARTUP_PLI = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("STARTUP-PLI", null, 0)));
    }
  }

  static void helpStartupPli2() {
    {
      Stella.defineFunctionObject("INITIALIZE", "(DEFUN INITIALIZE () :DOCUMENTATION \"Initialize the PowerLoom logic system.  This function\nneeds to be called by all applications before using PowerLoom.  If it\nis called more than once, every call after the first one is a no-op.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.powerloom.PLI", "initialize", new java.lang.Class [] {}), null);
      Stella.defineFunctionObject("RESET-POWERLOOM", "(DEFUN RESET-POWERLOOM () :DOCUMENTATION \"Reset PowerLoom to its initial state.\nCAUTION: This will destroy all loaded knowledge bases and might break other\nloaded STELLA systems if they do reference PowerLoom symbols in their code.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.powerloom.PLI", "resetPowerloom", new java.lang.Class [] {}), null);
      Stella.defineFunctionObject("CLEAR-CACHES", "(DEFUN CLEAR-CACHES () :DOCUMENTATION \"Clear all query and memoization caches.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.powerloom.PLI", "clearCaches", new java.lang.Class [] {}), null);
      Stella.defineFunctionObject("TEST-ENVIRONMENT-LEVEL?", "(DEFUN (TEST-ENVIRONMENT-LEVEL? BOOLEAN) ((ENV ENVIRONMENT) (LEVEL STRING)) :PUBLIC? FALSE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Test if `env' has level set to `level'\" (RETURN (AND (DEFINED? ENV) (STRING-EQL? (LEVEL ENV) LEVEL))))", Native.find_java_method("edu.isi.powerloom.Environment", "testEnvironmentLevelP", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.Environment"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineMethodObject("(DEFMETHOD (NEXT? BOOLEAN) ((SELF PL-ITERATOR)) :PUBLIC? TRUE :DOCUMENTATION \"Advance the PL-Iterator `self' and return `true' if more\nelements are available, `false' otherwise.\")", Native.find_java_method("edu.isi.powerloom.PlIterator", "nextP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (EMPTY? BOOLEAN) ((SELF PL-ITERATOR)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if the iterator `self' has no more elements.\")", Native.find_java_method("edu.isi.powerloom.PlIterator", "emptyP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (LENGTH INTEGER) ((SELF PL-ITERATOR)) :PUBLIC? TRUE :DOCUMENTATION \"Number of items remaining in `self'.  Non destructive.\")", Native.find_java_method("edu.isi.powerloom.PlIterator", "length", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("CONS-TO-PL-ITERATOR", "(DEFUN (CONS-TO-PL-ITERATOR PL-ITERATOR) ((SELF CONS)) :PUBLIC? FALSE :DOCUMENTATION \"Convert a Stella cons list into an API iterator.\")", Native.find_java_method("edu.isi.powerloom.PLI", "consToPlIterator", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineFunctionObject("LIST-TO-PL-ITERATOR", "(DEFUN (LIST-TO-PL-ITERATOR PL-ITERATOR) ((SELF LIST)) :PUBLIC? FALSE :DOCUMENTATION \"Convert a Stella list into an API iterator.\")", Native.find_java_method("edu.isi.powerloom.PLI", "listToPlIterator", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.List")}), null);
      Stella.defineFunctionObject("ITERATOR-TO-PL-ITERATOR", "(DEFUN (ITERATOR-TO-PL-ITERATOR PL-ITERATOR) ((SELF ITERATOR)) :PUBLIC? FALSE :DOCUMENTATION \"Convert an arbitrary Stella iterator into an API iterator.\")", Native.find_java_method("edu.isi.powerloom.PLI", "iteratorToPlIterator", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Iterator")}), null);
      Stella.defineMethodObject("(DEFMETHOD (LISTIFY LIST) ((SELF PL-ITERATOR)) :PUBLIC? TRUE :DOCUMENTATION \"Convert `self' into a Stella LIST.\")", Native.find_java_method("edu.isi.powerloom.PlIterator", "listify", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (CONSIFY CONS) ((SELF PL-ITERATOR)) :PUBLIC? TRUE :DOCUMENTATION \"Convert `self' into a Stella CONS.\")", Native.find_java_method("edu.isi.powerloom.PlIterator", "consify", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("SAFELY-GET-OBJECT", "(DEFUN (SAFELY-GET-OBJECT OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)", Native.find_java_method("edu.isi.powerloom.PLI", "safelyGetObject", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("SAFELY-GET-CONCEPT", "(DEFUN (SAFELY-GET-CONCEPT OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)", Native.find_java_method("edu.isi.powerloom.PLI", "safelyGetConcept", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("SAFELY-GET-RELATION", "(DEFUN (SAFELY-GET-RELATION OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)", Native.find_java_method("edu.isi.powerloom.PLI", "safelyGetRelation", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("SAFELY-GET-MODULE", "(DEFUN (SAFELY-GET-MODULE CONTEXT) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)", Native.find_java_method("edu.isi.powerloom.PLI", "safelyGetModule", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("SAFELY-GET-OBJECT-OR-NULL", "(DEFUN (SAFELY-GET-OBJECT-OR-NULL OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)", Native.find_java_method("edu.isi.powerloom.PLI", "safelyGetObjectOrNull", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("SEQUENCE-TO-CONS-LIST", "(DEFUN (SEQUENCE-TO-CONS-LIST CONS) ((SEQUENCE OBJECT)) :PUBLIC? FALSE)", Native.find_java_method("edu.isi.powerloom.PLI", "sequenceToConsList", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("EXPLODE-STRING-LIST", "(DEFUN (EXPLODE-STRING-LIST CONS) ((STRINGLIST STRING) (MODULE MODULE)) :PUBLIC? FALSE)", Native.find_java_method("edu.isi.powerloom.PLI", "explodeStringList", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Module")}), null);
      Stella.defineFunctionObject("LEGAL-OPERATOR?", "(DEFUN (LEGAL-OPERATOR? BOOLEAN) ((OPERATOR SYMBOL)) :PUBLIC? FALSE)", Native.find_java_method("edu.isi.powerloom.PLI", "legalOperatorP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Symbol")}), null);
      Stella.defineFunctionObject("GET-KEYWORD", "(DEFUN (GET-KEYWORD KEYWORD) ((NAME STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the Stella KEYWORD `name' if it exists.  Case sensitive.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getKeyword", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("GET-SYMBOL", "(DEFUN (GET-SYMBOL SYMBOL) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the Stella SYMBOL `name' visible in `module' if it\nexists.  `name' is ALWAYS treated case sensitively.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getSymbol", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-OPERATOR", "(DEFUN (GET-OPERATOR SYMBOL) ((NAME STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the logical operator object (a Stella SYMBOL) for `name'.\nIf no such operator exists then a `no-such-object' exception is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getOperator", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("GET-OBJECT", "(DEFUN (GET-OBJECT OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Look for an object named `name' that is local to\nor visible from the module `module'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getObject", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-GET-OBJECT", "(DEFUN (S-GET-OBJECT OBJECT) ((NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Look for an object named `name' that is local to\nor visible from the module `module-name'.  A module name of `null' or the\nempty string refers to the current module.  If no module can be found\nwith the name `module-name', then a Stella `no-such-context-exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sGetObject", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-CONCEPT", "(DEFUN (GET-CONCEPT LOGIC-OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a class/concept named `name' that is local to\nor visible from the module `module'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getConcept", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-GET-CONCEPT", "(DEFUN (S-GET-CONCEPT LOGIC-OBJECT) ((NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a class/concept named `name' that is local to\nor visible from the module `module-name'.  A module name of `null' or the\nempty string refers to the current module.  If no module can be found\nwith the name `module-name', then a Stella `no-such-context-exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sGetConcept", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-RELATION", "(DEFUN (GET-RELATION LOGIC-OBJECT) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a concept or relation named `name' that is local to\nor visible from the module `module'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getRelation", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-GET-RELATION", "(DEFUN (S-GET-RELATION LOGIC-OBJECT) ((NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a concept or relation named `name' that is local to\nor visible from the module `module-name'.  A module name of `null' or the\nempty string refers to the current module.  If no module can be found\nwith the name `module-name', then a Stella `no-such-context-exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sGetRelation", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-UNDEFINED-RELATIONS", "(DEFUN (GET-UNDEFINED-RELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ((MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return relations that have been referenced but not defined in `module'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getUndefinedRelations", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-NAME-IN-MODULE", "(DEFUN (GET-NAME-IN-MODULE STRING) ((OBJ OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the name, qualified as necessary, so that `obj' can be found from\n`module'.  If there is no name for the object return `null'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getNameInModule", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-NAME", "(DEFUN (GET-NAME STRING) ((OBJ OBJECT)) :DOCUMENTATION \"Return the fully qualified name of `obj', if it has one.  Otherwise return `null'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getName", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("GET-SHORT-NAME", "(DEFUN (GET-SHORT-NAME STRING) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the short name of `obj', if it has one.  Otherwise return `null'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getShortName", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("OBJECT-TO-STRING", "(DEFUN (OBJECT-TO-STRING STRING) ((SELF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a printed representation of the term `self' as a string.\")", Native.find_java_method("edu.isi.powerloom.PLI", "objectToString", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("OBJECT-TO-INTEGER", "(DEFUN (OBJECT-TO-INTEGER INTEGER) ((SELF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Coerce `self' to an integer, or throw a Stella Exception if the coersion is not feasible.\nFloating point values will be coerced by rounding.\")", Native.find_java_method("edu.isi.powerloom.PLI", "objectToInteger", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("OBJECT-TO-FLOAT", "(DEFUN (OBJECT-TO-FLOAT FLOAT) ((SELF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Coerce `self' to a float, or throw a Stella Exception if the coersion is not feasible.\")", Native.find_java_method("edu.isi.powerloom.PLI", "objectToFloat", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("OBJECT-TO-PARSABLE-STRING", "(DEFUN (OBJECT-TO-PARSABLE-STRING STRING) ((SELF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a string representing a printed\nrepresentation of the object `self'.  Like `object-to-string', but puts\nescaped double quotes around strings.\")", Native.find_java_method("edu.isi.powerloom.PLI", "objectToParsableString", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("STRING-TO-OBJECT", "(DEFUN (STRING-TO-OBJECT OBJECT) ((STRING STRING) (TYPE LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Evaluate `string' with respect to `module' and `environment'\nand return the corresponding logical term.  `type' is a concept used to assist the\ncorrect interpretation of `string'.\n\nCurrently `type' only has an effect on the interpretation of literal types.\")", Native.find_java_method("edu.isi.powerloom.PLI", "stringToObject", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("HELP-GET-TRUE-EXTENSION-MEMBERS", "(DEFUN (HELP-GET-TRUE-EXTENSION-MEMBERS (CONS OF PROPOSITION)) ((RELATION NAMED-DESCRIPTION) (SPECIALIZE? BOOLEAN)) :PUBLIC? FALSE)", Native.find_java_method("edu.isi.powerloom.PLI", "helpGetTrueExtensionMembers", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.NamedDescription"), java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("HELP-GET-PROPOSITIONS", "(DEFUN (HELP-GET-PROPOSITIONS (CONS OF PROPOSITION)) ((RELATION LOGIC-OBJECT) (ARGUMENTS CONS) (LIMIT INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)", Native.find_java_method("edu.isi.powerloom.PLI", "helpGetPropositions", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Cons"), java.lang.Integer.TYPE, Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-PROPOSITION", "(DEFUN (GET-PROPOSITION PROPOSITION) ((RELATION-AND-ARGUMENTS OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a proposition matching `relation-and-arguments' that\nhas been asserted (or inferred by forward chaining).  `relation-and-arguments'\nis a sequence containing objects and nulls.  The first argument must be the\nname of a relation.  A null value acts like a wild card.  If more than one \nproposition matches the input criteria, the selection among satisficing\npropositions is arbitrary.  This procedure is normally applied to single-valued\nrelations or functions.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getProposition", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-GET-PROPOSITION", "(DEFUN (S-GET-PROPOSITION PROPOSITION) ((RELATION-AND-ARGUMENTS STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a proposition matching `relation-and-arguments' that\nhas been asserted (or inferred by forward chaining).  `relation-and-arguments'\nis a string that begins with a left parenthesis, followed by a relation name, \none or more argument identifiers, and terminated by a right parenthesis.  Each\nargument identifier can be the name of a logical constant, a literal\nreference (e.g., a number), the null identifier, or a variable (an identifier that begins\nwith a question mark). Each occurrence of a null or a variable acts like a wild card.\nIf more than one proposition matches the input criteria, the selection among\nsatisficing propositions is arbitrary.  This procedure is normally applied to\nsingle-valued relations or functions.\n\nA module name of `null' or the\nempty string refers to the current module.  If no module can be found\nwith the name `module-name', then a Stella `no-such-context-exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sGetProposition", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-PROPOSITIONS", "(DEFUN (GET-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ((RELATION-AND-ARGUMENTS OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return propositions matching `relation-and-arguments' that\nhave been asserted (or inferred by forward chaining).  `relation-and-arguments'\nis a sequence containing objects and nulls.  The first argument must be the\nname of a relation.  A null value acts like a wild card.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getPropositions", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-GET-PROPOSITIONS", "(DEFUN (S-GET-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ((RELATION-AND-ARGUMENTS STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return propositions matching `relation-and-arguments' that\nhave been asserted (or inferred by forward chaining).  `relation-and-arguments'\nis a string that begins with a left parenthesis, followed by a relation name, \none or more argument identifiers, and terminated by a right parenthesis.  Each\nargument identifier can be the name of a logical constant, a literal \nreference (e.g., a number), the null identifier, or a variable (an identifier that begins\nwith a question mark). Each occurrence of a null or a variable acts like a wild card.\n\nA module name of `null' or the\nempty string refers to the current module.  If no module can be found\nwith the name `module-name', then a Stella `no-such-context-exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sGetPropositions", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-INCONSISTENT-PROPOSITIONS", "(DEFUN (GET-INCONSISTENT-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ((MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return inconsistent propositions visible in `module'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getInconsistentPropositions", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-BINARY-PROPOSITION", "(DEFUN (GET-BINARY-PROPOSITION PROPOSITION) ((RELATION LOGIC-OBJECT) (ARG1 OBJECT) (ARG2 OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a proposition such that (`relation' `arg1' `arg2')\nis true.  The `relation' argument must be bound to a relation.  One or both\nof the `arg1' and `arg2' arguments may be set to NULL, which is interpreted\nas a wildcard. If more than one proposition matches the input criteria,\nthe selection is arbitrary.  This procedure is normally applied to single-valued\nrelations or functions.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getBinaryProposition", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-BINARY-PROPOSITIONS", "(DEFUN (GET-BINARY-PROPOSITIONS (PL-ITERATOR OF PROPOSITION)) ((RELATION LOGIC-OBJECT) (ARG1 OBJECT) (ARG2 OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return propositions such that (`relation' `arg1' `arg2')\nis true.  The `relation' argument\nmust be bound to a relation.  One or both of the `arg1' and `arg2' arguments\nmay be set to NULL, which is interpreted as a wildcard.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getBinaryPropositions", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-INFERRED-BINARY-PROPOSITION-VALUES", "(DEFUN (GET-INFERRED-BINARY-PROPOSITION-VALUES PL-ITERATOR) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return all values `v' such that (`relation' `arg' `v')\nhas been asserted or can be inferred.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getInferredBinaryPropositionValues", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-GET-INFERRED-BINARY-PROPOSITION-VALUES", "(DEFUN (S-GET-INFERRED-BINARY-PROPOSITION-VALUES PL-ITERATOR) ((RELATION-NAME STRING) (ARG-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return all values `v' such that (`relation-name' `arg-name' `v')\nhas been asserted or can be inferred.\n\nA module name of `null' or the empty string refers to the current module. \nIf no module can be found with the name `module-name', then a Stella \n`no-such-context-exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sGetInferredBinaryPropositionValues", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-PROPOSITIONS-OF", "(DEFUN (GET-PROPOSITIONS-OF (PL-ITERATOR OF PROPOSITION)) ((OBJECT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return all propositions that have `object' among their arguments,\nand that are TRUE in the scope of the module `module'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getPropositionsOf", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-GET-PROPOSITIONS-OF", "(DEFUN (S-GET-PROPOSITIONS-OF (PL-ITERATOR OF PROPOSITION)) ((OBJECT-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return all propositions that have the object named `object-name' among\ntheir arguments, and that are TRUE in the scope of the module `module-name'.\nA module name of `null' or the empty string refers to the current module. \nIf no module can be found with the name `module-name', then a Stella \n`no-such-context-exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sGetPropositionsOf", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-PROPOSITIONS-IN-MODULE", "(DEFUN (GET-PROPOSITIONS-IN-MODULE (PL-ITERATOR OF PROPOSITION)) ((MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return propositions that have been conceived in\nthe module `module'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getPropositionsInModule", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("IS-TRUE-UNARY-PROPOSITION", "(DEFUN (IS-TRUE-UNARY-PROPOSITION BOOLEAN) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if the proposition (`relation' `arg') has\nbeen asserted (or inferred by forward chaining).\")", Native.find_java_method("edu.isi.powerloom.PLI", "isTrueUnaryProposition", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("IS-TRUE-BINARY-PROPOSITION", "(DEFUN (IS-TRUE-BINARY-PROPOSITION BOOLEAN) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (VALUE OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if the proposition (`relation' `arg' `value') has\nbeen asserted (or inferred by forward chaining).\")", Native.find_java_method("edu.isi.powerloom.PLI", "isTrueBinaryProposition", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("IS-TRUE-PROPOSITION1", "(DEFUN (IS-TRUE-PROPOSITION1 BOOLEAN) ((RELATION-AND-ARGUMENTS OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if a proposition (`relation' `args') has\nbeen asserted (or inferred by forward chaining).\")", Native.find_java_method("edu.isi.powerloom.PLI", "isTrueProposition1", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("IS-TRUE-PROPOSITION", "(DEFUN (IS-TRUE-PROPOSITION BOOLEAN) ((PROPOSITION PROPOSITION) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if `proposition' is  TRUE in the module `module'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "isTrueProposition", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.Proposition"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-IS-TRUE-PROPOSITION", "(DEFUN (S-IS-TRUE-PROPOSITION BOOLEAN) ((RELATION-AND-ARGUMENTS STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if a proposition that prints as the string\n`relation-and-arguments' is true in the module named `module-name'.\nA module name of `null' or the empty string refers to the current module. \nIf no module can be found with the name `module-name', then a Stella \n`no-such-context-exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sIsTrueProposition", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("IS-SUBRELATION", "(DEFUN (IS-SUBRELATION BOOLEAN) ((SUB LOGIC-OBJECT) (SUPER LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if `sub' is a subconcept/subrelation of `super'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "isSubrelation", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-PROPER-SUBRELATIONS", "(DEFUN (GET-PROPER-SUBRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ((RELATION LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return relations that specialize `relation'.\nNon-reflexive.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getProperSubrelations", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-DIRECT-SUBRELATIONS", "(DEFUN (GET-DIRECT-SUBRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ((RELATION LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return relations that directly specialize `relation'.\nNon-reflexive.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getDirectSubrelations", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
    }
  }

  static void helpStartupPli3() {
    {
      Stella.defineFunctionObject("GET-PROPER-SUPERRELATIONS", "(DEFUN (GET-PROPER-SUPERRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ((RELATION LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return relations that generalize `relation'.\nNon-reflexive.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getProperSuperrelations", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-DIRECT-SUPERRELATIONS", "(DEFUN (GET-DIRECT-SUPERRELATIONS (PL-ITERATOR OF LOGIC-OBJECT)) ((RELATION LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return relations that directly generalize `relation'.\nNon-reflexive.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getDirectSuperrelations", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("IS-A", "(DEFUN (IS-A BOOLEAN) ((OBJECT OBJECT) (CONCEPT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if `object' is a member of the concept `concept'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "isA", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-CONCEPT-INSTANCES", "(DEFUN (GET-CONCEPT-INSTANCES PL-ITERATOR) ((CONCEPT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return instances of the concept `concept'.\nInclude instances of subconcepts of `concept'.  Depending on `concept',\nthe return values could be (wrapped) literals.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getConceptInstances", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-GET-CONCEPT-INSTANCES", "(DEFUN (S-GET-CONCEPT-INSTANCES PL-ITERATOR) ((CONCEPT-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return instances of concept `concept-name'.\nInclude instances of subconcepts of `concept-name'.  Depending on `concept-name',\nthe return values could be (wrapped) literals.\n\nA module name of `null' or the empty string refers to the current module. \nIf no module can be found with the name `module-name', then a Stella \n`no-such-context-exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sGetConceptInstances", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-DIRECT-CONCEPT-INSTANCES", "(DEFUN (GET-DIRECT-CONCEPT-INSTANCES PL-ITERATOR) ((CONCEPT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return instances of concept `concept'.\nExclude instances of subconcepts of `concept'.  Depending on `concept',\nthe return values could be (wrapped) literals.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getDirectConceptInstances", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-GET-DIRECT-CONCEPT-INSTANCES", "(DEFUN (S-GET-DIRECT-CONCEPT-INSTANCES PL-ITERATOR) ((CONCEPT-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return instances of concept `concept-name'.\nExclude instances of subconcepts of `concept-name'.  Depending on `concept-name',\nthe return values could be (wrapped) literals.\n\nA module name of `null' or the empty string refers to the current module. \nIf no module can be found with the name `module-name', then a Stella \n`no-such-context-exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sGetDirectConceptInstances", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-CONCEPT-INSTANCES-MATCHING-VALUE", "(DEFUN (GET-CONCEPT-INSTANCES-MATCHING-VALUE PL-ITERATOR) ((CONCEPT LOGIC-OBJECT) (RELATION LOGIC-OBJECT) (VALUE OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return members of concept `concept' that\nhave an attribute matching `value' for the binary relation `relation', i.e.,\n`(relation <result> value)' holds.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getConceptInstancesMatchingValue", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-CONCEPT-INSTANCE-MATCHING-VALUE", "(DEFUN (GET-CONCEPT-INSTANCE-MATCHING-VALUE OBJECT) ((CONCEPT LOGIC-OBJECT) (RELATION LOGIC-OBJECT) (VALUE OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a member of concept `concept' that\nhas an attribute matching `value' for the binary relation `relation', i.e.,\n`(relation <result> value)' holds.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getConceptInstanceMatchingValue", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("HELP-GET-TYPES", "(DEFUN (HELP-GET-TYPES (CONS OF LOGIC-OBJECT)) ((OBJECT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? FALSE)", Native.find_java_method("edu.isi.powerloom.PLI", "helpGetTypes", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-TYPES", "(DEFUN (GET-TYPES (PL-ITERATOR OF LOGIC-OBJECT)) ((OBJECT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return all named concepts that `object' belongs to.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getTypes", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-DIRECT-TYPES", "(DEFUN (GET-DIRECT-TYPES (PL-ITERATOR OF LOGIC-OBJECT)) ((OBJECT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return most specific concepts that `object' belongs to.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getDirectTypes", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-RELATION-EXTENSION", "(DEFUN (GET-RELATION-EXTENSION (PL-ITERATOR OF PROPOSITION)) ((RELATION LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Return propositions that satisfy `relation'.\nInclude propositions that satisfy subrelations of `relation'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getRelationExtension", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-GET-RELATION-EXTENSION", "(DEFUN (S-GET-RELATION-EXTENSION (PL-ITERATOR OF PROPOSITION)) ((RELATION-NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return propositions that satisfy the relation named\n`relation-name'.  Include propositions that satisfy subrelations of the relation.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sGetRelationExtension", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-MODULE", "(DEFUN (GET-MODULE MODULE) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a module named `name'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getModule", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-CURRENT-MODULE", "(DEFUN (GET-CURRENT-MODULE MODULE) ((ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the currently set module\")", Native.find_java_method("edu.isi.powerloom.Environment", "getCurrentModule", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-HOME-MODULE", "(DEFUN (GET-HOME-MODULE MODULE) ((OBJECT LOGIC-OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the module in which `object' was created.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getHomeModule", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject")}), null);
      Stella.defineFunctionObject("GET-MODULES", "(DEFUN (GET-MODULES (PL-ITERATOR OF MODULE)) ((KB-MODULES-ONLY? BOOLEAN)) :PUBLIC? TRUE :DOCUMENTATION \"Return all modules currently loaded into PowerLoom.  If `kb-modules-only?'\nis `true', then Stella modules that are used only for program code are\nnot included in the list.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getModules", new java.lang.Class [] {java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("CREATE-MODULE", "(DEFUN (CREATE-MODULE MODULE) ((NAME STRING) (PARENT MODULE) (CASE-SENSITIVE? BOOLEAN)) :PUBLIC? TRUE :DOCUMENTATION \"Creates a new module `name' as a child of `parent'.  The flag\n`case-sensitive?' controls whether names read in this module will be\ncase sensitive or not.\")", Native.find_java_method("edu.isi.powerloom.PLI", "createModule", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Module"), java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("S-CREATE-MODULE", "(DEFUN (S-CREATE-MODULE MODULE) ((NAME STRING) (PARENT-NAME STRING) (CASE-SENSITIVE? BOOLEAN) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Creates a new module `name' as a child of `parent-name'.  The flag\n`case-sensitive?' controls whether names read in this module will be\ncase sensitive or not.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sCreateModule", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), java.lang.Boolean.TYPE, Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("CHANGE-MODULE", "(DEFUN (CHANGE-MODULE MODULE) ((MODULE MODULE)) :PUBLIC? TRUE :DOCUMENTATION \"Set the current module to `module' and return it.\nIf `module' is `null', then no switch is performed and the current\nmodule is returned.\")", Native.find_java_method("edu.isi.powerloom.PLI", "changeModule", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Module")}), null);
      Stella.defineFunctionObject("S-CHANGE-MODULE", "(DEFUN (S-CHANGE-MODULE MODULE) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Set the current module to the module named `name'.\nThe return value is the module named `name' unless `name' is null or\nthe empty string.  In that case, the current module is returned.\nIf no module named `name' exists, a Stella `no-such-context-exception'\nis thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sChangeModule", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("CLEAR-MODULE", "(DEFUN (CLEAR-MODULE MODULE) ((MODULE MODULE)) :PUBLIC? TRUE :DOCUMENTATION \"Destroy the contents of the module `module' as well as\nthe contents of all of its children, recursively.\")", Native.find_java_method("edu.isi.powerloom.PLI", "clearModule", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Module")}), null);
      Stella.defineFunctionObject("S-CLEAR-MODULE", "(DEFUN (S-CLEAR-MODULE MODULE) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Destroy the contents of the module named `name', as\nwell as the contents of all of its children, recursively.  If no module\nnamed `name' exists, a Stella `no-such-context-exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sClearModule", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-CHILD-MODULES", "(DEFUN (GET-CHILD-MODULES (PL-ITERATOR OF MODULE)) ((MODULE MODULE)) :PUBLIC? TRUE :DOCUMENTATION \"Return the modules that are immediate children of `module'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getChildModules", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Module")}), null);
      Stella.defineFunctionObject("S-GET-CHILD-MODULES", "(DEFUN (S-GET-CHILD-MODULES (PL-ITERATOR OF MODULE)) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the modules that are immediate children of module `name'.\nIf no module named `name' exists, a Stella `no-such-context-exception'\nis thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sGetChildModules", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-PARENT-MODULES", "(DEFUN (GET-PARENT-MODULES (PL-ITERATOR OF MODULE)) ((MODULE MODULE)) :PUBLIC? TRUE :DOCUMENTATION \"Return the modules that are immediate parents of `module'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getParentModules", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Module")}), null);
      Stella.defineFunctionObject("S-GET-PARENT-MODULES", "(DEFUN (S-GET-PARENT-MODULES (PL-ITERATOR OF MODULE)) ((NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the modules that are immediate parents of module `name'.\nIf no module named `name' exists, a Stella `no-such-context-exception'\nis thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sGetParentModules", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GENERATE-UNIQUE-NAME", "(DEFUN (GENERATE-UNIQUE-NAME STRING) ((PREFIX STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Generates a name based on `prefix' with a number appended that\nis not currently in use in `module.'  In a non-case-sensitive module, the returned\nname will be all upper case (This latter feature may change!)\")", Native.find_java_method("edu.isi.powerloom.PLI", "generateUniqueName", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("CREATE-KEYWORD", "(DEFUN (CREATE-KEYWORD KEYWORD) ((NAME STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the Stella keyword `name', creating it if\nnecessary.  `name' is treated case-sensitively.  This should\ngenerally not be necessary to do.\")", Native.find_java_method("edu.isi.powerloom.PLI", "createKeyword", new java.lang.Class [] {Native.find_java_class("java.lang.String")}), null);
      Stella.defineFunctionObject("CREATE-SYMBOL", "(DEFUN (CREATE-SYMBOL SYMBOL) ((NAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the Stella symbol `name' visible in `module',\ncreating it if necessary.  `name' is ALWAYS treated case-sensitively,\neven if `module' is case insensitive. This should generally not be\nnecessary to do.\")", Native.find_java_method("edu.isi.powerloom.PLI", "createSymbol", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("CREATE-OBJECT", "(DEFUN (CREATE-OBJECT LOGIC-OBJECT) ((NAME STRING) (CONCEPT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create an object named `name' of type `concept' in the designated\nmodule.  Both `name' and `concept' can be `null'.  If `name' is `null' then an\nobject will be created with a new, non-conflicting name based on the name of\n`concept', or system-generated if no concept is specified.  If `concept' is\n`null', then the object will be of type THING.  It is an error to create an\nobject with the same name as an existing object.\n\nNote that the string can be a qualified name, in which case the object\nwill be created in the module specified, but with a name as determined\nby the qualified name.  Vertical bars in the name string are interpreted\nas Stella escape characters.\n\nNote that because names in modules that are not case-sensitive are\ncanonicalized, the name of the returned object may not match `name'\nexactly.\n\nReturn the object.\")", Native.find_java_method("edu.isi.powerloom.PLI", "createObject", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-CREATE-OBJECT", "(DEFUN (S-CREATE-OBJECT LOGIC-OBJECT) ((NAME STRING) (CONCEPT-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create an object named `name' of type `concept-name' in the designated\nmodule.  Both `name' and `concept-name' can be null strings.  If `name' is a null string\nthen an object will be created with a new, non-conflicting name based on `concept-name', or\nsystem-generated if no concept nameis specified.  If `concept-name' is the null string, then\nthe object will be of type THING.\n\nA module name of `null' or the empty string refers to the current module. \nIf no module can be found with the name `module-name', then a Stella \n`no-such-context-exception' is thrown.\n\nNote that because names in modules that are not case-sensitive are canonicalized,\nthe name of the returned object may not match `name' exactly.\n\nReturn the object.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sCreateObject", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("CREATE-CONCEPT", "(DEFUN (CREATE-CONCEPT LOGIC-OBJECT) ((NAME STRING) (PARENT LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create a concept named `name' in the designated `module', with the\ndesignated `parent' superconcept (which can be left undefined).  Additional\nsuperconcepts can be added via assertions of the `subset-of' relation.  Note\nthat a specified `parent' concept needs to be created separately.\n\nNote that because names in modules that are not case-sensitive are canonicalized,\nthe name of the returned object may not match `name' exactly.\")", Native.find_java_method("edu.isi.powerloom.PLI", "createConcept", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-CREATE-CONCEPT", "(DEFUN (S-CREATE-CONCEPT LOGIC-OBJECT) ((NAME STRING) (PARENT-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create a concept named `name' in the designated module, with\nwith the concept named `parent-name' as superconcept (which can be left\nundefined).  Additional superconcepts can be added via assertions of the\n`subset-of' relation.  Note that a specified parent concept needs to be\ncreated separately.\n\nA module name of `null' or the empty string refers to the current module. \nIf no module can be found with the name `module-name', then a Stella \n`no-such-context-exception' is thrown.\n\nNote that because names in modules that are not case-sensitive are canonicalized,\nthe name of the returned object may not match `name' exactly.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sCreateConcept", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("CREATE-RELATION", "(DEFUN (CREATE-RELATION LOGIC-OBJECT) ((NAME STRING) (ARITY INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create a relation named `name' with arity `arity' in the\ndesignated module.  Domain and range information can be added via assertions\nof `nth-domain' (or `domain' and `range') relations.\n\nNote that because names in modules that are not case-sensitive are canonicalized,\nthe name of the returned object may not match `name' exactly.\")", Native.find_java_method("edu.isi.powerloom.PLI", "createRelation", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE, Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-CREATE-RELATION", "(DEFUN (S-CREATE-RELATION LOGIC-OBJECT) ((NAME STRING) (ARITY INTEGER) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create a relation named `name' with arity `arity' in the\ndesignated module.  Domain and range information can be added via assertions\nof `nth-domain' (or `domain' and `range') relations.\n\nA module name of `null' or the empty string refers to the current module. \nIf no module can be found with the name `module-name', then a Stella \n`no-such-context-exception' is thrown.\n\nNote that because names in modules that are not case-sensitive are canonicalized,\nthe name of the returned object may not match `name' exactly.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sCreateRelation", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE, Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("CREATE-FUNCTION", "(DEFUN (CREATE-FUNCTION LOGIC-OBJECT) ((NAME STRING) (ARITY INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create a function named `name' with arity `arity'  in the designated \n`module'.  Domain and range information can be added via assertions of\n`nth-domain' (or `domain' and `range') relations.\n\nNote that because names in modules that are not case-sensitive are canonicalized,\nthe name of the returned object may not match `name' exactly.\")", Native.find_java_method("edu.isi.powerloom.PLI", "createFunction", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE, Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-CREATE-FUNCTION", "(DEFUN (S-CREATE-FUNCTION LOGIC-OBJECT) ((NAME STRING) (ARITY INTEGER) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create a function named `name' with arity `arity' in the designated \nmodule.  Domain and range information can be added via assertions of\n`domain', `nth-domain' and `range' relations.\n\nA module name of `null' or the empty string refers to the current module. \nIf no module can be found with the name `module-name', then a Stella \n`no-such-context-exception' is thrown.\n\nNote that because names in modules that are not case-sensitive are canonicalized,\nthe name of the returned object may not match `name' exactly.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sCreateFunction", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE, Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("REGISTER-SPECIALIST-FUNCTION", "(DEFUN REGISTER-SPECIALIST-FUNCTION ((NAME STRING) (FUNCTION-REFERENCE FUNCTION-CODE) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Register `name' as a function name in `module' which will invoke the\nnative code procedure described by `function-reference.'  The `name'\nis a fully-qualified name which will be interpreted by the normal\nrules for reading names in PowerLoom.  The function must conform\nto the signature for specialist functions.\n\nThe exact form of `function-reference' depends on the underlying\nprogramming language.  The following type mappings are used:\n          C++:  \n  Common Lisp:  FUNCTION   (result of #' or (FUNCTION ...))\n         Java:  java.lang.reflect.Method\")", Native.find_java_method("edu.isi.powerloom.PLI", "registerSpecialistFunction", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.reflect.Method"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-REGISTER-SPECIALIST-FUNCTION", "(DEFUN S-REGISTER-SPECIALIST-FUNCTION ((NAME STRING) (NATIVE-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Register `name' as a function name in the module named `module-name'.\nThis function will the native code named `native-name'.  The `name'\nis a fully-qualified name which will be interpreted by the normal\nrules for reading names in PowerLoom.  The `native-name' will be\nprocessed in a manner that depends on the underlying programming\nlanguage.  The following type mappings are used:\n          C++:  Not available.  Error signaled.\n  Common Lisp:  The native-name is read by READ-FROM-STRING and then\n                the SYMBOL-FUNCTION is taken.\n         Java:  A fully package-qualified name is required.  It is\n                looked up using the Reflection tools.\nThe function found must conform to the signature for specialist functions.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sRegisterSpecialistFunction", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("REGISTER-COMPUTATION-FUNCTION", "(DEFUN REGISTER-COMPUTATION-FUNCTION ((NAME STRING) (FUNCTION-REFERENCE FUNCTION-CODE) (ARITY INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Register `name' as a function name in `module' which will invoke the\nnative code procedure described by `function-reference.'  The `name'\nis a fully-qualified name which will be interpreted by the normal\nrules for reading names in PowerLoom.  The function must conform\nto the signature for computation functions used by the computation\nspecialist.  Arity specifies the number of arguments the computation\naccepts.\n\nThe exact form of `function-reference' depends on the underlying\nprogramming language.  The following type mappings are used:\n          C++:  cpp_function_code (a pointer to the function code)\n  Common Lisp:  FUNCTION   (result of #' or (FUNCTION ...))\n         Java:  java.lang.reflect.Method\")", Native.find_java_method("edu.isi.powerloom.PLI", "registerComputationFunction", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.reflect.Method"), java.lang.Integer.TYPE, Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-REGISTER-COMPUTATION-FUNCTION", "(DEFUN S-REGISTER-COMPUTATION-FUNCTION ((NAME STRING) (NATIVE-NAME STRING) (ARITY INTEGER) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Register `name' as a function name in the module named `module-name'.\nThis function will the native code named `native-name'.  The `name'\nis a fully-qualified name which will be interpreted by the normal\nrules for reading names in PowerLoom.  The `native-name' will be\nprocessed in a manner that depends on the underlying programming\nlanguage.  The following type mappings are used:\n          C++:  Not available.  Error signaled.\n  Common Lisp:  The native-name is read by READ-FROM-STRING and then\n                the SYMBOL-FUNCTION is taken.\n         Java:  A fully package-qualified name is required.  It is\n                looked up using the Reflection tools.\nThe function found must conform to the signature for computation functions.\nArity specifies the number of arguments the computation accepts.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sRegisterComputationFunction", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE, Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("CREATE-ENUMERATED-LIST", "(DEFUN (CREATE-ENUMERATED-LIST LOGIC-OBJECT) ((MEMBERS CONS) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create a logical term that denotes a list containing `members' in\n`module' using `environment'.  Useful for passing lists as arguments\nto parameterized queries.\")", Native.find_java_method("edu.isi.powerloom.PLI", "createEnumeratedList", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("CREATE-ENUMERATED-SET", "(DEFUN (CREATE-ENUMERATED-SET LOGIC-OBJECT) ((MEMBERS CONS) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create a logical term that denotes the enumerated set containing `members'\nin `module' using `environment'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "createEnumeratedSet", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("DESTROY-OBJECT", "(DEFUN DESTROY-OBJECT ((OBJECT OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Delete the object `object', retracting all facts attached to it.\")", Native.find_java_method("edu.isi.powerloom.PLI", "destroyObject", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("S-DESTROY-OBJECT", "(DEFUN S-DESTROY-OBJECT ((OBJECT-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Delete the object named `object-name', retracting all facts\nattached to it.\n\nA module name of `null' or the empty string refers to the current module. \nIf no module can be found with the name `module-name', then a Stella \n`no-such-context-exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sDestroyObject", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("ASSERT-UNARY-PROPOSITION", "(DEFUN (ASSERT-UNARY-PROPOSITION PROPOSITION) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Assert that the proposition (`relation' `arg') is TRUE in `module'.  Return the asserted proposition.\")", Native.find_java_method("edu.isi.powerloom.PLI", "assertUnaryProposition", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("ASSERT-BINARY-PROPOSITION", "(DEFUN (ASSERT-BINARY-PROPOSITION PROPOSITION) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (VALUE OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Assert that the proposition (`relation' `arg' `value') is TRUE\nin `module'.  Return the asserted proposition.\")", Native.find_java_method("edu.isi.powerloom.PLI", "assertBinaryProposition", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("ASSERT-NARY-PROPOSITION", "(DEFUN (ASSERT-NARY-PROPOSITION PROPOSITION) ((RELATION-AND-ARGUMENTS OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Assert that the proposition represented by the list ` relation-and-arguments' satisfies\nthe relation `relation'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "assertNaryProposition", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("RETRACT-UNARY-PROPOSITION", "(DEFUN (RETRACT-UNARY-PROPOSITION PROPOSITION) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Retract that the proposition (`relation' `arg') is TRUE in `module'.  Return the asserted proposition.\")", Native.find_java_method("edu.isi.powerloom.PLI", "retractUnaryProposition", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("RETRACT-BINARY-PROPOSITION", "(DEFUN (RETRACT-BINARY-PROPOSITION PROPOSITION) ((RELATION LOGIC-OBJECT) (ARG OBJECT) (VALUE OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Retract that the proposition (`relation' `arg' `value') is TRUE\nin `module'.  Return the asserted proposition.\")", Native.find_java_method("edu.isi.powerloom.PLI", "retractBinaryProposition", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("RETRACT-NARY-PROPOSITION", "(DEFUN (RETRACT-NARY-PROPOSITION PROPOSITION) ((RELATION-AND-ARGUMENTS OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Retract the proposition that `arguments' satisfies\nthe relation `relation'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "retractNaryProposition", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("ASSERT-PROPOSITION", "(DEFUN (ASSERT-PROPOSITION PROPOSITION) ((PROPOSITION PROPOSITION) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Assert that the proposition `proposition' is true in `module'.\nReturn the asserted proposition.\")", Native.find_java_method("edu.isi.powerloom.PLI", "assertProposition", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.Proposition"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-ASSERT-PROPOSITION", "(DEFUN (S-ASSERT-PROPOSITION (PL-ITERATOR OF PROPOSITION)) ((SENTENCE STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Assert that the logical sentence `sentence' is true in the module\nnamed `module-name'.  A module name of `null' or the empty string refers to the\ncurrent module.  If no module can be found with the name `module-name',\nthen a Stella `no-such-context-exception' is thrown.\n\nReturn an iterator of the propositions resulting from sentence.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sAssertProposition", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("RETRACT-PROPOSITION", "(DEFUN (RETRACT-PROPOSITION PROPOSITION) ((PROPOSITION PROPOSITION) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Retract the truth of the proposition `proposition' in `module'.\nReturn the retracted proposition.\")", Native.find_java_method("edu.isi.powerloom.PLI", "retractProposition", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.Proposition"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-RETRACT-PROPOSITION", "(DEFUN (S-RETRACT-PROPOSITION (PL-ITERATOR OF PROPOSITION)) ((SENTENCE STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Retract the truth of the logical sentence `sentence' in the module named\n`module-name'.  A module name of `null' or the empty string refers to the\ncurrent module.  If no module can be found with the name `module-name',\nthen a Stella `no-such-context-exception' is thrown.\n\nReturn an iterator of the retracted propositions resulting from sentence.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sRetractProposition", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("CONCEIVE", "(DEFUN (CONCEIVE (PL-ITERATOR OF PROPOSITION)) ((SENTENCE OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create one or more proposition objects from the sentence `sentence'\nin the  module `module'.  Return an iterator of the propositions.\nIf any of the new propositions has the same structure as an already existing\nproposition, an automatic check for duplicates will return the pre-existing\nproposition.  Multiple propositions may be returned for a single sentence\nbecause of normalization of equivalences, conjunctions, etc.\n\nSignals a `Proposition-Error' if PowerLoom could not conceive `sentence'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "conceive", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-CONCEIVE", "(DEFUN (S-CONCEIVE (PL-ITERATOR OF PROPOSITION)) ((SENTENCE STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Create one or more proposition objects from the sentence `sentence'\nin the  module named `module-name'.  Return an iterator of the propositions.\nIf any of the new propositions has the same structure as an already existing\nproposition, an automatic check for duplicates will return the pre-existing\nproposition.  Multiple propositions may be returned for a single sentence\nbecause of normalization of equivalences, conjunctions, etc.\n\nA module name of `null' or the empty string refers to the current module.\nIf no module can be found with the name `module-name', then a Stella\n`No-Such-Context-Exception' is thrown.\n\nSignals a `Proposition-Error' if PowerLoom could not conceive `sentence'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sConceive", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-RULES", "(DEFUN (GET-RULES (PL-ITERATOR OF PROPOSITION)) ((RELATION LOGIC-OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return rules attached to the concept/relation `relation'\nin either antecedent or consequent position.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getRules", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
    }
  }

  static void helpStartupPli4() {
    {
      Stella.defineFunctionObject("S-GET-RULES", "(DEFUN (S-GET-RULES (PL-ITERATOR OF PROPOSITION)) ((RELATION-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return rules attached to the concept/relation named\n`relation-name' found in the module named `module-name'.\n\nA module name of `null' or the empty string refers to the current module.\nIf no module can be found with the name `module-name', then a Stella\n`No-Such-Context-Exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sGetRules", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-PRINT-RULES", "(DEFUN S-PRINT-RULES ((NAME STRING) (STREAM OUTPUT-STREAM) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Print rules attached to the concept/relation named `name'.\n\nA module name of `null' or the empty string refers to the\ncurrent module.  If no module can be found with the name `module-name',\nthen a Stella `no-such-context-exception' is thrown.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.powerloom.PLI", "sPrintRules", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.OutputStream"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("RUN-FORWARD-RULES", "(DEFUN RUN-FORWARD-RULES ((MODULE OBJECT) (FORCE? BOOLEAN)) :PUBLIC? TRUE :DOCUMENTATION \"Run forward inference rules in module `module'.\nIf `module' is NULL, the\ncurrent module will be used.  If forward inferencing is already up-to-date\nin the designated module, no additional inferencing will occur, unless `force'\nis set to TRUE, in which case all forward rules are run or rerun.\n\nCalling `run-forward-rules' temporarily puts the module into a mode where\nfuture assertional (monotonic) updates will trigger additional forward\ninference.  Once a non-monotonic update is performed, i.e., a retraction\nor clipping of relation value, all cached forward inferences will be discarded\nand forward inferencing will be disabled until this function is\ncalled again.\")", Native.find_java_method("edu.isi.powerloom.PLI", "runForwardRules", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Boolean.TYPE}), null);
      Stella.defineFunctionObject("GET-ARITY", "(DEFUN (GET-ARITY INTEGER) ((RELATION LOGIC-OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the arity of the relation `relation'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getArity", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject")}), null);
      Stella.defineFunctionObject("S-GET-ARITY", "(DEFUN (S-GET-ARITY INTEGER) ((RELATION-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the arity of the relation named `relation-name'.\n\n A module name of `null' or the empty string refers to the\ncurrent module.  If no module can be found with the name `module-name',\nthen a Stella `no-such-context-exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sGetArity", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-DOMAIN", "(DEFUN (GET-DOMAIN LOGIC-OBJECT) ((RELATION LOGIC-OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the type (a concept) for the first argument to the binary\nrelation `relation'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getDomain", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject")}), null);
      Stella.defineFunctionObject("S-GET-DOMAIN", "(DEFUN (S-GET-DOMAIN LOGIC-OBJECT) ((RELATION-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the type (concept) for the first argument to the binary\nrelation `relation-name'.\n\nA module name of `null' or the empty string refers to the\ncurrent module.  If no module can be found with the name `module-name',\nthen a Stella `no-such-context-exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sGetDomain", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-RANGE", "(DEFUN (GET-RANGE LOGIC-OBJECT) ((RELATION LOGIC-OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the type (a concept) for fillers of the binary relation\n`relation'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getRange", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject")}), null);
      Stella.defineFunctionObject("S-GET-RANGE", "(DEFUN (S-GET-RANGE LOGIC-OBJECT) ((RELATION-NAME STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the type (a concept) for fillers of the binary relation\n`relation-name'.\n\nA module name of `null' or the empty string refers to the\ncurrent module.  If no module can be found with the name `module-name',\nthen a Stella `no-such-context-exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sGetRange", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-NTH-DOMAIN", "(DEFUN (GET-NTH-DOMAIN LOGIC-OBJECT) ((RELATION LOGIC-OBJECT) (N INTEGER)) :PUBLIC? TRUE :DOCUMENTATION \"Return the type (a concept) for the the nth argument of the\nrelation `relation'.  Counting starts at zero.  NOTE: if there are multiple\n`nth-domain' propositions for `relation', this arbitrarily returns one of them;\nit does not look for the most specific one (which might have to be created).\")", Native.find_java_method("edu.isi.powerloom.PLI", "getNthDomain", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("S-GET-NTH-DOMAIN", "(DEFUN (S-GET-NTH-DOMAIN LOGIC-OBJECT) ((RELATION-NAME STRING) (N INTEGER) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the type (a concept) for the nth argument of the relation\nnamed `relation-name'.  Counting starts at zero.\n\nA module name of `null' or the empty string refers to the\ncurrent module.  If no module can be found with the name `module-name',\nthen a Stella `no-such-context-exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sGetNthDomain", new java.lang.Class [] {Native.find_java_class("java.lang.String"), java.lang.Integer.TYPE, Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("LOAD", "(DEFUN LOAD ((FILENAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Read logic commands from the file named `filename' and evaluate them.\nThe file should contain an `in-module' declaration that specifies the module\nwithin which all remaining commands are to be evaluated.  The remaining commands\nare evaluated one-by-one, applying the function `evaluate' to each of them.\")", Native.find_java_method("edu.isi.powerloom.PLI", "load", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("LOAD-IN-MODULE", "(DEFUN LOAD-IN-MODULE ((FILENAME STRING) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Read logic commands from the file named `filename' and evaluate them.\nIf the file does not have an `in-module' declaration that specifies the module\nwithin which all remaining commands are to be evaluated, it will be loaded\nin the `module' specified.  If no `module' is specified and the file does\nnot contain an `in-module' declaration, an error will be signaled.\nThe remaining commands are evaluated one-by-one, applying the function\n`evaluate' to each of them.\")", Native.find_java_method("edu.isi.powerloom.PLI", "loadInModule", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("LOAD-STREAM", "(DEFUN LOAD-STREAM ((STREAM INPUT-STREAM) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Read logic commands from the STELLA stream `stream' and evaluate them.\nThe stream should contain an `in-module' declaration that specifies\nthe module within which all remaining commands are to be evaluated.\nThe remaining commands are evaluated one-by-one, applying the function\n`evaluate' to each of them.\")", Native.find_java_method("edu.isi.powerloom.PLI", "loadStream", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.InputStream"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("LOAD-STREAM-IN-MODULE", "(DEFUN LOAD-STREAM-IN-MODULE ((STREAM INPUT-STREAM) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Read logic commands from the STELLA stream `stream' and evaluate them.\nIf the stream does not supply an `in-module' declaration that specifies the\nmodule within which all remaining commands are to be evaluated, it will be\nloaded in the `module' specified.  If no `module' is specified and the file \ndoes not supply an `in-module' declaration, an error will be signaled.\nThe remaining commands are evaluated one-by-one, applying the function\n`evaluate' to each of them.\")", Native.find_java_method("edu.isi.powerloom.PLI", "loadStreamInModule", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.InputStream"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("LOAD-NATIVE-STREAM", "(DEFUN LOAD-NATIVE-STREAM ((STREAM NATIVE-INPUT-STREAM) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Read logic commands from the native input stream `stream' and evaluate them.\nAssumes `stream' is a line-buffered stream which is a safe compromise but does\nnot generate the best efficiency for block-buffered streams such as files.\nThe stream should begin with an `in-module' declaration that specifies\nthe module within which all remaining commands are to be evaluated\nThe remaining commands are evaluated one-by-one, applying the function\n`evaluate' to each of them.\")", Native.find_java_method("edu.isi.powerloom.PLI", "loadNativeStream", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.javalib.NativeInputStream"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("LOAD-NATIVE-STREAM-IN-MODULE", "(DEFUN LOAD-NATIVE-STREAM-IN-MODULE ((STREAM NATIVE-INPUT-STREAM) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Read logic commands from the native input stream `stream' and evaluate them.\nAssumes `stream' is a line-buffered stream which is a safe compromise but does\nnot generate the best efficiency for block-buffered streams such as files.\nIf the stream does not supply an `in-module' declaration that specifies the\nmodule within which all remaining commands are to be evaluated, it will be\nloaded in the `module' specified.  If no `module' is specified and the file \ndoes not supply an `in-module' declaration, an error will be signaled.\nThe remaining commands are evaluated one-by-one, applying the function\n`evaluate' to each of them.\")", Native.find_java_method("edu.isi.powerloom.PLI", "loadNativeStreamInModule", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.javalib.NativeInputStream"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("SAVE-MODULE", "(DEFUN SAVE-MODULE ((MODULE MODULE) (FILENAME STRING) (IFEXISTS STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Save the contents of the module `mod' into a file named `filename'.\nIf a file named `filename' already exists, then the action taken depends on the\nvalue of `ifexists'.  Possible values are \\\"ASK\\\", \\\"REPLACE\\\", \\\"WARN\\\" and \\\"ERROR\\\":\n\n  REPLACE => Means overwrite without warning.\n  WARN    => Means overwrite with a warning.\n  ERROR   => Means don't overwrite, signal an error instead.\n  ASK     => Ask the user whether to overwrite or not.  If not overwritten, an \n             exception is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "saveModule", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-SAVE-MODULE", "(DEFUN S-SAVE-MODULE ((MODULE-NAME STRING) (FILENAME STRING) (IFEXISTS STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Save the contents of the module `module-name' into a file named `filename'.\nIf a file named `filename' already exists, then the action taken depends on the\nvalue of `ifexists'.  Possible values are \\\"ASK\\\", \\\"REPLACE\\\", \\\"WARN\\\" and \\\"ERROR\\\":\n\n  REPLACE => Means overwrite without warning.\n  WARN    => Means overwrite with a warning.\n  ERROR   => Means don't overwrite, signal an error instead.\n  ASK     => Ask the user whether to overwrite or not.  If not overwritten, an\n             exception is thrown.\n\nA module name of `null' or the empty string refers to the\ncurrent module.  If no module can be found with the name `module-name',\nthen a Stella `no-such-context-exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sSaveModule", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-PREDICATE", "(DEFUN (GET-PREDICATE LOGIC-OBJECT) ((PROP PROPOSITION)) :PUBLIC? TRUE :DOCUMENTATION \"Return the concept or relation predicate for\nthe proposition `prop'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getPredicate", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.Proposition")}), null);
      Stella.defineFunctionObject("GET-COLUMN-COUNT", "(DEFUN (GET-COLUMN-COUNT INTEGER) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the number of columns in `obj', which must\nbe of type proposition, cons, vector or PL-iterator.  For a proposition,\nthe number includes both the predidate and arguments. For the PL-iterator\ncase,the number of columns is for the current value of the iterator.\n\nFor a null item, the column count is zero.\nFor non sequence objects, the column count is one.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getColumnCount", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("GET-NTH-VALUE", "(DEFUN (GET-NTH-VALUE OBJECT) ((SEQUENCE OBJECT) (N INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the value in the `nth' column of `sequence'.\nCounting starts at zero.  Unless `n' is zero, `sequence' must be of type\nproposition, cons, vector or PL-iterator.  A zero column number returns\na proposition's relational predicate.  For the PL-iterator case, the number\nof columns is for the current value of the iterator.\n\nAs a special case, a column number of zero will also return `sequence' itself\nif it is not one of the types enumerated above.  This is done to allow the\nuse of `get-nth-value' on PL-iterators with only a single return variable.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getNthValue", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Integer.TYPE, Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-NTH-STRING", "(DEFUN (GET-NTH-STRING STRING) ((SEQUENCE OBJECT) (N INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a string representation of the value in the `nth' column of\n`sequence'. Counting starts at zero.   Unless `n' is zero, `sequence' must be of type\nproposition, cons, vector or PL-iterator.  A zero column number returns\na proposition's relational predicate.  For the PL-iterator case, the\nthe current value pointed to by the iterator is used.  This will always\nsucceed, even if the `nth' value is not a string object.  In that case, a\nstring reprensentation will be returned.\n\n\nAs a special case, a column number of zero will also return `sequence' itself\nas a string if it is not one of the types enumerated above.  This is done to \nallow the use of `get-nth-string' on PL-iterators with only a single return variable.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getNthString", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Integer.TYPE, Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-NTH-INTEGER", "(DEFUN (GET-NTH-INTEGER INTEGER) ((SEQUENCE OBJECT) (N INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return an integer representation of the value in the `nth' column of\n`sequence'. Counting starts at zero.   Unless `n' is zero, `sequence' must be of type\nproposition, cons, vector or PL-iterator.  A zero column number returns\na proposition's relational predicate.  For the PL-iterator case, the\nthe current value pointed to by the iterator is used.  If this is not\nan integer value, then an exception will be thrown.\n\n\nAs a special case, a column number of zero will also return the integer\nvalue of `sequence' itself if it is not one of the types enumerated\nabove.   This allows the use of `get-nth-integer' on PL-iterators with\nonly a single return variable.  If  `sequence' cannot be turned into an\ninteger, an exception will be thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getNthInteger", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Integer.TYPE, Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-NTH-FLOAT", "(DEFUN (GET-NTH-FLOAT FLOAT) ((SEQUENCE OBJECT) (N INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the floating point value in the `nth' column of\n`sequence'. Counting starts at zero.  `sequence' must be of type\nproposition, cons, vector or PL-iterator.  A zero column number returns\na proposition's relational predicate.  For the PL-iterator case, the\nthe current value pointed to by the iterator is used.  If this is not\na floating point value, then an exception will be thrown.\n\n\nAs a special case, a column number of zero will also return the floating\npoint value of `sequence' itself if it is not one of the types enumerated\nabove.  This allows the use of `get-nth-float' on PL-iterators with only\na single return variable.    If  `sequence' cannot be turned into a floating\npoint value, an exception will be thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getNthFloat", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Integer.TYPE, Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-NTH-LOGIC-OBJECT", "(DEFUN (GET-NTH-LOGIC-OBJECT LOGIC-OBJECT) ((SEQUENCE OBJECT) (N INTEGER) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Return a logic object representation of the value in the `nth' column\nof `sequence'.  Counting starts at zero.   Unless `n' is zero, `sequence' must be of type\nproposition, cons, vector or PL-iterator.  A zero column number returns\na proposition's relational predicate.  For the PL-iterator case, the\nthe current value pointed to by the iterator is used.  A zero column number\nreturns the proposition's relational predicate.  If the return value is\nnot a LOGIC-OBJECT, an exception is thrown.\n\nAs a special case, a column number of zero will also return `sequence' itself\nif it is not one of the types enumerated above.  This is done to allow the\nuse of `get-nth-value' on PL-iterators with only a single return variable.\nIf `sequence' is not a LOGIC-OBJECT, an exception is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "getNthLogicObject", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Integer.TYPE, Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("GET-ENUMERATED-COLLECTION-MEMBERS", "(DEFUN (GET-ENUMERATED-COLLECTION-MEMBERS CONS) ((COLLECTION OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the members of an enumerated collection.  This works on all types\nof collection, i.e., sets and lists\")", Native.find_java_method("edu.isi.powerloom.PLI", "getEnumeratedCollectionMembers", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("EVALUATE", "(DEFUN (EVALUATE OBJECT) ((COMMAND OBJECT) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Evaluate the command `command' within `module' and return\nthe result. Currently, only the evaluation of (possibly nested) commands and\nglobal variables is supported.  Commands are simple to program in Common Lisp,\nsince they are built into the language, and relatively awkward in Java and C++.\nUsers of either of those languages are more likely to want to call `s-evaluate'.\")", Native.find_java_method("edu.isi.powerloom.PLI", "evaluate", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-EVALUATE", "(DEFUN (S-EVALUATE OBJECT) ((COMMAND STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Evaluate the command represented by the string `command' within `module' and\nreturn the result.  Currently, only the evaluation of (possibly nested) commands and\nglobal variables is supported.\n\n A module name of `null' or the empty string refers to the\ncurrent module.  If no module can be found with the name `module-name',\nthen a Stella `no-such-context-exception' is thrown.\")", Native.find_java_method("edu.isi.powerloom.PLI", "sEvaluate", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("IS-LOGIC-OBJECT", "(DEFUN (IS-LOGIC-OBJECT BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Test whether `obj' is of type LOGIC-OBJECT\")", Native.find_java_method("edu.isi.powerloom.PLI", "isLogicObject", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("IS-INTEGER", "(DEFUN (IS-INTEGER BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Test whether `obj' is of type INTEGER\")", Native.find_java_method("edu.isi.powerloom.PLI", "isInteger", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("IS-FLOAT", "(DEFUN (IS-FLOAT BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Test whether `obj' is of type FLOAT (double)\")", Native.find_java_method("edu.isi.powerloom.PLI", "isFloat", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("IS-NUMBER", "(DEFUN (IS-NUMBER BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Test whether `obj' is of type NUMBER.  This can\nbe either an integer or a floating point number.  One key characteristic\nis that 'object-to-integer' and `object-to-float' will both work on it.\")", Native.find_java_method("edu.isi.powerloom.PLI", "isNumber", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("IS-STRING", "(DEFUN (IS-STRING BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Test whether `obj' is of type STRING\")", Native.find_java_method("edu.isi.powerloom.PLI", "isString", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("IS-ENUMERATED-COLLECTION", "(DEFUN (IS-ENUMERATED-COLLECTION BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Test whether `obj' is an enumerated collection.  This\nsubsumes both sets and lists.\")", Native.find_java_method("edu.isi.powerloom.PLI", "isEnumeratedCollection", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("IS-ENUMERATED-SET", "(DEFUN (IS-ENUMERATED-SET BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Test whether `obj' is an enumerated set.\")", Native.find_java_method("edu.isi.powerloom.PLI", "isEnumeratedSet", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("IS-ENUMERATED-LIST", "(DEFUN (IS-ENUMERATED-LIST BOOLEAN) ((OBJ OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Test whether `obj' is an enumerated list\")", Native.find_java_method("edu.isi.powerloom.PLI", "isEnumeratedList", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("IS-TRUE", "(DEFUN (IS-TRUE BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :DOCUMENTATION \"Tests whether `tv' is a true truth value.  It can be true\neither absolutely or by default.\")", Native.find_java_method("edu.isi.powerloom.PLI", "isTrue", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.TruthValue")}), null);
      Stella.defineFunctionObject("IS-FALSE", "(DEFUN (IS-FALSE BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :DOCUMENTATION \"Tests whether `tv' is a false truth value.  It can be false\neither absolutely or by default.\")", Native.find_java_method("edu.isi.powerloom.PLI", "isFalse", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.TruthValue")}), null);
      Stella.defineFunctionObject("IS-UNKNOWN", "(DEFUN (IS-UNKNOWN BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :DOCUMENTATION \"Tests whether `tv' is an unknown truth value.\")", Native.find_java_method("edu.isi.powerloom.PLI", "isUnknown", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.TruthValue")}), null);
      Stella.defineFunctionObject("IS-KNOWN", "(DEFUN (IS-KNOWN BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :DOCUMENTATION \"Tests whether `tv' is a known truth value (i.e., true or false).\")", Native.find_java_method("edu.isi.powerloom.PLI", "isKnown", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.TruthValue")}), null);
      Stella.defineFunctionObject("IS-INCONSISTENT", "(DEFUN (IS-INCONSISTENT BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :DOCUMENTATION \"Tests whether `tv' is an inconsistent truth value.\")", Native.find_java_method("edu.isi.powerloom.PLI", "isInconsistent", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.TruthValue")}), null);
      Stella.defineFunctionObject("IS-STRICT", "(DEFUN (IS-STRICT BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :DOCUMENTATION \"Tests whether `tv' is a strict (non-default) truth value.\")", Native.find_java_method("edu.isi.powerloom.PLI", "isStrict", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.TruthValue")}), null);
      Stella.defineFunctionObject("IS-DEFAULT", "(DEFUN (IS-DEFAULT BOOLEAN) ((TV TRUTH-VALUE)) :PUBLIC? TRUE :DOCUMENTATION \"Tests whether `tv' is a default truth value.\")", Native.find_java_method("edu.isi.powerloom.PLI", "isDefault", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.TruthValue")}), null);
      Stella.defineFunctionObject("ASK", "(DEFUN (ASK TRUTH-VALUE) ((QUERY CONS) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Returns a truth value for `query' in `module' and `environment'.\n`query' has the same syntax as the PowerLoom `ask' command (which see)\nbut with the `ask' operator omitted.  For example, here are some legal\n`query' arguments:\n	 \n    ((happy Fred))\n    ((happy Fred) :inference-level :assertion)\n    ((happy Fred) :inference-level :assertion :timeout 1.0)\n	\nAs a convenience, a `query' argument whose first element is a symbol is\ninterpreted as a sentence that is queried without any options.  For example:\n	 \n    (happy Fred)\n	\nis a legal `query' argument.  Note that for a sentence whose relation is a list\nitself, e.g., `((FruitFn BananaTree) MyBanana)' this shortcut is not available,\nthat is, in that case an extra level of list nesting is always necessary.\nThe returned truth value represents the logical truth of the queried sentence\nas determined by PowerLoom.  It can be be tested via the functions `is-true',\n`is-false' and `is-unknown' (which see).\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.powerloom.PLI", "ask", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-ASK", "(DEFUN (S-ASK TRUTH-VALUE) ((QUERY STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Returns a truth value for `query' in module `module-name' and `environment'.\n`query' has the same syntax as the PowerLoom `ask' command (which see) but\nwith the `ask' operator omitted.  Different from the PLI `ask' function, `s-ask'\ndoes not expect a top-level pair of parentheses.  For example, here are some legal\n`query' arguments:\n	 \n    \\\"(happy Fred)\\\"\n    \\\"(happy Fred) :inference-level :assertion\\\"\n    \\\"(happy Fred) :inference-level :assertion :timeout 1.0\\\"\n	\nNames in `query' will be interpreted relative to module `module-name'.\nA null `module-name' or the empty string refers to the current module.\nIf no module can be found with the name `module-name', then a STELLA\n`no-such-context-exception' is thrown.\nThe returned truth value represents the logical truth of the queried sentence\nas determined by PowerLoom.  It can be be tested via the functions `is-true',\n`is-false' and `is-unknown' (which see).\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.powerloom.PLI", "sAsk", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("RETRIEVE", "(DEFUN (RETRIEVE PL-ITERATOR) ((QUERY CONS) (MODULE MODULE) (ENVIRONMENT ENVIRONMENT)) :DOCUMENTATION \"Returns an iterator of variable bindings that when substituted for the\nopen variables in `query' satisfy the query proposition.  The query is\nrun in `module' and relative to `environment'.  `query' has the same syntax\nas the PowerLoom `retrieve' command (which see) but with the `retrieve'\noperator omitted.    For example, here are some legal `query' arguments:\n	 \n    ((happy ?x))\n    (10 (happy ?x))\n    (all (happy ?x))\n    (all ?x (happy ?x))\n    (10 (happy ?x) :inference-level :assertion)\n    (10 (happy ?x) :inference-level :assertion :timeout 1.0)\n	\nIf there is only a single output variable (as in all the examples above)\neach element generated by the returned iterator will be a binding for\nthat variable - unless, the output variable was declared with a surrounding\npair of parentheses.  For example:\n	 \n    (all (?x) (happy ?x))\n	\nIn that case, the generated elements will be one-element lists.  If there\nare multiple output variables, each element generated by the returned\niterator will be a list of variable bindings that can be accessed using\nthe various `get-nth-...' functions.  The list of output variables does\nnot need to be declared in which case they are taken to be the open variables\nin the query proposition in the order in which they were encountered.  If\norder does matter or should be different from its default, it can be forced\nby declaring the set of output variables.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.powerloom.PLI", "retrieve", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons"), Native.find_java_class("edu.isi.stella.Module"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("S-RETRIEVE", "(DEFUN (S-RETRIEVE PL-ITERATOR) ((QUERY STRING) (MODULE-NAME STRING) (ENVIRONMENT ENVIRONMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Returns an iterator of variable bindings that when substituted for the\nopen variables in `query' satisfy the query proposition.  The query is\nrun in `module' and relative to `environment'.  `query' has the same syntax\nas the PowerLoom `retrieve' command (which see) but with the `retrieve'\noperator omitted.  Different from the PLI `retrieve' function, `s-retrieve'\ndoes not expect a top-level pair of parentheses.  For example, here are some\nlegal `query' arguments:\n	 \n    \\\"(happy ?x)\\\"\n    \\\"10 (happy ?x)\\\"\n    \\\"all (happy ?x)\\\"\n    \\\"all ?x (happy ?x)\\\"\n    \\\"10 (happy ?x) :inference-level :assertion\\\"\n    \\\"10 (happy ?x) :inference-level :assertion :timeout 1.0\\\"\n	\nIf there is only a single output variable (as in all the examples above)\neach element generated by the returned iterator will be a binding for\nthat variable - unless, the output variable was declared with a surrounding\npair of parentheses.  For example:\n	 \n    \\\"all (?x) (happy ?x)\\\"\n	\nIn that case, the generated elements will be one-element lists.  If there\nare multiple output variables, each element generated by the returned\niterator will be a list of variable bindings that can be accessed using\nthe various `get-nth-...' functions.  The list of output variables does\nnot need to be declared in which case they are taken to be the open variables\nin the query proposition in the order in which they were encountered.  If\norder does matter or should be different from its default, it can be forced\nby declaring the set of output variables.\n\nNames in `query' will be interpreted relative to module `module-name'.\nA null `module-name' or the empty string refers to the current module.\nIf no module can be found with the name `module-name', then a STELLA\n`no-such-context-exception' is thrown.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.powerloom.PLI", "sRetrieve", new java.lang.Class [] {Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String"), Native.find_java_class("edu.isi.powerloom.Environment")}), null);
      Stella.defineFunctionObject("MAIN", "(DEFUN MAIN ((ARGV-061 (ARRAY () OF STRING))) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.powerloom.PLI", "main", new java.lang.Class [] {Native.find_java_class("[Ljava.lang.String;")}), null);
      Stella.defineFunctionObject("STARTUP-PLI", "(DEFUN STARTUP-PLI () :PUBLIC? TRUE)", Native.find_java_method("edu.isi.powerloom._StartupPli", "startupPli", new java.lang.Class [] {}), null);
      { MethodSlot function = Symbol.lookupFunction(PLI.SYM_PLI_STARTUP_PLI);

        KeyValueList.setDynamicSlotValue(function.dynamicSlots, Logic.SYM_STELLA_METHOD_STARTUP_CLASSNAME, StringWrapper.wrapString("_StartupPli"), Stella.NULL_STRING_WRAPPER);
      }
    }
  }

  public static void startupPli() {
    { Object old$Module$000 = Stella.$MODULE$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setSpecial(Stella.$MODULE$, Stella.getStellaModule("/PLI", Stella.$STARTUP_TIME_PHASE$ > 1));
        Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
        if (Stella.currentStartupTimePhaseP(2)) {
          _StartupPli.helpStartupPli1();
        }
        if (Stella.currentStartupTimePhaseP(4)) {
          { Environment self062 = Environment.newEnvironment();

            self062.level = "ASSERTION";
            PLI.ASSERTION_ENV = self062;
          }
          { Environment self063 = Environment.newEnvironment();

            self063.level = "TAXONOMIC";
            PLI.TAXONOMIC_ENV = self063;
          }
          { Environment self064 = Environment.newEnvironment();

            self064.level = "INFERENCE";
            PLI.INFERENCE_ENV = self064;
          }
          { PlIterator self065 = PlIterator.newPlIterator();

            self065.cursor = Stella.NIL;
            PLI.EMPTY_PL_ITERATOR = self065;
          }
        }
        if (Stella.currentStartupTimePhaseP(5)) {
          { Stella_Class renamed_Class = Stella.defineClassFromStringifiedSource("ENVIRONMENT", "(DEFCLASS ENVIRONMENT (STANDARD-OBJECT) :PUBLIC? TRUE :SLOTS ((LEVEL :TYPE STRING)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|ENV|\" (LEVEL SELF)))");

            renamed_Class.classConstructorCode = Native.find_java_method("edu.isi.powerloom.Environment", "newEnvironment", new java.lang.Class [] {});
            renamed_Class.classSlotAccessorCode = Native.find_java_method("edu.isi.powerloom.Environment", "accessEnvironmentSlotValue", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.Environment"), Native.find_java_class("edu.isi.stella.Symbol"), Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Boolean.TYPE});
          }
          { Stella_Class renamed_Class = Stella.defineClassFromStringifiedSource("PL-ITERATOR", "(DEFCLASS PL-ITERATOR (ITERATOR) :PUBLIC? TRUE :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((CURSOR :TYPE CONS)))");

            renamed_Class.classConstructorCode = Native.find_java_method("edu.isi.powerloom.PlIterator", "newPlIterator", new java.lang.Class [] {});
            renamed_Class.classSlotAccessorCode = Native.find_java_method("edu.isi.powerloom.PlIterator", "accessPlIteratorSlotValue", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.PlIterator"), Native.find_java_class("edu.isi.stella.Symbol"), Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Boolean.TYPE});
          }
        }
        if (Stella.currentStartupTimePhaseP(6)) {
          Stella.finalizeClasses();
        }
        if (Stella.currentStartupTimePhaseP(7)) {
          _StartupPli.helpStartupPli2();
          _StartupPli.helpStartupPli3();
          _StartupPli.helpStartupPli4();
        }
        if (Stella.currentStartupTimePhaseP(8)) {
          Stella.finalizeSlots();
          Stella.cleanupUnfinalizedClasses();
        }
        if (Stella.currentStartupTimePhaseP(9)) {
          Stella_Object.inModule(((StringWrapper)(Stella_Object.copyConsTree(StringWrapper.wrapString("PLI")))));
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFGLOBAL *POWERLOOM-INITIALIZED?* BOOLEAN FALSE)");
          PLI.$POWERLOOM_INITIALIZEDp$ = true;
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFCONSTANT ASSERTION-ENV ENVIRONMENT (NEW ENVIRONMENT :LEVEL \"ASSERTION\") :PUBLIC? TRUE)");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFCONSTANT TAXONOMIC-ENV ENVIRONMENT (NEW ENVIRONMENT :LEVEL \"TAXONOMIC\") :PUBLIC? TRUE)");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFCONSTANT INFERENCE-ENV ENVIRONMENT (NEW ENVIRONMENT :LEVEL \"INFERENCE\") :PUBLIC? TRUE)");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFGLOBAL EMPTY-PL-ITERATOR PL-ITERATOR (NEW PL-ITERATOR :CURSOR NIL) :PUBLIC? FALSE :DOCUMENTATION \"Iterator that generates no values.\")");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFGLOBAL *LITERAL-CONCEPT* NAMED-DESCRIPTION NULL :PUBLIC? FALSE)");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFGLOBAL *STRING-CONCEPT* NAMED-DESCRIPTION NULL :PUBLIC? FALSE)");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFGLOBAL *INTEGER-CONCEPT* NAMED-DESCRIPTION NULL :PUBLIC? FALSE)");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFGLOBAL *FLOAT-CONCEPT* NAMED-DESCRIPTION NULL :PUBLIC? FALSE)");
          PLI.$LITERAL_CONCEPT$ = ((NamedDescription)(PLI.sGetConcept("LITERAL", "PL-USER", null)));
          PLI.$STRING_CONCEPT$ = ((NamedDescription)(PLI.sGetConcept("STRING", "PL-USER", null)));
          PLI.$INTEGER_CONCEPT$ = ((NamedDescription)(PLI.sGetConcept("INTEGER", "PL-USER", null)));
          PLI.$FLOAT_CONCEPT$ = ((NamedDescription)(PLI.sGetConcept("FLOAT", "PL-USER", null)));
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Stella.$MODULE$.set(old$Module$000);
      }
    }
  }

}
