//  -*- Mode: Java -*-
//
// NamedDescription.java

/*
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2017      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
*/

package edu.isi.powerloom.logic;

import edu.isi.stella.javalib.Native;
import edu.isi.stella.javalib.StellaSpecialVariable;
import edu.isi.stella.*;

public class NamedDescription extends Description {
    public List ioVariableNames;
    public List ioVariableTypes;
    public SequenceIndex extension;
    public String objectStringifiedSource;
    /** List of propositions generated by the definition of
     * this description.
     */
    public List objectOriginatedPropositions;

  public static NamedDescription newNamedDescription() {
    { NamedDescription self = null;

      self = new NamedDescription();
      self.dependentPropositionsIndex = null;
      self.dynamicSlots = KeyValueList.newKeyValueList();
      self.surrogateValueInverse = null;
      self.variableValueInverse = null;
      self.homeContext = ((Module)(Stella.$MODULE$.get()));
      self.queryPatterns = null;
      self.internalVariables = Logic.ZERO_VARIABLES_VECTOR;
      self.ioVariables = null;
      self.proposition = null;
      self.objectOriginatedPropositions = null;
      self.objectStringifiedSource = null;
      self.extension = null;
      self.ioVariableTypes = null;
      self.ioVariableNames = null;
      LogicObject.logLogicObject(self);
      return (self);
    }
  }

  /** Helper function for <code>printConceptOutline</code>
   * @param stream
   * @param currentDepth
   * @param depth
   * @param namedP
   */
  public void helpPrintOutline(OutputStream stream, int currentDepth, int depth, boolean namedP) {
    { NamedDescription top = this;

      Stella.indentOutline(currentDepth, stream);
      stream.nativeStream.println(Logic.objectName(top).toString());
      if (!((depth != Stella.NULL_INTEGER) &&
          ((depth >= 0) &&
           (currentDepth >= depth)))) {
        currentDepth = currentDepth + 1;
        { LogicObject c = null;
          Iterator iter000 = LogicObject.allDirectSubcollections(top, true);

          while (iter000.nextP()) {
            c = ((LogicObject)(iter000.value));
            c.helpPrintOutline(stream, currentDepth, depth, namedP);
          }
        }
      }
    }
  }

  /** Return a set of relations that immediately specialize
   * 'relation'.  If 'removeEquivalents?' (recommended), don't include any
   * relations equivalent to 'relation'.
   * @param relation
   * @param removeequivalentsP
   * @return Cons
   */
  public static Cons allDirectSubrelations(NamedDescription relation, boolean removeequivalentsP) {
    { MemoizationTable memoTable000 = null;
      Cons memoizedEntry000 = null;
      Stella_Object memoizedValue000 = null;

      if (Stella.$MEMOIZATION_ENABLEDp$) {
        memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_ALL_DIRECT_SUBRELATIONS_MEMO_TABLE_000.surrogateValue));
        if (memoTable000 == null) {
          Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_ALL_DIRECT_SUBRELATIONS_MEMO_TABLE_000, "(:MAX-VALUES 500 :TIMESTAMPS (:META-KB-UPDATE))");
          memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_ALL_DIRECT_SUBRELATIONS_MEMO_TABLE_000.surrogateValue));
        }
        memoizedEntry000 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable000)), relation, ((Context)(Stella.$CONTEXT$.get())), (removeequivalentsP ? Stella.TRUE_WRAPPER : Stella.FALSE_WRAPPER), Stella.MEMOIZED_NULL_VALUE, -1);
        memoizedValue000 = memoizedEntry000.value;
      }
      if (memoizedValue000 != null) {
        if (memoizedValue000 == Stella.MEMOIZED_NULL_VALUE) {
          memoizedValue000 = null;
        }
      }
      else {
        memoizedValue000 = Logic.filterOutUnnamedDescriptions(LogicObject.allDirectSubcollections(relation, removeequivalentsP).consify());
        if (Stella.$MEMOIZATION_ENABLEDp$) {
          memoizedEntry000.value = ((memoizedValue000 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue000);
        }
      }
      { Cons value000 = ((Cons)(memoizedValue000));

        return (value000);
      }
    }
  }

  /** Return a set of relations that immediately subsume
   * 'relation'.  If 'removeEquivalents?' (recommended), don't include any
   * relations equivalent to 'relation'.
   * @param relation
   * @param removeequivalentsP
   * @return Cons
   */
  public static Cons allDirectSuperrelations(NamedDescription relation, boolean removeequivalentsP) {
    { MemoizationTable memoTable000 = null;
      Cons memoizedEntry000 = null;
      Stella_Object memoizedValue000 = null;

      if (Stella.$MEMOIZATION_ENABLEDp$) {
        memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_ALL_DIRECT_SUPERRELATIONS_MEMO_TABLE_000.surrogateValue));
        if (memoTable000 == null) {
          Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_ALL_DIRECT_SUPERRELATIONS_MEMO_TABLE_000, "(:MAX-VALUES 500 :TIMESTAMPS (:META-KB-UPDATE))");
          memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_ALL_DIRECT_SUPERRELATIONS_MEMO_TABLE_000.surrogateValue));
        }
        memoizedEntry000 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable000)), relation, ((Context)(Stella.$CONTEXT$.get())), (removeequivalentsP ? Stella.TRUE_WRAPPER : Stella.FALSE_WRAPPER), Stella.MEMOIZED_NULL_VALUE, -1);
        memoizedValue000 = memoizedEntry000.value;
      }
      if (memoizedValue000 != null) {
        if (memoizedValue000 == Stella.MEMOIZED_NULL_VALUE) {
          memoizedValue000 = null;
        }
      }
      else {
        memoizedValue000 = Logic.filterOutUnnamedDescriptions(LogicObject.allDirectSupercollections(relation, removeequivalentsP).consify());
        if (Stella.$MEMOIZATION_ENABLEDp$) {
          memoizedEntry000.value = ((memoizedValue000 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue000);
        }
      }
      { Cons value000 = ((Cons)(memoizedValue000));

        return (value000);
      }
    }
  }

  /** Return a set of all (named) relations that specialize
   * relation.
   * @param relation
   * @param removeequivalentsP
   * @return Cons
   */
  public static Cons allSubrelations(NamedDescription relation, boolean removeequivalentsP) {
    { MemoizationTable memoTable000 = null;
      Cons memoizedEntry000 = null;
      Stella_Object memoizedValue000 = null;

      if (Stella.$MEMOIZATION_ENABLEDp$) {
        memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_ALL_SUBRELATIONS_MEMO_TABLE_000.surrogateValue));
        if (memoTable000 == null) {
          Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_ALL_SUBRELATIONS_MEMO_TABLE_000, "(:MAX-VALUES 1000 :TIMESTAMPS (:META-KB-UPDATE))");
          memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_ALL_SUBRELATIONS_MEMO_TABLE_000.surrogateValue));
        }
        memoizedEntry000 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable000)), relation, ((Context)(Stella.$CONTEXT$.get())), (removeequivalentsP ? Stella.TRUE_WRAPPER : Stella.FALSE_WRAPPER), Stella.MEMOIZED_NULL_VALUE, -1);
        memoizedValue000 = memoizedEntry000.value;
      }
      if (memoizedValue000 != null) {
        if (memoizedValue000 == Stella.MEMOIZED_NULL_VALUE) {
          memoizedValue000 = null;
        }
      }
      else {
        memoizedValue000 = NamedDescription.helpMemoizeAllSubrelations(relation, removeequivalentsP);
        if (Stella.$MEMOIZATION_ENABLEDp$) {
          memoizedEntry000.value = ((memoizedValue000 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue000);
        }
      }
      { Cons value000 = ((Cons)(memoizedValue000));

        return (value000);
      }
    }
  }

  public static Cons helpMemoizeAllSubrelations(NamedDescription relation, boolean removeequivalentsP) {
    { Cons subslots = Logic.filterOutUnnamedDescriptions(LogicObject.allSubcollections(relation).consify());

      if (removeequivalentsP) {
        return (Logic.removeEquivalentRelations(subslots, relation));
      }
      else {
        return (subslots);
      }
    }
  }

  /** Return a set of all relations that subsume relation.
   * @param relation
   * @param removeequivalentsP
   * @return Cons
   */
  public static Cons allSuperrelations(NamedDescription relation, boolean removeequivalentsP) {
    { MemoizationTable memoTable000 = null;
      Cons memoizedEntry000 = null;
      Stella_Object memoizedValue000 = null;

      if (Stella.$MEMOIZATION_ENABLEDp$) {
        memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_ALL_SUPERRELATIONS_MEMO_TABLE_000.surrogateValue));
        if (memoTable000 == null) {
          Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_ALL_SUPERRELATIONS_MEMO_TABLE_000, "(:MAX-VALUES 500 :TIMESTAMPS (:META-KB-UPDATE))");
          memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_ALL_SUPERRELATIONS_MEMO_TABLE_000.surrogateValue));
        }
        memoizedEntry000 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable000)), relation, ((Context)(Stella.$CONTEXT$.get())), (removeequivalentsP ? Stella.TRUE_WRAPPER : Stella.FALSE_WRAPPER), Stella.MEMOIZED_NULL_VALUE, -1);
        memoizedValue000 = memoizedEntry000.value;
      }
      if (memoizedValue000 != null) {
        if (memoizedValue000 == Stella.MEMOIZED_NULL_VALUE) {
          memoizedValue000 = null;
        }
      }
      else {
        memoizedValue000 = NamedDescription.helpMemoizeAllSuperrelations(relation, removeequivalentsP);
        if (Stella.$MEMOIZATION_ENABLEDp$) {
          memoizedEntry000.value = ((memoizedValue000 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue000);
        }
      }
      { Cons value000 = ((Cons)(memoizedValue000));

        return (value000);
      }
    }
  }

  public static Cons helpMemoizeAllSuperrelations(NamedDescription relation, boolean removeequivalentsP) {
    { Cons superslots = Logic.filterOutUnnamedDescriptions(LogicObject.allSupercollections(relation).consify());

      if (removeequivalentsP) {
        return (Logic.removeEquivalentRelations(superslots, relation));
      }
      else {
        return (superslots);
      }
    }
  }

  /** Return a list of all relations equivalent to 'relation'.
   * If 'reflexive?', include 'relation' in the list.
   * @param relation
   * @param reflexiveP
   * @return Cons
   */
  public static Cons allEquivalentRelations(NamedDescription relation, boolean reflexiveP) {
    { MemoizationTable memoTable000 = null;
      Cons memoizedEntry000 = null;
      Stella_Object memoizedValue000 = null;

      if (Stella.$MEMOIZATION_ENABLEDp$) {
        memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_ALL_EQUIVALENT_RELATIONS_MEMO_TABLE_000.surrogateValue));
        if (memoTable000 == null) {
          Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_ALL_EQUIVALENT_RELATIONS_MEMO_TABLE_000, "(:MAX-VALUES 500 :TIMESTAMPS (:META-KB-UPDATE))");
          memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_ALL_EQUIVALENT_RELATIONS_MEMO_TABLE_000.surrogateValue));
        }
        memoizedEntry000 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable000)), relation, ((Context)(Stella.$CONTEXT$.get())), (reflexiveP ? Stella.TRUE_WRAPPER : Stella.FALSE_WRAPPER), Stella.MEMOIZED_NULL_VALUE, -1);
        memoizedValue000 = memoizedEntry000.value;
      }
      if (memoizedValue000 != null) {
        if (memoizedValue000 == Stella.MEMOIZED_NULL_VALUE) {
          memoizedValue000 = null;
        }
      }
      else {
        memoizedValue000 = Logic.filterOutUnnamedDescriptions(LogicObject.allEquivalentCollections(relation, reflexiveP));
        if (Stella.$MEMOIZATION_ENABLEDp$) {
          memoizedEntry000.value = ((memoizedValue000 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue000);
        }
      }
      { Cons value000 = ((Cons)(memoizedValue000));

        return (value000);
      }
    }
  }

  /** Given a relation object, return it's name.
   * @param self
   * @return String
   */
  public static String relationName(NamedDescription self) {
    return (self.surrogateValueInverse.symbolName);
  }

  public void processDefinitionOptions(Stella_Object options) {
    { NamedDescription self = this;

      { Stella_Object key = null;
        Stella_Object value = null;
        Cons iter000 = Stella_Object.vetOptions(options, null).thePlist;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest.rest) {
          key = iter000.value;
          value = iter000.rest.value;
          if (!Stella_Object.runOptionHandlerP(self, ((Keyword)(key)), value)) {
            Logic.definitionKeywordAxiomsHandler(self, self.descriptionName(), ((Keyword)(key)), value);
          }
        }
      }
      if (!(Logic.classP(self))) {
        { Symbol name = self.descriptionName();
          Vector iovariables = self.ioVariables;
          List iovariabletypes = self.ioVariableTypes;
          Cons theaxioms = Logic.axioms(self);
          Cons typedarguments = Stella.NIL;
          Stella_Object operator = null;
          Stella_Object firstarg = null;
          Cons argumenttypeaxioms = Stella.NIL;

          if ((theaxioms != null) &&
              iovariabletypes.membP(Logic.SGT_STELLA_THING)) {
            { Stella_Object axiom = null;
              Cons iter001 = theaxioms;

              for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                axiom = iter001.value;
                if (Stella_Object.safePrimaryType(axiom) == Logic.SGT_STELLA_CONS) {
                  { Cons axiom000 = ((Cons)(axiom));

                    operator = axiom000.value;
                    firstarg = axiom000.rest.value;
                    if ((operator == Logic.SYM_PL_KERNEL_KB_NTH_DOMAIN) &&
                        ((firstarg == name) &&
                         Stella_Object.integerP(axiom000.rest.rest.value))) {
                      typedarguments = Cons.cons(((PatternVariable)((iovariables.theArray)[(((IntegerWrapper)(axiom000.rest.rest.value)).wrapperValue)])), typedarguments);
                    }
                    else if ((operator == Logic.SYM_PL_KERNEL_KB_DOMAIN) &&
                        (firstarg == name)) {
                      typedarguments = Cons.cons(((PatternVariable)((iovariables.theArray)[0])), typedarguments);
                    }
                    else if ((operator == Logic.SYM_PL_KERNEL_KB_RANGE) &&
                        (firstarg == name)) {
                      typedarguments = Cons.cons(((PatternVariable)(iovariables.last())), typedarguments);
                    }
                  }
                }
                else {
                }
              }
            }
          }
          { Surrogate type = null;
            Cons iter002 = iovariabletypes.theConsList;
            PatternVariable var = null;
            Vector vector000 = iovariables;
            int index000 = 0;
            int length000 = vector000.length();
            int i = Stella.NULL_INTEGER;
            int iter003 = 0;
            Cons collect000 = null;

            for (;(!(iter002 == Stella.NIL)) &&
                      (index000 < length000); 
                  iter002 = iter002.rest,
                  index000 = index000 + 1,
                  iter003 = iter003 + 1) {
              type = ((Surrogate)(iter002.value));
              var = ((PatternVariable)((vector000.theArray)[index000]));
              i = iter003;
              if ((type != null) &&
                  ((!(type == Logic.SGT_STELLA_THING)) ||
                   (!typedarguments.membP(var)))) {
                if (collect000 == null) {
                  {
                    collect000 = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_PL_KERNEL_KB_NTH_DOMAIN, Cons.cons(name, Cons.cons(Cons.cons(IntegerWrapper.wrapInteger(i), Cons.cons(Symbol.internSymbolInModule(type.symbolName, ((Module)(type.homeContext)), false), Stella.NIL)), Stella.NIL)))), Stella.NIL);
                    if (argumenttypeaxioms == Stella.NIL) {
                      argumenttypeaxioms = collect000;
                    }
                    else {
                      Cons.addConsToEndOfConsList(argumenttypeaxioms, collect000);
                    }
                  }
                }
                else {
                  {
                    collect000.rest = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_PL_KERNEL_KB_NTH_DOMAIN, Cons.cons(name, Cons.cons(Cons.cons(IntegerWrapper.wrapInteger(i), Cons.cons(Symbol.internSymbolInModule(type.symbolName, ((Module)(type.homeContext)), false), Stella.NIL)), Stella.NIL)))), Stella.NIL);
                    collect000 = collect000.rest;
                  }
                }
              }
            }
          }
          if (!(argumenttypeaxioms == Stella.NIL)) {
            Logic.axiomsSetter(self, Logic.combineAxiomLists(argumenttypeaxioms, theaxioms));
          }
        }
      }
    }
  }

  public static void checkDescriptionArgumentTypes(NamedDescription self) {
    { Object old$Module$000 = Stella.$MODULE$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setSpecial(Stella.$MODULE$, self.homeModule());
        Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
        { Surrogate type = null;
          Cons iter000 = self.ioVariableTypes.theConsList;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            type = ((Surrogate)(iter000.value));
            { NamedDescription renamed_Class = Logic.getDescription(type);

              if (renamed_Class == null) {
                { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

                  { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

                    try {
                      Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                      {
                        stream000.nativeStream.println("ERROR: Undefined class `" + type.symbolName + "' appears as argument type");
                        stream000.nativeStream.println("   in the definition of relation `" + self.descriptionName() + "'.");
                        stream000.nativeStream.println(".");
                      }
;
                      Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

                    } finally {
                      Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
                    }
                  }
                  throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
                }
              }
              if (!NamedDescription.classDescriptionP(renamed_Class)) {
                {
                  Stella.STANDARD_OUTPUT.nativeStream.println("Non-class `" + type.symbolName + "' appears as argument type");
                  Stella.STANDARD_OUTPUT.nativeStream.println("in the definition of relation `" + self.descriptionName() + "'.");
                  Stella.STANDARD_OUTPUT.nativeStream.println();
                }
;
              }
            }
          }
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Stella.$MODULE$.set(old$Module$000);
      }
    }
  }

  public static Stella_Object completeRuleDefinition(NamedDescription self, Stella_Object body, Symbol arrow) {
    { Cons parameters = NamedDescription.yieldRelationParametersTree(self, false, false);

      return (Cons.list$(Cons.cons(Logic.SYM_STELLA_FORALL, Cons.cons(parameters, Cons.cons(Cons.cons(Cons.cons(arrow, Cons.list$(Cons.cons(Cons.cons(self.descriptionName(), parameters.concatenate(Stella.NIL, Stella.NIL)), Cons.cons(Logic.wrapKifWithForall(body, parameters), Cons.cons(Stella.NIL, Stella.NIL))))), Stella.NIL), Stella.NIL)))));
    }
  }

  public static Cons yieldRelationParametersTree(NamedDescription self, boolean dropfunctionparameterP, boolean typedP) {
    { Cons parameterlist = Stella.NIL;
      Stella_Object parameter = null;

      { Symbol pname = null;
        Cons iter000 = self.ioVariableNames.theConsList;
        Surrogate ptype = null;
        Cons iter001 = self.ioVariableTypes.theConsList;

        for (;(!(iter000 == Stella.NIL)) &&
                  (!(iter001 == Stella.NIL)); iter000 = iter000.rest, iter001 = iter001.rest) {
          pname = ((Symbol)(iter000.value));
          ptype = ((Surrogate)(iter001.value));
          parameter = pname;
          if (typedP &&
              (!(ptype == Logic.SGT_STELLA_THING))) {
            parameter = Cons.cons(parameter, Cons.cons(Symbol.internSymbolInModule(ptype.symbolName, ((Module)(ptype.homeContext)), true), Stella.NIL));
          }
          parameterlist = Cons.cons(parameter, parameterlist);
        }
      }
      if (dropfunctionparameterP &&
          NamedDescription.functionDescriptionP(self)) {
        parameterlist = parameterlist.rest;
      }
      return (parameterlist.reverse());
    }
  }

  public static void definitionHalfRuleHandler(NamedDescription self, StorageSlot slot, Stella_Object body) {
    { Keyword keyword = ((Keyword)(KeyValueList.dynamicSlotValue(slot.dynamicSlots, Logic.SYM_STELLA_SLOT_OPTION_KEYWORD, null)));
      Symbol arrow = Symbol.internSymbolInModule(keyword.symbolName, Stella.getStellaModule("PL-KERNEL-KB", true), false);
      Stella_Object newrule = null;

      if (body == null) {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream000.nativeStream.println("ERROR: Missing value for arrow keyword.");
              Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
            }
          }
          throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      if (Stella_Object.stringP(body)) {
        body = Stella.unstringifyInModule(((StringWrapper)(body)).wrapperValue, self.homeModule());
      }
      newrule = NamedDescription.completeRuleDefinition(self, body, arrow);
      Logic.axiomsSetter(self, Logic.combineAxiomLists(Logic.axioms(self), newrule));
    }
  }

  public static boolean inferableThroughBySomeDescendantP(NamedDescription self, LogicObject throughchild, Cons alreadyvisitedlist) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(throughchild);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        { NamedDescription throughchild000 = ((NamedDescription)(throughchild));

          if ((NamedDescription.lookupSpecialist(throughchild000) != null) ||
              (NamedDescription.lookupComputation(throughchild000) != null)) {
            return (true);
          }
          else if (!(self.proposition.kind == throughchild000.proposition.kind)) {
            return (true);
          }
          else if (!Description.inferableWithCycleCheckP(throughchild000, alreadyvisitedlist)) {
            return (false);
          }
          alreadyvisitedlist = Cons.cons(throughchild000, alreadyvisitedlist);
          { Proposition p = null;
            Cons iter000 = LogicObject.applicableRulesOfDescription(throughchild000, Logic.KWD_BACKWARD, false);

            for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
              p = ((Proposition)(iter000.value));
              if ((!((BooleanWrapper)(KeyValueList.dynamicSlotValue(p.dynamicSlots, Logic.SYM_LOGIC_FORWARD_ONLYp, Stella.FALSE_WRAPPER))).wrapperValue) &&
                  Proposition.trueP(p)) {
                if (NamedDescription.inferableThroughBySomeDescendantP(self, ((LogicObject)((p.arguments.theArray)[0])), alreadyvisitedlist)) {
                  return (true);
                }
              }
            }
          }
          return (false);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description throughchild000 = ((Description)(throughchild));

          { boolean testValue001 = false;

            { boolean foundP000 = false;

              { Description parent = null;
                Cons iter001 = Description.allIntensionalParents(throughchild000).theConsList;

                loop001 : for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                  parent = ((Description)(iter001.value));
                  if (LogicObject.collectionImpliesCollectionP(parent, self)) {
                    foundP000 = true;
                    break loop001;
                  }
                }
              }
              testValue001 = foundP000;
            }
            testValue001 = !testValue001;
            { boolean value000 = testValue001;

              return (value000);
            }
          }
        }
      }
      else {
        return (false);
      }
    }
  }

  public static double dynamicallyEstimateExtensionSize(NamedDescription description) {
    if ((description == null) ||
        (!NamedDescription.relationSupportsExtensionP(description))) {
      return (Stella.NULL_FLOAT);
    }
    { double estimate = Stella.NULL_FLOAT;

      if (estimate == Stella.NULL_FLOAT) {
        estimate = ((double)(NamedDescription.getDescriptionExtension(description, true).estimatedLength()));
      }
      return (estimate);
    }
  }

  public static double dynamicallyEstimateInferenceCost(NamedDescription self) {
    { MemoizationTable memoTable000 = null;
      Cons memoizedEntry000 = null;
      Stella_Object memoizedValue000 = null;

      if (Stella.$MEMOIZATION_ENABLEDp$) {
        memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_DYNAMICALLY_ESTIMATE_INFERENCE_COST_MEMO_TABLE_000.surrogateValue));
        if (memoTable000 == null) {
          Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_DYNAMICALLY_ESTIMATE_INFERENCE_COST_MEMO_TABLE_000, "(:MAX-VALUES 500 :TIMESTAMPS (:IMPLIES-PROPOSITION-UPDATE))");
          memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_DYNAMICALLY_ESTIMATE_INFERENCE_COST_MEMO_TABLE_000.surrogateValue));
        }
        memoizedEntry000 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable000)), self, ((Context)(Stella.$CONTEXT$.get())), Stella.MEMOIZED_NULL_VALUE, null, -1);
        memoizedValue000 = memoizedEntry000.value;
      }
      if (memoizedValue000 != null) {
        if (memoizedValue000 == Stella.MEMOIZED_NULL_VALUE) {
          memoizedValue000 = null;
        }
      }
      else {
        memoizedValue000 = IntegerWrapper.wrapInteger(LogicObject.applicableRulesOfDescription(self, Logic.KWD_BACKWARD, true).length());
        if (Stella.$MEMOIZATION_ENABLEDp$) {
          memoizedEntry000.value = ((memoizedValue000 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue000);
        }
      }
      { IntegerWrapper nofrules = ((IntegerWrapper)(memoizedValue000));

        return (Stella.float_max(Logic.INFERABLE_PENALTY_COST * nofrules.wrapperValue, 1.0));
      }
    }
  }

  public static double estimateCardinalityOfExtension(NamedDescription description) {
    if ((description == null) ||
        (!NamedDescription.relationSupportsExtensionP(description))) {
      return (Stella.NULL_FLOAT);
    }
    { int estimate = Description.accessObservedCardinality(description);

      if ((estimate == Stella.NULL_INTEGER) &&
          (description.extension != null)) {
        estimate = description.extension.estimatedLength();
      }
      if (estimate == Stella.NULL_INTEGER) {
        estimate = 0;
      }
      return (((double)(Stella.integer_max(estimate, (NamedDescription.classDescriptionP(description) ? ((int)(Logic.ESTIMATED_SIZE_OF_CLASS_EXTENSION)) : ((int)(Logic.ESTIMATED_NUMBER_OF_PREDICATE_BINDINGS * Logic.ESTIMATED_NUMBER_OF_PREDICATE_BINDINGS * Logic.ESTIMATED_NUMBER_OF_PREDICATE_BINDINGS)))))));
    }
  }

  public static void updateObservedCardinality(NamedDescription self, int cardinality) {
    { Object old$Context$000 = Stella.$CONTEXT$.get();
      Object old$Module$000 = Stella.$MODULE$.get();

      try {
        Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
        Native.setSpecial(Stella.$MODULE$, ((Context)(Stella.$CONTEXT$.get())).baseModule);
        { Object old$InvisibleassertionP$000 = Logic.$INVISIBLEASSERTIONp$.get();

          try {
            Native.setBooleanSpecial(Logic.$INVISIBLEASSERTIONp$, true);
            Logic.assertTuple(Logic.SGT_PL_KERNEL_KB_OBSERVED_CARDINALITY_OF, Cons.consList(Cons.cons(self, Cons.cons(IntegerWrapper.wrapInteger(cardinality), Stella.NIL))));

          } finally {
            Logic.$INVISIBLEASSERTIONp$.set(old$InvisibleassertionP$000);
          }
        }

      } finally {
        Stella.$MODULE$.set(old$Module$000);
        Stella.$CONTEXT$.set(old$Context$000);
      }
    }
  }

  public static BooleanVector getIndexingVector(NamedDescription self) {
    if (self.arity() == 2) {
      return (NamedDescription.getBinaryIndexingVector(self));
    }
    { BooleanVector cachedvector = ((BooleanVector)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_INDEXING_VECTOR, null)));

      if (cachedvector != null) {
        return (cachedvector);
      }
      { List zeroonelist = List.newList();

        { Surrogate type = null;
          Cons iter000 = self.ioVariableTypes.theConsList;
          Cons collect000 = null;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            type = ((Surrogate)(iter000.value));
            if (collect000 == null) {
              {
                collect000 = Cons.cons((Logic.typeHasBacklinksP(Logic.ensureDeferredDescription(type)) ? Stella.ONE_WRAPPER : Stella.ZERO_WRAPPER), Stella.NIL);
                if (zeroonelist.theConsList == Stella.NIL) {
                  zeroonelist.theConsList = collect000;
                }
                else {
                  Cons.addConsToEndOfConsList(zeroonelist.theConsList, collect000);
                }
              }
            }
            else {
              {
                collect000.rest = Cons.cons((Logic.typeHasBacklinksP(Logic.ensureDeferredDescription(type)) ? Stella.ONE_WRAPPER : Stella.ZERO_WRAPPER), Stella.NIL);
                collect000 = collect000.rest;
              }
            }
          }
        }
        KeyValueList.setDynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_INDEXING_VECTOR, Logic.zeroOneListToBooleanVector(zeroonelist), null);
        zeroonelist.free();
        return (((BooleanVector)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_INDEXING_VECTOR, null))));
      }
    }
  }

  public static BooleanVector getBinaryIndexingVector(NamedDescription self) {
    { List iovariabletypes = self.ioVariableTypes;
      Surrogate typeone = Logic.ensureDeferredDescription(((Surrogate)(iovariabletypes.nth(0))));
      Surrogate typetwo = Logic.ensureDeferredDescription(((Surrogate)(iovariabletypes.nth(1))));
      boolean bitoneP = Logic.typeHasBacklinksP(typeone);
      boolean bittwoP = Logic.typeHasBacklinksP(typetwo);

      if (bitoneP) {
        return ((bittwoP ? Logic.V_1_1 : Logic.V_1_0));
      }
      else {
        return ((bittwoP ? Logic.V_0_1 : Logic.V_0_0));
      }
    }
  }

  public static List getUniquenessVectors(NamedDescription self) {
    if (self.arity() == 2) {
      return (NamedDescription.getBinaryUniquenessVectors(self));
    }
    { List cachedvectorlist = self.uniquenessvectors();

      if (cachedvectorlist != null) {
        return (cachedvectorlist);
      }
      else {
        return (Stella.NIL_LIST);
      }
    }
  }

  public static List getBinaryUniquenessVectors(NamedDescription self) {
    { boolean singlevaluedinverseP = (((NamedDescription)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_INVERSE_DESCRIPTION, null))) != null) &&
          Logic.singleValuedTermP(((NamedDescription)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_INVERSE_DESCRIPTION, null))));

      if (Logic.singleValuedTermP(self)) {
        return ((singlevaluedinverseP ? Logic.V_1_0_AND_V_0_1 : Logic.V_1_0_SINGLETON));
      }
      else {
        return (((List)((singlevaluedinverseP ? Logic.V_0_1_SINGLETON : Stella.NIL_LIST))));
      }
    }
  }

  public List uniquenessvectors() {
    { NamedDescription self = this;

      { List answer = ((List)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_UNIQUENESSVECTORS, null)));

        if (answer == null) {
          return (Stella.NIL_LIST);
        }
        else {
          return (answer);
        }
      }
    }
  }

  public static boolean relationSupportsExtensionP(NamedDescription self) {
    return ((!Logic.testPropertyP(self, Logic.SGT_PL_KERNEL_KB_ABSTRACT)) &&
        (!Logic.logicalSubtypeOfLiteralP(self.surrogateValueInverse)));
  }

  public static boolean testRangeTypeP(NamedDescription relation, Stella_Object instance, NamedDescription valuetype) {
    { Surrogate relationref = relation.surrogateValueInverse;
      Surrogate valuesurrogate = valuetype.surrogateValueInverse;

      if (Logic.singleValuedTermP(relation)) {
        { Stella_Object filler = Logic.accessBinaryValue(instance, relationref);

          if (filler != null) {
            return (Logic.testTypeOnInstanceP(filler, valuesurrogate));
          }
        }
      }
      { Skolem roleset = NamedDescription.getRolesetOf(relation, instance);
        boolean closedP = Logic.closedTermP(relation) ||
            Logic.closedTermP(roleset);

        if (roleset != null) {
          { boolean testValue000 = false;

            if (LogicObject.collectionImpliesCollectionP(roleset, valuetype)) {
              testValue000 = true;
            }
            else {
              {
                testValue000 = closedP;
                if (testValue000) {
                  { boolean alwaysP000 = true;

                    { Stella_Object filler = null;
                      Cons iter000 = LogicObject.allSlotValues(((LogicObject)(instance)), relationref);

                      loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                        filler = iter000.value;
                        if (!Logic.testTypeOnInstanceP(filler, valuesurrogate)) {
                          alwaysP000 = false;
                          break loop000;
                        }
                      }
                    }
                    testValue000 = alwaysP000;
                  }
                }
              }
            }
            if (testValue000) {
              return (true);
            }
          }
        }
        else {
          { boolean testValue001 = false;

            testValue001 = closedP;
            if (testValue001) {
              { boolean alwaysP001 = true;

                { Stella_Object filler = null;
                  Cons iter001 = LogicObject.allSlotValues(((LogicObject)(instance)), relationref);

                  loop001 : for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                    filler = iter001.value;
                    if (!Logic.testTypeOnInstanceP(filler, valuesurrogate)) {
                      alwaysP001 = false;
                      break loop001;
                    }
                  }
                }
                testValue001 = alwaysP001;
              }
            }
            if (testValue001) {
              return (true);
            }
          }
        }
      }
      { NamedDescription superr = null;
        Cons iter002 = NamedDescription.allSuperrelations(relation, false);

        for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
          superr = ((NamedDescription)(iter002.value));
          { Skolem superroleset = NamedDescription.getRolesetOf(superr, instance);

            if ((superroleset != null) &&
                LogicObject.collectionImpliesCollectionP(superroleset, valuetype)) {
              return (true);
            }
          }
        }
      }
      return (false);
    }
  }

  public static int computeMaximumCardinality(NamedDescription relation, Stella_Object instance) {
    { Object old$ReversepolarityP$000 = Logic.$REVERSEPOLARITYp$.get();

      try {
        Native.setBooleanSpecial(Logic.$REVERSEPOLARITYp$, false);
        { Surrogate relationref = relation.surrogateValueInverse;
          boolean singlevaluedP = Logic.singleValuedTermP(relation);

          if (singlevaluedP &&
              (Logic.accessBinaryValue(instance, relationref) != null)) {
            return (1);
          }
          { Cons maxcards = Cons.consList(Cons.cons(IntegerWrapper.wrapInteger(NamedDescription.computeStoredBoundOnRoleset(relation, instance, Logic.KWD_UPPER)), Stella.NIL));

            if (singlevaluedP) {
              maxcards = Cons.cons(IntegerWrapper.wrapInteger(1), maxcards);
            }
            { Skolem roleset = NamedDescription.getRolesetOf(relation, instance);

              if ((roleset != null) &&
                  Logic.emptyTermP(roleset)) {
                return (0);
              }
            }
            if (Logic.closedTermP(relation)) {
              maxcards = Cons.cons(IntegerWrapper.wrapInteger(NamedDescription.computeMinimumCardinality(relation, instance)), maxcards);
            }
            { NamedDescription superr = null;
              Cons iter000 = NamedDescription.allSuperrelations(relation, false);

              for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                superr = ((NamedDescription)(iter000.value));
                maxcards = Cons.cons(IntegerWrapper.wrapInteger(NamedDescription.computeStoredBoundOnRoleset(superr, instance, Logic.KWD_UPPER)), maxcards);
              }
            }
            { int minmax = ((IntegerWrapper)(maxcards.value)).wrapperValue;

              { IntegerWrapper ub = null;
                Cons iter001 = maxcards.rest;

                for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                  ub = ((IntegerWrapper)(iter001.value));
                  if (ub != null) {
                    minmax = Stella.integer_min(minmax, ub.wrapperValue);
                  }
                }
              }
              return (minmax);
            }
          }
        }

      } finally {
        Logic.$REVERSEPOLARITYp$.set(old$ReversepolarityP$000);
      }
    }
  }

  public static int computeMinimumCardinality(NamedDescription relation, Stella_Object instance) {
    { Object old$ReversepolarityP$000 = Logic.$REVERSEPOLARITYp$.get();

      try {
        Native.setBooleanSpecial(Logic.$REVERSEPOLARITYp$, false);
        { Surrogate relationref = relation.surrogateValueInverse;

          if (Logic.singleValuedTermP(relation) &&
              (Logic.accessBinaryValue(instance, relationref) != null)) {
            return (1);
          }
          { Cons mincards = Cons.consList(Cons.cons(IntegerWrapper.wrapInteger(0), Cons.cons(IntegerWrapper.wrapInteger(NamedDescription.computeStoredBoundOnRoleset(relation, instance, Logic.KWD_LOWER)), Stella.NIL)));

            mincards = Cons.cons(IntegerWrapper.wrapInteger(LogicObject.allSlotValues(((LogicObject)(instance)), relationref).length()), mincards);
            { NamedDescription subr = null;
              Cons iter000 = NamedDescription.allSubrelations(relation, false);

              for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                subr = ((NamedDescription)(iter000.value));
                mincards = Cons.cons(IntegerWrapper.wrapInteger(NamedDescription.computeStoredBoundOnRoleset(subr, instance, Logic.KWD_LOWER)), mincards);
              }
            }
            { int maxmin = ((IntegerWrapper)(mincards.value)).wrapperValue;

              { IntegerWrapper lb = null;
                Cons iter001 = mincards.rest;

                for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                  lb = ((IntegerWrapper)(iter001.value));
                  if (lb != null) {
                    maxmin = Stella.integer_max(maxmin, lb.wrapperValue);
                  }
                }
              }
              return (maxmin);
            }
          }
        }

      } finally {
        Logic.$REVERSEPOLARITYp$.set(old$ReversepolarityP$000);
      }
    }
  }

  public static int computeStoredBoundOnRoleset(NamedDescription relation, Stella_Object instance, Keyword lowerorupper) {
    { Skolem roleset = NamedDescription.getRolesetOf(relation, instance);
      Stella_Object cardinality = null;
      edu.isi.powerloom.pl_kernel_kb.IntervalCache intervalcache = null;
      Stella_Object bound = null;

      if (roleset == null) {
        return (Stella.NULL_INTEGER);
      }
      cardinality = Logic.accessBinaryValue(roleset, Logic.SGT_PL_KERNEL_KB_CARDINALITY);
      if (cardinality != null) {
        { Surrogate testValue000 = Stella_Object.safePrimaryType(cardinality);

          if (Surrogate.subtypeOfIntegerP(testValue000)) {
            { IntegerWrapper cardinality000 = ((IntegerWrapper)(cardinality));

              return (cardinality000.wrapperValue);
            }
          }
          else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
            { Skolem cardinality000 = ((Skolem)(cardinality));

              { 
                intervalcache = edu.isi.powerloom.pl_kernel_kb.PlKernelKb.getIntervalCache(cardinality000);
                if (intervalcache != null) {
                  if (lowerorupper == Logic.KWD_LOWER) {
                    bound = intervalcache.lowerBound;
                  }
                  else if (lowerorupper == Logic.KWD_UPPER) {
                    bound = intervalcache.upperBound;
                  }
                  else {
                    { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

                      stream000.nativeStream.print("`" + lowerorupper + "' is not a valid case option");
                      throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
                    }
                  }
                  if ((bound != null) &&
                      Stella_Object.isaP(bound, Logic.SGT_STELLA_INTEGER_WRAPPER)) {
                    return (IntegerWrapper.unwrapInteger(((IntegerWrapper)(bound))));
                  }
                }
              }
            }
          }
          else {
            { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

              stream001.nativeStream.print("`" + testValue000 + "' is not a valid case option");
              throw ((StellaException)(StellaException.newStellaException(stream001.theStringReader()).fillInStackTrace()));
            }
          }
        }
      }
      return (Stella.NULL_INTEGER);
    }
  }

  public static Skolem getRolesetOf(NamedDescription relation, Stella_Object instance) {
    return (((Skolem)(Logic.allRelationValues(Logic.SGT_PL_KERNEL_KB_THE_ROLESET, Cons.consList(Cons.cons(relation, Cons.cons(instance, Stella.NIL)))).value)));
  }

  public static java.lang.reflect.Method lookupEvaluator(NamedDescription description) {
    { MethodSlot function = NamedDescription.lookupEvaluatorFunction(description);

      if (function != null) {
        return (function.functionCode);
      }
      else {
        return (null);
      }
    }
  }

  public static MethodSlot lookupEvaluatorFunction(NamedDescription description) {
    { Stella_Object computationprocedure = Logic.accessBinaryValue(description, Logic.SGT_PL_KERNEL_KB_RELATION_EVALUATOR);

      if (computationprocedure != null) {
        return (ComputedProcedure.stellaFunctionFromProcedure(((ComputedProcedure)(computationprocedure))));
      }
      else {
        return (null);
      }
    }
  }

  public static java.lang.reflect.Method lookupComputation(NamedDescription description) {
    { MethodSlot function = NamedDescription.lookupComputationFunction(description);

      if (function != null) {
        return (function.functionCode);
      }
      else {
        return (null);
      }
    }
  }

  public static MethodSlot lookupComputationFunction(NamedDescription description) {
    { Stella_Object computationprocedure = Logic.accessBinaryValue(description, Logic.SGT_PL_KERNEL_KB_RELATION_COMPUTATION);

      if (computationprocedure != null) {
        return (ComputedProcedure.stellaFunctionFromProcedure(((ComputedProcedure)(computationprocedure))));
      }
      else {
        return (null);
      }
    }
  }

  public static java.lang.reflect.Method lookupConstraint(NamedDescription description) {
    { MethodSlot function = NamedDescription.lookupConstraintFunction(description);

      if (function != null) {
        return (function.functionCode);
      }
      else {
        return (null);
      }
    }
  }

  public static MethodSlot lookupConstraintFunction(NamedDescription description) {
    { Stella_Object computationprocedure = Logic.accessBinaryValue(description, Logic.SGT_PL_KERNEL_KB_RELATION_CONSTRAINT);

      if (computationprocedure != null) {
        return (ComputedProcedure.stellaFunctionFromProcedure(((ComputedProcedure)(computationprocedure))));
      }
      else {
        return (null);
      }
    }
  }

  public static java.lang.reflect.Method lookupSpecialist(NamedDescription description) {
    { Stella_Object specialistprocedure = Logic.accessBinaryValue(description, Logic.SGT_PL_KERNEL_KB_RELATION_SPECIALIST);
      java.lang.reflect.Method functioncode = null;

      if (specialistprocedure != null) {
        if (((Boolean)(Logic.$REVERSEPOLARITYp$.get())).booleanValue() &&
            (!Logic.testPropertyP(specialistprocedure, Logic.SGT_PL_KERNEL_KB_HANDLES_REVERSE_POLARITY))) {
          return (null);
        }
        else {
          functioncode = ComputedProcedure.functionCodeFromProcedure(((ComputedProcedure)(specialistprocedure)));
        }
      }
      if (functioncode == null) {
        if ((description.nativeRelation() != null) &&
            (!NamedDescription.classDescriptionP(description))) {
          functioncode = Native.find_java_method("edu.isi.powerloom.logic.ControlFrame", "nativeSlotReaderSpecialist", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.ControlFrame"), Native.find_java_class("edu.isi.stella.Keyword")});
        }
      }
      return (functioncode);
    }
  }

  /** Prints a description of 'self' to stream 'stream'.  'mode'
   * can be :terse, :verbose, or :source.  Used by <code>describe</code>.
   * @param stream
   * @param mode
   */
  public void describeObject(OutputStream stream, Keyword mode) {
    { NamedDescription self = this;

      if (mode == Logic.KWD_TERSE) {
        Stella_Object.describeTersely(self, stream);
      }
      else if ((mode == Logic.KWD_VERBOSE) ||
          (mode == Logic.KWD_SOURCE)) {
        NamedDescription.prettyPrintNamedDescription(self, stream);
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + mode + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  public static void prettyPrintNamedDescription(NamedDescription self, OutputStream stream) {
    Logic.prettyPrintRelationDefinitionTree(((Cons)(Stella.readSExpressionFromString(Logic.stringifiedSource(self)))), stream);
  }

  public static boolean specialistApplicableP(NamedDescription description, Proposition proposition) {
    { int dArity = description.arity();
      int pArity = proposition.arguments.length();

      if (dArity < 0) {
        return (true);
      }
      else {
        return (dArity == pArity);
      }
    }
  }

  public static DescriptionExtensionIterator allTrueExtensionMembers(NamedDescription self, boolean specializeP) {
    { DescriptionExtensionIterator iterator = DescriptionExtensionIterator.newDescriptionExtensionIterator();

      iterator.rootDescription = self;
      iterator.extensionIterator = NamedDescription.allExtensionMembers(self);
      if (specializeP) {
        iterator.subcollections = null;
      }
      else {
        iterator.subcollections = Stella.NIL;
      }
      iterator.removingDuplicatesP = specializeP &&
          (self.arity() == 1);
      return (iterator);
    }
  }

  public static boolean disjointClassesP(NamedDescription desc1, NamedDescription desc2) {
    return ((!(desc1 == desc2)) &&
        ((!LogicObject.collectionImpliesCollectionP(desc1, desc2)) &&
         (!LogicObject.collectionImpliesCollectionP(desc2, desc1))));
  }

  public static boolean chainableRelationP(NamedDescription description, Keyword headortail) {
    if (headortail == null) {
      return (true);
    }
    { Cons nonpermittedpredicates = null;

      if (headortail == Logic.KWD_TAIL) {
        nonpermittedpredicates = Stella.getQuotedTree("((/PL-KERNEL-KB/@HOLDS /PL-KERNEL-KB/@MEMBER-OF /PL-KERNEL-KB/@INSTANCE-OF /PL-KERNEL-KB/@SUBSET-OF @NUMBER-WRAPPER.PLUS @NUMBER-WRAPPER.MINUS @NUMBER-WRAPPER.TIMES @NUMBER-WRAPPER.DIVIDE) \"/LOGIC\")", "/LOGIC");
      }
      else if (headortail == Logic.KWD_HEAD) {
        nonpermittedpredicates = Stella.getQuotedTree("((@NUMBER-WRAPPER.PLUS @NUMBER-WRAPPER.MINUS @NUMBER-WRAPPER.TIMES @NUMBER-WRAPPER.DIVIDE) \"/LOGIC\")", "/LOGIC");
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + headortail + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      return (!nonpermittedpredicates.memberP(description.surrogateValueInverse));
    }
  }

  public static boolean definedRelationP(NamedDescription self) {
    return ((!((BooleanWrapper)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_UNDECLAREDp, Stella.FALSE_WRAPPER))).wrapperValue) &&
        ((Logic.stringifiedSource(self) != null) ||
         (self.nativeRelation() != null)));
  }

  public static Description getComplementOfGoalDescription(NamedDescription self) {
    { Description complement = ((Description)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_COMPLEMENT_DESCRIPTION, null)));

      if (complement != null) {
        return (complement);
      }
      if (self == ((NamedDescription)(Logic.$RECURSIVEGETCOMPLEMENTARGUMENT$.get()))) {
        return (null);
      }
      { Object old$Module$000 = Stella.$MODULE$.get();
        Object old$Context$000 = Stella.$CONTEXT$.get();

        try {
          Native.setSpecial(Stella.$MODULE$, self.homeModule());
          Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
          { Cons declarations = Stella.NIL;
            Cons variables = Stella.NIL;
            Cons clauses = Stella.NIL;

            { PatternVariable v = null;
              Vector vector000 = self.ioVariables;
              int index000 = 0;
              int length000 = vector000.length();
              Surrogate type = null;
              Cons iter000 = self.ioVariableTypes.theConsList;
              Cons collect000 = null;

              for (;(index000 < length000) &&
                        (!(iter000 == Stella.NIL)); index000 = index000 + 1, iter000 = iter000.rest) {
                v = ((PatternVariable)((vector000.theArray)[index000]));
                type = ((Surrogate)(iter000.value));
                if ((type == null) ||
                    NamedDescription.classDescriptionP(self)) {
                  declarations = Cons.cons(v.skolemName, declarations);
                }
                else {
                  declarations = Cons.cons(Cons.cons(v.skolemName, Cons.cons(Symbol.internSymbolInModule(type.symbolName, ((Module)(type.homeContext)), true), Stella.NIL)), declarations);
                }
                if (collect000 == null) {
                  {
                    collect000 = Cons.cons(v.skolemName, Stella.NIL);
                    if (variables == Stella.NIL) {
                      variables = collect000;
                    }
                    else {
                      Cons.addConsToEndOfConsList(variables, collect000);
                    }
                  }
                }
                else {
                  {
                    collect000.rest = Cons.cons(v.skolemName, Stella.NIL);
                    collect000 = collect000.rest;
                  }
                }
              }
            }
            declarations = declarations.reverse();
            clauses = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_NOT, Cons.cons(Cons.cons(self.descriptionName(), variables.concatenate(Stella.NIL, Stella.NIL)), Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL);
            if (NamedDescription.classDescriptionP(self)) {
              { NamedDescription p = null;
                Cons iter001 = NamedDescription.allDirectSuperrelations(self, true);

                for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                  p = ((NamedDescription)(iter001.value));
                  clauses = Cons.cons(Cons.cons(p.descriptionName(), Cons.cons(variables.value, Stella.NIL)), clauses);
                }
              }
            }
            { Object old$Recursivegetcomplementargument$000 = Logic.$RECURSIVEGETCOMPLEMENTARGUMENT$.get();

              try {
                Native.setSpecial(Logic.$RECURSIVEGETCOMPLEMENTARGUMENT$, self);
                complement = ((Description)(Logic.conceiveTerm(Cons.list$(Cons.cons(Logic.SYM_LOGIC_KAPPA, Cons.cons(declarations, Cons.cons(Cons.cons(Cons.cons(Logic.SYM_STELLA_AND, clauses.concatenate(Stella.NIL, Stella.NIL)), Stella.NIL), Stella.NIL)))))));

              } finally {
                Logic.$RECURSIVEGETCOMPLEMENTARGUMENT$.set(old$Recursivegetcomplementargument$000);
              }
            }
            if (complement == null) {
              { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

                try {
                  Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                  {
                    Stella.STANDARD_WARNING.nativeStream.println("WARNING: Couldn't conceive goal complement for");
                    Stella.STANDARD_WARNING.nativeStream.println(Cons.list$(Cons.cons(Logic.SYM_LOGIC_KAPPA, Cons.cons(declarations, Cons.cons(Cons.cons(Cons.cons(Logic.SYM_STELLA_AND, clauses.concatenate(Stella.NIL, Stella.NIL)), Stella.NIL), Stella.NIL)))));
                  }
;
                  Logic.helpSignalPropositionError(Stella.STANDARD_WARNING, Logic.KWD_WARNING);

                } finally {
                  Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
                }
              }
              return (null);
            }
            KeyValueList.setDynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_COMPLEMENT_DESCRIPTION, complement, null);
            KeyValueList.setDynamicSlotValue(complement.dynamicSlots, Logic.SYM_LOGIC_COMPLEMENT_DESCRIPTION, self, null);
            Description.deriveDeferredContrapositiveSatelliteRules(self);
            return (complement);
          }

        } finally {
          Stella.$CONTEXT$.set(old$Context$000);
          Stella.$MODULE$.set(old$Module$000);
        }
      }
    }
  }

  public static Iterator allArgumentTypes(NamedDescription self) {
    if (Description.variableArityP(self)) {
      return (Logic.wrapIteratorForVariableArity(((ListIterator)(self.ioVariableTypes.allocateIterator()))));
    }
    else {
      return (((ListIterator)(self.ioVariableTypes.allocateIterator())));
    }
  }

  public static Iterator allDomainTypes(NamedDescription self) {
    { Iterator iterator = (NamedDescription.functionDescriptionP(self) ? ((Iterator)(self.ioVariableTypes.butLast())) : ((ListIterator)(self.ioVariableTypes.allocateIterator())));

      if (Description.variableArityP(self)) {
        return (Logic.wrapIteratorForVariableArity(iterator));
      }
      else {
        return (iterator);
      }
    }
  }

  public static void materializePrimitiveDescriptionBody(NamedDescription description) {
    { boolean nativeP = description.nativeRelation() != null;
      Symbol name = (nativeP ? Symbol.internSymbolInModule(description.nativeRelation().name(), description.nativeRelation().homeModule(), true) : description.descriptionName());
      List variabletypes = description.ioVariableTypes;
      int arity = variabletypes.length();
      Cons tree = null;
      Cons variables = Stella.NIL;
      Cons arguments = Stella.NIL;

      { IntegerIntervalIterator i = Stella.interval(1, arity);
        Symbol name000 = null;
        Cons iter000 = Logic.SYSTEM_DEFINED_ARGUMENT_NAMES;
        Cons collect000 = null;

        for (;i.nextP() &&
                  (!(iter000 == Stella.NIL)); iter000 = iter000.rest) {
          name000 = ((Symbol)(iter000.value));
          if (collect000 == null) {
            {
              collect000 = Cons.cons(name000, Stella.NIL);
              if (variables == Stella.NIL) {
                variables = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(variables, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(name000, Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      arguments = Cons.copyConsList(variables);
      if (nativeP &&
          (arity > 1)) {
        variables.firstSetter(Cons.list$(Cons.cons(Logic.SYM_STELLA_ISA, Cons.cons(variables.value, Cons.cons(Cons.cons(Surrogate.typeToSymbol(((Surrogate)(variabletypes.first()))), Stella.NIL), Stella.NIL)))));
      }
      tree = Cons.list$(Cons.cons(Logic.SYM_LOGIC_KAPPA, Cons.cons(variables, Cons.cons(Cons.cons(Cons.cons(name, arguments.concatenate(Stella.NIL, Stella.NIL)), Stella.NIL), Stella.NIL))));
      { Object old$LogicDialect$000 = Logic.$LOGIC_DIALECT$.get();
        Object old$Logicvariabletable$000 = Logic.$LOGICVARIABLETABLE$.get();
        Object old$Termunderconstruction$000 = Logic.$TERMUNDERCONSTRUCTION$.get();
        Object old$Evaluationmode$000 = Logic.$EVALUATIONMODE$.get();
        Object old$Context$000 = Stella.$CONTEXT$.get();

        try {
          Native.setSpecial(Logic.$LOGIC_DIALECT$, Logic.KWD_KIF);
          Native.setSpecial(Logic.$LOGICVARIABLETABLE$, Stella.NIL);
          Native.setSpecial(Logic.$TERMUNDERCONSTRUCTION$, tree);
          Native.setSpecial(Logic.$EVALUATIONMODE$, Logic.KWD_DESCRIPTION);
          Native.setSpecial(Stella.$CONTEXT$, description.homeContext);
          { Description sacrificialdescription = Logic.evaluateDescriptionTerm(tree, false);

            description.ioVariables = sacrificialdescription.ioVariables;
            description.proposition = sacrificialdescription.proposition;
            sacrificialdescription.deletedPSetter(true);
          }

        } finally {
          Stella.$CONTEXT$.set(old$Context$000);
          Logic.$EVALUATIONMODE$.set(old$Evaluationmode$000);
          Logic.$TERMUNDERCONSTRUCTION$.set(old$Termunderconstruction$000);
          Logic.$LOGICVARIABLETABLE$.set(old$Logicvariabletable$000);
          Logic.$LOGIC_DIALECT$.set(old$LogicDialect$000);
        }
      }
    }
  }

  /** Return the name of the description <code>self</code>.
   * @return Symbol
   */
  public Symbol descriptionName() {
    { NamedDescription self = this;

      return (Logic.objectName(self));
    }
  }

  public static boolean relationImpliesRelationP(NamedDescription subrel, NamedDescription superrel) {
    return (LogicObject.collectionImpliesCollectionP(subrel, superrel));
  }

  public static Iterator allExtensionMembers(NamedDescription description) {
    { SequenceIndex extension = NamedDescription.getDescriptionExtension(description, true);

      extension.removeDeletedMembers();
      return (extension.allocateIterator());
    }
  }

  public static void cleanupDescriptionExtension(NamedDescription description) {
    description.extension.removeDeletedMembers();
  }

  public static SequenceIndex getDescriptionExtension(NamedDescription description, boolean updateP) {
    { SequenceIndex extension = description.extension;
      SequenceIndex result = null;

      if ((extension != null) &&
          (!(extension == Logic.NIL_PAGING_INDEX))) {
        result = extension;
      }
      else if (updateP) {
        extension = Logic.createSequenceIndex(Logic.KWD_PAGING, Cons.cons(Logic.KWD_RELATION, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(description.surrogateValueInverse, Stella.NIL))));
        description.extension = extension;
        result = extension;
      }
      else {
        result = Logic.NIL_PAGING_INDEX;
      }
      if (!(Logic.$ALL_OBJECT_STORES$ == Stella.NIL_LIST)) {
        result = SequenceIndex.maybeWrapSequenceIndex(result, null, Logic.KWD_RELATION, description.surrogateValueInverse, null);
      }
      return (result);
    }
  }

  public static void transferDescriptionExtension(NamedDescription from, NamedDescription to) {
    to.extension = from.extension;
    from.extension = null;
  }

  public static boolean indexIthDomainP(NamedDescription description, int i) {
    { boolean testValue000 = false;

      testValue000 = false;
      if (testValue000) {
        testValue000 = NamedDescription.functionDescriptionP(description);
        if (testValue000) {
          testValue000 = !NamedDescription.computedRelationP(description);
          if (testValue000) {
            testValue000 = i == 0;
            if (testValue000) {
              { boolean alwaysP000 = true;

                { Surrogate t = null;
                  Iterator iter000 = description.ioVariableTypes.butLast();

                  loop000 : while (iter000.nextP()) {
                    t = ((Surrogate)(iter000.value));
                    if (!Logic.logicalSubtypeOfLiteralP(t)) {
                      alwaysP000 = false;
                      break loop000;
                    }
                  }
                }
                testValue000 = alwaysP000;
              }
            }
          }
        }
      }
      { boolean value000 = testValue000;

        return (value000);
      }
    }
  }

  public static boolean relationInModuleP(NamedDescription self) {
    return (self.homeContext == ((Module)(Stella.$MODULE$.get())));
  }

  public static Proposition assertImpliesLinkBetweenRelations(NamedDescription sub, NamedDescription renamed_Super) {
    { Proposition impliesprop = Description.assertDescriptionImpliesDescription(sub, renamed_Super, true);

      KeyValueList.setDynamicSlotValue(impliesprop.dynamicSlots, Logic.SYM_LOGIC_SUBRELATION_LINKp, Stella.TRUE_WRAPPER, Stella.FALSE_WRAPPER);
      Proposition.updatePropositionTruthValue(impliesprop, Logic.KWD_ASSERT_TRUE);
      Logic.linkOriginatedProposition(sub, impliesprop);
      return (impliesprop);
    }
  }

  public static void retractRelationAxioms(NamedDescription oldrelation) {
    { List originatedpropositions = Logic.originatedPropositions(oldrelation);

      if (originatedpropositions != null) {
        { Proposition proposition = null;
          Cons iter000 = originatedpropositions.theConsList;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            proposition = ((Proposition)(iter000.value));
            Proposition.unassertProposition(proposition);
          }
        }
      }
    }
  }

  public static boolean computedRelationP(NamedDescription description) {
    return (((description.nativeRelation() != null) &&
        (!description.nativeRelation().abstractP)) ||
        (Logic.accessBinaryValue(description, Logic.SGT_PL_KERNEL_KB_RELATION_COMPUTATION) != null));
  }

  public int arity() {
    { NamedDescription self = this;

      if (Description.variableArityP(self)) {
        return (-1);
      }
      else {
        return (self.ioVariableTypes.length());
      }
    }
  }

  public static boolean functionDescriptionP(NamedDescription self) {
    return (Logic.functionP(self));
  }

  public static boolean classDescriptionP(NamedDescription self) {
    return (Logic.classP(self));
  }

  public static boolean subrelationOfP(NamedDescription desc1, NamedDescription desc2) {
    { Object old$ReversepolarityP$000 = Logic.$REVERSEPOLARITYp$.get();

      try {
        Native.setBooleanSpecial(Logic.$REVERSEPOLARITYp$, false);
        return (LogicObject.collectionImpliesCollectionP(desc1, desc2));

      } finally {
        Logic.$REVERSEPOLARITYp$.set(old$ReversepolarityP$000);
      }
    }
  }

  public static Stella_Object accessNamedDescriptionSlotValue(NamedDescription self, Symbol slotname, Stella_Object value, boolean setvalueP) {
    if (slotname == Logic.SYM_LOGIC_IO_VARIABLE_NAMES) {
      if (setvalueP) {
        self.ioVariableNames = ((List)(value));
      }
      else {
        value = self.ioVariableNames;
      }
    }
    else if (slotname == Logic.SYM_LOGIC_IO_VARIABLE_TYPES) {
      if (setvalueP) {
        self.ioVariableTypes = ((List)(value));
      }
      else {
        value = self.ioVariableTypes;
      }
    }
    else if (slotname == Logic.SYM_STELLA_EXTENSION) {
      if (setvalueP) {
        self.extension = ((SequenceIndex)(value));
      }
      else {
        value = self.extension;
      }
    }
    else if (slotname == Logic.SYM_LOGIC_OBJECT_STRINGIFIED_SOURCE) {
      if (setvalueP) {
        Logic.stringifiedSourceSetter(self, ((StringWrapper)(value)).wrapperValue);
      }
      else {
        value = StringWrapper.wrapString(Logic.stringifiedSource(self));
      }
    }
    else if (slotname == Logic.SYM_LOGIC_OBJECT_ORIGINATED_PROPOSITIONS) {
      if (setvalueP) {
        Logic.originatedPropositionsSetter(self, ((List)(value)));
      }
      else {
        value = Logic.originatedPropositions(self);
      }
    }
    else {
      if (setvalueP) {
        KeyValueList.setDynamicSlotValue(self.dynamicSlots, slotname, value, null);
      }
      else {
        value = self.dynamicSlots.lookup(slotname);
      }
    }
    return (value);
  }

  public void nativeRelationSetter(Relation value) {
    { NamedDescription self = this;

      KeyValueList.setDynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_NATIVE_RELATION_BACK_POINTER, value, null);
    }
  }

  public Relation nativeRelation() {
    { NamedDescription self = this;

      return (((Relation)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_NATIVE_RELATION_BACK_POINTER, null))));
    }
  }

  public Surrogate primaryType() {
    { NamedDescription self = this;

      return (Logic.SGT_LOGIC_NAMED_DESCRIPTION);
    }
  }

}

