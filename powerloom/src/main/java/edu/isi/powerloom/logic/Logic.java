//  -*- Mode: Java -*-
//
// Logic.java

/*
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2017      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
*/

package edu.isi.powerloom.logic;

import edu.isi.stella.javalib.Native;
import edu.isi.stella.javalib.StellaSpecialVariable;
import edu.isi.stella.*;

public class Logic {
  public final static StellaSpecialVariable $SUPPRESSNONLOGICOBJECTWARNINGp$ = new StellaSpecialVariable();

  public static Symbol SYM_STELLA_LET = null;

  public static Symbol SYM_STELLA_NEW = null;

  public static Symbol SYM_STELLA_OUTPUT_STRING_STREAM = null;

  public static Symbol SYM_STELLA_SPECIAL = null;

  public static Symbol SYM_STELLA_$PRINTREADABLYp$ = null;

  public static Symbol SYM_STELLA_TRUE = null;

  public static Symbol SYM_STELLA_PRINT_STREAM = null;

  public static Symbol SYM_STELLA_EOL = null;

  public static Symbol SYM_LOGIC_HELP_SIGNAL_PROPOSITION_ERROR = null;

  public static Keyword KWD_ERROR = null;

  public static Symbol SYM_STELLA_SIGNAL_EXCEPTION = null;

  public static Symbol SYM_LOGIC_PARSING_ERROR = null;

  public static Keyword KWD_MESSAGE = null;

  public static Symbol SYM_STELLA_THE_STRING = null;

  public static Symbol SYM_LOGIC_PROPOSITION_ERROR = null;

  public static Symbol SYM_STELLA_STANDARD_WARNING = null;

  public static Keyword KWD_WARNING = null;

  public static Symbol SYM_STELLA_DEFUN = null;

  public static Symbol SYM_STELLA_STRING = null;

  public static Symbol SYM_STELLA_PRINT = null;

  public static Symbol SYM_STELLA_RETURN = null;

  public static Symbol SYM_STELLA_PROGN = null;

  public static Symbol SYM_STELLA_SETF = null;

  public static Symbol SYM_LOGIC_TRUTH_VALUE = null;

  public static Symbol SYM_LOGIC_FRAME = null;

  public static Symbol SYM_STELLA_NULL = null;

  public static Symbol SYM_LOGIC_JUSTIFICATION = null;

  public static Symbol SYM_STELLA_WHEN = null;

  public static Symbol SYM_STELLA_DEFINEDp = null;

  public static Symbol SYM_LOGIC_PARTIAL_MATCH_FRAME = null;

  public static Symbol SYM_LOGIC_CLEAR_FRAME_PARTIAL_TRUTH = null;

  public static Symbol SYM_STELLA_SETQ = null;

  public static Symbol SYM_LOGIC_LASTMOVE = null;

  public static Keyword KWD_DOWN = null;

  public static Symbol SYM_STELLA_COND = null;

  public static Symbol SYM_LOGIC_CHECKFORMOVEOUTp = null;

  public static Symbol SYM_LOGIC_PARENT = null;

  public static Symbol SYM_LOGIC_UP = null;

  public static Symbol SYM_LOGIC_STARTTICKS = null;

  public static Symbol SYM_LOGIC_STARTING_CLOCK_TICKS = null;

  public static Symbol SYM_LOGIC_AVAILABLETICKS = null;

  public static Symbol SYM_STELLA__ = null;

  public static Symbol SYM_LOGIC_ALLOTTED_CLOCK_TICKS = null;

  public static Symbol SYM_LOGIC_CLOCKTICKS = null;

  public static Symbol SYM_STELLA___ = null;

  public static Symbol SYM_LOGIC_CURRENT_CLOCK_TICKS = null;

  public static Symbol SYM_LOGIC_QUERY = null;

  public static Symbol SYM_STELLA_ii = null;

  public static Symbol SYM_STELLA_le = null;

  public static Symbol SYM_LOGIC_POP_FRAMES_UP_TO = null;

  public static Symbol SYM_STELLA_MV_SETQ = null;

  public static Symbol SYM_STELLA_DEPTH = null;

  public static Symbol SYM_LOGIC_HANDLE_TIMEOUT = null;

  public static Keyword KWD_UP_FAIL = null;

  public static Symbol SYM_STELLA_1i = null;

  public static Symbol SYM_STELLA_OTHERWISE = null;

  public static Symbol SYM_LOGIC_UPFRAME = null;

  public static Symbol SYM_LOGIC_DOWNFRAME = null;

  public static Symbol SYM_LOGIC_DOWN = null;

  public static Symbol SYM_STELLA_AND = null;

  public static Symbol SYM_STELLA_NULLp = null;

  public static Symbol SYM_STELLA_1_ = null;

  public static Symbol SYM_LOGIC_PROPOSITION = null;

  public static Symbol SYM_LOGIC_ARGUMENT_BOUND_TO = null;

  public static Symbol SYM_STELLA_NTH = null;

  public static Symbol SYM_STELLA_ARGUMENTS = null;

  public static Symbol SYM_LOGIC_ARGUMENT_CURSOR = null;

  public static Symbol SYM_LOGIC_CREATE_DOWN_FRAME = null;

  public static Symbol SYM_STELLA_g = null;

  public static Symbol SYM_LOGIC_CURRENT_DEPTH_CUTOFF = null;

  public static Symbol SYM_STELLA_EQLp = null;

  public static Symbol SYM_STELLA_STATE = null;

  public static Keyword KWD_PATTERN = null;

  public static Symbol SYM_LOGIC_HANDLE_DEPTH_VIOLATION = null;

  public static Symbol SYM_STELLA_NOT = null;

  public static Symbol SYM_LOGIC_FAIL = null;

  public static Keyword KWD_UP_TRUE = null;

  public static Symbol SYM_STELLA_FALSE = null;

  public static Symbol SYM_STELLA_RESULT = null;

  public static Symbol SYM_STELLA_IF = null;

  public static Symbol SYM_LOGIC_CACHE_QUERY_RESULTSp = null;

  public static Symbol SYM_LOGIC_CACHE_GOAL = null;

  public static Symbol SYM_LOGIC_UPDATE_GOAL_CACHE = null;

  public static Symbol SYM_LOGIC_SUCCESSp = null;

  public static Symbol SYM_STELLA_BREAK = null;

  public static Symbol SYM_LOGIC_KEEP_FRAME = null;

  public static Symbol SYM_LOGIC_POP_DOWN_FRAME = null;

  public static Symbol SYM_LOGIC_APPLY_CACHED_RETRIEVE = null;

  public static Symbol SYM_STELLA_BQUOTE = null;

  public static Symbol SYM_STELLA_CONS_LIST = null;

  public static Symbol SYM_STELLA_QUOTE = null;

  public static Symbol SYM_LOGIC_APPLY_CACHED_ASK = null;

  public static Symbol SYM_STELLA_$CONTEXT$ = null;

  public static Symbol SYM_LOGIC_GET_INFERENCE_CACHE = null;

  public static Symbol SYM_STELLA_$MODULE$ = null;

  public static Keyword KWD_META = null;

  public static Symbol SYM_LOGIC_$CLASSIFICATIONSESSION$ = null;

  public static Symbol SYM_LOGIC_GET_CLASSIFICATION_SESSION = null;

  public static Symbol SYM_LOGIC_CLASSIFICATION_WORLD = null;

  public static Symbol SYM_STELLA_OBJECT = null;

  public static Symbol SYM_LOGIC_MISSING_ARGUMENT = null;

  public static Symbol SYM_STELLA_INTEGER_WRAPPER = null;

  public static Symbol SYM_STELLA_CASE = null;

  public static Symbol SYM_STELLA_WRAPPER_VALUE = null;

  public static Symbol SYM_STELLA_BOOLEAN = null;

  public static Symbol SYM_STELLA_X = null;

  public static Symbol SYM_STELLA_NUMBER_WRAPPER = null;

  public static Symbol SYM_STELLA_Y = null;

  public static Keyword KWD_PUBLICp = null;

  public static Symbol SYM_STELLA_TYPECASE = null;

  public static Symbol SYM_STELLA_FLOAT_WRAPPER = null;

  public static Symbol SYM_STELLA_CAST = null;

  public static Symbol SYM_STELLA_FLOAT = null;

  public static Symbol SYM_LOGIC_FLOATRESULT = null;

  public static Symbol SYM_STELLA_WRAP_LITERAL = null;

  public static Symbol SYM_STELLA_SAFE_CAST = null;

  public static Symbol SYM_STELLA_INTEGER = null;

  public static Symbol SYM_STELLA_MODULE = null;

  public static Symbol SYM_STELLA_CONTEXT = null;

  public static Symbol SYM_STELLA_WITH_PROCESS_LOCK = null;

  public static Symbol SYM_LOGIC_$POWERLOOM_LOCK$ = null;

  public static Symbol SYM_STELLA_IGNORE = null;

  public static boolean $CYC_KLUDGES_ENABLEDp$ = false;

  public static Symbol SYM_LOGIC_$CYC_KLUDGES_ENABLEDp$ = null;

  public static Symbol SYM_LOGIC_STARTUP_LOGIC_MACROS = null;

  public static Symbol SYM_STELLA_METHOD_STARTUP_CLASSNAME = null;

  public static Symbol SYM_LOGIC_SELECTION_PATTERN = null;

  public static Symbol SYM_LOGIC_THE_SEQUENCE = null;

  public static Symbol SYM_LOGIC_THE_SEQUENCE_LENGTH = null;

  public static Surrogate SGT_LOGIC_NON_PAGING_INDEX = null;

  public static Surrogate SGT_LOGIC_PAGING_INDEX = null;

  public static Symbol SYM_LOGIC_STORE = null;

  /** Returns a non-writable empty sequence.
   */
  public static NonPagingIndex NIL_NON_PAGING_INDEX = null;

  /** Returns a non-writable empty sequence.
   */
  public static PagingIndex NIL_PAGING_INDEX = null;

  public static Surrogate SGT_LOGIC_SEQUENCE_INDEX_ITERATOR = null;

  public static Symbol SYM_STELLA_LIST_ITERATOR_CURSOR = null;

  public static Surrogate SGT_LOGIC_PAGING_INDEX_ITERATOR = null;

  /** The list of all currently active object stores.  To signal
   * that no object stores are active, this has to be NIL-LIST as opposed to the
   * empty list.
   */
  public static List $ALL_OBJECT_STORES$ = null;

  /** If TRUE, objects being created are regenerable,
   * and should not be indexed using the backlinks procedures.
   */
  public final static StellaSpecialVariable $LOADINGREGENERABLEOBJECTSp$ = new StellaSpecialVariable();

  public static Symbol SYM_LOGIC_OBJECT_STORE = null;

  public static Surrogate SGT_STELLA_MODULE = null;

  public static Surrogate SGT_LOGIC_OBJECT_STORE = null;

  public static Keyword KWD_PAGING = null;

  public static Keyword KWD_NON_PAGING = null;

  public static Symbol SYM_LOGIC_STARTUP_SEQUENCE_INDICES = null;

  public static Symbol SYM_LOGIC_PARSE_TREE = null;

  /** Character that identifies variables representing
   * instances named by the system.
   */
  public static char $AUTOMATIC_INSTANCE_CHARACTER$ = '$';

  public static Surrogate SGT_STELLA_CONS = null;

  public static Symbol SYM_STELLA_ISA = null;

  public static Symbol SYM_STELLA_EXISTS = null;

  public static Symbol SYM_STELLA_FORALL = null;

  public static Symbol SYM_LOGIC_SETOFALL = null;

  public static Symbol SYM_LOGIC_KAPPA = null;

  public static Symbol SYM_LOGIC_THE = null;

  public static Symbol SYM_LOGIC_THE_ONLY = null;

  public static Symbol SYM_STELLA_e = null;

  public static Symbol SYM_STELLA_OR = null;

  public static Symbol SYM_STELLA_eg = null;

  public static Symbol SYM_LOGIC_legg = null;

  public static Symbol SYM_LOGIC_lleg = null;

  public static Symbol SYM_LOGIC_llegg = null;

  public static Symbol SYM_LOGIC_ltg = null;

  public static Symbol SYM_LOGIC_ltgg = null;

  public static Symbol SYM_LOGIC_lltg = null;

  public static Symbol SYM_LOGIC_lltgg = null;

  public static Symbol SYM_LOGIC_egg = null;

  public static Symbol SYM_LOGIC_lle = null;

  public static Symbol SYM_LOGIC_tg = null;

  public static Symbol SYM_LOGIC_lt = null;

  public static Symbol SYM_LOGIC_tgg = null;

  public static Symbol SYM_LOGIC_llt = null;

  public static Symbol SYM_LOGIC_ABOUT = null;

  public static Symbol SYM_PL_KERNEL_KB_VALUE = null;

  public static Cons $ANNOTATION_TRANSLATION_TABLE$ = null;

  public static Keyword KWD_DIRECTION = null;

  public static Keyword KWD_BACKWARD = null;

  public static Keyword KWD_FORWARD = null;

  public static Keyword KWD_CONFIDENCE_LEVEL = null;

  public static Keyword KWD_DEFAULT = null;

  public static Keyword KWD_ABOUT = null;

  public static Symbol SYM_PL_KERNEL_KB_HOLDS = null;

  public static Symbol SYM_LOGIC_leg = null;

  public static Cons $KIF_SENTENCE_OPERATORS$ = null;

  public static Cons $KIF_TERM_OPERATORS$ = null;

  public static Symbol SYM_LOGIC_LAMBDA = null;

  public static Symbol SYM_STELLA_SETOF = null;

  public static Symbol SYM_LOGIC_LISTOF = null;

  public static Symbol SYM_STELLA_WHERE = null;

  public static Symbol SYM_STELLA_ALWAYS = null;

  /** Indicates the current dialect of logic used to phrase
   * queries, assertions, and definitions.
   */
  public final static StellaSpecialVariable $LOGIC_DIALECT$ = new StellaSpecialVariable();

  public static Keyword KWD_KIF = null;

  public static Keyword KWD_STELLA = null;

  public static Keyword KWD_PREFIX_STELLA = null;

  public static Keyword KWD_MELD = null;

  public static Keyword KWD_LOOM = null;

  public static Symbol SYM_LOGIC_STARTUP_KIF_IN = null;

  public static Symbol SYM_LOGIC_PROPOSITIONS_INDEX = null;

  public static Symbol SYM_LOGIC_INSTANCES_INDEX = null;

  public static Surrogate SGT_LOGIC_BACKLINKS_INDEX = null;

  public static Symbol SYM_LOGIC_DEPENDENT_PROPOSITIONS_LIST = null;

  public static Symbol SYM_LOGIC_DEPENDENT_ISA_PROPOSITIONS_LIST = null;

  public static Symbol SYM_LOGIC_PREDICATE_PROPOSITIONS_TABLE = null;

  public static Surrogate SGT_LOGIC_LOGIC_OBJECT = null;

  public static Symbol SYM_STELLA_BADp = null;

  public static Symbol SYM_STELLA_HOME_CONTEXT = null;

  public static Symbol SYM_LOGIC_VARIABLE_VALUE_INVERSE = null;

  public static Symbol SYM_STELLA_SURROGATE_VALUE_INVERSE = null;

  public static Symbol SYM_LOGIC_OBJECT_STRINGIFIED_SOURCE = null;

  public static Symbol SYM_LOGIC_OBJECT_ORIGINATED_PROPOSITIONS = null;

  public static Surrogate SGT_STELLA_CS_VALUE = null;

  public static Symbol SYM_STELLA_DELETED_OBJECTp = null;

  public static Surrogate SGT_LOGIC_LOGIC_THING = null;

  public static Surrogate SGT_LOGIC_PATTERN_VARIABLE = null;

  public static Surrogate SGT_LOGIC_SKOLEM = null;

  public static Symbol SYM_LOGIC_SKOLEM_TYPE = null;

  public static Symbol SYM_LOGIC_SKOLEM_NAME = null;

  public static Symbol SYM_LOGIC_VARIABLE_VALUE = null;

  public static Symbol SYM_LOGIC_DEFINING_PROPOSITION = null;

  public static Symbol SYM_LOGIC_BOUND_TO_OFFSET = null;

  public static Symbol SYM_STELLA_VARIABLE_NAME = null;

  public static Symbol SYM_LOGIC_OBJECT_VECTOR = null;

  public static Symbol SYM_LOGIC_ARGUMENTS_VECTOR = null;

  public static Symbol SYM_LOGIC_VARIABLES_VECTOR = null;

  /** Save space by structure-sharing zero-length variable vectors.
   */
  public static Vector ZERO_VARIABLES_VECTOR = null;

  public static Surrogate SGT_LOGIC_FORWARD_CHAINING_INDEX = null;

  public static Symbol SYM_LOGIC_FORWARD_GOAL = null;

  public static Symbol SYM_LOGIC_MASTER_RULE = null;

  public static Symbol SYM_LOGIC_IO_VARIABLES = null;

  public static Symbol SYM_LOGIC_QUERY_BODY = null;

  public static Symbol SYM_LOGIC_INPUT_BINDINGS = null;

  public static Symbol SYM_LOGIC_CACHE_ID = null;

  public static Symbol SYM_LOGIC_CONSEQUENT = null;

  public static Surrogate SGT_LOGIC_DESCRIPTION = null;

  public static Symbol SYM_LOGIC_FORWARD_CHAINING_INDICES = null;

  public static Symbol SYM_LOGIC_DEFERRED_CONTRAPOSITIVESp = null;

  public static Symbol SYM_LOGIC_INTERNAL_VARIABLES = null;

  public static Symbol SYM_LOGIC_QUERY_PATTERNS = null;

  public static Symbol SYM_LOGIC_RELATIVE_COMPLEMENT = null;

  public static Symbol SYM_LOGIC_COMPLEMENT_DESCRIPTION = null;

  public static Surrogate SGT_LOGIC_NAMED_DESCRIPTION = null;

  public static Symbol SYM_LOGIC_NATIVE_RELATION_BACK_POINTER = null;

  public static Symbol SYM_LOGIC_IO_VARIABLE_NAMES = null;

  public static Symbol SYM_LOGIC_IO_VARIABLE_TYPES = null;

  public static Symbol SYM_STELLA_EXTENSION = null;

  public static Symbol SYM_LOGIC_PARTIAL_MATCH_SCORE = null;

  public static Symbol SYM_LOGIC_SET_OF_SUPPORT = null;

  public static Symbol SYM_LOGIC_TIMESTAMP = null;

  public static Keyword KWD_UNKNOWN = null;

  public static Surrogate SGT_LOGIC_TRUTH_VALUE = null;

  public static Symbol SYM_LOGIC_POLARITY = null;

  public static Symbol SYM_LOGIC_STRENGTH = null;

  public static Symbol SYM_LOGIC_POSITIVE_SCORE = null;

  public static Surrogate SGT_LOGIC_PARTIAL_SUPPORT = null;

  public static Symbol SYM_LOGIC_FACT = null;

  public static Symbol SYM_LOGIC_AXIOM = null;

  public static Symbol SYM_LOGIC_SCORE = null;

  public static Symbol SYM_LOGIC_ID = null;

  public static Symbol SYM_LOGIC_ARGUMENT_SCORES = null;

  public static int $PARTIAL_SUPPORT_COUNTER$ = 0;

  public static Surrogate SGT_LOGIC_PROPOSITION = null;

  public static Symbol SYM_LOGIC_VARIABLE_TYPEp = null;

  public static Symbol SYM_LOGIC_SATELLITE_PROPOSITIONS = null;

  public static Symbol SYM_LOGIC_UNFASTENEDp = null;

  public static Symbol SYM_LOGIC_WEIGHT_DELTA = null;

  public static Symbol SYM_LOGIC_SUPPORT = null;

  public static Symbol SYM_LOGIC_KIND = null;

  public static Symbol SYM_STELLA_OPERATOR = null;

  public static Symbol SYM_LOGIC_RELATIONREF = null;

  public static Symbol SYM_LOGIC_DEPENDENT_PROPOSITIONS = null;

  public static Symbol SYM_LOGIC_PROPOSITION_ORIGINATED_PROPOSITIONS = null;

  public static Symbol SYM_LOGIC_PROPOSITION_STRINGIFIED_SOURCE = null;

  public static Surrogate SGT_LOGIC_QUANTITY_LOGIC_WRAPPER = null;

  public static Symbol SYM_LOGIC_FUNCTION_TERM = null;

  public static Surrogate SGT_LOGIC_INTEGER_LOGIC_WRAPPER = null;

  public static Surrogate SGT_LOGIC_FLOAT_LOGIC_WRAPPER = null;

  public static Surrogate SGT_LOGIC_STRING_LOGIC_WRAPPER = null;

  public static Symbol SYM_LOGIC_ENTITY_MAPPING = null;

  /** Maps names of KIF operators to relational surrogates.
   */
  public static PropertyList $OPERATOR_NAME_TO_SURROGATE_TABLE$ = null;

  public static Keyword KWD_AND = null;

  public static Surrogate SGT_PL_KERNEL_KB_AND = null;

  public static Keyword KWD_OR = null;

  public static Surrogate SGT_PL_KERNEL_KB_OR = null;

  public static Keyword KWD_NOT = null;

  public static Surrogate SGT_PL_KERNEL_KB_NOT = null;

  public static Keyword KWD_FORALL = null;

  public static Surrogate SGT_PL_KERNEL_KB_FORALL = null;

  public static Keyword KWD_EXISTS = null;

  public static Surrogate SGT_PL_KERNEL_KB_EXISTS = null;

  public static Keyword KWD_EQUIVALENT = null;

  public static Surrogate SGT_PL_KERNEL_KB_EQUIVALENT = null;

  public static Keyword KWD_FAIL = null;

  public static Surrogate SGT_PL_KERNEL_KB_FAIL = null;

  public static Keyword KWD_COLLECT_INTO = null;

  public static Surrogate SGT_PL_KERNEL_KB_COLLECT_INTO = null;

  public static Keyword KWD_IMPLIES = null;

  public static Surrogate SGT_PL_KERNEL_KB_SUBSET_OF = null;

  public static Symbol SYM_STELLA_FUNCTION = null;

  public static Symbol SYM_STELLA_PREDICATE = null;

  public static Symbol SYM_LOGIC_DESCRIPTIVEp = null;

  public static Symbol SYM_STELLA_CODE_ONLYp = null;

  public static Surrogate SGT_LOGIC_EXCEPTION_RECORD = null;

  public static Module $LOGIC_MODULE$ = null;

  public static Module $PL_KERNEL_MODULE$ = null;

  public static Symbol SYM_LOGIC_LOCALLY_CONCEIVED_PROPOSITIONS_INTERNAL = null;

  public static Keyword KWD_CONTEXT_PROPOSITIONS = null;

  public static Symbol SYM_LOGIC_LOCALLY_CONCEIVED_INSTANCES_INTERNAL = null;

  public static Keyword KWD_CONTEXT_INSTANCES = null;

  /** The NOW time stamp is incremented whenever a series
   * of one or more updates is followed by a query.
   */
  public static int $NOW_TIMESTAMP$ = 0;

  /** Records whether the last KB access was a query or
   * an update.  Used to determine when to increment the NOW time stamp
   * counter.
   */
  public static Keyword $LAST_KB_ACTION$ = null;

  public static Keyword KWD_UPDATE_PROPOSITION = null;

  public static Keyword KWD_EXECUTE_QUERY = null;

  /** The undefined individual.  Denotes the non-existence of
   * an individual in whatever slot it occupies.
   */
  public static LogicObject BOTTOM = null;

  public static Symbol SYM_LOGIC_BOTTOM = null;

  public static Surrogate SGT_STELLA_LITERAL = null;

  public static Surrogate SGT_LOGIC_F_LOGICAL_SUBTYPE_OF_LITERALp_MEMO_TABLE_000 = null;

  public static Surrogate SGT_STELLA_CLASS = null;

  public static Surrogate SGT_STELLA_LITERAL_WRAPPER = null;

  public static Surrogate SGT_STELLA_BOOLEAN = null;

  public static Surrogate SGT_STELLA_BOOLEAN_WRAPPER = null;

  public static Surrogate SGT_PL_KERNEL_KB_VARIABLE_ARITY = null;

  public static Surrogate SGT_STELLA_COLLECTION = null;

  public static Surrogate SGT_PL_KERNEL_KB_RELATION_COMPUTATION = null;

  public static Surrogate SGT_STELLA_THING = null;

  /** Indicates the context for evaluating a proposition.  One
   * of :DESCRIPTION, :INTENSIONAL-ASSERTION, or :EXTENSIONAL-ASSERTION.
   */
  public final static StellaSpecialVariable $EVALUATIONMODE$ = new StellaSpecialVariable();

  public static Keyword KWD_EXTENSIONAL_ASSERTION = null;

  public static Keyword KWD_DESCRIPTION = null;

  /** When enabled, slot-value assertions can be retracted
   * by later conflicting assertions.
   */
  public final static StellaSpecialVariable $CLIPPINGENABLEDp$ = new StellaSpecialVariable();

  /** When enabled, blocks normalizations that significantly
   * change the behavior of inference rules.
   */
  public final static StellaSpecialVariable $NATURALDEDUCTIONMODEp$ = new StellaSpecialVariable();

  /** Signals that we are performing search across multiple
   * contexts.  Used to disable retraction from collections, since that increases
   * the overhead of the context mechanism.
   */
  public static boolean $CONTEXT_DEPENDENT_SEARCH_MODEp$ = false;

  public static Keyword KWD_DEVELOPMENT = null;

  public static Keyword KWD_RETRACT_TRUE = null;

  public static Surrogate SGT_PL_KERNEL_KB_UPDATE_PROPOSITION_DEMON = null;

  public static Keyword KWD_FUNCTION = null;

  public static Keyword KWD_ISA = null;

  public static Surrogate SGT_PL_KERNEL_KB_GOES_TRUE_DEMON = null;

  public static Keyword KWD_PREDICATE = null;

  public static Surrogate SGT_PL_KERNEL_KB_GOES_FALSE_DEMON = null;

  public static Surrogate SGT_PL_KERNEL_KB_GOES_UNKNOWN_DEMON = null;

  public static Symbol SYM_LOGIC_MASTER_PROPOSITION = null;

  public static Keyword KWD_ASSERT_TRUE = null;

  public static Keyword KWD_PRESUME_TRUE = null;

  public static Keyword KWD_ASSERT_FALSE = null;

  public static Keyword KWD_PRESUME_FALSE = null;

  public static Keyword KWD_RETRACT_FALSE = null;

  public static Keyword KWD_ASSERT = null;

  public static Keyword KWD_RETRACT_INCONSISTENT = null;

  public static Keyword KWD_RETRACT = null;

  public static Keyword KWD_CONCEIVE = null;

  public static Surrogate SGT_PL_KERNEL_KB_HIDDEN_RELATION = null;

  public static Surrogate SGT_LOGIC_HIDDEN_INSTANCE = null;

  public static Keyword KWD_MODULE = null;

  public static Keyword KWD_LOCALp = null;

  public static Keyword KWD_KB_UPDATE = null;

  public static Keyword KWD_META_KB_UPDATE = null;

  public static Surrogate SGT_STELLA_STORAGE_SLOT = null;

  public static Surrogate SGT_STELLA_SURROGATE = null;

  public static Surrogate SGT_STELLA_RELATION = null;

  public static Symbol SYM_LOGIC_DESCRIPTION = null;

  public static Symbol SYM_LOGIC_EQUIVALENT_VALUE = null;

  /** Used to signal 'ground-value-of' that it can
   * call 'bound-to' safely.
   */
  public final static StellaSpecialVariable $COMPUTEDQUERYp$ = new StellaSpecialVariable();

  public static int $SKOLEM_ID_COUNTER$ = 0;

  public final static StellaSpecialVariable $VARIABLEIDCOUNTER$ = new StellaSpecialVariable();

  /** Cons-list of top-level existentially-quantified skolems.
   */
  public final static StellaSpecialVariable $FREESKOLEMS$ = new StellaSpecialVariable();

  /** Value representing TRUE.
   */
  public static TruthValue TRUE_TRUTH_VALUE = null;

  public static Keyword KWD_TRUE = null;

  public static Keyword KWD_STRICT = null;

  /** Value representing FALSE.
   */
  public static TruthValue FALSE_TRUTH_VALUE = null;

  public static Keyword KWD_FALSE = null;

  /** Value representing DEFAULT-TRUE.
   */
  public static TruthValue DEFAULT_TRUE_TRUTH_VALUE = null;

  /** Value representing DEFAULT-FALSE.
   */
  public static TruthValue DEFAULT_FALSE_TRUTH_VALUE = null;

  /** Value representing UNKNOWN.  Needed for those cases
   * where we need a non-NULL truth value to represents UNKNOWN.
   */
  public static TruthValue UNKNOWN_TRUTH_VALUE = null;

  /** Value representing a contradiction.
   */
  public static TruthValue INCONSISTENT_TRUTH_VALUE = null;

  public static Keyword KWD_INCONSISTENT = null;

  public static Keyword KWD_LOOKUP_ASSERTIONS = null;

  public static Symbol SYM_LOGIC_META_INFERENCE_CACHE = null;

  public static Symbol SYM_LOGIC_TRUTH_MAINTAINED_INFERENCE_CACHE = null;

  public static Symbol SYM_LOGIC_CLASH_EXCEPTIONS = null;

  public static Surrogate SGT_PL_KERNEL_KB_INCOHERENT = null;

  public static Symbol SYM_LOGIC_IOTAp = null;

  public static Surrogate SGT_PL_KERNEL_KB_CONCEPT = null;

  public static Surrogate SGT_PL_KERNEL_KB_RELATION = null;

  public static Surrogate SGT_STELLA_SET = null;

  public static Surrogate SGT_PL_KERNEL_KB_SET = null;

  public static Surrogate SGT_STELLA_SLOT = null;

  public static Surrogate SGT_PL_KERNEL_KB_FUNCTION = null;

  /** Used by 'safe-logical-type' to ask for a type
   * without signalling an error if none exists.
   */
  public final static StellaSpecialVariable $SUPPRESSUNTYPEDTYPEERRORp$ = new StellaSpecialVariable();

  public static Surrogate SGT_PL_KERNEL_KB_INTERVAL_CACHE = null;

  public static Surrogate SGT_PL_KERNEL_KB_ge = null;

  public static Symbol SYM_LOGIC_CONFLICTING_DEFAULT_VALUES = null;

  /** Experiment with equality reasoning on collections.
   */
  public static boolean $EQUIVALENCE_COLLECTIONSp$ = true;

  public static Proposition TRUE_PROPOSITION = null;

  public static Keyword KWD_CONSTANT = null;

  public static Surrogate SGT_STELLA_TRUE = null;

  public static Proposition FALSE_PROPOSITION = null;

  public static Surrogate SGT_STELLA_FALSE = null;

  public static Symbol SYM_LOGIC_CREATE = null;

  public static Keyword KWD_INTENSIONAL_ASSERTION = null;

  /** Variables with name 'ANONYMOUS-VARIABLE-NAME' are considered
   * anonymous, and are not assumed to be identical to any other variable also named
   * 'ANONYMOUS-VARIABLE-NAME'.
   */
  public static Symbol ANONYMOUS_VARIABLE_NAME = null;

  public static Symbol SYM_STELLA_p = null;

  /** Represents a key-value list that should never be used.
   */
  public static KeyValueList $MISSING_KEY_VALUE_LIST$ = null;

  /** Used by 'evaluate-automatic-instance' to
   * record current bindings of automatic instance symbols.
   */
  public final static StellaSpecialVariable $AUTOMATICINSTANCETABLE$ = new StellaSpecialVariable();

  public static Symbol SYM_STELLA_CLASS_EXTENSION = null;

  public static Symbol SYM_LOGIC_TRANSFER_LOGIC_INFORMATION_FROM_RELATION_HOOK = null;

  public static Symbol SYM_LOGIC_SUBRELATION_LINKp = null;

  public static Surrogate SGT_PL_KERNEL_KB_HOLDS = null;

  public static Surrogate SGT_PL_KERNEL_KB_MEMBER_OF = null;

  public final static StellaSpecialVariable $DEFAULTCREATIONTYPE$ = new StellaSpecialVariable();

  /** Contains a table of propositions and descriptions, indexed by a
   * structure hash code which might be shared by different objects.
   */
  public static KeyValueMap $STRUCTURED_OBJECTS_INDEX$ = null;

  public static Keyword KWD_DISABLED = null;

  /** If TRUE never check for the existence of duplicate
   * propositions when building a new proposition.
   */
  public final static StellaSpecialVariable $DONT_CHECK_FOR_DUPLICATE_PROPOSITIONSp$ = new StellaSpecialVariable();

  public static Symbol SYM_LOGIC_ANNOTATIONS = null;

  /** Used by 'recursively-fasten-down-propositions'.
   */
  public final static StellaSpecialVariable $VISITEDUNFASTENEDDEFININGPROPOSITIONS$ = new StellaSpecialVariable();

  public static Surrogate SGT_STELLA_STRING_WRAPPER = null;

  public static Symbol SYM_LOGIC_CONSTANT = null;

  public static Surrogate SGT_STELLA_SYMBOL = null;

  public static Symbol SYM_PL_KERNEL_KB_MEMBER_OF = null;

  public static Symbol SYM_LOGIC_IMPLIES = null;

  public static Symbol SYM_PL_KERNEL_KB_SUBSET_OF = null;

  public static Symbol SYM_STELLA_COLLECT_INTO = null;

  public static Surrogate SGT_STELLA_GENERALIZED_SYMBOL = null;

  public static Symbol SYM_LOGIC_FORWARD_ONLYp = null;

  public static Symbol SYM_LOGIC_BACKWARD_ONLYp = null;

  public static Keyword KWD_WEIGHT = null;

  public static Symbol SYM_LOGIC_WEIGHT = null;

  public static Symbol SYM_LOGIC_EQUIVALENT = null;

  public static Surrogate SGT_STELLA_TABLE = null;

  public static Surrogate SGT_PL_KERNEL_KB_POLYMORPHIC = null;

  /** If TRUE, automatically coerce propositional arguments of a
   * proposition, even if the corresponding argument type of the hosting relation
   * doesn't indicate that.
   */
  public static boolean $AUTO_COERCE_PROPOSITIONAL_ARGUMENTSp$ = false;

  public static Surrogate SGT_PL_KERNEL_KB_VALUE = null;

  public static Surrogate SGT_PL_KERNEL_KB_QUANTITY = null;

  public static Surrogate SGT_PL_KERNEL_KB_DATE = null;

  public static Surrogate SGT_STELLA_FLOAT = null;

  public static Surrogate SGT_STELLA_INTEGER = null;

  /** Three policies are implemented:
   *    :AUTOMATICALLY-FIX-TYPE-VIOLATIONS asserts missing types to fix type
   *        violations (default),
   *    :REPORT-TYPE-VIOLATIONS complains about missing or incorrect types,
   *    :SIGNAL-TYPE-VIOLATIONS throws exception for missing or incorrect types, and
   *    :IGNORE-TYPE-VIOLATIONS which disables all type checking.
   */
  public static Keyword $TYPE_CHECK_POLICY$ = null;

  public static Keyword KWD_AUTOMATICALLY_FIX_TYPE_VIOLATIONS = null;

  /** Controls the behavior of the type-checking
   * routines in the event that a type-check fails.  Options are:
   *   :POST-TYPE-VIOLATIONS              push offending proposition onto queue,
   *   :REPORT-TYPE-VIOLATIONS            print occasions of failed type checks,
   *   :SIGNAL-TYPE-VIOLATIONS            throw exception for failed type checks,
   *   :AUTOMATICALLY-FIX-TYPE-VIOLATIONS assert missing types on propositions, and
   *   :IGNORE-TYPE-VIOLATIONS            don't perform any type checking at all.
   */
  public final static StellaSpecialVariable $TYPECHECKMODE$ = new StellaSpecialVariable();

  public static Keyword KWD_POST_TYPE_VIOLATIONS = null;

  public static Keyword KWD_IGNORE_TYPE_VIOLATIONS = null;

  public static Keyword KWD_REPORT_TYPE_VIOLATIONS = null;

  public static Keyword KWD_SIGNAL_TYPE_VIOLATIONS = null;

  public static Symbol SYM_LOGIC_ASSERTED_BY_TYPE_CHECKERp = null;

  public static Surrogate SGT_LOGIC_CHECK_TYPES_RECORD = null;

  public static Symbol SYM_LOGIC_PARENT_PROPOSITION = null;

  public static Symbol SYM_LOGIC_PARENT_DESCRIPTION = null;

  /** List of propositions that have failed a type check,
   * but might pass once finalization is complete.
   */
  public static VectorSequence $CHECK_TYPES_AGENDA$ = null;

  public static Keyword KWD_MEDIUM = null;

  public static Keyword KWD_REALISTIC = null;

  public static Surrogate SGT_PL_KERNEL_KB_SETOF = null;

  public static Surrogate SGT_PL_KERNEL_KB_TOTAL = null;

  public static Surrogate SGT_PL_KERNEL_KB_LISTOF = null;

  public static Surrogate SGT_PL_KERNEL_KB_LIST = null;

  public static Symbol SYM_PL_KERNEL_KB_SETOF = null;

  public static Symbol SYM_PL_KERNEL_KB_LISTOF = null;

  public static Symbol SYM_LOGIC_BAGOF = null;

  public static Symbol SYM_STELLA_ASSERT = null;

  public static Keyword KWD_CPP = null;

  public static Keyword KWD_DELETED = null;

  public final static StellaSpecialVariable $DEFERRED_TERMS_TO_UNLINK$ = new StellaSpecialVariable();

  public static Symbol SYM_LOGIC_INTRODUCE_MODULE = null;

  public static Surrogate SGT_STELLA_KEY_VALUE_LIST = null;

  public static Symbol SYM_LOGIC_CLEAR_LOGIC_MODULE_HOOK = null;

  public static Symbol SYM_LOGIC_MONOTONICp = null;

  public static Surrogate SGT_STELLA_WORLD = null;

  public static Symbol SYM_LOGIC_DESTROY_LOGIC_CONTEXT_HOOK = null;

  public static Symbol SYM_STELLA_CLEARABLEp = null;

  public static Symbol SYM_STELLA_PROTECT_SURROGATESp = null;

  public static Keyword KWD_PREORDER = null;

  public static Surrogate SGT_STELLA_MUTABLE_STRING_WRAPPER = null;

  public static Surrogate SGT_STELLA_CONTEXT = null;

  public static Surrogate SGT_LOGIC_COMPUTED_PROCEDURE = null;

  public static Surrogate SGT_STELLA_NUMBER_WRAPPER = null;

  public static Symbol SYM_LOGIC_STARTUP_PROPOSITIONS = null;

  public static Keyword KWD_DEPENDENTS = null;

  public static Symbol SYM_LOGIC_DEPENDENT_PROPOSITIONS_INDEX = null;

  /** When 'dependent-propositions-list' gets this long in a
   * backlinks index, then we create a hash table index and other
   * specialized indices.
   */
  public static int $SPECIALIZED_BACKLINKS_CROSSOVER_POINT$ = 10;

  public static Keyword KWD_RELATION = null;

  public static Keyword KWD_DEBUGGING = null;

  public static Symbol SYM_LOGIC_HYPOTHESIZED_INSTANCEp = null;

  public static Surrogate SGT_STELLA_STRING = null;

  public static IntegerHashTable $INTEGER_LOGIC_WRAPPER_TABLE$ = null;

  public static FloatHashTable $FLOAT_LOGIC_WRAPPER_TABLE$ = null;

  public static StringHashTable $STRING_LOGIC_WRAPPER_TABLE$ = null;

  /** If TRUE, wrap all literal proposition arguments
   * so that they can all support backlink indices.
   */
  public static boolean $BACKLINK_ALL_PROPOSITION_ARGUMENTSp$ = false;

  public static Surrogate SGT_LOGIC_BACKLINKS_MIXIN = null;

  public static Symbol SYM_LOGIC_SUBSUMPTION_LINKp = null;

  public static Keyword KWD_RULES = null;

  public static Surrogate SGT_LOGIC_F_SELECT_RELATION_PROPOSITIONS_MEMO_TABLE_000 = null;

  public static Surrogate SGT_LOGIC_F_SELECT_RELATION_PROPOSITIONS_MEMO_TABLE_001 = null;

  public static Surrogate SGT_LOGIC_F_SELECT_RELATION_PROPOSITIONS_MEMO_TABLE_002 = null;

  public static Keyword KWD_EVALUATEp = null;

  /** Used when creating a skolem (e.g., a prototype) that
   * isn't visible in the corresponding class extension.
   */
  public final static StellaSpecialVariable $SUPPRESSINSERTIONINTOCLASSEXTENSIONp$ = new StellaSpecialVariable();

  public static Symbol SYM_LOGIC_STARTUP_BACKLINKS = null;

  public static Surrogate SGT_LOGIC_PROPAGATION_ENVIRONMENT = null;

  public static Symbol SYM_LOGIC_EVALUATION_QUEUE = null;

  public static Symbol SYM_LOGIC_EVALUATION_STATES = null;

  public static Symbol SYM_LOGIC_FORWARD_CHAINING_QUEUE = null;

  public static Symbol SYM_LOGIC_FORWARD_CHAINING_SET = null;

  public static Symbol SYM_LOGIC_DEFERRED_DEFAULT_PROPOSITIONS = null;

  public static Symbol SYM_LOGIC_ELABORATED_OBJECTS = null;

  public static Symbol SYM_LOGIC_PROPAGATION_ENVIRONMENT = null;

  /** True if we are inside of 'react-to-kb-update'.
   */
  public final static StellaSpecialVariable $FILLINGCONSTRAINTPROPAGATIONQUEUESp$ = new StellaSpecialVariable();

  /** True if we are propagating strict inferences, and
   * posting derived default propositions to temporary queues.
   */
  public final static StellaSpecialVariable $DEFERINGDEFAULTFORWARDINFERENCESp$ = new StellaSpecialVariable();

  public static Keyword KWD_POSTED = null;

  public static Surrogate SGT_LOGIC_F_COLLECT_FORWARD_CHAINING_RULES_MEMO_TABLE_000 = null;

  /** Collect goes-true propositions produced by forward
   * chaining.
   */
  public final static StellaSpecialVariable $COLLECTFORWARDPROPOSITIONS$ = new StellaSpecialVariable();

  public static Symbol SYM_LOGIC_SKOLEM_GENERATION_COUNT = null;

  public static int $MAX_SKOLEM_GENERATION_COUNT$ = 3;

  public static Keyword KWD_PROPAGATE = null;

  public static Keyword KWD_GOAL_TREE = null;

  public static Keyword KWD_SINGLETONSp = null;

  public static Keyword KWD_INFERENCE_LEVEL = null;

  public static Keyword KWD_SHALLOW = null;

  public static Keyword KWD_EVALUATED = null;

  /** If TRUE, ensures that forward propagation has
   * been applied to each instance 'touched' during a query.
   */
  public static boolean $JUST_IN_TIME_FORWARD_INFERENCEp$ = true;

  /** Collects clash exceptions that occur during inference.
   */
  public static List $CLASH_EXCEPTIONS$ = null;

  public static Symbol SYM_LOGIC_CULL_CLASH_EXCEPTIONS = null;

  public static Keyword KWD_ELABORATE = null;

  public static Surrogate SGT_PL_KERNEL_KB_INEQUALITY = null;

  public static Surrogate SGT_PL_KERNEL_KB_PHRASE = null;

  public static Symbol SYM_LOGIC_STARTUP_PROPAGATE = null;

  public static Symbol SYM_LOGIC_INFERENCE_CACHE_OF = null;

  public static Keyword KWD_JUST_IN_TIME = null;

  public static Symbol SYM_LOGIC_JUST_IN_TIME_INFERENCE_CACHE = null;

  public static Keyword KWD_TMS = null;

  public static Symbol SYM_LOGIC_UP_TO_DATE_INFERENCESp = null;

  /** Used to signal an assertion that doesn't
   * blow away inference caches.
   */
  public final static StellaSpecialVariable $INVISIBLEASSERTIONp$ = new StellaSpecialVariable();

  public static Symbol SYM_LOGIC_TRUTH_MAINTAINEDp = null;

  public static Keyword KWD_PERFORMANCE_CLUES = null;

  public static Keyword KWD_FORCEp = null;

  public static Keyword KWD_FORCE = null;

  public static Symbol SYM_LOGIC_STARTUP_INFERENCE_CACHES = null;

  public static Surrogate SGT_STELLA_METHOD_SLOT = null;

  public static Symbol SYM_STELLA_ANY_VALUE = null;

  /** Installed in a description with undetermined arity.
   */
  public static Vector FAKE_IO_VARIABLES = null;

  public static Cons SYSTEM_DEFINED_ARGUMENT_NAMES = null;

  public static Symbol SYM_LOGIC_pX1 = null;

  public static Symbol SYM_LOGIC_pX2 = null;

  public static Symbol SYM_LOGIC_pX3 = null;

  public static Symbol SYM_LOGIC_pX4 = null;

  public static Symbol SYM_LOGIC_pX5 = null;

  public static Symbol SYM_LOGIC_pX6 = null;

  public static Symbol SYM_LOGIC_pX7 = null;

  public static Symbol SYM_LOGIC_pX8 = null;

  public static Symbol SYM_LOGIC_pX9 = null;

  public static Symbol SYM_LOGIC_pX10 = null;

  public static Symbol SYM_LOGIC_pX11 = null;

  public static Symbol SYM_LOGIC_pX12 = null;

  public static Symbol SYM_LOGIC_pX13 = null;

  public static Symbol SYM_LOGIC_pX14 = null;

  public static Symbol SYM_LOGIC_pX15 = null;

  public static Symbol SYM_LOGIC_pX16 = null;

  public static Symbol SYM_LOGIC_pX17 = null;

  public static Symbol SYM_LOGIC_pX18 = null;

  public static Symbol SYM_LOGIC_pX19 = null;

  public static Symbol SYM_LOGIC_pX20 = null;

  public static Symbol SYM_LOGIC_pX21 = null;

  public static Symbol SYM_LOGIC_pX22 = null;

  public static Symbol SYM_LOGIC_pX23 = null;

  public static Symbol SYM_LOGIC_pX24 = null;

  public static Symbol SYM_LOGIC_pX25 = null;

  public static Symbol SYM_LOGIC_pX26 = null;

  public static Symbol SYM_LOGIC_pX27 = null;

  public static Symbol SYM_LOGIC_pX28 = null;

  public static Symbol SYM_LOGIC_pX29 = null;

  public static Symbol SYM_LOGIC_pX30 = null;

  public static Symbol SYM_LOGIC_pX31 = null;

  public static Symbol SYM_LOGIC_pX32 = null;

  public static Symbol SYM_LOGIC_pX33 = null;

  public static Symbol SYM_LOGIC_pX34 = null;

  public static Symbol SYM_LOGIC_pX35 = null;

  public static Symbol SYM_LOGIC_pX36 = null;

  public static Symbol SYM_LOGIC_pX37 = null;

  public static Symbol SYM_LOGIC_pX38 = null;

  public static Symbol SYM_LOGIC_pX39 = null;

  public static Symbol SYM_LOGIC_pX40 = null;

  public static Symbol SYM_LOGIC_pX41 = null;

  public static Symbol SYM_LOGIC_pX42 = null;

  public static Symbol SYM_LOGIC_pX43 = null;

  public static Symbol SYM_LOGIC_pX44 = null;

  public static Symbol SYM_LOGIC_pX45 = null;

  public static Symbol SYM_LOGIC_pX46 = null;

  public static Symbol SYM_LOGIC_pX47 = null;

  public static Symbol SYM_LOGIC_pX48 = null;

  public static Symbol SYM_LOGIC_pX49 = null;

  public static Symbol SYM_LOGIC_pX50 = null;

  public static Symbol SYM_LOGIC_pX51 = null;

  public static Symbol SYM_LOGIC_pX52 = null;

  public static Symbol SYM_LOGIC_pX53 = null;

  public static Symbol SYM_LOGIC_pX54 = null;

  public static Symbol SYM_LOGIC_pX55 = null;

  public static Symbol SYM_LOGIC_pX56 = null;

  public static Symbol SYM_LOGIC_pX57 = null;

  public static Symbol SYM_LOGIC_pX58 = null;

  public static Symbol SYM_LOGIC_pX59 = null;

  public static Symbol SYM_LOGIC_pX60 = null;

  public static Symbol SYM_LOGIC_pX61 = null;

  public static Symbol SYM_LOGIC_pX62 = null;

  public static Symbol SYM_LOGIC_pX63 = null;

  public static Symbol SYM_LOGIC_pX64 = null;

  public static Symbol SYM_LOGIC_pX65 = null;

  public static Symbol SYM_LOGIC_pX66 = null;

  public static Symbol SYM_LOGIC_pX67 = null;

  public static Symbol SYM_LOGIC_pX68 = null;

  public static Symbol SYM_LOGIC_pX69 = null;

  public static Symbol SYM_LOGIC_pX70 = null;

  public static Symbol SYM_LOGIC_pX71 = null;

  public static Symbol SYM_LOGIC_pX72 = null;

  public static Symbol SYM_LOGIC_pX73 = null;

  public static Symbol SYM_LOGIC_pX74 = null;

  public static Symbol SYM_LOGIC_pX75 = null;

  public static Symbol SYM_LOGIC_pX76 = null;

  public static Symbol SYM_LOGIC_pX77 = null;

  public static Symbol SYM_LOGIC_pX78 = null;

  public static Symbol SYM_LOGIC_pX79 = null;

  public static Symbol SYM_LOGIC_pX80 = null;

  public static Symbol SYM_LOGIC_pX81 = null;

  public static Symbol SYM_LOGIC_pX82 = null;

  public static Symbol SYM_LOGIC_pX83 = null;

  public static Symbol SYM_LOGIC_pX84 = null;

  public static Symbol SYM_LOGIC_pX85 = null;

  public static Symbol SYM_LOGIC_pX86 = null;

  public static Symbol SYM_LOGIC_pX87 = null;

  public static Symbol SYM_LOGIC_pX88 = null;

  public static Symbol SYM_LOGIC_pX89 = null;

  public static Symbol SYM_LOGIC_pX90 = null;

  public static Symbol SYM_LOGIC_pX91 = null;

  public static Symbol SYM_LOGIC_pX92 = null;

  public static Symbol SYM_LOGIC_pX93 = null;

  public static Symbol SYM_LOGIC_pX94 = null;

  public static Symbol SYM_LOGIC_pX95 = null;

  public static Symbol SYM_LOGIC_pX96 = null;

  public static Symbol SYM_LOGIC_pX97 = null;

  public static Symbol SYM_LOGIC_pX98 = null;

  public static Symbol SYM_LOGIC_pX99 = null;

  public static Symbol SYM_LOGIC_pX100 = null;

  public static Surrogate SGT_LOGIC_UNFINALIZED = null;

  /** Table mapping logic variable names to variables or skolems.
   * Used during construction of a proposition or description.
   */
  public final static StellaSpecialVariable $LOGICVARIABLETABLE$ = new StellaSpecialVariable();

  /** List of propositions extracted from parsing
   * a list of quantified, typed variables.
   */
  public final static StellaSpecialVariable $VARIABLETYPEPROPOSITIONS$ = new StellaSpecialVariable();

  public static Surrogate SGT_STELLA_LIST = null;

  public final static StellaSpecialVariable $UNIFY_PROPOSITIONSp$ = new StellaSpecialVariable();

  public static Symbol SYM_LOGIC_EXTERNAL_VARIABLES = null;

  public static Surrogate SGT_STELLA_PROPOSITIONdIF = null;

  public static Keyword KWD_HEAD = null;

  /** Used by 'evaluate-DESCRIPTION-term' for collecting
   * a list of variables declared external to the description in which they
   * are referenced.
   */
  public final static StellaSpecialVariable $EXTERNALVARIABLES$ = new StellaSpecialVariable();

  public static Keyword KWD_TOP_LEVEL = null;

  /** Used to prevent infinite looping.
   */
  public final static StellaSpecialVariable $RECURSIVEGETCOMPLEMENTARGUMENT$ = new StellaSpecialVariable();

  public static Symbol SYM_LOGIC_VARIABLE_TYPE_TABLE = null;

  /** Used by 'infer-variable-types'.
   */
  public final static StellaSpecialVariable $ADDEDNEWTYPEp$ = new StellaSpecialVariable();

  public static Symbol SYM_LOGIC_UNDECLAREDp = null;

  public static Symbol SYM_LOGIC_pX = null;

  public static Symbol SYM_PL_KERNEL_KB_RELATION = null;

  public static Symbol SYM_LOGIC_F_CALL_LIST_UNDEFINED_RELATIONS_QUERY_000 = null;

  public static Symbol SYM_LOGIC_STARTUP_DESCRIPTIONS = null;

  public static Surrogate SGT_PL_KERNEL_KB_CUT = null;

  public static Surrogate SGT_PL_KERNEL_KB_BOUND_VARIABLES = null;

  public static Surrogate SGT_PL_KERNEL_KB_FORK = null;

  public static Surrogate SGT_PL_KERNEL_KB_QUERY = null;

  public static Symbol SYM_LOGIC_NEURAL_NETWORK = null;

  public static Surrogate SGT_PL_KERNEL_KB_ARITY = null;

  public static Surrogate SGT_PL_KERNEL_KB_CLASS = null;

  public static Symbol SYM_LOGIC_DONT_OPTIMIZEp = null;

  public static Keyword KWD_TAIL = null;

  public static Surrogate SGT_LOGIC_NOT = null;

  public static Surrogate SGT_LOGIC_FORALL = null;

  public static Surrogate SGT_LOGIC_EXISTS = null;

  public static Surrogate SGT_LOGIC_OR = null;

  public static Surrogate SGT_LOGIC_AND = null;

  public static Symbol SYM_LOGIC_STARTUP_NORMALIZE = null;

  /** If true, inversion of forall propositions happens lazily.
   * I.e., satellite rules are generated on-demand during inference only if they
   * are actually needed.
   */
  public static boolean $LAZY_SATELLITE_RULESp$ = false;

  public static Keyword KWD_POSITIVE = null;

  public static Keyword KWD_CONTRAPOSITIVE = null;

  public static Symbol SYM_LOGIC_RULES_WITH_DEFERRED_SATELLITES = null;

  public static Keyword KWD_POSITIVE_AND_CONTRAPOSITIVE = null;

  public final static StellaSpecialVariable $DERIVE_DEFERRED_SATELLITE_RULES_INVOCATIONS$ = new StellaSpecialVariable();

  public static Symbol SYM_LOGIC_STARTUP_RULES = null;

  public static Surrogate SGT_LOGIC_INFERENCE_LEVEL = null;

  public static Symbol SYM_STELLA_KEYWORD = null;

  public static Surrogate SGT_LOGIC_NORMAL_INFERENCE_LEVEL = null;

  public static Surrogate SGT_LOGIC_BACKTRACKING_INFERENCE_LEVEL = null;

  public static Surrogate SGT_LOGIC_SUBSUMPTION_INFERENCE_LEVEL = null;

  public static Surrogate SGT_LOGIC_SHALLOW_INFERENCE_LEVEL = null;

  public static Surrogate SGT_LOGIC_ASSERTION_INFERENCE_LEVEL = null;

  public static Surrogate SGT_LOGIC_REFUTATION_INFERENCE_LEVEL = null;

  public static NormalInferenceLevel NORMAL_INFERENCE = null;

  public static Keyword KWD_NORMAL = null;

  public static BacktrackingInferenceLevel BACKTRACKING_INFERENCE = null;

  public static Keyword KWD_BACKTRACKING = null;

  public static SubsumptionInferenceLevel SUBSUMPTION_INFERENCE = null;

  public static Keyword KWD_SUBSUMPTION = null;

  public static ShallowInferenceLevel SHALLOW_INFERENCE = null;

  public static AssertionInferenceLevel ASSERTION_INFERENCE = null;

  public static Keyword KWD_ASSERTION = null;

  public static RefutationInferenceLevel REFUTATION_INFERENCE = null;

  public static Keyword KWD_REFUTATION = null;

  /** Specifies the level/depth of inference applied
   * during a query.  Possible values are:
   *   :ASSERTION -- database lookup with no inheritance;
   *   :SHALLOW -- includes database lookup, computed predicates and specialists;
   *   :SUBSUMPTION -- shallow plus cached subsumption links and equality reasoning;
   *   :BACKTRACKING -- all of the above plus backtracking over rules;
   *   :NORMAL -- all of the above plus universal introduction;
   *   :REFUTATION -- all of the above plus disjunctive implication introduction and refutation.
   */
  public final static StellaSpecialVariable $INFERENCELEVEL$ = new StellaSpecialVariable();

  public static Symbol SYM_LOGIC_INFERENCE_LEVEL = null;

  /** Controls whether queries use default knowledge or not.
   */
  public final static StellaSpecialVariable $DONTUSEDEFAULTKNOWLEDGEp$ = new StellaSpecialVariable();

  /** Value for the maximum depth allowable during
   * backtrack search.
   */
  public static int $MAXIMUM_BACKTRACKING_DEPTH$ = Stella.NULL_INTEGER;

  /** Determines whether there is a slow but thorough type test
   * when variables are bound, a fast but very shallow one, or none.  Values
   * are :NONE, :LOOKUP, :DISJOINT.  The default is :LOOKUP.
   */
  public final static StellaSpecialVariable $TYPE_CHECK_STRATEGY$ = new StellaSpecialVariable();

  public static Keyword KWD_LOOKUP = null;

  /** Determines what kind of duplicate subgoal test to use.  Choices
   * are :DUPLICATE-RULES, :DUPLICATE-GOALS, and :DUPLICATE-GOALS-WITH-CACHING.
   */
  public static Keyword $DUPLICATE_SUBGOAL_STRATEGY$ = null;

  public static Keyword KWD_DUPLICATE_GOALS = null;

  /** Sets the maximum number of frames search looking for
   * a duplicate subgoal.  Default value is infinite.  Possibly this should
   * be replaced by a function that increases with depth of search.
   */
  public static int $DUPLICATE_GOAL_SEARCH_DEPTH$ = Stella.NULL_INTEGER;

  /** Set limit on number of frames searched looking for
   * a duplicate rule.  Default value is infinite.
   */
  public static int $DUPLICATE_RULE_SEARCH_DEPTH$ = Stella.NULL_INTEGER;

  /** If TRUE, all collections are assumed to be closed.
   */
  public static boolean $GLOBALLY_CLOSED_COLLECTIONSp$ = false;

  /** If TRUE, the backchainer follows all lines of proof
   * for each goal, rather than switching to a new goal once the first proof
   * of a goal is achieved.  The partial matcher sets this variable to
   * TRUE to force generation of proofs having possibly different
   * weights.
   */
  public final static StellaSpecialVariable $GENERATE_ALL_PROOFSp$ = new StellaSpecialVariable();

  public static Keyword KWD_TRACE_SUBGOALS = null;

  public static Keyword KWD_STRATEGIES = null;

  public static Symbol SYM_LOGIC_COST_ESTIMATE = null;

  public static Surrogate SGT_LOGIC_QUERY_ITERATOR = null;

  public static Symbol SYM_LOGIC_RESIDUE_GOALS = null;

  public static Symbol SYM_LOGIC_BEST_GOAL_SEQUENCE = null;

  public static Symbol SYM_LOGIC_EXHAUSTEDp = null;

  public static Symbol SYM_STELLA_OPTIONS = null;

  public static Symbol SYM_LOGIC_SOLUTIONS = null;

  public static Symbol SYM_LOGIC_QUERY_CONTEXT = null;

  public static Symbol SYM_LOGIC_BASE_CONTROL_FRAME = null;

  public static Symbol SYM_LOGIC_CURRENT_CONTROL_FRAME = null;

  public static Symbol SYM_LOGIC_CURRENT_PATTERN_RECORD = null;

  public static Symbol SYM_LOGIC_CURRENT_PARALLEL_THREAD = null;

  public static Symbol SYM_LOGIC_CONTROL_FRAME_PRIORITY_QUEUE = null;

  public static Symbol SYM_LOGIC_AUGMENTED_GOAL_CACHEp = null;

  public static Symbol SYM_LOGIC_ACTIVE_GOAL_CACHES = null;

  public static Symbol SYM_LOGIC_TRIGGERED_DEPTH_CUTOFFp = null;

  public static Symbol SYM_LOGIC_FAILED_TO_FIND_DUPLICATE_SUBGOALp = null;

  public static Symbol SYM_LOGIC_FOUND_AT_LEAST_ONE_SOLUTIONp = null;

  public static Symbol SYM_LOGIC_PARTIAL_MATCH_STRATEGY = null;

  public static Symbol SYM_LOGIC_MAXIMUM_DEPTH = null;

  public static Symbol SYM_LOGIC_ALLOTTED_TIME = null;

  public static Symbol SYM_LOGIC_TIMEOUTp = null;

  public static Symbol SYM_LOGIC_DEPTH_CUTOFFSp = null;

  public static Symbol SYM_LOGIC_NEGATED_QUERY = null;

  public static Symbol SYM_LOGIC_LATEST_PARTIAL_SCORE = null;

  public static Symbol SYM_LOGIC_AUXILIARY_QUERY = null;

  public static Symbol SYM_LOGIC_LATEST_POSITIVE_SCORE = null;

  public static Symbol SYM_LOGIC_GOAL_BINDINGS = null;

  public static Surrogate SGT_LOGIC_CONTROL_FRAME = null;

  public static Symbol SYM_LOGIC_REVERSE_POLARITYp = null;

  public static Symbol SYM_LOGIC_PATTERN_RECORD = null;

  public static Symbol SYM_LOGIC_INHERITED_PATTERN_RECORD = null;

  public static Symbol SYM_LOGIC_CHOICE_POINT_UNBINDING_OFFSET = null;

  public static Symbol SYM_LOGIC_CURRENT_STRATEGY = null;

  public static Symbol SYM_LOGIC_NEXT_STRATEGIES = null;

  public static Symbol SYM_LOGIC_JUSTIFICATIONS = null;

  public static Symbol SYM_LOGIC_CACHED_GOAL_RESULTp = null;

  public static Symbol SYM_LOGIC_DONT_CACHE_GOAL_FAILUREp = null;

  public static Surrogate SGT_LOGIC_PARALLEL_THREAD = null;

  public static Symbol SYM_LOGIC_TOP_CONTROL_FRAME = null;

  public static Symbol SYM_LOGIC_HYPOTHETICAL_WORLD = null;

  public static Symbol SYM_LOGIC_VARIABLE_BINDINGS = null;

  public static Symbol SYM_LOGIC_UNBINDING_STACK = null;

  public static Symbol SYM_LOGIC_TOP_UNBINDING_STACK_OFFSET = null;

  public static Symbol SYM_LOGIC_PRIORITY = null;

  public static Symbol SYM_LOGIC_STATUS = null;

  public static Surrogate SGT_LOGIC_PARALLEL_CONTROL_FRAME = null;

  public static Symbol SYM_LOGIC_CHILD_THREADS = null;

  public static Symbol SYM_LOGIC_UNBOUND_VARIABLESp = null;

  public static Symbol SYM_LOGIC_CURRENT_CHILD_THREAD = null;

  public static Symbol SYM_LOGIC_SAVED_PARENT_CONTEXT = null;

  public static Symbol SYM_LOGIC_SAVED_PARENT_PARALLEL_THREAD = null;

  public static Surrogate SGT_LOGIC_CONTROL_FRAME_PRIORITY_QUEUE = null;

  public static Symbol SYM_LOGIC_QUEUE = null;

  /** Points to the query iterator for the currently executing query.
   */
  public final static StellaSpecialVariable $QUERYITERATOR$ = new StellaSpecialVariable();

  /** Possibly a good value for the maximum backtracking depth.
   * More testing is needed.
   */
  public static int $DEFAULT_MAXIMUM_DEPTH$ = 25;

  /** Value of the initial depth used during an interative
   * deepening search.
   */
  public static int $INITIAL_BACKTRACKING_DEPTH$ = 5;

  /** Default setting.  If TRUE, queries are evaluated
   * using iterative deepening from depth '*initial-backtracking-depth*'
   * to depth '*maximum-backtracking-depth*'.
   */
  public static boolean $ITERATIVE_DEEPENING_MODEp$ = false;

  /** When TRUE, various kinds of characters are
   * emitted to STANDARD-OUTPUT while PowerLoom is 'thinking'.
   */
  public static boolean $EMIT_THINKING_DOTSp$ = true;

  /** Used to determine when to generate linefeeds
   * after forty-or-so thinking dots.
   */
  public static int $THINKING_DOT_COUNTER$ = 0;

  /** Maps kind of thinking keywords to characters.
   */
  public static PropertyList $THINKING_DOT_TABLE$ = null;

  public static Keyword KWD_UPCLASSIFY = null;

  public static Keyword KWD_DOWNCLASSIFY = null;

  public static Keyword KWD_PARTIAL_MATCH = null;

  public static Surrogate SGT_LOGIC_PROOF_ADJUNCT = null;

  public static Surrogate SGT_LOGIC_PATTERN_RECORD = null;

  public static Symbol SYM_LOGIC_CONTROL_FRAME = null;

  public static Symbol SYM_LOGIC_EXTERNAL_ARGUMENTS = null;

  public static Symbol SYM_STELLA_BOOLEAN_VECTOR = null;

  public static Symbol SYM_LOGIC_OPTIMAL_PATTERN = null;

  public static Symbol SYM_LOGIC_COLLECTION_LIST = null;

  public static Surrogate SGT_LOGIC_BOOLEAN_VECTOR_INDEX_NODE = null;

  public static Symbol SYM_LOGIC_TRUE_LINK = null;

  public static Symbol SYM_LOGIC_FALSE_LINK = null;

  public static Symbol SYM_LOGIC_THE_VECTOR = null;

  /** Points to the head of a discrimination tree of containing
   * all boolean vectors.
   */
  public static BooleanVectorIndexNode $BOOLEAN_VECTOR_INDEX$ = null;

  public static Keyword KWD_CONTAINED_BY = null;

  public static Keyword KWD_PARENT = null;

  public static Symbol SYM_LOGIC_CACHED_BINDINGS_ITERATOR = null;

  public static Keyword KWD_POPPED = null;

  public static Keyword KWD_LOCAL = null;

  public static Keyword KWD_QUERY_STACKS = null;

  public static Keyword KWD_NONE = null;

  public static Keyword KWD_SHALLOW_DISJOINT = null;

  public static Keyword KWD_DISJOINT = null;

  /** If set, controls diagnostic printing by making
   * variable bindings appear relative to the frame '*printInFrame*'.
   */
  public final static StellaSpecialVariable $PRINTINFRAME$ = new StellaSpecialVariable();

  public static Keyword KWD_FLAT = null;

  public static HashSet $TRACED_GOALS$ = null;

  public static Keyword KWD_ATOMIC_GOAL = null;

  public static Keyword KWD_ITERATIVE_FORALL = null;

  public static Keyword KWD_STATE_MACHINE = null;

  public static Keyword KWD_PARALLEL_STRATEGIES = null;

  public static Keyword KWD_STRATEGY = null;

  public static Keyword KWD_SPECIALIST = null;

  public static Symbol SYM_LOGIC_ANTECEDENTS_RULE = null;

  public static Keyword KWD_FULL_SUBQUERY = null;

  public static Keyword KWD_ANTECEDENTS = null;

  public static Symbol SYM_STELLA_ITERATOR = null;

  public static Keyword KWD_FAILURE = null;

  public static Keyword KWD_FINAL_SUCCESS = null;

  public static Surrogate SGT_LOGIC_NN_PARTIAL_MATCH = null;

  public static Symbol SYM_LOGIC_MATCH_SCORE = null;

  public static Symbol SYM_LOGIC_BACK = null;

  public static Symbol SYM_LOGIC_GOAL_CACHE = null;

  /** Generates unique IDs for control frames.  Used only for debugging.
   */
  public static int $CONTROL_FRAME_ID_COUNTER$ = -1;

  public static Symbol SYM_LOGIC_DEBUG_FRAME_ID_INTERNAL = null;

  public static Keyword KWD_MOVE_DOWN = null;

  public static Keyword KWD_CONTINUING_SUCCESS = null;

  public static Keyword KWD_MOVE_IN_PLACE = null;

  public static Keyword KWD_TIMEOUT = null;

  public static Keyword KWD_SCAN_CACHED_BINDINGS = null;

  public static Keyword KWD_CLUSTERED_CONJUNCTION = null;

  public static Keyword KWD_DISJUNCTIVE_IMPLICATION_INTRODUCTION = null;

  /** Signals atomic proposition provers that polarity is negative.
   */
  public final static StellaSpecialVariable $REVERSEPOLARITYp$ = new StellaSpecialVariable();

  public static Keyword KWD_DUPLICATE_GOALS_WITH_CACHING = null;

  public static Keyword KWD_MANUFACTURE_SKOLEM = null;

  public static Symbol SYM_LOGIC_CACHED_SINGLE_VALUEDp = null;

  public static Keyword KWD_FAILED_OVERLAY = null;

  /** If true and goal tracing is on, subgoals of disjointness
   * queries will also be traced.
   */
  public static boolean $TRACE_DISJOINTNESS_SUBGOALSp$ = false;

  public static Surrogate SGT_PL_KERNEL_KB_PARTITION_MEMBERSHIP = null;

  public static Surrogate SGT_PL_KERNEL_KB_DISJOINT = null;

  public static Symbol SYM_LOGIC_pD1 = null;

  public static Symbol SYM_LOGIC_pD2 = null;

  public static Symbol SYM_LOGIC_DISJOINT = null;

  public static Symbol SYM_LOGIC_F_DISJOINT_TERMSp_QUERY_000 = null;

  public static Surrogate SGT_LOGIC_F_DISJOINT_TERMSp_MEMO_TABLE_000 = null;

  public static Symbol SYM_LOGIC_F_DISJOINT_TERMSp_QUERY_001 = null;

  public static Symbol SYM_PL_KERNEL_KB_CLASS = null;

  public static Symbol SYM_LOGIC_REFUTATION_DISJOINT = null;

  public static Symbol SYM_LOGIC_F_EXPENSIVE_DISJOINT_TERMSp_QUERY_000 = null;

  public static Surrogate SGT_PL_KERNEL_KB_COLLECTIONOF = null;

  public static Surrogate SGT_LOGIC_DESCRIPTION_EXTENSION_ITERATOR = null;

  public static Symbol SYM_LOGIC_ROOT_DESCRIPTION = null;

  public static Symbol SYM_LOGIC_SUBCOLLECTIONS = null;

  public static Symbol SYM_LOGIC_EXTENSION_ITERATOR = null;

  public static Symbol SYM_LOGIC_REFERENCE_PROPOSITION = null;

  public static Symbol SYM_LOGIC_ALREADY_GENERATED_LIST = null;

  public static Symbol SYM_LOGIC_ALREADY_GENERATED_TABLE = null;

  public static Symbol SYM_LOGIC_REMOVING_DUPLICATESp = null;

  /** Point where a cache of generated instances in a 
   * description extension iterator is switched from a list to a hash table
   */
  public static int $DUPLICATEINSTANCESCACHECROSSOVERPOINT$ = 20;

  public static Keyword KWD_GOAL_CACHES = null;

  public static Keyword KWD_GOAL_CUTOFFS = null;

  public static Keyword KWD_DEPTH_VIOLATION = null;

  public static Keyword KWD_DEPTH_CUTOFF = null;

  public static Keyword KWD_TECHNICAL = null;

  public static Keyword KWD_LAY = null;

  public static Surrogate SGT_LOGIC_QUERY_SOLUTION_TABLE = null;

  public static Symbol SYM_STELLA_THE_MAP = null;

  public static Symbol SYM_STELLA_FIRST = null;

  public static Symbol SYM_STELLA_LAST = null;

  public static Surrogate SGT_LOGIC_QUERY_SOLUTION = null;

  public static Symbol SYM_LOGIC_BINDINGS = null;

  public static Symbol SYM_LOGIC_BEST_JUSTIFICATION = null;

  public static Symbol SYM_LOGIC_ALL_JUSTIFICATIONS = null;

  public static Symbol SYM_STELLA_NEXT = null;

  public static Surrogate SGT_LOGIC_QUERY_SOLUTION_TABLE_ITERATOR = null;

  public static Symbol SYM_STELLA_THE_TABLE = null;

  public static Symbol SYM_STELLA_CURSOR = null;

  public static int $QUERY_ITERATOR_DEBUG_ID_COUNTER$ = 0;

  public static Symbol SYM_LOGIC_DEBUG_ID = null;

  public static Keyword KWD_FORMAT = null;

  public static Keyword KWD_OUTPUT_FILE = null;

  public static Keyword KWD_IF_EXISTS = null;

  public static Keyword KWD_SUPERSEDE = null;

  public static Keyword KWD_APPEND = null;

  public static Keyword KWD_VERTICAL = null;

  public static Keyword KWD_LIST = null;

  public static Keyword KWD_TSV = null;

  public static Keyword KWD_HORIZONTAL = null;

  public static Keyword KWD_TRACE_SOLUTIONS = null;

  public static Symbol SYM_LOGIC_ATOMIC_SINGLETONSp = null;

  public static Symbol SYM_PL_KERNEL_KB_pMATCH_SCORE = null;

  public static Keyword KWD_DONT_OPTIMIZEp = null;

  public static Symbol SYM_LOGIC_INITIAL_BINDINGS = null;

  public static Keyword KWD_ITERATIVE_DEEPENINGp = null;

  public static Symbol SYM_LOGIC_ITERATIVE_DEEPENINGp = null;

  public static Keyword KWD_MATCH_MODE = null;

  public static Keyword KWD_DEFERRED_OPTIONS = null;

  public static Keyword KWD_FOUR_VALUEDp = null;

  public static Keyword KWD_HOW_MANY = null;

  public static Keyword KWD_SORT_BY = null;

  public static Keyword KWD_SCORE = null;

  public static Keyword KWD_CHECK_VARIABLESp = null;

  public static Keyword KWD_MOVEOUT = null;

  public static Keyword KWD_MAXIMUM_DEPTH = null;

  public static Keyword KWD_THREE_VALUEDp = null;

  public static Keyword KWD_ATOMIC_SINGLETONSp = null;

  public static Keyword KWD_ALL_PROOFSp = null;

  public static Keyword KWD_VALUES = null;

  public static Keyword KWD_VALUES_DESCENDING = null;

  public static Keyword KWD_VALUES_ASCENDING = null;

  public static Keyword KWD_READABLE_VALUESp = null;

  public static Keyword KWD_MINIMUM_SCORE = null;

  public static Keyword KWD_MAXIMIZE_SCOREp = null;

  public static Keyword KWD_MAXIMUM_UNKNOWNS = null;

  public static Surrogate SGT_STELLA_PROPERTY_LIST = null;

  public static Keyword KWD_HIGH = null;

  public static QueryIterator $MOST_RECENT_QUERY$ = null;

  /** Caches queries used in-line by code, so that they don't have to
   * be reparsed and reoptimized each time they are invoked.
   */
  public static KeyValueMap $INLINE_QUERY_CACHE$ = null;

  public static int $MAX_CACHED_QUERIES_PER_ID$ = 10;

  public static Keyword KWD_DYNAMIC = null;

  public static Keyword KWD_DYNAMIC_WITH_CLUSTERING = null;

  public static Surrogate SGT_PL_KERNEL_KB_CONCEPT_PROTOTYPE = null;

  public static Symbol SYM_LOGIC_pC = null;

  public static Symbol SYM_LOGIC_pP = null;

  public static Symbol SYM_PL_KERNEL_KB_CONCEPT_PROTOTYPE = null;

  public static Symbol SYM_LOGIC_F_GET_PROTOTYPE_QUERY_000 = null;

  public static Surrogate SGT_STELLA_VECTOR = null;

  public static Keyword KWD_UPDATE_FROM_QUERY = null;

  public static Keyword KWD_ASSERT_FROM_QUERY = null;

  public static Keyword KWD_RECORD_JUSTIFICATIONSp = null;

  public static Symbol SYM_LOGIC_STARTUP_QUERY = null;

  public static Keyword $PARTIAL_MATCH_MODE$ = null;

  public static Keyword KWD_BASIC = null;

  public static boolean $GREEDY_NETWORK_PRUNING$ = true;

  public static Keyword $RULE_COMBINATION$ = null;

  public static Keyword KWD_MAX = null;

  public static boolean $PLANNING_MODE$ = false;

  public static Cons $PLANABLE_PREDICATES$ = null;

  public static Symbol SYM_LOGIC_CHILD = null;

  public static Symbol SYM_LOGIC_NEGATIVE_SCORE = null;

  public static Symbol SYM_LOGIC_DYNAMIC_CUTOFF = null;

  public static Symbol SYM_LOGIC_ARGUMENT_WEIGHTS = null;

  public static Symbol SYM_LOGIC_UNBOUND_VARS = null;

  public static boolean $FAIL_UNBOUND_CLAUSESp$ = false;

  /** Positive scores below *minimum-score-cutoff* get trimmed
   * to 0.0 during partial match operations.
   */
  public static double $MINIMUM_SCORE_CUTOFF$ = 0.0;

  /** Positive scores above *maximum-score-cutoff* get trimmed
   * to 1.0 during partial match operations.
   */
  public static double $MAXIMUM_SCORE_CUTOFF$ = 0.0;

  public static boolean $AND_MISSED_A_BINDING$ = false;

  public static Keyword KWD_CONTROL_FRAME = null;

  public static Keyword KWD_KIND = null;

  public static Surrogate SGT_LOGIC_INCREMENTAL_PARTIAL_MATCH = null;

  public static Symbol SYM_LOGIC_ACCUMULATED_SCORE = null;

  public static Symbol SYM_LOGIC_ACCUMULATED_WEIGHT = null;

  public static Symbol SYM_LOGIC_TOTAL_WEIGHT = null;

  public static Symbol SYM_LOGIC_MAXIMUM_SCORE = null;

  public static Keyword KWD_SKIPPED_CONJUNCT = null;

  public static Keyword KWD_NOISY_OR = null;

  public static Symbol SYM_LOGIC_INFERENCE_CUTOFF_REASON = null;

  public static Symbol SYM_LOGIC_RULES = null;

  public static Symbol SYM_STELLA_ARITY = null;

  public static Keyword KWD_INCREMENTAL = null;

  public static Keyword KWD_NN = null;

  public static Keyword KWD_NEURAL_NETWORK = null;

  public static Surrogate SGT_PL_KERNEL_KB_NULL = null;

  public static Symbol SYM_LOGIC_STARTUP_PARTIAL_MATCH = null;

  public static Surrogate SGT_LOGIC_TRAINING_EXAMPLE = null;

  public static Symbol SYM_LOGIC_CONCEPT = null;

  public static Symbol SYM_STELLA_NAME = null;

  public static Symbol SYM_LOGIC_INPUT_FEATURES = null;

  public static Symbol SYM_LOGIC_INPUT = null;

  public static Symbol SYM_LOGIC_FACTS = null;

  public static Symbol SYM_LOGIC_NN_HIDDEN = null;

  public static Symbol SYM_LOGIC_OUTPUT = null;

  public static Symbol SYM_LOGIC_TEMP = null;

  public static Symbol SYM_LOGIC_CACHED_SOLUTION = null;

  public static List $TRAINING_EXAMPLES$ = null;

  public static List $TESTING_EXAMPLES$ = null;

  public static boolean $CLOSED_WORLD_TRAINING_EXAMPLES$ = true;

  public static Symbol SYM_LOGIC_DEFRELATION = null;

  public static Symbol SYM_STELLA_THING = null;

  public static Symbol SYM_LOGIC_DEFRULE = null;

  public static Symbol SYM_LOGIC_pY = null;

  public static int $MAX_STRUCTURE_DEPTH$ = 3;

  public static boolean $DROP_FUNCTION_VALUESp$ = true;

  public static List $TABOO_OPERATORS$ = null;

  public static Symbol SYM_STELLA_ge = null;

  public static Symbol SYM_STELLA_el = null;

  public static Keyword KWD_IN = null;

  public static Symbol SYM_LOGIC_STARTUP_MACHINE_LEARNING = null;

  public static Keyword $RULE_INDUCTION_STRATEGY$ = null;

  public static Keyword KWD_TOP_DOWN = null;

  public static Keyword $SIGNATURE_STRATEGY$ = null;

  public static boolean $ENABLE_USER_THING$ = true;

  public static boolean $OPTIMIZE_INDUCED_QUERIES$ = true;

  /** Flag to control whether we try to simplify the rule antecedent.
   * This should be set to FALSE if we expect the user to edit the rule and
   * TRUE if we want to have final rules as general as possible.
   */
  public static boolean $SIMPLIFY_RULE_ANTECEDENTp$ = false;

  public static boolean $TRACE_ID3$ = false;

  public static boolean $TRACE_FOIL$ = false;

  public static boolean $INDUCE_RULES_FROM_SIGNATURES$ = true;

  public static int $NUM_LGGS$ = 2000;

  public static boolean $ENFORCE_LINKED_VARIABLES$ = false;

  public static boolean $LOG_INDUCED_RULES$ = false;

  public static boolean $ALLOW_RECURSIVE_DECISION_NODES$ = true;

  public static boolean $LOG_DECISION_RULE_CONSTRUCTION$ = false;

  public static double LOG_2 = 0.6931472;

  public static Surrogate SGT_LOGIC_DECISION_TREE = null;

  public static Symbol SYM_LOGIC_FEATURE = null;

  public static Symbol SYM_LOGIC_FEATURE_INDEX = null;

  public static Symbol SYM_LOGIC_TRUE_BRANCH = null;

  public static Symbol SYM_LOGIC_FALSE_BRANCH = null;

  public static List $INDUCED_DECISION_RULES$ = null;

  public static int $INDUCED_RULE_COUNTER$ = 0;

  public static Vector $CANDIDATE_CLAUSES$ = null;

  public static Keyword KWD_BOTTOM_UP = null;

  public final static StellaSpecialVariable $BOTTOM_UP_VARIABLE_COUNTER$ = new StellaSpecialVariable();

  public static Symbol SYM_STELLA_l = null;

  public static Keyword KWD_DECISION_TREE = null;

  public static Symbol SYM_LOGIC_USER_THING = null;

  public static Symbol SYM_LOGIC_STARTUP_RULE_INDUCTION = null;

  public static Keyword $NEURAL_NETWORK_TRAINING_METHOD$ = null;

  public static Keyword KWD_BACKPROP = null;

  public static double $LEARNING_RATE$ = 0.1;

  public static double $MOMENTUM_TERM$ = 0.9;

  public static double $WEIGHT_RANGE$ = 0.05;

  public static double $ERROR_CUTOFF$ = 0.0;

  public static int $ERROR_PRINT_CYCLE$ = 25;

  public static int $SAVE_NETWORK_CYCLE$ = 10000;

  public static String $SAVE_NETWORK_FILE$ = null;

  public static boolean $TRACE_NEURAL_NETWORK_TRAINING$ = false;

  public static boolean $TRAIN_CACHED_NETWORKSp$ = true;

  public static double $MAX_MOVEMENT$ = 1.75;

  public static double $MODE_SWITCH$ = 0.0;

  public static double $SHRINK_FACTOR$ = Stella.NULL_FLOAT;

  public static double $WEIGHT_DECAY$ = -1.0e-4;

  public static double $SIGMOID_PRIME_OFFSET$ = 0.1;

  public static Symbol SYM_LOGIC_WEIGHT_VECTOR = null;

  public static Symbol SYM_LOGIC_2_D_WEIGHT_ARRAY = null;

  public static Surrogate SGT_LOGIC_PROPOSITION_NEURAL_NETWORK = null;

  public static Symbol SYM_LOGIC_HIDDEN = null;

  public static Symbol SYM_LOGIC_INPUT_ERROR = null;

  public static Symbol SYM_LOGIC_HIDDEN_ERROR = null;

  public static Symbol SYM_LOGIC_IH = null;

  public static Symbol SYM_LOGIC_IH_DELTA = null;

  public static Symbol SYM_LOGIC_HO = null;

  public static Symbol SYM_LOGIC_HO_DELTA = null;

  public static Symbol SYM_LOGIC_IH_SLOPE = null;

  public static Symbol SYM_LOGIC_IH_PREV_SLOPE = null;

  public static Symbol SYM_LOGIC_HO_SLOPE = null;

  public static Symbol SYM_LOGIC_HO_PREV_SLOPE = null;

  public static List $MASTER_NEURAL_NETWORK_LIST$ = null;

  public static List $ACTIVATED_NETWORKS$ = null;

  public static PropositionNeuralNetwork $SAVED_NET$ = null;

  public static Keyword KWD_QUICKPROP = null;

  public static Keyword KWD_BACKPROPAGATION = null;

  public static List $PARTIAL_SUPPORT_CACHE$ = null;

  public static Vector $LEARNING_CURVE$ = null;

  public static Symbol SYM_LOGIC_DEFNETWORK = null;

  public static Surrogate SGT_LOGIC_MULTI_DIMENSIONAL_ARRAY = null;

  public static Surrogate SGT_LOGIC_2_D_ARRAY = null;

  public static Symbol SYM_LOGIC_NOF_ROWS = null;

  public static Symbol SYM_LOGIC_NOF_COLUMNS = null;

  public static Surrogate SGT_LOGIC_FLOAT_VECTOR = null;

  public static Symbol SYM_STELLA_ARRAY_SIZE = null;

  public static Surrogate SGT_LOGIC_2_D_FLOAT_ARRAY = null;

  public static Symbol SYM_LOGIC_STARTUP_NEURAL_NETWORK = null;

  public static boolean $LOG_MATCH_RULES$ = false;

  public static boolean $LOG_ANTECEDENT_CONSTRUCTION$ = false;

  public static int $NUM_NEIGHBORS$ = 3;

  public static Keyword $CASE_SOLUTION_COMBINATION$ = null;

  public static Keyword KWD_WEIGHTED_VOTE = null;

  public static List $CASE_RULE_NAMES$ = null;

  public static int $NUM_CASES$ = 0;

  public static int $NUM_TRAINING_PER_CASE$ = 12;

  public static int $CASE_VARIABLE_COUNTER$ = 0;

  public static int $BASE_COUNTER$ = 0;

  public static List $VISITED_INSTANCES$ = null;

  public static boolean $ONLY_VARIABLIZE_VISITED_INSTANCES$ = false;

  public static List $VISITED_PROPOSITIONS$ = null;

  public static List $SEEN_INSTANCES$ = null;

  public static List $DELETED_CASE_VARIABLES$ = null;

  public static HashTable $SYMBOL_VARIABLE_HASH_TABLE$ = null;

  public static StringHashTable $CASE_ANTECEDENT_TABLE$ = null;

  public static StringHashTable $CASE_TYPES_TABLE$ = null;

  public static HashTable $CASE_NAME_TABLE$ = null;

  public static Symbol SYM_LOGIC_CASE_MATCH = null;

  public static Symbol SYM_PL_KERNEL_KB_CASE_MATCH = null;

  public static Keyword KWD_WEIGHTED_AVERAGE = null;

  public static Surrogate SGT_STELLA_FLOAT_WRAPPER = null;

  public static Surrogate SGT_STELLA_INTEGER_WRAPPER = null;

  public static Keyword KWD_AVERAGE = null;

  public static Symbol SYM_LOGIC_OBJECT_NAME = null;

  public static Symbol SYM_STELLA_SECOND = null;

  public static Symbol SYM_LOGIC_CASES = null;

  public static Symbol SYM_LOGIC_SOFT_EQ = null;

  public static boolean $PRINT_CASE_DISTANCES$ = false;

  public static Symbol SYM_LOGIC_STARTUP_CASE_BASED = null;

  public static Surrogate SGT_LOGIC_GOAL_CACHE = null;

  public static Symbol SYM_LOGIC_CACHED_BINDINGS = null;

  public static Symbol SYM_LOGIC_CACHE_CONTEXT = null;

  public static Symbol SYM_LOGIC_GOAL_CACHE_TABLE = null;

  public static Symbol SYM_LOGIC_NEGATED_GOAL_CACHE_TABLE = null;

  public static boolean $CACHE_SUCCEEDED_GOALSp$ = true;

  public static boolean $CACHE_FAILED_GOALSp$ = true;

  /** Only goals whose success or failure took at least this
   * number of query clock ticks will be cached.
   */
  public static int $CACHE_GOAL_QUANTUM$ = 5;

  public static Surrogate SGT_LOGIC_ATOMIC_GOAL_CACHE = null;

  public static Symbol SYM_LOGIC_GOAL_CONTEXT = null;

  public static Symbol SYM_LOGIC_PREVIOUS = null;

  public static Vector $SUCCEEDED_GOALS_CACHE$ = null;

  public static Vector $FAILED_GOALS_CACHE$ = null;

  public static Symbol SYM_LOGIC_GOAL_CACHE_LIST = null;

  public final static StellaSpecialVariable $UNIFICATION_VECTOR_1$ = new StellaSpecialVariable();

  public final static StellaSpecialVariable $UNIFICATION_VECTOR_2$ = new StellaSpecialVariable();

  public static Keyword KWD_GOAL_INSTANTIATES_CACHE = null;

  public static Keyword KWD_CACHE_INSTANTIATES_GOAL = null;

  public static Surrogate SGT_PL_KERNEL_KB_FRAME_PREDICATE = null;

  public static Symbol SYM_LOGIC_CHECK_FOR_CACHED_GOALSp = null;

  public static Keyword KWD_SUCCESS = null;

  public static Surrogate SGT_LOGIC_ATOMIC_GOAL_CACHE_ITERATOR = null;

  public static Symbol SYM_LOGIC_GOAL = null;

  public static Symbol SYM_LOGIC_CACHE_LIST = null;

  public static Symbol SYM_LOGIC_STARTUP_GOAL_CACHES = null;

  public static Keyword KWD_TERMINAL_FAILURE = null;

  public static Symbol SYM_LOGIC_PROOF_ADJUNCT = null;

  public static Keyword KWD_SELECT_PARALLEL_THREAD = null;

  public static Keyword KWD_TIME_OUT = null;

  public static Keyword KWD_CONDITIONAL_ANTECEDENT = null;

  public static Keyword KWD_DUMMY_JUSTIFICATION = null;

  public static Keyword KWD_LOOKUP_GOAL_CACHES = null;

  public static Keyword KWD_SCAN_PROPOSITIONS = null;

  public static Keyword KWD_SCAN_PARTIAL_PROPOSITIONS = null;

  public static Keyword KWD_SCAN_COLLECTION = null;

  public static Keyword KWD_SHALLOW_DISPROOF = null;

  public static Keyword KWD_SCAN_FOR_VALUE_CLASH = null;

  public static Keyword KWD_ALL_SUBGOAL_STRATEGIES = null;

  public static Keyword KWD_GOAL_COMPLEMENT = null;

  public static Keyword KWD_FORWARD_GOALS = null;

  public static Keyword KWD_EQUIVALENCE = null;

  public static Keyword KWD_UNIVERSAL_INTRODUCTION = null;

  public static Keyword KWD_SUBSUMPTION_TEST = null;

  /** List of strategies (keywords) that fork a parallel
   * control stack before executing.
   */
  public static List $PARALLEL_STRATEGIES$ = null;

  public static Keyword KWD_DEBUG = null;

  public static int $FAILED_GOAL_CUTOFFS$ = 0;

  public static int $SUCCEEDED_GOAL_CUTOFFS$ = 0;

  public static Surrogate SGT_LOGIC_WHYNOT_PARTIAL_MATCH = null;

  public static Keyword KWD_DUPLICATE_ = null;

  public static Keyword KWD_FORWARD_RULE = null;

  public static Surrogate SGT_LOGIC_CONDITIONAL_ANTECEDENT_PROOF_ADJUNCT = null;

  public static Symbol SYM_LOGIC_PROVABLE_RULE = null;

  public static Symbol SYM_STELLA_PHASE = null;

  public static Keyword KWD_ORIGINAL_GOAL = null;

  public static Symbol SYM_LOGIC_CONTAINED_BY = null;

  public static Surrogate SGT_LOGIC_CLUSTERED_CONJUNCTION_PROOF_ADJUNCT = null;

  public static Symbol SYM_LOGIC_CLUSTER_FRAMES = null;

  public static Module $PL_ANONYMOUS_MODULE$ = null;

  public static Keyword KWD_CONSTANT_PROPOSITION = null;

  public static Symbol SYM_LOGIC_STARTUP_STRATEGIES = null;

  public static Surrogate SGT_LOGIC_JUSTIFICATION = null;

  public static Symbol SYM_LOGIC_INFERENCE_RULE = null;

  public static Symbol SYM_LOGIC_ANTECEDENTS = null;

  public static Symbol SYM_LOGIC_SUBSTITUTION = null;

  public static Keyword KWD_PRIMITIVE_STRATEGY = null;

  public static Surrogate SGT_LOGIC_PRIMITIVE_STRATEGY = null;

  public static Symbol SYM_LOGIC_STRATEGY = null;

  /** If TRUE every query records justifications to enable
   * the explanation of concluded results.
   */
  public final static StellaSpecialVariable $RECORD_JUSTIFICATIONSp$ = new StellaSpecialVariable();

  public static Keyword KWD_COMPUTED_PREDICATE = null;

  public static Keyword KWD_SUBSUMPTION_REASONING = null;

  public static Keyword KWD_AND_INTRODUCTION = null;

  public static Keyword KWD_MODUS_TOLLENS = null;

  public static Keyword KWD_MODUS_PONENS = null;

  public static Keyword KWD_AMPLIFICATION = null;

  public static Keyword KWD_PARTIAL = null;

  public static Keyword KWD_REVERSE = null;

  public static Keyword KWD_OR_INTRODUCTION = null;

  public static Keyword KWD_DISPROOF = null;

  public static Keyword KWD_FAIL_INTRODUCTION = null;

  public static Keyword KWD_NEGATED_FAIL = null;

  public static Keyword KWD_CLOSED_NOT_INTRODUCTION = null;

  public static Keyword KWD_EXISTENTIAL_INTRODUCTION = null;

  public static Keyword KWD_RAW = null;

  public static Keyword KWD_INFERENCE_RULE = null;

  public static Keyword KWD_TRUTH_VALUE = null;

  public static Keyword KWD_POSITIVE_SCORE = null;

  public static Keyword KWD_SUBSTITUTION = null;

  public static Surrogate SGT_LOGIC_FORWARD_GOAL_RECORD = null;

  public static Symbol SYM_LOGIC_FORWARD_RULE = null;

  public static Symbol SYM_LOGIC_FORWARD_CHAINING_GOALS = null;

  public static Surrogate SGT_LOGIC_FORWARD_JUSTIFICATION = null;

  public static Symbol SYM_LOGIC_FORWARD_JUSTIFICATIONS = null;

  public static Keyword KWD_FORWARD_INFERENCE = null;

  public static Surrogate SGT_LOGIC_CLASH_JUSTIFICATION = null;

  public static Symbol SYM_LOGIC_DIRECTION = null;

  public static Keyword KWD_CLASH = null;

  public static Symbol SYM_LOGIC_STARTUP_JUSTIFICATIONS = null;

  /** Keyword to control the explanation format.
   * Valid values are :ASCII, :HTML and :XML
   */
  public final static StellaSpecialVariable $EXPLANATION_FORMAT$ = new StellaSpecialVariable();

  public static Keyword KWD_ASCII = null;

  /** Keywords that controls how detailed explanations will be.
   * Valid values are :VERBOSE and :BRIEF.
   */
  public final static StellaSpecialVariable $EXPLANATION_STYLE$ = new StellaSpecialVariable();

  public static Keyword KWD_BRIEF = null;

  /** Keywords that controls the language for justifications.
   * Valid values are :TECHNICAL and :LAY
   */
  public final static StellaSpecialVariable $EXPLANATION_AUDIENCE$ = new StellaSpecialVariable();

  /** Maximal explanation depth used if not otherwise specified.
   */
  public static int $DEFAULT_EXPLANATION_DEPTH$ = 3;

  public static String $EXPLANATION_TAB_STRING$ = "    ";

  /** Maximum length of a label string for which the following
   * proposition will be printed on the same line.
   */
  public static int $MAX_INLINE_LABEL_LENGTH$ = 10;

  public static String $EXPLANATION_ASSERTION_MARKER$ = "!";

  public static String $EXPLANATION_FAILURE_MARKER$ = "?";

  public static String $EXPLANATION_CUTOFF_MARKER$ = "x";

  public static String $EXPLANATION_INFERENCE_MARKER$ = " ";

  public static Keyword KWD_CUTOFF = null;

  public static Keyword KWD_INFERENCE = null;

  public static Keyword KWD_HTML = null;

  public static Symbol SYM_LOGIC_EXPLANATION_VOCABULARY = null;

  /** The currently active vocabulary lookup table
   */
  public final static StellaSpecialVariable $EXPLANATION_VOCABULARY$ = new StellaSpecialVariable();

  /** List of vocabularies with keyword keys
   */
  public static KeyValueList $EXPLANATION_VOCABULARIES$ = null;

  public static Keyword KWD_UNKNOWN_RULE = null;

  public static Keyword KWD_FOLLOWS = null;

  public static Keyword KWD_HOLDS = null;

  public static Keyword KWD_DEFINITION = null;

  public static Keyword KWD_FAILED = null;

  public static Keyword KWD_NOT_ASSERTED = null;

  public static Keyword KWD_NO_RULES = null;

  public static Surrogate SGT_LOGIC_EXPLANATION_INFO = null;

  public static Symbol SYM_STELLA_LABEL = null;

  public static Symbol SYM_LOGIC_EXPLAINEDp = null;

  public static Symbol SYM_LOGIC_EXPLANATION_MAPPING = null;

  public static Keyword KWD_XML = null;

  public final static StellaSpecialVariable $CURRENTJUSTIFICATION$ = new StellaSpecialVariable();

  public static Keyword KWD_CYC_NL = null;

  public static Keyword KWD_KIF_ONTOSAURUS = null;

  public static Keyword KWD_JAVA_GUI_HTML = null;

  public static Surrogate SGT_LOGIC_ALTERNATIVE_BINDINGS_SET = null;

  public final static StellaSpecialVariable $MOST_RECENT_EXPLANATION_MAPPING$ = new StellaSpecialVariable();

  public static Keyword KWD_DIGIT = null;

  public static Keyword KWD_VERBOSE = null;

  public static Keyword KWD_DEPTH = null;

  public static Symbol SYM_LOGIC_STARTUP_EXPLANATIONS = null;

  public static Symbol SYM_LOGIC_UNKNOWN_GOAL_CUTOFF = null;

  public static Surrogate SGT_LOGIC_WHYNOT_DEEP_PARTIAL_MATCH = null;

  public static Surrogate SGT_LOGIC_M_WHYNOT_PARTIAL_MATCHdNUMBER_OF_FAILED_SUBGOALS_MEMO_TABLE_000 = null;

  public static int $MIN_CLOCK_TICKS_PER_WHYNOT_ANTECEDENT$ = 5;

  public static Symbol SYM_LOGIC_REAL_ALLOTTED_CLOCK_TICKS = null;

  public static Surrogate SGT_STELLA_CONS_ITERATOR = null;

  public static Surrogate SGT_LOGIC_WHYNOT_PROOF_CLASS = null;

  public static Symbol SYM_LOGIC_REPRESENTATIVE = null;

  public static Symbol SYM_LOGIC_DEVIATING_PATTERN = null;

  public static Symbol SYM_LOGIC_DEVIATING_VARIABLE = null;

  public static Symbol SYM_LOGIC_DEVIATING_INSTANCES = null;

  public final static StellaSpecialVariable $MAX_WHYNOT_PROOF_CLASS_DEVIATIONS$ = new StellaSpecialVariable();

  public static Symbol SYM_LOGIC_THE_VARIABLE = null;

  public static int $SIMILAR_WHYNOT_PROOF_CUTOFF$ = 3;

  public static Keyword KWD_WHYNOT = null;

  public static Keyword KWD_JUSTIFICATIONS = null;

  public static Symbol SYM_LOGIC_STARTUP_WHYNOT = null;

  /** Controls whether logical forms print on single lines
   * (unformatted) or multi-line indented.
   */
  public final static StellaSpecialVariable $PRETTYPRINTLOGICALFORMSp$ = new StellaSpecialVariable();

  /** Controls whether KIF expressions print on single lines
   * (unformatted) or multi-line indented.
   */
  public final static StellaSpecialVariable $PRETTYPRINTKIFp$ = new StellaSpecialVariable();

  /** Eliminates necessity of passing stream argument
   * throughout 'print-logical-form' functions.
   */
  public final static StellaSpecialVariable $PRINTLOGICALFORMSTREAM$ = new StellaSpecialVariable();

  /** Controls whether down-casing happens during logical
   * form printing (leading to lots more string garbage).
   */
  public final static StellaSpecialVariable $DOWNCASEOPERATORSp$ = new StellaSpecialVariable();

  /** Table to allow extension of the logical form printing code
   * by associating keywords with print functions.  Should have values added only
   * via the associated function REGISTER-LOGIC-DIALECT-PRINT-FUNCTION.
   */
  public static KeyValueList $LOGIC_DIALECT_PRINT_FUNCTIONS$ = null;

  /** Used to register objects that quantify variables, so we
   * can decide in certain contexts whether to print a variable or its value.
   */
  public final static StellaSpecialVariable $PRINTQUANTIFIEDOBJECTSSTACK$ = new StellaSpecialVariable();

  /** The number of spaces prepended during printing a logical form.
   */
  public final static StellaSpecialVariable $INDENTCOUNTER$ = new StellaSpecialVariable();

  /** The number of spaces added by a call to 'increase-indent'.
   */
  public static int $INDENT_QUANTUM$ = 3;

  public static Keyword KWD_SQL = null;

  public static Keyword KWD_ORIGINAL = null;

  public static Keyword KWD_UNESCAPED = null;

  public static Keyword KWD_ESCAPED = null;

  public static Keyword KWD_COMPLEX_ESCAPED = null;

  public final static StellaSpecialVariable $TOPLEVELPRINTKIFPROPOSITIONp$ = new StellaSpecialVariable();

  public static Surrogate SGT_PL_KERNEL_KB_le = null;

  public static Surrogate SGT_PL_KERNEL_KB_KAPPA = null;

  public static Surrogate SGT_PL_KERNEL_KB_eg = null;

  public static Surrogate SGT_PL_KERNEL_KB_egg = null;

  public static Surrogate SGT_PL_KERNEL_KB_lle = null;

  public static Surrogate SGT_PL_KERNEL_KB_lt = null;

  public static Surrogate SGT_PL_KERNEL_KB_tg = null;

  public static Surrogate SGT_PL_KERNEL_KB_llt = null;

  public static Surrogate SGT_PL_KERNEL_KB_tgg = null;

  /** List of propositions that shouldn't be saved by <code>saveModule</code>.
   */
  public final static StellaSpecialVariable $EXCLUDEDPROPOSITIONS$ = new StellaSpecialVariable();

  public static Keyword KWD_TERSE = null;

  public static Keyword KWD_SOURCE = null;

  public static Keyword KWD_SLOTS = null;

  public static Keyword KWD_PUBLIC_SLOTS = null;

  public static Keyword KWD_METHODS = null;

  public static Keyword KWD_PUBLIC_METHODS = null;

  public static Symbol SYM_LOGIC_PRESUME = null;

  public static Symbol SYM_STELLA_RETRACT = null;

  public static Cons $BUILT_IN_MODULE_NAMES$ = null;

  public static Symbol SYM_LOGIC_IN_DIALECT = null;

  public static Surrogate SGT_STELLA_OUTPUT_STREAM = null;

  public static Keyword KWD_FILE = null;

  public static Symbol SYM_LOGIC_STARTUP_KIF_OUT = null;

  /** If set to TRUE, modify printing so that it
   * doesn't break and is more informative during a debugging session.
   */
  public static boolean $DEBUG_PRINT_MODEp$ = false;

  /** Controls the kind of detail that gets printed about
   * individual objects.  Values are :ORIGINAL, :REALISTIC, :FLAT, :DEBUG-LOW, and
   *  :DEBUG-HIGH.
   */
  public final static StellaSpecialVariable $PRINTMODE$ = new StellaSpecialVariable();

  /** Controls whether functions are printed as relations (F i v) or
   * as functions (= (F i) v).
   */
  public final static StellaSpecialVariable $PRINTFUNCTIONSASRELATIONSp$ = new StellaSpecialVariable();

  public final static String VARIABLE_BINDING_SEPARATOR = "/";

  public final static String VALUE_OF_SEPARATOR = "//";

  /** If set, maps some skolems to names other than
   * their own.
   */
  public final static StellaSpecialVariable $SKOLEMNAMEMAPPINGTABLE$ = new StellaSpecialVariable();

  public static Keyword KWD_DEBUG_LOW = null;

  public static Keyword KWD_DEBUG_HIGH = null;

  public static Symbol SYM_LOGIC_STARTUP_PRINT = null;

  /** Maps variables to symbols in SYSTEM-DEFINED-ARGUMENT-NAMES.
   */
  public final static StellaSpecialVariable $CANONICALVARIABLENAMEMAPPING$ = new StellaSpecialVariable();

  /** Number of the last canonically-mapped variable.
   */
  public final static StellaSpecialVariable $CANONICALVARIABLECOUNTER$ = new StellaSpecialVariable();

  public static Symbol SYM_LOGIC_UNIDENTIFIED_SKOLEM = null;

  public static Symbol SYM_LOGIC_UNNAMED_OBJECT = null;

  public static Symbol SYM_LOGIC_ILLEGAL_TERM = null;

  public static Symbol SYM_LOGIC_STARTUP_GENERATE = null;

  public static Symbol SYM_LOGIC_PROCEDURE_NAME = null;

  public static Symbol SYM_LOGIC_PROCEDURE_FUNCTION = null;

  public static Keyword KWD_RELEASE = null;

  public static Surrogate SGT_PL_KERNEL_KB_RELATION_SPECIALIST = null;

  public static Surrogate SGT_PL_KERNEL_KB_HANDLES_REVERSE_POLARITY = null;

  public static Surrogate SGT_PL_KERNEL_KB_RELATION_CONSTRAINT = null;

  public static Surrogate SGT_PL_KERNEL_KB_RELATION_EVALUATOR = null;

  public static Surrogate SGT_STELLA_FUNCTION_CODE_WRAPPER = null;

  public static Surrogate SGT_STELLA_METHOD_CODE_WRAPPER = null;

  public static Surrogate SGT_LOGIC_SUBSTRING_POSITION_ITERATOR = null;

  public static Symbol SYM_LOGIC_SUPER_STRING = null;

  public static Symbol SYM_LOGIC_SUB_STRING = null;

  public static Symbol SYM_STELLA_START = null;

  public static Symbol SYM_LOGIC_SUB_LENGTH = null;

  public static Surrogate SGT_STELLA_OBJECT = null;

  public static Symbol SYM_STELLA_DUMMY = null;

  public static Surrogate SGT_LOGIC_FORK_PROOF_ADJUNCT = null;

  public static Symbol SYM_LOGIC_CONDITION_JUSTIFICATION = null;

  public static Symbol SYM_LOGIC_DOWN_FRAME = null;

  public static Keyword KWD_FORK_ELSE = null;

  public static Keyword KWD_FORK_THEN = null;

  public static Keyword KWD_INHERIT = null;

  public static Keyword KWD_ALL = null;

  public static Keyword KWD_CURRENT = null;

  public static Symbol SYM_LOGIC_QUERY_SPECIALIST_IO_VARIABLES = null;

  public static Surrogate SGT_LOGIC_SAVED_INFERENCE_LEVEL_PROOF_ADJUNCT = null;

  public static Symbol SYM_LOGIC_SAVED_INFERENCE_LEVEL = null;

  public static Surrogate SGT_PL_KERNEL_KB_ASSERTION_QUERY = null;

  public static Surrogate SGT_PL_KERNEL_KB_SHALLOW_QUERY = null;

  public static Surrogate SGT_PL_KERNEL_KB_SUBSUMPTION_QUERY = null;

  public static Surrogate SGT_PL_KERNEL_KB_BACKTRACKING_QUERY = null;

  public static Surrogate SGT_PL_KERNEL_KB_NORMAL_QUERY = null;

  public static Surrogate SGT_PL_KERNEL_KB_REFUTATION_QUERY = null;

  public static Keyword KWD_LEVELED_QUERY = null;

  public static int $PROTOTYPE_ID_COUNTER$ = 0;

  public static Surrogate SGT_PL_KERNEL_KB_CLOSED = null;

  public static Surrogate SGT_LOGIC_F_CLOSED_TERMp_MEMO_TABLE_000 = null;

  public static Surrogate SGT_LOGIC_F_CLOSED_PROPOSITIONp_MEMO_TABLE_000 = null;

  public static Surrogate SGT_PL_KERNEL_KB_SINGLE_VALUED = null;

  public static Surrogate SGT_LOGIC_F_SINGLE_VALUED_TERMp_MEMO_TABLE_000 = null;

  public static Surrogate SGT_PL_KERNEL_KB_COLLECT_INTO_LIST = null;

  public static Surrogate SGT_PL_KERNEL_KB_COLLECT_INTO_ORDERED_SET = null;

  public static Keyword KWD_COLLECT_MEMBERS = null;

  public static Symbol SYM_LOGIC_pSUPER = null;

  public static Symbol SYM_LOGIC_pMDC = null;

  public static Symbol SYM_LOGIC_MEMBER_OF = null;

  public static Symbol SYM_LOGIC_MUTUALLY_DISJOINT_COLLECTION = null;

  public static Symbol SYM_LOGIC_F_HELP_DERIVE_PARTITION_MEMBERSHIPS_QUERY_000 = null;

  public static Surrogate SGT_PL_KERNEL_KB_MUTUALLY_DISJOINT_COLLECTION = null;

  public static Surrogate SGT_PL_KERNEL_KB_HAS_PARTITION_MEMBERSHIP = null;

  public static Surrogate SGT_PL_KERNEL_KB_EMPTY = null;

  public static Surrogate SGT_LOGIC_SAVED_CONTEXT_PROOF_ADJUNCT = null;

  public static Symbol SYM_LOGIC_SAVED_CONTEXT = null;

  public static Keyword KWD_IST_INTRODUCTION = null;

  /** Used to test how big is the effect of the frame
   * specialists.
   */
  public static boolean $ACCELERATE_FRAME_COMPUTATIONSp$ = true;

  public static Surrogate SGT_PL_KERNEL_KB_THE_ROLESET = null;

  public static Surrogate SGT_PL_KERNEL_KB_CARDINALITY = null;

  public static Keyword KWD_LOWER = null;

  public static Keyword KWD_UPPER = null;

  public static Surrogate SGT_PL_KERNEL_KB_DIRECT_SUBRELATION = null;

  public static Surrogate SGT_PL_KERNEL_KB_DIRECT_SUPERRELATION = null;

  public static Surrogate SGT_PL_KERNEL_KB_SUBRELATION = null;

  public static Surrogate SGT_PL_KERNEL_KB_SUPERRELATION = null;

  public static Surrogate SGT_PL_KERNEL_KB_PROPER_SUBRELATION = null;

  public static Surrogate SGT_PL_KERNEL_KB_PROPER_SUPERRELATION = null;

  public static Surrogate SGT_PL_KERNEL_KB_EQUIVALENT_RELATION = null;

  public static Surrogate SGT_PL_KERNEL_KB_SYNONYM = null;

  public static Symbol SYM_LOGIC_STARTUP_SPECIALISTS = null;

  public static Surrogate SGT_LOGIC_ABSTRACT_PROPOSITIONS_ITERATOR = null;

  public static Symbol SYM_LOGIC_PROPOSITION_CURSOR = null;

  public static Symbol SYM_LOGIC_EQUIVALENTS_STACK = null;

  public static Surrogate SGT_LOGIC_TRUE_PROPOSITIONS_ITERATOR = null;

  public static Surrogate SGT_LOGIC_SPECIALIZING_PROPOSITIONS_ITERATOR = null;

  public static Symbol SYM_LOGIC_SPECIALIZING_RELATIONS = null;

  /** This iterator returns no values whenever its called.
   */
  public static Iterator EMPTY_PROPOSITIONS_ITERATOR = null;

  public static Surrogate SGT_LOGIC_F_TEST_PROPERTYp_MEMO_TABLE_000 = null;

  public static Surrogate SGT_PL_KERNEL_KB_COLLECTION = null;

  public static Surrogate SGT_LOGIC_F_TEST_ISAp_MEMO_TABLE_000 = null;

  public static Surrogate SGT_LOGIC_F_TEST_ISAp_MEMO_TABLE_001 = null;

  public static Surrogate SGT_LOGIC_F_ACCESS_BINARY_VALUE_MEMO_TABLE_000 = null;

  public static Surrogate SGT_LOGIC_TRANSITIVE_CLOSURE_ITERATOR = null;

  public static Symbol SYM_LOGIC_ALLOCATE_ADJACENCY_ITERATOR_FUNCTION = null;

  public static Symbol SYM_LOGIC_FILTERp = null;

  public static Symbol SYM_LOGIC_ADJACENCY_ITERATOR_STACK = null;

  public static Symbol SYM_LOGIC_BEEN_THERE_LIST = null;

  public static Surrogate SGT_LOGIC_SUPPORTED_CLOSURE_ITERATOR = null;

  public static Surrogate SGT_LOGIC_DIRECTLY_LINKED_OBJECTS_ITERATOR = null;

  public static Symbol SYM_LOGIC_INVERSEp = null;

  public static Symbol SYM_LOGIC_ROOT_TRUTH_VALUE = null;

  public static Surrogate SGT_LOGIC_F_ALL_SUPERCOLLECTIONS_MEMO_TABLE_000 = null;

  public static Surrogate SGT_LOGIC_F_ALL_SUPPORTED_NAMED_SUBCOLLECTIONS_MEMO_TABLE_000 = null;

  public static Surrogate SGT_STELLA_NUMBER = null;

  public static Surrogate SGT_LOGIC_CLASHING_PROPOSITIONS_ITERATOR = null;

  public static TaxonomyGraph $IMPLICATION_SUBSUMPTION_GRAPH$ = null;

  public static Symbol SYM_STELLA_TAXONOMY_NODE = null;

  public static Symbol SYM_LOGIC_STARTUP_SPECIALIZE = null;

  public static Surrogate SGT_LOGIC_GOAL_RECORD = null;

  public static Symbol SYM_LOGIC_GENERATOR_GOALS = null;

  public static Symbol SYM_LOGIC_OTHER_GOALS = null;

  public static Symbol SYM_LOGIC_PERMUTATION_TABLE = null;

  public static Surrogate SGT_PL_KERNEL_KB_COMPUTED = null;

  public static Surrogate SGT_PL_KERNEL_KB_ABSTRACT = null;

  public static Symbol SYM_LOGIC_OPTIMIZER_GOAL_RECORDS = null;

  /** Used by 'distribute-open-goal' to signal that
   * a goal was distributed by 'help-distribute-goal'.
   */
  public final static StellaSpecialVariable $DISTRIBUTEDOPENGOALp$ = new StellaSpecialVariable();

  public static Symbol SYM_LOGIC_UNIQUENESSVECTORS = null;

  public static BooleanVector V_0_0 = null;

  public static BooleanVector V_1_0 = null;

  public static BooleanVector V_0_1 = null;

  public static BooleanVector V_1_1 = null;

  public static List V_1_0_AND_V_0_1 = null;

  public static List V_1_0_SINGLETON = null;

  public static List V_0_1_SINGLETON = null;

  public static Symbol SYM_LOGIC_INVERSE_DESCRIPTION = null;

  public static Symbol SYM_LOGIC_INDEXING_VECTOR = null;

  /** Estimate of the average size of a collection
   * representing the fillers of a slot.
   */
  public final static double ESTIMATED_SLOT_VALUE_COLLECTION_SIZE = 4.0;

  /** Very crude estimate of the number of stored propositions
   * that will match a predicate at least one of whose arguments are bound.
   * Chosen to be larger than ESTIMATED-SLOT-VALUE-COLLECTION-SIZE.
   */
  public final static double ESTIMATED_NUMBER_OF_PREDICATE_BINDINGS = 6.0;

  /** Must be greater than ESTIMATED-NUMBER-OF-PREDICATE-BINDINGS
   * to force the optimizer to prefer predicates containing at least
   * one bound variable.  Also greater than ESTIMATED-SIZE-OF-PREDICATE-EXTENSION,
   * for no particularly valid reason.
   */
  public final static double ESTIMATED_SIZE_OF_CLASS_EXTENSION = 11.0;

  /** Indefensible estimate of the number instances
   * generable by an arbitrary unnamed description.
   */
  public final static double ESTIMATED_CARDINALITY_OF_DESCRIPTION = 20.0;

  /** Even more indefensible estimate of the number instances
   * generable by a 'member-of' predicate.  CAUTION: Must be set
   * less than 'ESTIMATED-CARDINALITY-OF-SUBSET-OF'.
   */
  public final static double ESTIMATED_CARDINALITY_OF_MEMBER_OF = 30.0;

  /** Egregiously indefensible estimate of the number instances
   * generable by a 'subset-of' predicate.  Set high because 'subset-of'
   * can't generate all defined supersets or subsets, causing potential
   * incompleteness.
   */
  public final static double ESTIMATED_CARDINALITY_OF_SUBSET_OF = 40.0;

  public static Surrogate SGT_PL_KERNEL_KB_OBSERVED_CARDINALITY_OF = null;

  /** Amount of penalty for using inferable relations as goals.
   */
  public final static double INFERABLE_PENALTY_COST = 7.0;

  /** Amount of penalty for using 'subset-of' as a goal.
   */
  public final static double SUBSET_OF_PENALTY_COST = 20.0;

  public static Keyword KWD_OPTIMIZER = null;

  public final static StellaSpecialVariable $OPTIMALGOALORDERINGRECURSIONS$ = new StellaSpecialVariable();

  public static int $OPTIMAL_GOAL_ORDERING_CUTOFF$ = 100;

  public static Symbol SYM_LOGIC_BEST_COST = null;

  public static Keyword KWD_STATIC_WITH_CLUSTERING = null;

  public static Keyword KWD_BOUND = null;

  /** Keeps track of last control frame allocated by
   * the query optimizer.  Used by recursive invocations of the optimizer.
   */
  public final static StellaSpecialVariable $QUERYOPTIMIZERCONTROLFRAME$ = new StellaSpecialVariable();

  /** Enables 'select-optimal-query-pattern' to tell
   * 'copy-variables-vector' that it should initialize the 'bound-to-offset'
   * slot of each variable in the copy operation.
   */
  public final static StellaSpecialVariable $BOUNDTOOFFSETCOUNTER$ = new StellaSpecialVariable();

  /** Keyword indicating what clause reordering strategy should
   * be used for conjunctive queries.  Legal values are :STATIC which performs
   * optimization once for each conjunctive pattern by simulating a query,
   * :STATIC-WITH-CLUSTERING which additionally tries to cluster conjunction into
   * independent clusters, :DYNAMIC which performs simple greedy optimization
   * dynamically during a query, :DYNAMIC-WITH-CLUSTERING which also looks
   * for clusters (not yet implemented), and :NONE to indicate no optimization
   * should be performed.
   */
  public static Keyword $QUERY_OPTIMIZATION_STRATEGY$ = null;

  public static Surrogate SGT_LOGIC_F_DYNAMICALLY_ESTIMATE_INFERENCE_COST_MEMO_TABLE_000 = null;

  public static Surrogate SGT_PL_KERNEL_KB_INSTANCE_OF = null;

  /** Used by 'simplify-description' to permit application
   * of order-dependent optimizations.
   */
  public final static StellaSpecialVariable $POSTOPTIMIZATIONp$ = new StellaSpecialVariable();

  public static Keyword KWD_CREATED_SKOLEMS = null;

  public static Surrogate SGT_LOGIC_F_FILTER_IMPLIED_SKOLEM_PROPOSITIONS_MEMO_TABLE_000 = null;

  public static Symbol SYM_LOGIC_STRUCTURAL_FUNCTION_EVALUATION_ORDER = null;

  public static Symbol SYM_LOGIC_STARTUP_OPTIMIZE = null;

  public static Keyword KWD_IMPLIES_PROPOSITION_UPDATE = null;

  public static Surrogate SGT_LOGIC_F_INFERABLE_WITH_CYCLE_CHECKp_MEMO_TABLE_000 = null;

  public static Surrogate SGT_LOGIC_MARKER_TABLE = null;

  public static Symbol SYM_LOGIC_TEST_TABLE = null;

  public static Symbol SYM_LOGIC_RECALL_TABLE = null;

  public static Symbol SYM_LOGIC_SUPPORTS_RECALLp = null;

  /** Special variable that points to the marker table 
   * referenced by the function 'test-special-marker-table?'.
   */
  public final static StellaSpecialVariable $SPECIALMARKERTABLE$ = new StellaSpecialVariable();

  public static Keyword KWD_CLASSIFIER_INFERENCES = null;

  /** Points to a possibly unnamed description being
   * temporarily classified.
   */
  public final static StellaSpecialVariable $FINDSUPERSANDSUBSDESCRIPTION$ = new StellaSpecialVariable();

  public static Surrogate SGT_LOGIC_CLASSIFICATION_CACHE = null;

  public static Symbol SYM_LOGIC_INFERABLE_DIRECT_SUBDESCRIPTIONS = null;

  public static Symbol SYM_LOGIC_CACHE_UPCLASSIFICATION_TIMESTAMP = null;

  public static Symbol SYM_LOGIC_CACHE_DOWNCLASSIFICATION_TIMESTAMP = null;

  public static Symbol SYM_LOGIC_INTRODUCTION_TIMESTAMP = null;

  public static Surrogate SGT_LOGIC_CLASSIFICATION_SESSION = null;

  public static Symbol SYM_LOGIC_CLASSIFICATION_CACHE_TABLE = null;

  public static Symbol SYM_LOGIC_CLASSIFICATION_TIMECLOCK = null;

  public static Symbol SYM_LOGIC_INTRODUCTION_TIMESTAMP_STACK = null;

  public static Symbol SYM_LOGIC_EVERYTHING_CLASSIFIEDp = null;

  public static Symbol SYM_LOGIC_LAST_CACHE_TABLE_KEY = null;

  public static Symbol SYM_LOGIC_LAST_CACHE_TABLE_VALUE = null;

  /** Points to state of on-going classification session.
   */
  public final static StellaSpecialVariable $CLASSIFICATIONSESSION$ = new StellaSpecialVariable();

  public static Keyword KWD_INSTANCE = null;

  public static Symbol SYM_LOGIC_CLASSIFICATION_SESSION = null;

  /** If TRUE, prevents caching of computations of
   * all inferable subcollections of a collection.
   */
  public static boolean $CACHE_INFERABLE_SUBCOLLECTIONSp$ = true;

  public static Keyword KWD_CLASSIFIER = null;

  public static Keyword KWD_CLASSIFIER_PROFILE = null;

  /** If true (the default) only consider those relations (or instances) for
   * classification that have at least one non-inferable parent (or type).  This
   * can greatly reduce the classification effort.  To find entities that were
   * left unclassified due to this optimization use <code>listUnclassifiedRelations</code>
   * or <code>listUnclassifiedInstances</code>.
   */
  public final static StellaSpecialVariable $CLASSIFY_FROM_NON_INFERABLE_PARENTS_ONLYp$ = new StellaSpecialVariable();

  public static Symbol SYM_LOGIC_STARTUP_CLASSIFY = null;

  /** List of PowerLoom environment features.
   */
  public static List $AVAILABLE_POWERLOOM_FEATURES$ = null;

  public static Keyword KWD_TRACE_CLASSIFIER = null;

  public static Keyword KWD_ITERATIVE_DEEPENING = null;

  public static Keyword KWD_JUST_IN_TIME_INFERENCE = null;

  public static Keyword KWD_EMIT_THINKING_DOTS = null;

  /** List of currently enabled PowerLoom environment features.
   */
  public static List $CURRENT_POWERLOOM_FEATURES$ = null;

  /** List of PowerLoom environment features enabled upon call to
   * 'reset-features'.
   */
  public static List $DEFAULT_POWERLOOM_FEATURES$ = null;

  public static Keyword KWD_CLOSED_WORLD = null;

  /** The prompt used by the PowerLoom listener.
   */
  public static String $LOGIC_PROMPT$ = "|= ";

  /** Flag to control whether the logic prompt shows the module name.
   */
  public final static StellaSpecialVariable $PROMPT_SHOW_MODULEp$ = new StellaSpecialVariable();

  public static String $LOGIC_COMMAND_RESULT_INDENT$ = "";

  /** If TRUE exiting from the logic-command loop (or PowerLoom
   * listener) will be protected by a confirmation dialog.  This is mainly useful
   * for C++ where exiting the listener will also exit the program.
   */
  public final static StellaSpecialVariable $CAREFUL_LOGIC_COMMAND_LOOP_EXIT$p = new StellaSpecialVariable();

  public static Keyword KWD_BYE = null;

  public static Keyword KWD_EXIT = null;

  public static Keyword KWD_HALT = null;

  public static Keyword KWD_QUIT = null;

  public static Keyword KWD_STOP = null;

  public static Keyword KWD_DEFINE = null;

  public static Symbol SYM_STELLA_DEFMODULE = null;

  public static Keyword KWD_FINALIZE = null;

  /** If the extension of a KB file is unspecified in a
   * <code>load</code> or <code>demo</code> command, try to find it with one of these extensions.
   */
  public static Cons $POWERLOOM_KB_FILE_EXTENSIONS$ = null;

  public static Keyword KWD_CHECK_DUPLICATESp = null;

  public static Symbol SYM_STELLA_CLEAR_MODULE = null;

  public static Symbol SYM_STELLA_DEFCLASS = null;

  public static Symbol SYM_STELLA_DEFSLOT = null;

  public static Symbol SYM_STELLA_DEFMETHOD = null;

  public static Symbol SYM_LOGIC_DEFCONCEPT = null;

  public static Symbol SYM_LOGIC_DEFFUNCTION = null;

  public static Symbol SYM_LOGIC_DEFOBJECT = null;

  public static Symbol SYM_LOGIC_DEFINSTANCE = null;

  public static Keyword KWD_LOW = null;

  public final static StellaSpecialVariable $DEMO_LEVEL$ = new StellaSpecialVariable();

  public static Keyword KWD_WHITE_SPACE = null;

  /** List of example demo files.
   * Each entry is a <code>_LfileGLdescriptionG_</code> pair.
   */
  public static Cons $DEMO_FILES$ = null;

  public static Keyword KWD_LEVEL = null;

  public static Keyword KWD_PORT = null;

  public static Keyword KWD_HOST = null;

  public static Keyword KWD_DEBUG_LEVEL = null;

  public static Symbol SYM_LOGIC_POWERLOOM_GUI_EXIT_HOOK = null;

  /** Points to the source of the relation being parsed.
   */
  public final static StellaSpecialVariable $TERMSOURCEBEINGPARSED$ = new StellaSpecialVariable();

  /** Pofints to a description or its parse tree which
   * is the input to the description being constructed.
   */
  public final static StellaSpecialVariable $DESCRIPTIONUNDERCONSTRUCTION$ = new StellaSpecialVariable();

  /** Points to the parse tree which is the input to the
   * proposition being constructed.
   */
  public final static StellaSpecialVariable $TERMUNDERCONSTRUCTION$ = new StellaSpecialVariable();

  /** Limit on how big an s-expression we will print within
   * an error message.
   */
  public static int $EXPRESSION_SIZE_CUTOFF$ = 300;

  public static Symbol SYM_LOGIC_MODULE_LOGIC_DIALECT = null;

  public static Keyword KWD_REDEFINITION = null;

  public static Keyword KWD_PROPER_DEFINITION = null;

  public static boolean $HANDLE_EXPLICITLY_QUALIFIED_LOGIC_OBJECTSp$ = true;

  public static Symbol SYM_LOGIC_OBJECT_AXIOMS = null;

  public static Symbol SYM_LOGIC_PROPOSITION_AXIOMS = null;

  public static Symbol SYM_STELLA_SLOT_OPTION_KEYWORD = null;

  /** List of objects whose definitions and/or associated
   * axioms and constraints are not yet processed.
   */
  public static List $UNFINALIZED_OBJECTS$ = null;

  public final static StellaSpecialVariable $FINALIZEOBJECTSIMMEDIATELYp$ = new StellaSpecialVariable();

  /** Used to prevent finalization from triggering in the
   * middle of 'delicate' computations.  Also used to prevent recursive
   * invocation of 'finalize-objects'.
   */
  public final static StellaSpecialVariable $INHIBITOBJECTFINALIZATIONp$ = new StellaSpecialVariable();

  public static Symbol SYM_PL_KERNEL_KB_NTH_DOMAIN = null;

  public static Symbol SYM_PL_KERNEL_KB_DOMAIN = null;

  public static Symbol SYM_PL_KERNEL_KB_RANGE = null;

  public static Keyword KWD__g = null;

  public static Symbol SYM_LOGIC_pSELF = null;

  public static Keyword KWD_eg = null;

  public static Symbol SYM_LOGIC_DEFPROPOSITION = null;

  public static Keyword KWD_FORWARDp = null;

  public static Keyword KWD_FORWARD_ONLYp = null;

  public static Keyword KWD_BACKWARDp = null;

  public static Keyword KWD_BACKWARD_ONLYp = null;

  public static Cons $LOGIC_RELEVANT_STELLA_COMMANDS$ = null;

  public static Symbol SYM_STELLA_CC = null;

  public static Symbol SYM_STELLA_IN_MODULE = null;

  public static Symbol SYM_STELLA_LIST_MODULES = null;

  public static Symbol SYM_STELLA_METHOD_COMMANDp = null;

  public static Symbol SYM_STELLA_DOCUMENTATION = null;

  public static Symbol SYM_LOGIC_STARTUP_LOGIC_IN = null;

  public static Surrogate SGT_PL_KERNEL_KB_SCALAR = null;

  public static Surrogate SGT_LOGIC_F_ALL_TAXONOMIC_TYPES_MEMO_TABLE_000 = null;

  public static Surrogate SGT_LOGIC_F_ALL_TYPES_MEMO_TABLE_000 = null;

  public static Surrogate SGT_LOGIC_F_ALL_EQUIVALENT_RELATIONS_MEMO_TABLE_000 = null;

  public static Surrogate SGT_LOGIC_F_ALL_SUPERRELATIONS_MEMO_TABLE_000 = null;

  public static Surrogate SGT_LOGIC_F_ALL_SUBRELATIONS_MEMO_TABLE_000 = null;

  public static Surrogate SGT_LOGIC_F_ALL_DIRECT_SUPERRELATIONS_MEMO_TABLE_000 = null;

  public static Surrogate SGT_LOGIC_F_ALL_DIRECT_SUBRELATIONS_MEMO_TABLE_000 = null;

  public static Surrogate SGT_PL_KERNEL_KB_RANGE_MIN_CARDINALITY = null;

  public static Surrogate SGT_PL_KERNEL_KB_RANGE_MAX_CARDINALITY = null;

  public static Surrogate SGT_PL_KERNEL_KB_RANGE_TYPE = null;

  /** KLUDGE: until we know how to handle recursive subgoals
   * across recursive query invocations, this allows us to disable chaining.
   */
  public static boolean $LEVELLIZED_BACKCHAINING_ENABLEDp$ = false;

  public static Symbol SYM_LOGIC_pCONCEPT = null;

  public static Symbol SYM_LOGIC_pINSTANCE = null;

  public static Symbol SYM_LOGIC_M_NORMAL_INFERENCE_LEVELdLEVELLIZED_TEST_TYPE_ON_INSTANCEp_QUERY_000 = null;

  public static Symbol SYM_LOGIC_M_NORMAL_INFERENCE_LEVELdLEVELLIZED_ALL_CLASS_INSTANCES_QUERY_000 = null;

  public static Symbol SYM_LOGIC_pRELATION = null;

  public static Symbol SYM_LOGIC_M_NORMAL_INFERENCE_LEVELdLEVELLIZED_ALL_RELATION_VALUES_QUERY_000 = null;

  public static Symbol SYM_LOGIC_M_NORMAL_INFERENCE_LEVELdLEVELLIZED_ALL_RELATION_VALUES_QUERY_001 = null;

  public static Symbol SYM_LOGIC_pZ = null;

  public static Symbol SYM_LOGIC_M_NORMAL_INFERENCE_LEVELdLEVELLIZED_ALL_RELATION_VALUES_QUERY_002 = null;

  public static Symbol SYM_LOGIC_pW = null;

  public static Symbol SYM_LOGIC_M_NORMAL_INFERENCE_LEVELdLEVELLIZED_ALL_RELATION_VALUES_QUERY_003 = null;

  public static Symbol SYM_LOGIC_ALL = null;

  public static Symbol SYM_LOGIC_M_NORMAL_INFERENCE_LEVELdLEVELLIZED_TEST_RELATION_ON_ARGUMENTSp_QUERY_000 = null;

  public static Symbol SYM_LOGIC_M_NORMAL_INFERENCE_LEVELdLEVELLIZED_TEST_RELATION_ON_ARGUMENTSp_QUERY_001 = null;

  public static Symbol SYM_LOGIC_M_NORMAL_INFERENCE_LEVELdLEVELLIZED_TEST_RELATION_ON_ARGUMENTSp_QUERY_002 = null;

  public static Symbol SYM_LOGIC_M_NORMAL_INFERENCE_LEVELdLEVELLIZED_TEST_RELATION_ON_ARGUMENTSp_QUERY_003 = null;

  public static Symbol SYM_LOGIC_pOBJECT = null;

  public static Symbol SYM_LOGIC_pN = null;

  public static Symbol SYM_LOGIC_RANGE_MIN_CARDINALITY = null;

  public static Symbol SYM_LOGIC_M_NORMAL_INFERENCE_LEVELdLEVELLIZED_GET_SLOT_MINIMUM_CARDINALITY_QUERY_000 = null;

  public static Symbol SYM_LOGIC_RANGE_MAX_CARDINALITY = null;

  public static Symbol SYM_LOGIC_M_NORMAL_INFERENCE_LEVELdLEVELLIZED_GET_SLOT_MAXIMUM_CARDINALITY_QUERY_000 = null;

  public static Symbol SYM_LOGIC_pTYPE = null;

  public static Symbol SYM_LOGIC_RANGE_TYPE = null;

  public static Symbol SYM_LOGIC_BOUND_VARIABLES = null;

  public static Symbol SYM_LOGIC_M_NORMAL_INFERENCE_LEVELdLEVELLIZED_ALL_SLOT_VALUE_TYPES_QUERY_000 = null;

  public static Symbol SYM_LOGIC_STARTUP_FRAME_SUPPORT = null;

  public static Symbol SYM_STELLA_INVERSE = null;

  public static Symbol SYM_PL_KERNEL_KB_INVERSE = null;

  public static Keyword KWD_BINARY = null;

  public static Keyword KWD_UNARY = null;

  public static Symbol SYM_LOGIC_AT_LEAST = null;

  public static Symbol SYM_LOGIC_AT_MOST = null;

  public static Symbol SYM_LOGIC_EXACTLY = null;

  public static Symbol SYM_STELLA_SOME = null;

  public static Symbol SYM_LOGIC_FILLED_BY = null;

  public static Symbol SYM_LOGIC_FILLERS = null;

  public static Symbol SYM_LOGIC_NOT_FILLED_BY = null;

  public static Symbol SYM_PL_KERNEL_KB_QUALIFIED_RANGE_CARDINALITY_LOWER_BOUND = null;

  public static Symbol SYM_PL_KERNEL_KB_QUALIFIED_RANGE_CARDINALITY_UPPER_BOUND = null;

  public static Symbol SYM_PL_KERNEL_KB_QUALIFIED_RANGE_CARDINALITY = null;

  public static Symbol SYM_PL_KERNEL_KB_RANGE_CARDINALITY_LOWER_BOUND = null;

  public static Symbol SYM_PL_KERNEL_KB_RANGE_CARDINALITY_UPPER_BOUND = null;

  public static Symbol SYM_PL_KERNEL_KB_RANGE_CARDINALITY = null;

  public static Symbol SYM_PL_KERNEL_KB_RANGE_TYPE = null;

  public static Symbol SYM_LOGIC_RELATES = null;

  public static Symbol SYM_LOGIC_FOR_SOME = null;

  public static Symbol SYM_LOGIC_THROUGH = null;

  public static Symbol SYM_LOGIC_INTERVALii = null;

  public static Symbol SYM_LOGIC_INTERVALi_ = null;

  public static Symbol SYM_LOGIC_INTERVAL_i = null;

  public static Symbol SYM_LOGIC_INTERVAL__ = null;

  public static Symbol SYM_LOGIC_SAME_AS = null;

  public static Symbol SYM_LOGIC_lg = null;

  public static Symbol SYM_LOGIC_ONE_OF = null;

  public static Symbol SYM_LOGIC_THE_ORDERED_SET = null;

  public static Symbol SYM_LOGIC_SATISFIES = null;

  public static Symbol SYM_LOGIC_DOMAIN = null;

  public static Symbol SYM_STELLA_DOMAINS = null;

  public static Symbol SYM_LOGIC_RANGE = null;

  public static Symbol SYM_LOGIC_COMPOSE = null;

  public static Symbol SYM_LOGIC_SUPERRELATIONS = null;

  public static Symbol SYM_LOGIC_SUPERCONCEPTS = null;

  public static Keyword KWD_3_VALUED_P = null;

  public static Symbol SYM_STELLA_ASK = null;

  public static Symbol SYM_STELLA_CONSIFY = null;

  public static Symbol SYM_STELLA_RETRIEVE = null;

  public static Symbol SYM_LOGIC_EVAL_WHEN = null;

  public static Symbol SYM_LOGIC_TELL = null;

  public static Symbol SYM_LOGIC_FORGET = null;

  public static Symbol SYM_LOGIC_TELLM = null;

  public static Symbol SYM_LOGIC_FORGETM = null;

  public static Symbol SYM_LOGIC_CREATEM = null;

  public static Symbol SYM_LOGIC_DEFSET = null;

  public static Symbol SYM_LOGIC_DEFPROPERTY = null;

  public static Symbol SYM_LOGIC_DEFCONTEXT = null;

  public static Symbol SYM_LOGIC_ADD_VALUE = null;

  public static Symbol SYM_LOGIC_SET_VALUE = null;

  public static Symbol SYM_LOGIC_FADD_VALUE = null;

  public static Symbol SYM_STELLA_CHANGE_CONTEXT = null;

  public static Symbol SYM_LOGIC_IN_CONTEXT = null;

  public static Symbol SYM_LOGIC_IN_KB = null;

  public static Symbol SYM_STELLA_NIL = null;

  public static Keyword KWD_SINGLE_VALUED = null;

  public static Symbol SYM_PL_KERNEL_KB_CLOSED = null;

  public static Keyword KWD_COMMUTATIVE = null;

  public static Symbol SYM_PL_KERNEL_KB_COMMUTATIVE = null;

  public static Keyword KWD_SYMMETRIC = null;

  public static Symbol SYM_PL_KERNEL_KB_SYMMETRIC = null;

  public static Keyword KWD_CLOS_CLASS = null;

  public static Keyword KWD_MULTIPLE_VALUED = null;

  public static Keyword KWD_HASH_ON_DOMAINS = null;

  public static Keyword KWD_NON_EXPORTED = null;

  public static Keyword KWD_PERFECT = null;

  public static Keyword KWD_CLOSED_ON_CONSTANTS = null;

  public static Keyword KWD_BACKWARD_CHAINING = null;

  public static Keyword KWD_MONOTONIC = null;

  public static Keyword KWD_TEMPORAL = null;

  public static Keyword KWD_ATTRIBUTES = null;

  public static Keyword KWD_CHARACTERISTICS = null;

  public static Keyword KWD_PARTITION = null;

  public static Keyword KWD_PARTITIONS = null;

  public static Keyword KWD_CONSTRAINTS = null;

  public static Keyword KWD_EXHAUSTIVE_PARTITION = null;

  public static Keyword KWD_EXHAUSTIVE_PARTITIONS = null;

  public static Keyword KWD_IS_PRIMITIVE = null;

  public static Keyword KWD_IS = null;

  public static Keyword KWD_DEFAULTS = null;

  public static Keyword KWD_DOMAIN = null;

  public static Keyword KWD_DOMAINS = null;

  public static Keyword KWD_RANGE = null;

  public static Keyword KWD_ARITY = null;

  public static Keyword KWD_IN_PARTITION = null;

  public static Keyword KWD_ANNOTATIONS = null;

  public static Keyword KWD_ROLES = null;

  public static Keyword KWD_NAME = null;

  public static Keyword KWD_IDENTIFIER = null;

  public static Keyword KWD_llegg = null;

  public static Keyword KWD_egg = null;

  public static Symbol SYM_LOGIC_STARTUP_LOOM_TO_KIF = null;

  public static Symbol SYM_LOGIC_STARTUP_API_SUPPORT = null;

  public static int $POWERLOOM_MAJOR_VERSION_NUMBER$ = 4;

  public static int $POWERLOOM_MINOR_VERSION_NUMBER$ = 0;

  public static String $POWERLOOM_RELEASE_STATE$ = "";

  public static int $POWERLOOM_PATCH_LEVEL$ = 10;

  public static String $POWERLOOM_VERSION_STRING$ = null;

  /** Either :development, :debugging or :release (so far) which controls
   * whether certain internal error and warning messages are surfaced to the user.
   */
  public static Keyword $POWERLOOM_EXECUTION_MODE$ = null;

  public static Keyword KWD_LOG_LEVELS = null;

  public static Keyword KWD_PREFIX = null;

  public static Keyword KWD_MAX_WIDTH = null;

  /** Lock object for synchronizing safe multi-process access to PowerLoom
   */
  public static Object $POWERLOOM_LOCK$ = null;

  public static Symbol SYM_LOGIC_STARTUP_POWERLOOM = null;

  public static Symbol SYM_LOGIC_STARTUP_TOOLS = null;

  public static Symbol SYM_LOGIC_STARTUP_LOGIC_SYSTEM = null;

  public static Stella_Object signalParsingError(Cons message) {
    { Symbol streamvar = Stella.localGensym("STREAM");

      message = Cons.formatMessageArguments(message, false);
      return (Cons.list$(Cons.cons(Logic.SYM_STELLA_LET, Cons.cons(Cons.cons(Cons.cons(streamvar, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_NEW, Cons.cons(Logic.SYM_STELLA_OUTPUT_STRING_STREAM, Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL)), Stella.NIL), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SPECIAL, Cons.cons(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_$PRINTREADABLYp$, Cons.cons(Logic.SYM_STELLA_TRUE, Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_PRINT_STREAM, Cons.cons(streamvar, Cons.cons(Cons.cons(StringWrapper.wrapString("PARSING ERROR: "), message.concatenate(Cons.list$(Cons.cons(StringWrapper.wrapString("."), Cons.cons(Logic.SYM_STELLA_EOL, Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL)), Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_HELP_SIGNAL_PROPOSITION_ERROR, Cons.cons(streamvar, Cons.cons(Cons.cons(Logic.KWD_ERROR, Stella.NIL), Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SIGNAL_EXCEPTION, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_NEW, Cons.cons(Logic.SYM_LOGIC_PARSING_ERROR, Cons.cons(Logic.KWD_MESSAGE, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_THE_STRING, Cons.cons(streamvar, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))))));
    }
  }

  public static Stella_Object signalPropositionError(Cons message) {
    { Symbol streamvar = Stella.localGensym("STREAM");

      message = Cons.formatMessageArguments(message, false);
      return (Cons.list$(Cons.cons(Logic.SYM_STELLA_LET, Cons.cons(Cons.cons(Cons.cons(streamvar, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_NEW, Cons.cons(Logic.SYM_STELLA_OUTPUT_STRING_STREAM, Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL)), Stella.NIL), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SPECIAL, Cons.cons(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_$PRINTREADABLYp$, Cons.cons(Logic.SYM_STELLA_TRUE, Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_PRINT_STREAM, Cons.cons(streamvar, Cons.cons(Cons.cons(StringWrapper.wrapString("ERROR: "), message.concatenate(Cons.list$(Cons.cons(StringWrapper.wrapString("."), Cons.cons(Logic.SYM_STELLA_EOL, Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL)), Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_HELP_SIGNAL_PROPOSITION_ERROR, Cons.cons(streamvar, Cons.cons(Cons.cons(Logic.KWD_ERROR, Stella.NIL), Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SIGNAL_EXCEPTION, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_NEW, Cons.cons(Logic.SYM_LOGIC_PROPOSITION_ERROR, Cons.cons(Logic.KWD_MESSAGE, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_THE_STRING, Cons.cons(streamvar, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))))));
    }
  }

  public static Stella_Object signalPropositionWarning(Cons message) {
    return (Cons.list$(Cons.cons(Logic.SYM_STELLA_SPECIAL, Cons.cons(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_$PRINTREADABLYp$, Cons.cons(Logic.SYM_STELLA_TRUE, Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_PRINT_STREAM, Cons.cons(Logic.SYM_STELLA_STANDARD_WARNING, Cons.cons(StringWrapper.wrapString("WARNING: "), Cons.cons(message.concatenate(Cons.cons(Logic.SYM_STELLA_EOL, Stella.NIL), Stella.NIL), Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_HELP_SIGNAL_PROPOSITION_ERROR, Cons.cons(Logic.SYM_STELLA_STANDARD_WARNING, Cons.cons(Logic.KWD_WARNING, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))))));
  }

  public static Stella_Object defDisplayGlobals(Symbol displayfunctionname, Cons globalvariablenames) {
    { Cons printclauses = Stella.NIL;

      { Symbol g = null;
        Cons iter000 = globalvariablenames.reverse();

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          g = ((Symbol)(iter000.value));
          printclauses = Cons.append(Cons.cons(StringWrapper.wrapString(g.symbolName), Cons.list$(Cons.cons(StringWrapper.wrapString(" =  "), Cons.cons(g, Cons.cons(Cons.cons(Logic.SYM_STELLA_EOL, Stella.NIL), Stella.NIL))))), printclauses);
        }
      }
      return (Cons.list$(Cons.cons(Logic.SYM_STELLA_DEFUN, Cons.cons(Cons.cons(displayfunctionname, Cons.cons(Logic.SYM_STELLA_STRING, Stella.NIL)), Cons.cons(Stella.NIL, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_PRINT, Cons.cons(Logic.SYM_STELLA_EOL, Cons.cons(printclauses.concatenate(Cons.cons(Logic.SYM_STELLA_EOL, Stella.NIL), Stella.NIL), Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_RETURN, Cons.cons(StringWrapper.wrapString(""), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))))));
    }
  }

  public static Stella_Object moveInPlace() {
    return (Cons.list$(Cons.cons(Logic.SYM_STELLA_PROGN, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETF, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_TRUTH_VALUE, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Logic.SYM_STELLA_NULL, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETF, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_JUSTIFICATION, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Logic.SYM_STELLA_NULL, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WHEN, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_DEFINEDp, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_PARTIAL_MATCH_FRAME, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_CLEAR_FRAME_PARTIAL_TRUTH, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_PARTIAL_MATCH_FRAME, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETQ, Cons.cons(Logic.SYM_LOGIC_LASTMOVE, Cons.cons(Logic.KWD_DOWN, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_COND, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_CHECKFORMOVEOUTp, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_LET, Cons.cons(Cons.list$(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_PARENT, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_UP, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_STARTTICKS, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_STARTING_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_AVAILABLETICKS, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA__, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_ALLOTTED_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_PARENT, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA__, Cons.cons(Logic.SYM_LOGIC_CLOCKTICKS, Cons.cons(Logic.SYM_LOGIC_STARTTICKS, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(IntegerWrapper.wrapInteger(1), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETF, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_ALLOTTED_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_PARENT, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Logic.SYM_LOGIC_AVAILABLETICKS, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA___, Cons.cons(Logic.SYM_LOGIC_AVAILABLETICKS, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETF, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_ALLOTTED_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Logic.SYM_LOGIC_AVAILABLETICKS, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETF, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_CURRENT_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_QUERY, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_ii, Cons.cons(Logic.SYM_LOGIC_CLOCKTICKS, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETF, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_STARTING_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Logic.SYM_LOGIC_CLOCKTICKS, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WHEN, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_le, Cons.cons(Logic.SYM_LOGIC_AVAILABLETICKS, Cons.cons(IntegerWrapper.wrapInteger(0), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_POP_FRAMES_UP_TO, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_MV_SETQ, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Logic.SYM_STELLA_DEPTH, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_HANDLE_TIMEOUT, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Logic.SYM_STELLA_DEPTH, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETQ, Cons.cons(Logic.SYM_LOGIC_LASTMOVE, Cons.cons(Logic.KWD_UP_FAIL, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA___, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_ALLOTTED_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_1i, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA__, Cons.cons(Logic.SYM_LOGIC_CLOCKTICKS, Cons.cons(Logic.SYM_LOGIC_STARTTICKS, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))))))), Cons.cons(Stella.NIL, Stella.NIL)))))))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_OTHERWISE, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETF, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_CURRENT_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_QUERY, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_ii, Cons.cons(Logic.SYM_LOGIC_CLOCKTICKS, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETF, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_STARTING_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Logic.SYM_LOGIC_CLOCKTICKS, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))))))));
  }

  public static Stella_Object moveDown() {
    return (Cons.list$(Cons.cons(Logic.SYM_STELLA_LET, Cons.cons(Cons.list$(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_UPFRAME, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_DOWNFRAME, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_DOWN, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETQ, Cons.cons(Logic.SYM_STELLA_DEPTH, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_1i, Cons.cons(Logic.SYM_STELLA_DEPTH, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETF, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_CURRENT_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_QUERY, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_ii, Cons.cons(Logic.SYM_LOGIC_CLOCKTICKS, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_COND, Cons.cons(Cons.list$(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_DEFINEDp, Cons.cons(Logic.SYM_LOGIC_DOWNFRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETQ, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Logic.SYM_LOGIC_DOWNFRAME, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETF, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_STARTING_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Logic.SYM_LOGIC_CLOCKTICKS, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WHEN, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_AND, Cons.cons(Logic.SYM_LOGIC_CHECKFORMOVEOUTp, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_NULLp, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_ALLOTTED_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETF, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_ALLOTTED_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_1_, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_ALLOTTED_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_UPFRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETF, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_TRUTH_VALUE, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Logic.SYM_STELLA_NULL, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETF, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_JUSTIFICATION, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Logic.SYM_STELLA_NULL, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WHEN, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_DEFINEDp, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_PARTIAL_MATCH_FRAME, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_CLEAR_FRAME_PARTIAL_TRUTH, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_PARTIAL_MATCH_FRAME, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETQ, Cons.cons(Logic.SYM_LOGIC_LASTMOVE, Cons.cons(Logic.KWD_DOWN, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))))))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_OTHERWISE, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_LET, Cons.cons(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_PROPOSITION, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_ARGUMENT_BOUND_TO, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_NTH, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_ARGUMENTS, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_PROPOSITION, Cons.cons(Logic.SYM_LOGIC_UPFRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_ARGUMENT_CURSOR, Cons.cons(Logic.SYM_LOGIC_UPFRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETQ, Cons.cons(Logic.SYM_LOGIC_DOWNFRAME, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_CREATE_DOWN_FRAME, Cons.cons(Logic.SYM_LOGIC_UPFRAME, Cons.cons(Logic.SYM_LOGIC_PROPOSITION, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETQ, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Logic.SYM_LOGIC_DOWNFRAME, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETF, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_STARTING_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Logic.SYM_LOGIC_CLOCKTICKS, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WHEN, Cons.cons(Logic.SYM_LOGIC_CHECKFORMOVEOUTp, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETF, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_ALLOTTED_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_1_, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_ALLOTTED_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_UPFRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETQ, Cons.cons(Logic.SYM_LOGIC_LASTMOVE, Cons.cons(Logic.KWD_DOWN, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WHEN, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_AND, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_g, Cons.cons(Logic.SYM_STELLA_DEPTH, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_CURRENT_DEPTH_CUTOFF, Cons.cons(Logic.SYM_LOGIC_QUERY, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_EQLp, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_STATE, Cons.cons(Logic.SYM_LOGIC_UPFRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Logic.KWD_PATTERN, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_POP_FRAMES_UP_TO, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_MV_SETQ, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Logic.SYM_STELLA_DEPTH, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_HANDLE_DEPTH_VIOLATION, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Logic.SYM_STELLA_DEPTH, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETQ, Cons.cons(Logic.SYM_LOGIC_LASTMOVE, Cons.cons(Logic.KWD_UP_FAIL, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WHEN, Cons.cons(Logic.SYM_LOGIC_CHECKFORMOVEOUTp, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WHEN, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_AND, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_le, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_ALLOTTED_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(IntegerWrapper.wrapInteger(0), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_NOT, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_EQLp, Cons.cons(Logic.SYM_LOGIC_LASTMOVE, Cons.cons(Logic.KWD_UP_FAIL, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_POP_FRAMES_UP_TO, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_MV_SETQ, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Logic.SYM_STELLA_DEPTH, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_HANDLE_TIMEOUT, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Logic.SYM_STELLA_DEPTH, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETQ, Cons.cons(Logic.SYM_LOGIC_LASTMOVE, Cons.cons(Logic.KWD_UP_FAIL, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WHEN, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_EQLp, Cons.cons(Logic.SYM_LOGIC_LASTMOVE, Cons.cons(Logic.KWD_UP_FAIL, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA___, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_ALLOTTED_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_1i, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA__, Cons.cons(Logic.SYM_LOGIC_CLOCKTICKS, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_STARTING_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_DOWNFRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons(Stella.NIL, Stella.NIL))))))))));
  }

  public static Stella_Object moveUp(Symbol successP, Symbol keepframeP) {
    { Keyword lastmove = null;

      if (successP == Logic.SYM_STELLA_TRUE) {
        lastmove = Logic.KWD_UP_TRUE;
      }
      else if (successP == Logic.SYM_LOGIC_FAIL) {
        lastmove = Logic.KWD_UP_FAIL;
        successP = Logic.SYM_STELLA_FALSE;
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + successP + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      return (Cons.list$(Cons.cons(Logic.SYM_STELLA_LET, Cons.cons(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_PARENT, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_UP, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WHEN, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_DEFINEDp, Cons.cons(Logic.SYM_LOGIC_PARENT, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETF, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_RESULT, Cons.cons(Logic.SYM_LOGIC_PARENT, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_IF, Cons.cons(Cons.cons(Logic.SYM_LOGIC_CACHE_QUERY_RESULTSp, Stella.NIL), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_CACHE_GOAL, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(successP, Cons.cons(Cons.cons(((keepframeP == Logic.SYM_LOGIC_KEEP_FRAME) ? Logic.SYM_STELLA_TRUE : Logic.SYM_STELLA_FALSE), Cons.cons(Logic.SYM_LOGIC_CLOCKTICKS, Stella.NIL)), Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_UPDATE_GOAL_CACHE, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(successP, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETQ, Cons.cons(Logic.SYM_STELLA_DEPTH, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_1_, Cons.cons(Logic.SYM_STELLA_DEPTH, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WHEN, Cons.cons(Logic.SYM_LOGIC_CHECKFORMOVEOUTp, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETF, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_ALLOTTED_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Logic.SYM_STELLA_NULL, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WHEN, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_DEFINEDp, Cons.cons(Logic.SYM_LOGIC_PARENT, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETF, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_ALLOTTED_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_PARENT, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA__, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_ALLOTTED_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_PARENT, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA__, Cons.cons(Logic.SYM_LOGIC_CLOCKTICKS, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_STARTING_CLOCK_TICKS, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(IntegerWrapper.wrapInteger(1), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETQ, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Logic.SYM_LOGIC_PARENT, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WHEN, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_NULLp, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETQ, Cons.cons(Logic.SYM_LOGIC_SUCCESSp, Cons.cons(successP, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.cons(Logic.SYM_STELLA_BREAK, Stella.NIL), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons((((keepframeP == Logic.SYM_LOGIC_KEEP_FRAME) ? Stella.NIL : Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_POP_DOWN_FRAME, Cons.cons(Logic.SYM_LOGIC_FRAME, Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL))).concatenate(Cons.list$(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETQ, Cons.cons(Logic.SYM_LOGIC_LASTMOVE, Cons.cons(lastmove, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Logic.SYM_LOGIC_LASTMOVE, Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL), Stella.NIL))))))))));
    }
  }

  /** Execute a query composed of io-variables <code>variables</code>
   * and body <code>queryBody</code>.  Before executing, bind variables to <code>inputBindings</code>
   * (in sequence). If one variable is left unbound, returns a cons list of
   * bindings of that variable.  If two or more are unbound, returns
   * a cons list of cons lists of bindings.  Setting the option :singletons?
   * to FALSE always returns a list of lists.  Example call:
   *   <code>_apply_retrieve_variables_queryBody_inputBindings_</code>
   * @param body
   * @return Stella_Object
   */
  public static Stella_Object applyRetrieve(Cons body) {
    { Symbol gensymname = Stella.methodGensym("QUERY");

      return (Cons.list$(Cons.cons(Logic.SYM_LOGIC_APPLY_CACHED_RETRIEVE, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_BQUOTE, Cons.cons(body.value, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_BQUOTE, Cons.cons(body.rest.value, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.cons(Logic.SYM_STELLA_CONS_LIST, ((Cons)(body.rest.rest.value)).concatenate(Stella.NIL, Stella.NIL)), Cons.cons(Cons.cons(Logic.SYM_STELLA_CONS_LIST, body.nthRest(3).concatenate(Stella.NIL, Stella.NIL)), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_QUOTE, Cons.cons(gensymname, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))))))));
    }
  }

  /** Execute a yes/no query composed of input-variables
   * <code>inputVariables</code> and body <code>queryBody</code>.  Before executing, bind variables
   * to <code>inputBindings</code> (in sequence).
   *   <code>_apply_ask_inputVariables_queryBody_inputBindings_</code>
   * @param body
   * @return Stella_Object
   */
  public static Stella_Object applyAsk(Cons body) {
    { Symbol gensymname = Stella.methodGensym("QUERY");

      return (Cons.list$(Cons.cons(Logic.SYM_LOGIC_APPLY_CACHED_ASK, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_BQUOTE, Cons.cons(body.value, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_BQUOTE, Cons.cons(body.rest.value, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.cons(Logic.SYM_STELLA_CONS_LIST, ((Cons)(body.rest.rest.value)).concatenate(Stella.NIL, Stella.NIL)), Cons.cons(Cons.cons(Logic.SYM_STELLA_CONS_LIST, body.nthRest(3).concatenate(Stella.NIL, Stella.NIL)), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_QUOTE, Cons.cons(gensymname, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))))))));
    }
  }

  /** Execute <code>body</code> within the meta cache of the current module.
   * Set appropriate special variables.
   * @param body
   * @return Stella_Object
   */
  public static Stella_Object withinMetaCache(Cons body) {
    return (Cons.list$(Cons.cons(Logic.SYM_STELLA_SPECIAL, Cons.cons(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_$CONTEXT$, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_GET_INFERENCE_CACHE, Cons.cons(Logic.SYM_STELLA_$MODULE$, Cons.cons(Logic.KWD_META, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL), Cons.cons(body.concatenate(Stella.NIL, Stella.NIL), Stella.NIL)))));
  }

  /** Used during classification.  Execute <code>body</code> within the indicated
   * classification session and inference world.
   * @param descriptionorinstance
   * @param body
   * @return Stella_Object
   */
  public static Stella_Object withinClassificationSession(Keyword descriptionorinstance, Cons body) {
    return (Cons.list$(Cons.cons(Logic.SYM_STELLA_SPECIAL, Cons.cons(Cons.list$(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_$CLASSIFICATIONSESSION$, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_GET_CLASSIFICATION_SESSION, Cons.cons(descriptionorinstance, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_$CONTEXT$, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_CLASSIFICATION_WORLD, Cons.cons(Logic.SYM_LOGIC_$CLASSIFICATIONSESSION$, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(body.concatenate(Stella.NIL, Stella.NIL), Stella.NIL)))));
  }

  /** Defines <code>name</code> to be a constraint computation which uses
   * <code>constraintTest</code> to determine if a fully bound set of variables
   * satisfies the constraint.  The forms in <code>positionComputations</code>
   * are used to compute the value for each of the positions. All such
   * computations must set the variable <code>value</code> to be the result
   * computed for the missing position.  Setting <code>value</code> to <code>null</code> for
   * any such computation means that that particular argument cannot
   * be computed from the others.  The input variables in <code>varList</code>
   * will be bound to the N arguments to the constraint.
   *   The generated function will return a Stella Object and take as 
   * inputs the values of the N arguments to the constraint.  A value
   * of <code>null</code> means that the value is not available.  If all
   * arguments are not <code>null</code>, then the return value will be a Stella
   * wrapped boolean indicating whether the constraint is satisified
   * or not.
   *   If more than one input value is <code>null</code>, then this constraint
   * code will not be called.
   * @param name
   * @param varList
   * @param constraintTest
   * @param positionComputations
   * @return Stella_Object
   */
  public static Stella_Object defineComputedConstraint(Symbol name, Cons varList, Cons constraintTest, Cons positionComputations) {
    { Cons valuecomputationcode = Stella.NIL;
      Symbol valuesymbol = Symbol.internSymbol("VALUE");

      { Stella_Object computation = null;
        Cons iter000 = positionComputations;
        int i = Stella.NULL_INTEGER;
        int iter001 = 0;
        Cons collect000 = null;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
          computation = iter000.value;
          i = iter001;
          if (collect000 == null) {
            {
              collect000 = Cons.cons(Cons.cons(IntegerWrapper.wrapInteger(i), Cons.cons(computation, Stella.NIL)), Stella.NIL);
              if (valuecomputationcode == Stella.NIL) {
                valuecomputationcode = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(valuecomputationcode, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(Cons.cons(IntegerWrapper.wrapInteger(i), Cons.cons(computation, Stella.NIL)), Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      return (Cons.list$(Cons.cons(Logic.SYM_STELLA_DEFUN, Cons.cons(Cons.cons(name, Cons.cons(Logic.SYM_STELLA_OBJECT, Stella.NIL)), Cons.cons(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_MISSING_ARGUMENT, Cons.cons(Logic.SYM_STELLA_INTEGER_WRAPPER, Cons.cons(Stella.NIL, Stella.NIL)))), varList.concatenate(Stella.NIL, Stella.NIL)), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_LET, Cons.cons(Cons.cons(Cons.cons(valuesymbol, Cons.list$(Cons.cons(Logic.SYM_STELLA_OBJECT, Cons.cons(Logic.SYM_STELLA_NULL, Cons.cons(Stella.NIL, Stella.NIL))))), Stella.NIL), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_CASE, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WRAPPER_VALUE, Cons.cons(Logic.SYM_LOGIC_MISSING_ARGUMENT, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(IntegerWrapper.wrapInteger(-1), Cons.cons(constraintTest, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(valuecomputationcode.concatenate(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_OTHERWISE, Cons.cons(Logic.SYM_STELLA_NULL, Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL), Stella.NIL), Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_RETURN, Cons.cons(valuesymbol, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons(Stella.NIL, Stella.NIL)))))));
    }
  }

  /** Defines <code>name</code> as an arithmetic comparision operation using the
   * test <code>testName</code>.  It will take two wrapped number parameters and
   * return a <code>renamed_Boolean</code>.  The code will use the appropriate test for
   * the specific subtype of wrapped number actually passed in.
   * @param name
   * @param testName
   * @return Stella_Object
   */
  public static Stella_Object defineArithmeticTestOnWrappers(Symbol name, Symbol testName) {
    return (Cons.list$(Cons.cons(Logic.SYM_STELLA_DEFUN, Cons.cons(Cons.cons(name, Cons.cons(Logic.SYM_STELLA_BOOLEAN, Stella.NIL)), Cons.cons(Cons.list$(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_X, Cons.cons(Logic.SYM_STELLA_NUMBER_WRAPPER, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_Y, Cons.cons(Logic.SYM_STELLA_NUMBER_WRAPPER, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Logic.KWD_PUBLICp, Cons.cons(Logic.SYM_STELLA_TRUE, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_TYPECASE, Cons.cons(Logic.SYM_STELLA_X, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_INTEGER_WRAPPER, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_TYPECASE, Cons.cons(Logic.SYM_STELLA_Y, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_INTEGER_WRAPPER, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_RETURN, Cons.cons(Cons.cons(testName, Cons.list$(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WRAPPER_VALUE, Cons.cons(Logic.SYM_STELLA_X, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WRAPPER_VALUE, Cons.cons(Logic.SYM_STELLA_Y, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_FLOAT_WRAPPER, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_RETURN, Cons.cons(Cons.cons(testName, Cons.list$(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_CAST, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WRAPPER_VALUE, Cons.cons(Logic.SYM_STELLA_X, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Logic.SYM_STELLA_FLOAT, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WRAPPER_VALUE, Cons.cons(Logic.SYM_STELLA_Y, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_FLOAT_WRAPPER, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_TYPECASE, Cons.cons(Logic.SYM_STELLA_Y, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_INTEGER_WRAPPER, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_RETURN, Cons.cons(Cons.cons(testName, Cons.list$(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WRAPPER_VALUE, Cons.cons(Logic.SYM_STELLA_X, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_CAST, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WRAPPER_VALUE, Cons.cons(Logic.SYM_STELLA_Y, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Logic.SYM_STELLA_FLOAT, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_FLOAT_WRAPPER, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_RETURN, Cons.cons(Cons.cons(testName, Cons.list$(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WRAPPER_VALUE, Cons.cons(Logic.SYM_STELLA_X, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WRAPPER_VALUE, Cons.cons(Logic.SYM_STELLA_Y, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons(Stella.NIL, Stella.NIL)))))))));
  }

  /** Defines <code>name</code> as an arithmetic comparision operation using the
   * test <code>testName</code>.  It will take two wrapped number parameters and
   * return a wrapped number.  The code will use the appropriate test
   * for the specific subtype of wrapped number actually passed in,
   * and return the appropriate subtype of wrapped number based on the
   * normal arithmetic contagion rules.
   *   
   * For example, if both input parameters are wrapped integers then
   * the output will be a wrapped integer.  If the inputs are a
   * wrapped integer and a wrapped float then the output will be a
   * wrapped float, etc.
   * @param name
   * @param operationName
   * @return Stella_Object
   */
  public static Stella_Object defineArithmeticOperationOnWrappers(Symbol name, Symbol operationName) {
    return (Cons.list$(Cons.cons(Logic.SYM_STELLA_DEFUN, Cons.cons(Cons.cons(name, Cons.cons(Logic.SYM_STELLA_NUMBER_WRAPPER, Stella.NIL)), Cons.cons(Cons.list$(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_X, Cons.cons(Logic.SYM_STELLA_NUMBER_WRAPPER, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_Y, Cons.cons(Logic.SYM_STELLA_NUMBER_WRAPPER, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Logic.KWD_PUBLICp, Cons.cons(Logic.SYM_STELLA_TRUE, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_LET, Cons.cons(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_FLOATRESULT, Cons.cons(Logic.SYM_STELLA_FLOAT, Cons.cons(Logic.SYM_STELLA_NULL, Cons.cons(Stella.NIL, Stella.NIL))))), Stella.NIL), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_TYPECASE, Cons.cons(Logic.SYM_STELLA_X, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_INTEGER_WRAPPER, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_TYPECASE, Cons.cons(Logic.SYM_STELLA_Y, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_INTEGER_WRAPPER, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_RETURN, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WRAP_LITERAL, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SAFE_CAST, Cons.cons(Cons.cons(operationName, Cons.list$(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WRAPPER_VALUE, Cons.cons(Logic.SYM_STELLA_X, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WRAPPER_VALUE, Cons.cons(Logic.SYM_STELLA_Y, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Logic.SYM_STELLA_INTEGER, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_FLOAT_WRAPPER, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETQ, Cons.cons(Logic.SYM_LOGIC_FLOATRESULT, Cons.cons(Cons.cons(operationName, Cons.list$(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WRAPPER_VALUE, Cons.cons(Logic.SYM_STELLA_X, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WRAPPER_VALUE, Cons.cons(Logic.SYM_STELLA_Y, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_FLOAT_WRAPPER, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_TYPECASE, Cons.cons(Logic.SYM_STELLA_Y, Cons.cons(Cons.list$(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_INTEGER_WRAPPER, Cons.cons(Logic.SYM_STELLA_FLOAT_WRAPPER, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETQ, Cons.cons(Logic.SYM_LOGIC_FLOATRESULT, Cons.cons(Cons.cons(operationName, Cons.list$(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WRAPPER_VALUE, Cons.cons(Logic.SYM_STELLA_X, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WRAPPER_VALUE, Cons.cons(Logic.SYM_STELLA_Y, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_RETURN, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WRAP_LITERAL, Cons.cons(Logic.SYM_LOGIC_FLOATRESULT, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons(Stella.NIL, Stella.NIL)))))))));
  }

  /** Execute <code>body</code> within the module resulting from <code>moduleform</code>.
   * <code>$MODULE$</code> is an acceptable <code>moduleform</code>.  It will locally rebind 
   * <code>$MODULE$</code> and <code>$CONTEXT$</code> and shield the outer bindings from changes.
   * @param moduleform
   * @param environment
   * @param body
   * @return Stella_Object
   */
  public static Stella_Object withLogicEnvironment(Stella_Object moduleform, Stella_Object environment, Cons body) {
    { Symbol modulevar = Stella.localGensym("MDL");
      Symbol contextvar = Stella.localGensym("CXT");

      return (Cons.list$(Cons.cons(Logic.SYM_STELLA_LET, Cons.cons(Cons.list$(Cons.cons(Cons.cons(modulevar, Cons.list$(Cons.cons(Logic.SYM_STELLA_MODULE, Cons.cons(moduleform, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.cons(contextvar, Cons.list$(Cons.cons(Logic.SYM_STELLA_CONTEXT, Cons.cons(modulevar, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WHEN, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_NULLp, Cons.cons(modulevar, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETQ, Cons.cons(modulevar, Cons.cons(Cons.cons(Logic.SYM_STELLA_$MODULE$, Stella.NIL), Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SETQ, Cons.cons(contextvar, Cons.cons(Cons.cons(Logic.SYM_STELLA_$CONTEXT$, Stella.NIL), Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SPECIAL, Cons.cons(Cons.list$(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_$MODULE$, Cons.cons(modulevar, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_$CONTEXT$, Cons.cons(contextvar, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons((((Stella_Object.symbolP(environment) &&
          (!(environment == Logic.SYM_STELLA_NULL))) ? Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_IGNORE, Cons.cons(environment, Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL) : Stella.NIL)).concatenate(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_WITH_PROCESS_LOCK, Cons.cons(Logic.SYM_LOGIC_$POWERLOOM_LOCK$, Cons.cons(body.concatenate(Stella.NIL, Stella.NIL), Stella.NIL)))), Stella.NIL), Stella.NIL), Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))))));
    }
  }

  public static Stella_Object whenCycKludgesEnabled(Cons body) {
    return (Cons.list$(Cons.cons(Logic.SYM_STELLA_WHEN, Cons.cons(Logic.SYM_LOGIC_$CYC_KLUDGES_ENABLEDp$, Cons.cons(body.concatenate(Stella.NIL, Stella.NIL), Stella.NIL)))));
  }

  /** Return TRUE if we have at least one object store opened/linked into
   * PowerLoom, which changes some index access routines to be considerate of that.
   * @return boolean
   */
  public static boolean haveActiveObjectStoresP() {
    return (!(Logic.$ALL_OBJECT_STORES$ == Stella.NIL_LIST));
  }

  public static ObjectStore homeObjectStore(Stella_Object self) {
    { Module module = self.homeModule();

      return (((module != null) ? ((ObjectStore)(KeyValueList.dynamicSlotValue(module.dynamicSlots, Logic.SYM_LOGIC_OBJECT_STORE, null))) : null));
    }
  }

  public static SequenceIndex createSequenceIndex(Stella_Object self, Cons pattern) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfKeywordP(testValue000)) {
        { Keyword self000 = ((Keyword)(self));

          return (Logic.keywordDcreateSequenceIndex(self000, pattern));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_MODULE)) {
        { Module self000 = ((Module)(self));

          return (Logic.moduleDcreateSequenceIndex(self000, pattern));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_OBJECT_STORE)) {
        { ObjectStore self000 = ((ObjectStore)(self));

          return (self000.objectStoreDcreateSequenceIndex(pattern));
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("Don't know how to create a sequence index on `" + self + "'");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  public static SequenceIndex keywordDcreateSequenceIndex(Keyword kind, Cons pattern) {
    if (kind == Logic.KWD_PAGING) {
      { Stella_Object anchor = pattern.rest.rest.value;
        ObjectStore store = null;

        if (!(anchor != null)) {
          System.err.print("Safety violation: Null argument passed into paging index pattern");
        }
        store = Logic.homeObjectStore(anchor);
        if (store != null) {
          return (Logic.createSequenceIndex(store, pattern));
        }
        else {
          return (NonPagingIndex.newNonPagingIndex());
        }
      }
    }
    else if (kind == Logic.KWD_NON_PAGING) {
      return (NonPagingIndex.newNonPagingIndex());
    }
    else {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        stream000.nativeStream.print("`" + kind + "' is not a valid case option");
        throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
      }
    }
  }

  public static SequenceIndex moduleDcreateSequenceIndex(Module module, Cons pattern) {
    { ObjectStore store = ((ObjectStore)(KeyValueList.dynamicSlotValue(module.dynamicSlots, Logic.SYM_LOGIC_OBJECT_STORE, null)));

      if (store != null) {
        return (Logic.createSequenceIndex(store, pattern));
      }
      else {
        return (Logic.createSequenceIndex(Logic.KWD_PAGING, pattern));
      }
    }
  }

  public static boolean questionMarkSymbolP(Stella_Object symbol) {
    return (Stella_Object.symbolP(symbol) &&
        ((((Symbol)(symbol)).symbolName).charAt(0) == '?'));
  }

  public static boolean sequenceVariableSymbolP(Stella_Object self) {
    self = self;
    return (false);
  }

  public static boolean automaticInstanceSymbolP(Stella_Object symbol) {
    return (Stella_Object.symbolP(symbol) &&
        ((((Symbol)(symbol)).symbolName).charAt(0) == Logic.$AUTOMATIC_INSTANCE_CHARACTER$));
  }

  public static GeneralizedSymbol kifSymbolToStellaSymbol(Symbol symbol) {
    if (Logic.questionMarkSymbolP(symbol) ||
        Logic.automaticInstanceSymbolP(symbol)) {
      return (symbol);
    }
    else {
      return (Logic.coerceToBoundOrLocalSurrogate(symbol));
    }
  }

  public static Symbol kifVariableToStellaVariable(Stella_Object variable) {
    if (Surrogate.subtypeOfSymbolP(Stella_Object.safePrimaryType(variable))) {
      { Symbol variable000 = ((Symbol)(variable));

        if (!Logic.questionMarkSymbolP(variable000)) {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

              try {
                Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                stream000.nativeStream.println("PARSING ERROR: Missing question mark on KIF variable: `" + variable000 + "'.");
                Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

              } finally {
                Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
              }
            }
            throw ((ParsingError)(ParsingError.newParsingError(stream000.theStringReader()).fillInStackTrace()));
          }
        }
        return (((Symbol)(Logic.kifSymbolToStellaSymbol(variable000))));
      }
    }
    else {
      { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

        { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

          try {
            Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
            stream001.nativeStream.println("PARSING ERROR: Illegal value in KIF expression where symbol expected `" + variable + "'.");
            Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

          } finally {
            Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
          }
        }
        throw ((ParsingError)(ParsingError.newParsingError(stream001.theStringReader()).fillInStackTrace()));
      }
    }
  }

  public static boolean kifVariableDeclarationP(Stella_Object tree) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(tree);

      if (testValue000 == Logic.SGT_STELLA_CONS) {
        { Cons tree000 = ((Cons)(tree));

          switch (tree000.length()) {
            case 1: 
              return (Logic.questionMarkSymbolP(tree000.value));
            case 2: 
              return (Logic.questionMarkSymbolP(tree000.value) &&
                  (Stella_Object.symbolP(tree000.rest.value) &&
                   (!Logic.questionMarkSymbolP(tree000.rest.value))));
            default:
              return (false);
          }
        }
      }
      else if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol tree000 = ((Symbol)(tree));

          if (Logic.questionMarkSymbolP(tree000)) {
            return (true);
          }
        }
      }
      else {
        return (false);
      }
    }
    return (false);
  }

  public static Stella_Object oneKifVariableDeclarationToStella(Stella_Object tree) {
    if (!Logic.kifVariableDeclarationP(tree)) {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

          try {
            Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
            stream000.nativeStream.println("PARSING ERROR: Illegal KIF variable declaration: `" + tree + "'.");
            Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

          } finally {
            Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
          }
        }
        throw ((ParsingError)(ParsingError.newParsingError(stream000.theStringReader()).fillInStackTrace()));
      }
    }
    if (Stella_Object.safePrimaryType(tree) == Logic.SGT_STELLA_CONS) {
      { Cons tree000 = ((Cons)(tree));

        tree000.firstSetter(Logic.kifVariableToStellaVariable(tree000.value));
        if (tree000.rest.value != null) {
          {
            tree000.secondSetter(Logic.kifSymbolToStellaSymbol(((Symbol)(tree000.rest.value))));
            return (Cons.cons(Logic.SYM_STELLA_ISA, tree000.concatenate(Stella.NIL, Stella.NIL)));
          }
        }
        else {
          return (Logic.kifVariableToStellaVariable(tree000.value));
        }
      }
    }
    else {
      return (Logic.kifVariableToStellaVariable(tree));
    }
  }

  public static boolean stellaVariableDeclarationsP(Stella_Object tree) {
    if (Stella_Object.safePrimaryType(tree) == Logic.SGT_STELLA_CONS) {
      { Cons tree000 = ((Cons)(tree));

        if ((tree000.value == Logic.SYM_STELLA_ISA) ||
            (Stella_Object.consP(tree000.value) &&
             (((Cons)(tree000.value)).value == Logic.SYM_STELLA_ISA))) {
          return (true);
        }
      }
    }
    else {
    }
    return (false);
  }

  public static Cons kifVariableDeclarationsToStella(Stella_Object tree, boolean errorP) {
    if (Logic.stellaVariableDeclarationsP(tree)) {
      {
        return (((Cons)(tree)));
      }
    }
    else {
      if (Logic.kifVariableDeclarationP(tree)) {
        {
          return (Cons.cons(Logic.oneKifVariableDeclarationToStella(tree), Stella.NIL));
        }
      }
      else {
        { boolean testValue000 = false;

          testValue000 = Stella_Object.consP(tree);
          if (testValue000) {
            { boolean alwaysP000 = true;

              { Stella_Object d = null;
                Cons iter000 = ((Cons)(tree));

                loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                  d = iter000.value;
                  if (!Logic.kifVariableDeclarationP(d)) {
                    alwaysP000 = false;
                    break loop000;
                  }
                }
              }
              testValue000 = alwaysP000;
            }
          }
          if (testValue000) {
            {
              { ConsIterator it = ((Cons)(tree)).allocateIterator();

                while (it.nextP()) {
                  it.valueSetter(Logic.oneKifVariableDeclarationToStella(it.value));
                }
              }
              return (((Cons)(tree)));
            }
          }
          else {
            {
              if (errorP) {
                { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

                  { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

                    try {
                      Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                      stream000.nativeStream.println("PARSING ERROR: Illegal declaration syntax: `" + tree + "'.");
                      Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

                    } finally {
                      Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
                    }
                  }
                  throw ((ParsingError)(ParsingError.newParsingError(stream000.theStringReader()).fillInStackTrace()));
                }
              }
              return (null);
            }
          }
        }
      }
    }
  }

  public static boolean kifQuantifierSymbolP(Symbol self) {
    if ((self == Logic.SYM_STELLA_EXISTS) ||
        ((self == Logic.SYM_STELLA_FORALL) ||
         ((self == Logic.SYM_LOGIC_SETOFALL) ||
          ((self == Logic.SYM_LOGIC_KAPPA) ||
           (self == Logic.SYM_LOGIC_THE))))) {
      return (true);
    }
    else {
      return (false);
    }
  }

  public static Cons kifTheToStellaTheOnly(Cons tree) {
    tree = Logic.kifSetofallToStellaSetofall(tree);
    tree.firstSetter(Logic.SYM_LOGIC_THE_ONLY);
    return (tree);
  }

  public static Cons kifSetofallToStellaSetofall(Cons tree) {
    if (!((tree.length() == 3) ||
        (tree.length() == 2))) {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

          try {
            Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
            stream000.nativeStream.println("PARSING ERROR: Illegal `" + tree.value + "' tree: `" + tree + "'.");
            Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

          } finally {
            Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
          }
        }
        throw ((ParsingError)(ParsingError.newParsingError(stream000.theStringReader()).fillInStackTrace()));
      }
    }
    { Cons declarations = Logic.kifVariableDeclarationsToStella(tree.rest.value, false);

      if (declarations == null) {
        declarations = ((Cons)(Logic.kifTermToUntypedStellaTerm(tree.rest.value)));
      }
      else if (declarations.length() > 1) {
        { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream001.nativeStream.println("PARSING ERROR: Too many declarations in SETOFALL expression.");
              Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
            }
          }
          throw ((ParsingError)(ParsingError.newParsingError(stream001.theStringReader()).fillInStackTrace()));
        }
      }
      tree.secondSetter(declarations);
    }
    if (tree.rest.rest.value != null) {
      tree.thirdSetter(Logic.kifSentenceToUntypedStellaSentence(tree.rest.rest.value));
    }
    return (tree);
  }

  public static Cons kifKappaToStellaKappa(Cons tree) {
    if (!(tree.length() >= 2)) {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

          try {
            Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
            stream000.nativeStream.println("PARSING ERROR: Illegal KAPPA tree: `" + tree + "'.");
            Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

          } finally {
            Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
          }
        }
        throw ((ParsingError)(ParsingError.newParsingError(stream000.theStringReader()).fillInStackTrace()));
      }
    }
    { Cons sentences = tree.rest.rest;

      tree.secondSetter(Logic.kifVariableDeclarationsToStella(tree.rest.value, true));
      { ConsIterator it = sentences.allocateIterator();

        while (it.nextP()) {
          it.valueSetter(Logic.kifSentenceToUntypedStellaSentence(it.value));
        }
      }
      switch (sentences.length()) {
        case 0: 
          tree.rest.rest = Cons.cons(Logic.SYM_STELLA_TRUE, Stella.NIL);
        break;
        case 1: 
          tree.thirdSetter(tree.rest.rest.value);
        break;
        default:
          tree.rest.rest = Cons.cons(Cons.cons(Logic.SYM_STELLA_AND, sentences.concatenate(Stella.NIL, Stella.NIL)), Stella.NIL);
        break;
      }
      return (tree);
    }
  }

  public static Cons kifLambdaToStellaKappa(Cons tree) {
    { Symbol valuevariable = Stella.gensym("?v");
      Cons variables = ((Cons)(tree.rest.value));
      Stella_Object term = tree.rest.rest.value;
      boolean openquantifierP = (variables.length() == 2) &&
          (!Logic.questionMarkSymbolP(variables.rest.value));

      if (openquantifierP) {
        variables = Cons.cons(variables, Stella.NIL);
      }
      return (Cons.list$(Cons.cons(Logic.SYM_LOGIC_KAPPA, Cons.cons(variables.concatenate(Cons.cons(valuevariable, Stella.NIL), Stella.NIL), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_e, Cons.cons(valuevariable, Cons.cons(Cons.cons(term, Stella.NIL), Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))));
    }
  }

  public static Cons kifCondToIf(Cons conditions) {
    if (conditions == Stella.NIL) {
      return (Stella.NIL);
    }
    else {
      {
        if (!(Stella_Object.consP(conditions.value) &&
            (!(((Cons)(conditions.value)).rest.value == Stella.NIL)))) {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

              try {
                Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                stream000.nativeStream.println("PARSING ERROR: Illegal condition in 'COND': `" + conditions.value + "'.");
                Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

              } finally {
                Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
              }
            }
            throw ((ParsingError)(ParsingError.newParsingError(stream000.theStringReader()).fillInStackTrace()));
          }
        }
        { Cons firstcondition = ((Cons)(conditions.value));
          Cons valueterm = Logic.kifCondToIf(conditions.rest);

          if (!(valueterm == Stella.NIL)) {
            valueterm = Cons.consList(Cons.cons(valueterm, Stella.NIL));
          }
          return (Cons.list$(Cons.cons(Logic.SYM_STELLA_IF, Cons.cons(((Cons)(firstcondition.value)), Cons.cons(Cons.cons(((Cons)(firstcondition.rest.value)), valueterm.concatenate(Stella.NIL, Stella.NIL)), Stella.NIL)))));
        }
      }
    }
  }

  public static Stella_Object kifInvertSentence(Stella_Object tree) {
    if (Stella_Object.consP(tree) &&
        (((Cons)(tree)).value == Logic.SYM_STELLA_NOT)) {
      return (((Cons)(tree)).rest.value);
    }
    else {
      return (Cons.list$(Cons.cons(Logic.SYM_STELLA_NOT, Cons.cons(tree, Cons.cons(Stella.NIL, Stella.NIL)))));
    }
  }

  public static Cons kifImpliesToOrNot(Cons tree) {
    if (tree.length() < 2) {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

          try {
            Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
            stream000.nativeStream.println("PARSING ERROR: Illegal implication tree: `" + tree + "'.");
            Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

          } finally {
            Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
          }
        }
        throw ((ParsingError)(ParsingError.newParsingError(stream000.theStringReader()).fillInStackTrace()));
      }
    }
    if (((GeneralizedSymbol)(tree.value)) == Logic.SYM_STELLA_le) {
      tree.rest = tree.rest.reverse();
    }
    else {
    }
    Logic.changeKifExpressionsToStellaExpressions(tree.rest, false);
    tree.firstSetter(Logic.SYM_STELLA_OR);
    switch (tree.length()) {
      case 2: 
        return (((Cons)(tree.rest.value)));
      case 3: 
        tree.secondSetter(Logic.kifInvertSentence(tree.rest.value));
        return (tree);
      default:
        tree.rest = tree.rest.reverse();
        tree.rest.rest = Cons.cons(Cons.cons(Logic.SYM_STELLA_AND, tree.rest.rest.reverse().concatenate(Stella.NIL, Stella.NIL)), Stella.NIL);
        tree.rest = tree.rest.reverse();
        tree.secondSetter(Logic.kifInvertSentence(tree.rest.value));
        return (tree);
    }
  }

  public static Cons kifBiconditionalToTwoImplies(Cons tree) {
    if (tree.length() > 3) {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

          try {
            Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
            stream000.nativeStream.println("PARSING ERROR: Too many arguments to <=>: `" + tree + "'.");
            Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

          } finally {
            Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
          }
        }
        throw ((ParsingError)(ParsingError.newParsingError(stream000.theStringReader()).fillInStackTrace()));
      }
    }
    { Cons copy = ((Cons)(Stella_Object.copyConsTree(tree)));
      Stella_Object arrow = tree.value;
      Symbol forwardarrow = Logic.SYM_STELLA_eg;
      Symbol backwardarrow = Logic.SYM_STELLA_le;

      { GeneralizedSymbol testValue000 = ((GeneralizedSymbol)(arrow));

        if (testValue000 == Logic.SYM_LOGIC_legg) {
          forwardarrow = Logic.SYM_LOGIC_egg;
        }
        else if (testValue000 == Logic.SYM_LOGIC_lleg) {
          backwardarrow = Logic.SYM_LOGIC_lle;
        }
        else if (testValue000 == Logic.SYM_LOGIC_llegg) {
          forwardarrow = Logic.SYM_LOGIC_egg;
          backwardarrow = Logic.SYM_LOGIC_lle;
        }
        else if (testValue000 == Logic.SYM_LOGIC_ltg) {
          forwardarrow = Logic.SYM_LOGIC_tg;
          backwardarrow = Logic.SYM_LOGIC_lt;
        }
        else if (testValue000 == Logic.SYM_LOGIC_ltgg) {
          forwardarrow = Logic.SYM_LOGIC_tgg;
          backwardarrow = Logic.SYM_LOGIC_lt;
        }
        else if (testValue000 == Logic.SYM_LOGIC_lltg) {
          forwardarrow = Logic.SYM_LOGIC_tg;
          backwardarrow = Logic.SYM_LOGIC_llt;
        }
        else if (testValue000 == Logic.SYM_LOGIC_lltgg) {
          forwardarrow = Logic.SYM_LOGIC_tgg;
          backwardarrow = Logic.SYM_LOGIC_llt;
        }
        else {
        }
      }
      copy.firstSetter(forwardarrow);
      tree.firstSetter(backwardarrow);
      return (Cons.list$(Cons.cons(Logic.SYM_STELLA_AND, Cons.cons(tree, Cons.cons(Cons.cons(copy, Stella.NIL), Stella.NIL)))));
    }
  }

  public static Cons kifExistsToStellaExists(Cons tree) {
    if ((tree.length() < 3) ||
        (tree.length() > 4)) {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

          try {
            Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
            stream000.nativeStream.println("PARSING ERROR: Illegal EXISTS tree: `" + tree + "'.");
            Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

          } finally {
            Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
          }
        }
        throw ((ParsingError)(ParsingError.newParsingError(stream000.theStringReader()).fillInStackTrace()));
      }
    }
    { Stella_Object sentence1 = Logic.kifSentenceToUntypedStellaSentence(tree.rest.rest.value);
      Stella_Object sentence2 = Logic.kifSentenceToUntypedStellaSentence(tree.fourth());

      tree.secondSetter(Logic.kifVariableDeclarationsToStella(tree.rest.value, true));
      if (sentence2 != null) {
        return (Cons.list$(Cons.cons(Logic.SYM_STELLA_EXISTS, Cons.cons(tree.rest.value, Cons.cons(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_AND, Cons.cons(sentence1, Cons.cons(Cons.cons(sentence2, Stella.NIL), Stella.NIL)))), Stella.NIL), Stella.NIL)))));
      }
      tree.thirdSetter(sentence1);
      return (tree);
    }
  }

  public static Cons kifThreeArgumentForallToStellaForall(Cons tree, Cons declarations) {
    { Stella_Object antecedent = Logic.kifSentenceToUntypedStellaSentence(tree.rest.rest.value);
      Stella_Object consequent = Logic.kifSentenceToUntypedStellaSentence(tree.fourth());

      return (Cons.list$(Cons.cons(Logic.SYM_STELLA_FORALL, Cons.cons(declarations, Cons.cons(Cons.cons(antecedent, Cons.cons(consequent, Stella.NIL)), Stella.NIL)))));
    }
  }

  public static Cons kifTwoArgumentForallToStellaForall(Cons tree, Cons declarations) {
    { Stella_Object sentence = Logic.kifSentenceToUntypedStellaSentence(tree.rest.rest.value);

      if (Stella_Object.safePrimaryType(sentence) == Logic.SGT_STELLA_CONS) {
        { Cons sentence000 = ((Cons)(sentence));

          { GeneralizedSymbol testValue000 = ((GeneralizedSymbol)(sentence000.value));

            if (testValue000 == Logic.SYM_STELLA_AND) {
              { Cons foralls = Stella.NIL;

                { Stella_Object conjunct = null;
                  Cons iter000 = sentence000.rest;

                  for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                    conjunct = iter000.value;
                    foralls = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_FORALL, Cons.cons(Stella_Object.copyConsTree(tree.rest.value), Cons.cons(Cons.cons(conjunct, Stella.NIL), Stella.NIL)))), foralls);
                  }
                }
                return (((Cons)(Logic.kifSentenceToUntypedStellaSentence(Cons.cons(Logic.SYM_STELLA_AND, foralls.concatenate(Stella.NIL, Stella.NIL))))));
              }
            }
            else if (testValue000 == Logic.SYM_STELLA_OR) {
              { Stella_Object antecedent = Logic.kifInvertSentence(sentence000.rest.value);
                Stella_Object consequent = sentence000.rest.rest.value;

                return (Cons.list$(Cons.cons(Logic.SYM_STELLA_FORALL, Cons.cons(declarations, Cons.cons(Cons.cons(antecedent, Cons.cons(consequent, Stella.NIL)), Stella.NIL)))));
              }
            }
            else if (testValue000 == Logic.SYM_STELLA_FORALL) {
              { Stella_Object v = null;
                Cons iter001 = declarations;

                for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                  v = iter001.value;
                  sentence000.secondSetter(Cons.cons(v, ((Cons)(sentence000.rest.value))));
                }
              }
              return (sentence000);
            }
            else if (testValue000 == Logic.SYM_LOGIC_ABOUT) {
              return (Cons.list$(Cons.cons(Logic.SYM_LOGIC_ABOUT, Cons.cons(Logic.kifSentenceToUntypedStellaSentence(Cons.list$(Cons.cons(Logic.SYM_STELLA_FORALL, Cons.cons(declarations, Cons.cons(Cons.cons(sentence000.rest.value, Stella.NIL), Stella.NIL))))), Cons.cons(sentence000.rest.rest.concatenate(Stella.NIL, Stella.NIL), Stella.NIL)))));
            }
            else {
            }
          }
        }
      }
      else {
      }
      return (Cons.list$(Cons.cons(Logic.SYM_STELLA_FORALL, Cons.cons(declarations, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_TRUE, Cons.cons(sentence, Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL)))));
    }
  }

  public static Cons kifForallToStellaForall(Cons tree) {
    if ((tree.length() < 3) ||
        (tree.length() > 4)) {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

          try {
            Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
            stream000.nativeStream.println("PARSING ERROR: Illegal FORALL tree: `" + tree + "'.");
            Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

          } finally {
            Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
          }
        }
        throw ((ParsingError)(ParsingError.newParsingError(stream000.theStringReader()).fillInStackTrace()));
      }
    }
    { Cons declarations = Logic.kifVariableDeclarationsToStella(tree.rest.value, true);

      switch (tree.length()) {
        case 3: 
          return (Logic.kifTwoArgumentForallToStellaForall(tree, declarations));
        case 4: 
          return (Logic.kifThreeArgumentForallToStellaForall(tree, declarations));
        default:
          { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

            stream001.nativeStream.print("`" + tree.length() + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream001.theStringReader()).fillInStackTrace()));
          }
      }
    }
  }

  public static Cons kifPredicationToStellaPredication(Cons tree) {
    { Symbol operator = Logic.kifOperatorToInternalStella(((Symbol)(tree.value)));
      Cons arguments = tree.rest;

      tree.firstSetter(operator);
      Logic.changeKifExpressionsToStellaExpressions(arguments, true);
      return (tree);
    }
  }

  public static Cons helpTransformKifFunction(Stella_Object arg1, Stella_Object arg2) {
    if (!Stella_Object.consP(arg1)) {
      if (Stella_Object.safePrimaryType(arg2) == Logic.SGT_STELLA_CONS) {
        { Cons arg2000 = ((Cons)(arg2));

          if (!Logic.termKifSpecialFormP(arg2000.value)) {
            return (arg2000.concatenate(Cons.cons(arg1, Stella.NIL), Stella.NIL));
          }
        }
      }
      else {
      }
    }
    return (null);
  }

  public static Cons kifEqualityToStellaEquality(Cons tree) {
    if (tree.length() == 3) {
      { Cons functiontree = null;
        Stella_Object arg1 = tree.rest.value;
        Stella_Object arg2 = tree.rest.rest.value;

        { boolean testValue000 = false;

          { 
            functiontree = Logic.helpTransformKifFunction(arg1, arg2);
            testValue000 = functiontree != null;
          }
          if (!testValue000) {
            { 
              functiontree = Logic.helpTransformKifFunction(arg2, arg1);
              testValue000 = functiontree != null;
            }
          }
          if (testValue000) {
            if (Stella_Object.consP(functiontree.value)) {
              functiontree = Cons.cons(Logic.SYM_PL_KERNEL_KB_VALUE, functiontree);
            }
            functiontree.firstSetter(Logic.kifOperatorToInternalStella(((Symbol)(functiontree.value))));
            Logic.changeKifExpressionsToStellaExpressions(functiontree.rest, true);
            return (functiontree);
          }
        }
      }
    }
    Logic.changeKifExpressionsToStellaExpressions(tree.rest, true);
    return (tree);
  }

  public static Symbol kifOperatorToInternalStella(Symbol operator) {
    return (operator);
  }

  public static Symbol internalStellaOperatorToKif(Symbol operator) {
    return (operator);
  }

  public static void changeKifExpressionsToStellaExpressions(Cons expressions, boolean termsP) {
    { ConsIterator it = expressions.allocateIterator();

      while (it.nextP()) {
        it.valueSetter((termsP ? Logic.kifTermToUntypedStellaTerm(it.value) : Logic.kifSentenceToUntypedStellaSentence(it.value)));
      }
    }
  }

  public static Cons canonicalizeAnnotation(Cons tree) {
    { Stella_Object operator = tree.value;

      if (operator == Logic.KWD_ABOUT) {
        tree.firstSetter(Logic.SYM_LOGIC_ABOUT);
        return (tree);
      }
      { Cons entry = null;
        Cons iter000 = Logic.$ANNOTATION_TRANSLATION_TABLE$;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          entry = ((Cons)(iter000.value));
          if (Stella_Object.eqlP(operator, entry.value)) {
            tree.firstSetter(entry.rest.value);
            return (Cons.list$(Cons.cons(Logic.SYM_LOGIC_ABOUT, Cons.cons(tree, Cons.cons(((Cons)(Stella_Object.copyConsTree(((Cons)(entry.rest.rest.value))))).concatenate(Stella.NIL, Stella.NIL), Stella.NIL)))));
          }
        }
      }
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        stream000.nativeStream.print("``" + operator + "'' not found in *ANNOTATION-TRANSLATION-TABLE*");
        throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
      }
    }
  }

  public static Stella_Object kifSentenceToUntypedStellaSentence(Stella_Object tree) {
    if (tree == null) {
      return (null);
    }
    { Surrogate testValue000 = Stella_Object.safePrimaryType(tree);

      if (testValue000 == Logic.SGT_STELLA_CONS) {
        { Cons tree000 = ((Cons)(tree));

          { Stella_Object operator = tree000.value;

            if (Stella_Object.isaP(operator, Logic.SGT_STELLA_CONS)) {
              return (Logic.kifPredicationToStellaPredication(Cons.cons(Logic.SYM_PL_KERNEL_KB_HOLDS, tree000.concatenate(Stella.NIL, Stella.NIL))));
            }
            if (!Stella_Object.symbolP(operator)) {
              { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

                { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

                  try {
                    Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                    {
                      stream000.nativeStream.println("PARSING ERROR: Bad first argument in KIF sentence: `" + operator + "'");
                      stream000.nativeStream.println("   Operator must be a symbol or an expression.");
                    }
;
                    Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

                  } finally {
                    Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
                  }
                }
                throw ((ParsingError)(ParsingError.newParsingError(stream000.theStringReader()).fillInStackTrace()));
              }
            }
            { GeneralizedSymbol testValue001 = ((GeneralizedSymbol)(operator));

              if ((testValue001 == Logic.SYM_STELLA_AND) ||
                  ((testValue001 == Logic.SYM_STELLA_OR) ||
                   ((testValue001 == Logic.SYM_STELLA_NOT) ||
                    (testValue001 == Logic.SYM_LOGIC_FAIL)))) {
                Logic.changeKifExpressionsToStellaExpressions(tree000.rest, false);
                return (tree000);
              }
              else if ((testValue001 == Logic.SYM_STELLA_eg) ||
                  (testValue001 == Logic.SYM_STELLA_le)) {
                return (Logic.kifImpliesToOrNot(tree000));
              }
              else if ((testValue001 == Logic.SYM_LOGIC_leg) ||
                  ((testValue001 == Logic.SYM_LOGIC_legg) ||
                   ((testValue001 == Logic.SYM_LOGIC_lleg) ||
                    ((testValue001 == Logic.SYM_LOGIC_llegg) ||
                     ((testValue001 == Logic.SYM_LOGIC_ltg) ||
                      ((testValue001 == Logic.SYM_LOGIC_ltgg) ||
                       ((testValue001 == Logic.SYM_LOGIC_lltg) ||
                        (testValue001 == Logic.SYM_LOGIC_lltgg)))))))) {
                return (Logic.kifSentenceToUntypedStellaSentence(Logic.kifBiconditionalToTwoImplies(tree000)));
              }
              else if (testValue001 == Logic.SYM_STELLA_EXISTS) {
                return (Logic.kifExistsToStellaExists(tree000));
              }
              else if (testValue001 == Logic.SYM_STELLA_FORALL) {
                return (Logic.kifForallToStellaForall(tree000));
              }
              else if (testValue001 == Logic.SYM_STELLA_e) {
                return (Logic.kifEqualityToStellaEquality(tree000));
              }
              else if (testValue001 == Logic.SYM_LOGIC_ABOUT) {
                tree000.secondSetter(Logic.kifSentenceToUntypedStellaSentence(tree000.rest.value));
                return (tree000);
              }
              else if ((testValue001 == Logic.KWD_ABOUT) ||
                  ((testValue001 == Logic.SYM_LOGIC_lle) ||
                   ((testValue001 == Logic.SYM_LOGIC_egg) ||
                    ((testValue001 == Logic.SYM_LOGIC_lt) ||
                     ((testValue001 == Logic.SYM_LOGIC_tg) ||
                      ((testValue001 == Logic.SYM_LOGIC_llt) ||
                       (testValue001 == Logic.SYM_LOGIC_tgg))))))) {
                return (Logic.kifSentenceToUntypedStellaSentence(Logic.canonicalizeAnnotation(tree000)));
              }
              else {
                return (Logic.kifPredicationToStellaPredication(tree000));
              }
            }
          }
        }
      }
      else if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol tree000 = ((Symbol)(tree));

          return (Logic.kifSymbolToStellaSymbol(tree000));
        }
      }
      else if (Surrogate.subtypeOfStringP(testValue000)) {
        { StringWrapper tree000 = ((StringWrapper)(tree));

          { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

            { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

              try {
                Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                stream001.nativeStream.println("PARSING ERROR: Illegal term in sentence position: `" + tree000 + "'.");
                Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

              } finally {
                Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
              }
            }
            throw ((ParsingError)(ParsingError.newParsingError(stream001.theStringReader()).fillInStackTrace()));
          }
        }
      }
      else {
        return (tree);
      }
    }
  }

  public static boolean termKifSpecialFormP(Stella_Object operator) {
    return (Logic.$KIF_TERM_OPERATORS$.membP(operator));
  }

  public static Stella_Object kifTermToUntypedStellaTerm(Stella_Object tree) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(tree);

      if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol tree000 = ((Symbol)(tree));

          return (Logic.kifSymbolToStellaSymbol(tree000));
        }
      }
      else if (testValue000 == Logic.SGT_STELLA_CONS) {
        { Cons tree000 = ((Cons)(tree));

          { Stella_Object operator = tree000.value;

            if (Stella_Object.isaP(operator, Logic.SGT_STELLA_CONS)) {
              return (Logic.kifTermToUntypedStellaTerm(Cons.cons(Logic.SYM_PL_KERNEL_KB_VALUE, tree000.concatenate(Stella.NIL, Stella.NIL))));
            }
            if (!Stella_Object.symbolP(operator)) {
              { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

                { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

                  try {
                    Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                    {
                      stream000.nativeStream.println("PARSING ERROR: Bad first argument in KIF term: `" + operator + "'");
                      stream000.nativeStream.println("   Operator must be a symbol or an expression.");
                    }
;
                    Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

                  } finally {
                    Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
                  }
                }
                throw ((ParsingError)(ParsingError.newParsingError(stream000.theStringReader()).fillInStackTrace()));
              }
            }
            if (Logic.$KIF_SENTENCE_OPERATORS$.memberP(operator)) {
              return (Logic.kifSentenceToUntypedStellaSentence(tree000));
            }
            else if (Logic.termKifSpecialFormP(operator)) {
              { GeneralizedSymbol testValue001 = ((GeneralizedSymbol)(operator));

                if (testValue001 == Logic.SYM_LOGIC_THE) {
                  return (Logic.kifTheToStellaTheOnly(tree000));
                }
                else if (testValue001 == Logic.SYM_LOGIC_SETOFALL) {
                  return (Logic.kifSetofallToStellaSetofall(tree000));
                }
                else if (testValue001 == Logic.SYM_LOGIC_KAPPA) {
                  return (Logic.kifKappaToStellaKappa(tree000));
                }
                else if (testValue001 == Logic.SYM_LOGIC_LAMBDA) {
                  return (Logic.kifTermToUntypedStellaTerm(Logic.kifLambdaToStellaKappa(tree000)));
                }
                else if (testValue001 == Logic.SYM_STELLA_IF) {
                  tree000.secondSetter(Logic.kifSentenceToUntypedStellaSentence(tree000.rest.value));
                  Logic.changeKifExpressionsToStellaExpressions(tree000.rest.rest, true);
                  return (tree000);
                }
                else if (testValue001 == Logic.SYM_STELLA_COND) {
                  return (Logic.kifTermToUntypedStellaTerm(Logic.kifCondToIf(tree000.rest)));
                }
                else if ((testValue001 == Logic.SYM_STELLA_SETOF) ||
                    (testValue001 == Logic.SYM_LOGIC_LISTOF)) {
                  Logic.changeKifExpressionsToStellaExpressions(tree000.rest, true);
                  return (tree000);
                }
                else {
                  { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

                    stream001.nativeStream.print("`" + testValue001 + "' is not a valid case option");
                    throw ((StellaException)(StellaException.newStellaException(stream001.theStringReader()).fillInStackTrace()));
                  }
                }
              }
            }
            else {
              tree000.firstSetter(Logic.kifOperatorToInternalStella(((Symbol)(operator))));
              Logic.changeKifExpressionsToStellaExpressions(tree000.rest, true);
              return (tree000);
            }
          }
        }
      }
      else {
        return (tree);
      }
    }
  }

  public static boolean kifVariableP(Stella_Object self) {
    return (Logic.questionMarkSymbolP(self));
  }

  public static Cons extractVariablesFromDeclarations(Stella_Object declarations) {
    { Cons result = Stella.NIL;

      if (Stella_Object.safePrimaryType(declarations) == Logic.SGT_STELLA_CONS) {
        { Cons declarations000 = ((Cons)(declarations));

          { Stella_Object item = null;
            Cons iter000 = declarations000;

            for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
              item = iter000.value;
              if (Stella_Object.safePrimaryType(item) == Logic.SGT_STELLA_CONS) {
                { Cons item000 = ((Cons)(item));

                  if (Logic.kifVariableP(item000.value)) {
                    result = Cons.cons(item000.value, result);
                  }
                  else {
                    { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

                      { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

                        try {
                          Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                          stream000.nativeStream.println("PARSING ERROR: Non-variable `" + item000.value + "' found where ?variable expected.");
                          Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

                        } finally {
                          Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
                        }
                      }
                      throw ((ParsingError)(ParsingError.newParsingError(stream000.theStringReader()).fillInStackTrace()));
                    }
                  }
                }
              }
              else {
                if (Logic.kifVariableP(item)) {
                  result = Cons.cons(item, result);
                }
              }
            }
          }
        }
      }
      else {
        if (Logic.kifVariableP(declarations)) {
          result = Cons.cons(declarations, result);
        }
        else {
          { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

            { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

              try {
                Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                stream001.nativeStream.println("PARSING ERROR: Non-variable `" + declarations + "' found where ?variable expected.");
                Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

              } finally {
                Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
              }
            }
            throw ((ParsingError)(ParsingError.newParsingError(stream001.theStringReader()).fillInStackTrace()));
          }
        }
      }
      return (result.reverse());
    }
  }

  public static void collectUndeclaredVariables(Stella_Object tree, Cons declaredvariables, List undeclaredvariables) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(tree);

      if (testValue000 == Logic.SGT_STELLA_CONS) {
        { Cons tree000 = ((Cons)(tree));

          { Stella_Object operator = tree000.value;

            { Surrogate testValue001 = Stella_Object.safePrimaryType(operator);

              if (testValue001 == Logic.SGT_STELLA_CONS) {
                { Cons operator000 = ((Cons)(operator));

                  Logic.collectUndeclaredVariables(operator000, declaredvariables, undeclaredvariables);
                  { Stella_Object arg = null;
                    Cons iter000 = tree000.rest;

                    for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                      arg = iter000.value;
                      Logic.collectUndeclaredVariables(arg, declaredvariables, undeclaredvariables);
                    }
                  }
                }
              }
              else if (Surrogate.subtypeOfSymbolP(testValue001)) {
                { Symbol operator000 = ((Symbol)(operator));

                  if ((operator000 == Logic.SYM_STELLA_EXISTS) ||
                      (operator000 == Logic.SYM_STELLA_FORALL)) {
                    { Stella_Object v = null;
                      Cons iter001 = Logic.extractVariablesFromDeclarations(tree000.rest.value);

                      for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                        v = iter001.value;
                        declaredvariables = Cons.cons(v, declaredvariables);
                      }
                    }
                    { Stella_Object arg = null;
                      Cons iter002 = tree000.rest.rest;

                      for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
                        arg = iter002.value;
                        Logic.collectUndeclaredVariables(arg, declaredvariables, undeclaredvariables);
                      }
                    }
                  }
                  else if ((operator000 == Logic.SYM_LOGIC_SETOFALL) ||
                      ((operator000 == Logic.SYM_LOGIC_KAPPA) ||
                       ((operator000 == Logic.SYM_LOGIC_LAMBDA) ||
                        (operator000 == Logic.SYM_LOGIC_THE)))) {
                  }
                  else {
                    { Stella_Object arg = null;
                      Cons iter003 = tree000.rest;

                      for (;!(iter003 == Stella.NIL); iter003 = iter003.rest) {
                        arg = iter003.value;
                        Logic.collectUndeclaredVariables(arg, declaredvariables, undeclaredvariables);
                      }
                    }
                  }
                }
              }
              else {
              }
            }
          }
        }
      }
      else if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol tree000 = ((Symbol)(tree));

          if (Logic.questionMarkSymbolP(tree000) &&
              (!declaredvariables.memberP(tree000))) {
            if (!undeclaredvariables.memberP(tree000)) {
              undeclaredvariables.insertLast(tree000);
            }
          }
        }
      }
      else {
      }
    }
  }

  public static Stella_Object wrapKifWithForall(Stella_Object tree, Cons declaredvariables) {
    if (Stella_Object.safePrimaryType(tree) == Logic.SGT_STELLA_CONS) {
      { Cons tree000 = ((Cons)(tree));

        if (Stella_Object.symbolP(tree000.value)) {
          { GeneralizedSymbol testValue000 = ((GeneralizedSymbol)(tree000.value));

            if (testValue000 == Logic.SYM_STELLA_AND) {
              { Cons sentences = Stella.NIL;

                { Stella_Object conjunct = null;
                  Cons iter000 = tree000.rest;
                  Cons collect000 = null;

                  for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                    conjunct = iter000.value;
                    if (collect000 == null) {
                      {
                        collect000 = Cons.cons(Logic.wrapKifWithForall(conjunct, declaredvariables), Stella.NIL);
                        if (sentences == Stella.NIL) {
                          sentences = collect000;
                        }
                        else {
                          Cons.addConsToEndOfConsList(sentences, collect000);
                        }
                      }
                    }
                    else {
                      {
                        collect000.rest = Cons.cons(Logic.wrapKifWithForall(conjunct, declaredvariables), Stella.NIL);
                        collect000 = collect000.rest;
                      }
                    }
                  }
                }
                return (Cons.cons(Logic.SYM_STELLA_AND, sentences.concatenate(Stella.NIL, Stella.NIL)));
              }
            }
            else if (testValue000 == Logic.SYM_LOGIC_leg) {
              return (Logic.wrapKifWithForall(Logic.kifBiconditionalToTwoImplies(tree000), declaredvariables));
            }
            else {
            }
          }
        }
      }
    }
    else {
    }
    { List undeclaredvariables = List.newList();

      Logic.collectUndeclaredVariables(tree, declaredvariables, undeclaredvariables);
      switch (undeclaredvariables.length()) {
        case 0: 
          undeclaredvariables.free();
          return (tree);
        case 1: 
          return (Cons.list$(Cons.cons(Logic.SYM_STELLA_FORALL, Cons.cons(undeclaredvariables.first(), Cons.cons(Cons.cons(tree, Stella.NIL), Stella.NIL)))));
        default:
          return (Cons.list$(Cons.cons(Logic.SYM_STELLA_FORALL, Cons.cons(Stella_Object.copyConsTree(undeclaredvariables.theConsList), Cons.cons(Cons.cons(tree, Stella.NIL), Stella.NIL)))));
      }
    }
  }

  public static Stella_Object kifExpressionToUntypedStellaExpression(Stella_Object tree) {
    if (Stella_Object.safePrimaryType(tree) == Logic.SGT_STELLA_CONS) {
      { Cons tree000 = ((Cons)(tree));

        if (Stella_Object.symbolP(tree000.value)) {
          { GeneralizedSymbol testValue000 = ((GeneralizedSymbol)(tree000.value));

            if ((testValue000 == Logic.SYM_LOGIC_THE) ||
                ((testValue000 == Logic.SYM_LOGIC_SETOFALL) ||
                 (testValue000 == Logic.SYM_LOGIC_KAPPA))) {
              return (Logic.kifTermToUntypedStellaTerm(tree000));
            }
            else {
            }
          }
        }
      }
    }
    else {
    }
    tree = Logic.wrapKifWithForall(tree, Stella.NIL);
    return (Logic.kifSentenceToUntypedStellaSentence(tree));
  }

  public static Stella_Object convertToPrefixPropositionTree(Stella_Object tree) {
    if (Stella_Object.safePrimaryType(tree) == Logic.SGT_STELLA_CONS) {
      { Cons tree000 = ((Cons)(tree));

        { Symbol operator = ((Symbol)(tree000.value));

          if (Logic.kifQuantifierSymbolP(operator)) {
            tree000 = Logic.infixToPrefixQuantificationTree(tree000);
          }
          else {
            { ConsIterator it = tree000.rest.allocateIterator();

              while (it.nextP()) {
                if (Stella_Object.consP(it.value)) {
                  it.valueSetter(Logic.convertToPrefixPropositionTree(it.value));
                }
              }
            }
          }
          return (tree000);
        }
      }
    }
    else {
      return (tree);
    }
  }

  public static Cons infixToPrefixQuantificationTree(Cons tree) {
    { Stella_Object quantifier = tree.value;
      Cons generatorsclause = null;
      Stella_Object whereclause = null;
      Stella_Object alwaysclause = null;
      Cons residue = tree.rest;
      Cons otree = null;

      { Object [] caller_MV_returnarray = new Object[1];

        generatorsclause = Cons.extractGeneratorsClause(residue, caller_MV_returnarray);
        residue = ((Cons)(caller_MV_returnarray[0]));
      }
      if (generatorsclause == null) {
        return (null);
      }
      { Object [] caller_MV_returnarray = new Object[1];

        whereclause = Symbol.extractOptionAndResidue(Logic.SYM_STELLA_WHERE, residue, caller_MV_returnarray);
        residue = ((Cons)(caller_MV_returnarray[0]));
      }
      { Object [] caller_MV_returnarray = new Object[1];

        alwaysclause = Symbol.extractOptionAndResidue(Logic.SYM_STELLA_ALWAYS, residue, caller_MV_returnarray);
        residue = ((Cons)(caller_MV_returnarray[0]));
      }
      otree = Cons.cons(quantifier, Cons.cons(Logic.convertToPrefixPropositionTree(generatorsclause), (((whereclause != null) ? Cons.cons(Logic.convertToPrefixPropositionTree(whereclause), Stella.NIL) : Stella.getQuotedTree("((TRUE) \"/LOGIC\")", "/LOGIC"))).concatenate((((alwaysclause != null) ? Cons.cons(Logic.convertToPrefixPropositionTree(alwaysclause), Stella.NIL) : Stella.NIL)).concatenate(Stella.NIL, Stella.NIL), Stella.NIL)));
      if (!(residue == Stella.NIL)) {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream000.nativeStream.println("PARSING ERROR: Extra expressions at the end of quantified expression.");
              Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
            }
          }
          throw ((ParsingError)(ParsingError.newParsingError(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      return (otree);
    }
  }

  public static Stella_Object standardizeLogicalParseTree(Stella_Object tree) {
    { Stella_Object standardizedtree = null;

      if (((Keyword)(Logic.$LOGIC_DIALECT$.get())) == Logic.KWD_KIF) {
        standardizedtree = Logic.kifExpressionToUntypedStellaExpression(tree);
      }
      else if (((Keyword)(Logic.$LOGIC_DIALECT$.get())) == Logic.KWD_STELLA) {
        standardizedtree = Logic.convertToPrefixPropositionTree(tree);
      }
      else if (((Keyword)(Logic.$LOGIC_DIALECT$.get())) == Logic.KWD_PREFIX_STELLA) {
        standardizedtree = tree;
      }
      else if (((Keyword)(Logic.$LOGIC_DIALECT$.get())) == Logic.KWD_MELD) {
      }
      else if (((Keyword)(Logic.$LOGIC_DIALECT$.get())) == Logic.KWD_LOOM) {
        standardizedtree = Logic.kifExpressionToUntypedStellaExpression(tree);
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + ((Keyword)(Logic.$LOGIC_DIALECT$.get())) + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      return (standardizedtree);
    }
  }

  /** Change the current logic dialect to <code>dialect</code>.
   * Currently supported dialects are <code>KIF</code>, <code>STELLA</code>, and <code>PREFIX_STELLA</code>.
   * The STELLA dialects are not recommended for the construction of knowledge
   * bases, they are mainly used internally by PowerLoom.
   * @param dialect
   * @return Keyword
   */
  public static Keyword inDialect(Stella_Object dialect) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(dialect);

      if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol dialect000 = ((Symbol)(dialect));

          Native.setSpecial(Logic.$LOGIC_DIALECT$, dialect000.keywordify());
        }
      }
      else if (Surrogate.subtypeOfStringP(testValue000)) {
        { StringWrapper dialect000 = ((StringWrapper)(dialect));

          Native.setSpecial(Logic.$LOGIC_DIALECT$, Stella.string_keywordify(dialect000.wrapperValue));
        }
      }
      else if (Surrogate.subtypeOfKeywordP(testValue000)) {
        { Keyword dialect000 = ((Keyword)(dialect));

          Native.setSpecial(Logic.$LOGIC_DIALECT$, dialect000);
        }
      }
      else {
        Stella.STANDARD_WARNING.nativeStream.println("Warning: IN-DIALECT: Illegal dialect specification: `" + dialect + "'");
      }
    }
    return (((Keyword)(Logic.$LOGIC_DIALECT$.get())));
  }

  public static String stringifiedSource(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        { NamedDescription self000 = ((NamedDescription)(self));

          return (self000.objectStringifiedSource);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          return (((StringWrapper)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_OBJECT_STRINGIFIED_SOURCE, Stella.NULL_STRING_WRAPPER))).wrapperValue);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          return (((StringWrapper)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_PROPOSITION_STRINGIFIED_SOURCE, Stella.NULL_STRING_WRAPPER))).wrapperValue);
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  public static String stringifiedSourceSetter(Stella_Object self, String value) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        { NamedDescription self000 = ((NamedDescription)(self));

          self000.objectStringifiedSource = value;
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          KeyValueList.setDynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_OBJECT_STRINGIFIED_SOURCE, StringWrapper.wrapString(value), Stella.NULL_STRING_WRAPPER);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          KeyValueList.setDynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_PROPOSITION_STRINGIFIED_SOURCE, StringWrapper.wrapString(value), Stella.NULL_STRING_WRAPPER);
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
    return (value);
  }

  public static List originatedPropositions(Stella_Object self) {
    { Stella_Object value = null;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

        if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
          { NamedDescription self000 = ((NamedDescription)(self));

            value = self000.objectOriginatedPropositions;
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
          { LogicObject self000 = ((LogicObject)(self));

            value = ((List)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_OBJECT_ORIGINATED_PROPOSITIONS, null)));
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
          { Proposition self000 = ((Proposition)(self));

            value = ((List)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_PROPOSITION_ORIGINATED_PROPOSITIONS, null)));
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
      if (value == null) {
        return (Stella.NIL_LIST);
      }
      else {
        return (((List)(value)));
      }
    }
  }

  public static List originatedPropositionsSetter(Stella_Object self, List value) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        { NamedDescription self000 = ((NamedDescription)(self));

          self000.objectOriginatedPropositions = value;
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          KeyValueList.setDynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_OBJECT_ORIGINATED_PROPOSITIONS, value, null);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          KeyValueList.setDynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_PROPOSITION_ORIGINATED_PROPOSITIONS, value, null);
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
    return (value);
  }

  public static Proposition createProposition(Symbol kind, int argumentcount) {
    Logic.enforceCodeOnly();
    { Proposition proposition = Proposition.newProposition();

      proposition.arguments = Vector.newVector(argumentcount);
      proposition.kind = Stella.internKeyword(kind.symbolName);
      if ((kind == Logic.SYM_STELLA_FUNCTION) ||
          ((kind == Logic.SYM_STELLA_PREDICATE) ||
           (kind == Logic.SYM_STELLA_ISA))) {
      }
      else {
        proposition.operator = ((Surrogate)(Logic.$OPERATOR_NAME_TO_SURROGATE_TABLE$.lookup(proposition.kind)));
      }
      if (Logic.descriptionModeP()) {
        KeyValueList.setDynamicSlotValue(proposition.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTIVEp, Stella.TRUE_WRAPPER, Stella.FALSE_WRAPPER);
      }
      KeyValueList.setDynamicSlotValue(proposition.dynamicSlots, Logic.SYM_LOGIC_UNFASTENEDp, Stella.TRUE_WRAPPER, null);
      return (proposition);
    }
  }

  public static void enforceCodeOnly() {
    if (((BooleanWrapper)(KeyValueList.dynamicSlotValue(((Module)(Stella.$MODULE$.get())).dynamicSlots, Logic.SYM_STELLA_CODE_ONLYp, Stella.FALSE_WRAPPER))).wrapperValue) {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

          try {
            Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
            {
              stream000.nativeStream.println("ERROR: Can't create a relation, instance or proposition in module:");
              stream000.nativeStream.println("       `" + ((Module)(Stella.$MODULE$.get())).moduleName + "'");
              stream000.nativeStream.println("    because it is marked as 'code-only?'");
              stream000.nativeStream.println(".");
            }
;
            Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

          } finally {
            Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
          }
        }
        throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
      }
    }
  }

  /** Return TRUE if 'self' is a logic module, implying
   * that relations defined within it define a knowledge base.  A module
   * is a logic module iff it inherits the module 'PL-KERNEL'.
   * @param self
   * @return boolean
   */
  public static boolean logicModuleP(Module self) {
    { boolean testValue000 = false;

      if (self == Logic.$PL_KERNEL_MODULE$) {
        testValue000 = true;
      }
      else {
        {
          { boolean foundP000 = false;

            { Module m = null;
              Cons iter000 = self.parentModules.theConsList;

              loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                m = ((Module)(iter000.value));
                if (Logic.logicModuleP(m)) {
                  foundP000 = true;
                  break loop000;
                }
              }
            }
            testValue000 = foundP000;
          }
          if (!testValue000) {
            { boolean foundP001 = false;

              { Module m = null;
                Cons iter001 = self.uses.theConsList;

                loop001 : for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                  m = ((Module)(iter001.value));
                  if (Logic.logicModuleP(m)) {
                    foundP001 = true;
                    break loop001;
                  }
                }
              }
              testValue000 = foundP001;
            }
          }
        }
      }
      { boolean value000 = testValue000;

        return (value000);
      }
    }
  }

  public static SequenceIndex locallyConceivedPropositions(Module self) {
    { SequenceIndex propositions = ((SequenceIndex)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_LOCALLY_CONCEIVED_PROPOSITIONS_INTERNAL, null)));

      if (propositions == null) {
        propositions = Logic.createSequenceIndex(Logic.KWD_PAGING, Cons.cons(Logic.KWD_CONTEXT_PROPOSITIONS, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(self, Stella.NIL))));
        KeyValueList.setDynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_LOCALLY_CONCEIVED_PROPOSITIONS_INTERNAL, propositions, null);
      }
      return (propositions);
    }
  }

  public static void locallyConceivedPropositionsSetter(Module self, SequenceIndex value) {
    KeyValueList.setDynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_LOCALLY_CONCEIVED_PROPOSITIONS_INTERNAL, value, null);
  }

  public static SequenceIndex locallyConceivedInstances(Context self) {
    { SequenceIndex instances = ((SequenceIndex)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_LOCALLY_CONCEIVED_INSTANCES_INTERNAL, null)));

      if (instances == null) {
        instances = Logic.createSequenceIndex(Logic.KWD_PAGING, Cons.cons(Logic.KWD_CONTEXT_INSTANCES, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(self, Stella.NIL))));
        KeyValueList.setDynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_LOCALLY_CONCEIVED_INSTANCES_INTERNAL, instances, null);
      }
      return (instances);
    }
  }

  public static void locallyConceivedInstancesSetter(Context self, SequenceIndex value) {
    KeyValueList.setDynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_LOCALLY_CONCEIVED_INSTANCES_INTERNAL, value, null);
  }

  public static void incrementNowTimestamp() {
    Logic.$NOW_TIMESTAMP$ = Logic.$NOW_TIMESTAMP$ + 1;
  }

  public static int getNowTimestamp() {
    return (Logic.$NOW_TIMESTAMP$);
  }

  public static void updateNowTimestamp(Keyword kbaction) {
    if (kbaction == Logic.$LAST_KB_ACTION$) {
      return;
    }
    if (kbaction == Logic.KWD_UPDATE_PROPOSITION) {
      if (Logic.descriptionModeP() ||
          ((!(((Module)(Stella.$MODULE$.get())) == ((Context)(Stella.$CONTEXT$.get())))) ||
           ((Boolean)(Logic.$INVISIBLEASSERTIONp$.get())).booleanValue())) {
        return;
      }
      Logic.incrementNowTimestamp();
    }
    else if (kbaction == Logic.KWD_EXECUTE_QUERY) {
    }
    else {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        stream000.nativeStream.print("`" + kbaction + "' is not a valid case option");
        throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
      }
    }
    Logic.$LAST_KB_ACTION$ = kbaction;
  }

  /** Return TRUE if 'self' is the undefined individual BOTTOM.
   * @param self
   * @return boolean
   */
  public static boolean bottomP(Stella_Object self) {
    return (self == Logic.BOTTOM);
  }

  public static boolean logicalSubtypeOfP(Surrogate type1, Surrogate type2) {
    if (type1 == type2) {
      return (true);
    }
    else {
      { NamedDescription desc1 = Logic.getDescription(type1);
        NamedDescription desc2 = Logic.getDescription(type2);

        if ((desc1 == null) ||
            (desc2 == null)) {
          return (false);
        }
        return (NamedDescription.subrelationOfP(desc1, desc2));
      }
    }
  }

  public static boolean logicalSubtypeOfLiteralP(Surrogate type) {
    { NamedDescription desc = Logic.surrogateToDescription(type);
      NamedDescription literalclass = Logic.surrogateToDescription(Logic.SGT_STELLA_LITERAL);
      Cons literalsubs = Stella.NIL;

      if (desc == null) {
        return (false);
      }
      else if (desc == literalclass) {
        return (true);
      }
      else {
        { Object old$ReversepolarityP$000 = Logic.$REVERSEPOLARITYp$.get();
          Object old$Context$000 = Stella.$CONTEXT$.get();

          try {
            Native.setBooleanSpecial(Logic.$REVERSEPOLARITYp$, false);
            Native.setSpecial(Stella.$CONTEXT$, Logic.getPropertyTestContext());
            { MemoizationTable memoTable000 = null;
              Cons memoizedEntry000 = null;
              Stella_Object memoizedValue000 = null;

              if (Stella.$MEMOIZATION_ENABLEDp$) {
                memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_LOGICAL_SUBTYPE_OF_LITERALp_MEMO_TABLE_000.surrogateValue));
                if (memoTable000 == null) {
                  Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_LOGICAL_SUBTYPE_OF_LITERALp_MEMO_TABLE_000, "(:MAX-VALUES 10 :TIMESTAMPS (:META-KB-UPDATE))");
                  memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_LOGICAL_SUBTYPE_OF_LITERALp_MEMO_TABLE_000.surrogateValue));
                }
                memoizedEntry000 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable000)), ((Context)(Stella.$CONTEXT$.get())), Stella.MEMOIZED_NULL_VALUE, null, null, -1);
                memoizedValue000 = memoizedEntry000.value;
              }
              if (memoizedValue000 != null) {
                if (memoizedValue000 == Stella.MEMOIZED_NULL_VALUE) {
                  memoizedValue000 = null;
                }
              }
              else {
                memoizedValue000 = LogicObject.allSubcollections(literalclass).consify();
                if (Stella.$MEMOIZATION_ENABLEDp$) {
                  memoizedEntry000.value = ((memoizedValue000 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue000);
                }
              }
              literalsubs = ((Cons)(memoizedValue000));
            }
            if (literalsubs.membP(desc)) {
              return (true);
            }

          } finally {
            Stella.$CONTEXT$.set(old$Context$000);
            Logic.$REVERSEPOLARITYp$.set(old$ReversepolarityP$000);
          }
        }
      }
      return (false);
    }
  }

  public static boolean literalTypeP(Surrogate type) {
    { Stella_Object value = type.surrogateValue;

      return (Stella_Object.isaP(value, Logic.SGT_STELLA_CLASS) &&
          (Surrogate.subtypeOfP(type, Logic.SGT_STELLA_LITERAL) ||
           Surrogate.subtypeOfP(type, Logic.SGT_STELLA_LITERAL_WRAPPER)));
    }
  }

  public static boolean booleanTypeP(Surrogate self) {
    return ((self == Logic.SGT_STELLA_BOOLEAN) ||
        (self == Logic.SGT_STELLA_BOOLEAN_WRAPPER));
  }

  public static boolean propositionTypeP(Surrogate self) {
    return (self == Logic.SGT_LOGIC_PROPOSITION);
  }

  public static boolean monadicP(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description self000 = ((Description)(self));

          return (self000.arity() == 1);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_COLLECTION)) {
        { Collection self000 = ((Collection)(self));

          return (true);
        }
      }
      else {
        return (false);
      }
    }
  }

  /** Return the surrogate naming the object <code>self</code>, which
   * may be a Stella class that is used in PowerLoom as well as
   * a more normal powerloom object.
   * @param self
   * @return Surrogate
   */
  public static Surrogate objectSurrogate(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          return (self000.surrogateValueInverse);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          return (((Surrogate)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_STELLA_SURROGATE_VALUE_INVERSE, null))));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing self000 = ((Thing)(self));

          return (self000.surrogateValueInverse);
        }
      }
      else if (Surrogate.subtypeOfClassP(testValue000)) {
        { Stella_Class self000 = ((Stella_Class)(self));

          return (self000.classType);
        }
      }
      else {
        return (null);
      }
    }
  }

  /** Return the name of the logic object <code>self</code> to <code>name</code>.
   * @param self
   * @param name
   * @return Surrogate
   */
  public static Surrogate objectSurrogateSetter(Stella_Object self, Surrogate name) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          self000.surrogateValueInverse = name;
          return (name);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          KeyValueList.setDynamicSlotValue(self000.dynamicSlots, Logic.SYM_STELLA_SURROGATE_VALUE_INVERSE, name, null);
          return (name);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing self000 = ((Thing)(self));

          self000.surrogateValueInverse = name;
          return (name);
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  /** Return the name symbol for the logic object <code>self</code>.
   * @param self
   * @return Symbol
   */
  public static Symbol objectName(Stella_Object self) {
    { Surrogate surrogate = Logic.objectSurrogate(self);

      if (surrogate != null) {
        return (Symbol.internSymbolInModule(surrogate.symbolName, ((Module)(surrogate.homeContext)), true));
      }
      else {
        return (null);
      }
    }
  }

  /** Return the name string for the logic object <code>self</code>.
   * @param self
   * @return String
   */
  public static String objectNameString(Stella_Object self) {
    { Surrogate surrogate = Logic.objectSurrogate(self);

      if (surrogate != null) {
        return (surrogate.symbolName);
      }
      else {
        return (null);
      }
    }
  }

  public static String objectStringName(Stella_Object self) {
    return (Logic.objectNameString(self));
  }

  public static boolean descriptionModeP() {
    return (((Keyword)(Logic.$EVALUATIONMODE$.get())) == Logic.KWD_DESCRIPTION);
  }

  /** True if normalization is governed by natural
   * deduction semantics.
   * @return boolean
   */
  public static boolean naturalDeductionModeP() {
    return (((Boolean)(Logic.$NATURALDEDUCTIONMODEp$.get())).booleanValue());
  }

  public static boolean contextDependentSearchModeP() {
    return (Logic.$CONTEXT_DEPENDENT_SEARCH_MODEp$);
  }

  public static void logNewlyConceivedProposition(Module self, Proposition proposition) {
    { boolean testValue000 = false;

      { boolean foundP000 = false;

        { Stella_Object arg = null;
          Vector vector000 = proposition.arguments;
          int index000 = 0;
          int length000 = vector000.length();

          loop000 : for (;index000 < length000; index000 = index000 + 1) {
            arg = (vector000.theArray)[index000];
            if (Stella_Object.isaP(arg, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
              foundP000 = true;
              break loop000;
            }
          }
        }
        testValue000 = foundP000;
      }
      if (testValue000) {
        testValue000 = Logic.$POWERLOOM_EXECUTION_MODE$ == Logic.KWD_DEVELOPMENT;
      }
      if (testValue000) {
        { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

          try {
            Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
            {
              Stella.STANDARD_WARNING.nativeStream.println("WARNING: LOGGED QUESTIONABLE CONCEPTION: ");
              Stella.STANDARD_WARNING.nativeStream.println("   " + proposition);
            }
;
            Logic.helpSignalPropositionError(Stella.STANDARD_WARNING, Logic.KWD_WARNING);

          } finally {
            Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
          }
        }
      }
    }
    Logic.locallyConceivedPropositions(self).insert(proposition);
  }

  public static Context tickleContext() {
    { NamedDescription description = Logic.getDescription(Logic.SGT_PL_KERNEL_KB_HIDDEN_RELATION);

      LogicObject.assertProperty(description, Logic.SGT_PL_KERNEL_KB_HIDDEN_RELATION);
      LogicObject.updateProperty(description, Logic.SGT_PL_KERNEL_KB_HIDDEN_RELATION, Logic.KWD_RETRACT_TRUE);
      return (((Context)(Stella.$CONTEXT$.get())));
    }
  }

  public static Context tickleInstances() {
    { Stella_Object temp000 = Logic.getInstance(StringWrapper.wrapString("HIDDEN-INSTANCE"));

      { Stella_Object instance = ((temp000 != null) ? temp000 : Logic.createLogicInstance(Logic.SGT_LOGIC_HIDDEN_INSTANCE, null));

        LogicObject.assertProperty(((LogicObject)(instance)), Logic.SGT_PL_KERNEL_KB_HIDDEN_RELATION);
        LogicObject.updateProperty(((LogicObject)(instance)), Logic.SGT_PL_KERNEL_KB_HIDDEN_RELATION, Logic.KWD_RETRACT_TRUE);
        return (((Context)(Stella.$CONTEXT$.get())));
      }
    }
  }

  /** Return a list of all currently known inconsistent proposition in the module defined
   * by the :module option (which defaults to the current module).  If <code>ClocalP</code> is specified
   * as TRUE only look in the specified module but not any modules it inherits.  Note, that
   * this simply reports propositions that have been assigned an inconsistent truth value so
   * far (e.g., in clash exceptions), it will not try to detect any new or all inconsistencies
   * in a module.
   * @param options
   * @return Cons
   */
  public static Cons listInconsistentPropositions(Cons options) {
    { PropertyList theoptions = Stella_Object.parseOptions(options, Cons.list$(Cons.cons(Logic.KWD_MODULE, Cons.cons(Logic.SGT_STELLA_MODULE, Cons.cons(Logic.KWD_LOCALp, Cons.cons(Logic.SGT_STELLA_BOOLEAN, Cons.cons(Stella.NIL, Stella.NIL)))))), true, false);
      Module themodule = ((Module)(theoptions.lookupWithDefault(Logic.KWD_MODULE, ((Module)(Stella.$MODULE$.get())))));
      boolean localP = BooleanWrapper.coerceWrappedBooleanToBoolean(((BooleanWrapper)(theoptions.lookupWithDefault(Logic.KWD_LOCALp, Stella.FALSE_WRAPPER))));

      return (Logic.allInconsistentPropositions(themodule, localP).consify());
    }
  }

  public static Cons listInconsistentPropositionsEvaluatorWrapper(Cons arguments) {
    return (Logic.listInconsistentPropositions(arguments));
  }

  public static void clearNativeSlotValue(Thing renamed_Object, StorageSlot slot) {
    StandardObject.putSlotValue(renamed_Object, slot, null);
  }

  public static void dropNativeSlotValue(Thing self, StorageSlot slot, Stella_Object value) {
    { Stella_Object oldvalue = StandardObject.readSlotValue(self, slot);

      if (Stella_Object.eqlP(value, oldvalue)) {
        Logic.clearNativeSlotValue(self, slot);
      }
    }
  }

  public static Surrogate lookupSlotrefOnInstance(Stella_Object term, Symbol slotname) {
    { Surrogate termtype = null;

      termtype = Logic.safeLogicalType(term);
      if (termtype == null) {
        return (null);
      }
      if ((termtype.surrogateValue == null) ||
          ((!Stella_Object.isaP(termtype.surrogateValue, Logic.SGT_STELLA_CLASS)) ||
           (termtype == Logic.SGT_STELLA_THING))) {
        return (null);
      }
      if (Symbol.lookupFunction(slotname) != null) {
        return (null);
      }
      { Surrogate surrogate = Surrogate.lookupSlotref(termtype, slotname);

        if (surrogate != null) {
          return (surrogate);
        }
        if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(term), Logic.SGT_LOGIC_LOGIC_OBJECT)) {
          { LogicObject term000 = ((LogicObject)(term));

            { Proposition prop = null;
              Iterator iter000 = Logic.unfilteredDependentIsaPropositions(term000).allocateIterator();

              while (iter000.nextP()) {
                prop = ((Proposition)(iter000.value));
                if (prop.kind == Logic.KWD_ISA) {
                  surrogate = Surrogate.lookupSlotref(((Surrogate)(prop.operator)), slotname);
                  if (surrogate != null) {
                    return (surrogate);
                  }
                }
              }
            }
          }
        }
        else {
        }
        if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(term), Logic.SGT_LOGIC_SKOLEM)) {
          { Skolem term000 = ((Skolem)(term));

            if ((term000.definingProposition != null) &&
                Stella_Object.isaP(term000.definingProposition.operator, Logic.SGT_STELLA_SURROGATE)) {
              { NamedDescription description = Logic.getDescription(((Surrogate)(term000.definingProposition.operator)));

                if (description != null) {
                  termtype = ((Surrogate)(description.ioVariableTypes.last()));
                  surrogate = Surrogate.lookupSlotref(termtype, slotname);
                  if (surrogate != null) {
                    return (surrogate);
                  }
                }
              }
            }
          }
        }
        else {
        }
        return (null);
      }
    }
  }

  public static Stella_Object valueOf(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
        { Skolem self000 = ((Skolem)(self));

          if (((Stella_Object)(Stella_Object.accessInContext(self000.variableValue, self000.homeContext, false))) == null) {
            return (self000);
          }
          else {
            return (Logic.valueOf(((Stella_Object)(Stella_Object.accessInContext(self000.variableValue, self000.homeContext, false)))));
          }
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate self000 = ((Surrogate)(self));

          return (Logic.surrogateDvalueOf(self000));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_RELATION)) {
        { Relation self000 = ((Relation)(self));

          return (Logic.relationDvalueOf(self000));
        }
      }
      else {
        return (self);
      }
    }
  }

  public static Stella_Object surrogateDvalueOf(Surrogate self) {
    { Stella_Object value = self.surrogateValue;

      if (value != null) {
        return (Logic.valueOf(value));
      }
      else {
        {
          if (Stella.dottedStringP(self.symbolName)) {
            { Slot slot = ((Slot)(Stella.stringToSlot(self.symbolName)));

              if (slot != null) {
                return (Logic.valueOf(slot));
              }
            }
          }
          if (!(((Boolean)(Logic.$SUPPRESSNONLOGICOBJECTWARNINGp$.get())).booleanValue())) {
            Logic.signalUndefinedTerm(StringWrapper.wrapString(self.symbolName));
          }
          return (null);
        }
      }
    }
  }

  public static Description relationDvalueOf(Relation self) {
    { NamedDescription description = ((NamedDescription)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null)));

      if (description != null) {
        return (description);
      }
      if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(self), Logic.SGT_STELLA_RELATION)) {
        { Relation self000 = ((Relation)(self));

          description = Logic.getDescription(self000);
        }
      }
      else {
      }
      if (description != null) {
        return (description);
      }
      if (!(((Boolean)(Logic.$SUPPRESSNONLOGICOBJECTWARNINGp$.get())).booleanValue())) {
        { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

          try {
            Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
            Stella.STANDARD_WARNING.nativeStream.println("WARNING: value-of: encountered missing description on class or relation " + self.name());
            Logic.helpSignalPropositionError(Stella.STANDARD_WARNING, Logic.KWD_WARNING);

          } finally {
            Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
          }
        }
      }
      return (null);
    }
  }

  public static Stella_Object equivalentValueOf(Stella_Object self) {
    if (self == null) {
      return (null);
    }
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(self), Logic.SGT_LOGIC_LOGIC_OBJECT)) {
      { LogicObject self000 = ((LogicObject)(self));

        if (((Description)(Stella_Object.accessInContext(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_EQUIVALENT_VALUE, null), self000.homeContext, false))) != null) {
          return (Logic.equivalentValueOf(((Description)(Stella_Object.accessInContext(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_EQUIVALENT_VALUE, null), self000.homeContext, false)))));
        }
        else {
          return (self000);
        }
      }
    }
    else {
      return (self);
    }
  }

  public static Stella_Object groundValueOf(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable self000 = ((PatternVariable)(self));

          { Stella_Object value = null;

            if ((self000.boundToOffset != Stella.NULL_INTEGER) &&
                ((Boolean)(Logic.$COMPUTEDQUERYp$.get())).booleanValue()) {
              value = (((QueryIterator)(Logic.$QUERYITERATOR$.get())).currentPatternRecord.variableBindings.theArray)[(self000.boundToOffset)];
            }
            if (value == null) {
              value = ((Stella_Object)(Stella_Object.accessInContext(self000.variableValue, self000.homeContext, false)));
            }
            if (value != null) {
              return (Logic.groundValueOf(value));
            }
            else {
              return (null);
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
        { Skolem self000 = ((Skolem)(self));

          { Stella_Object value = ((Stella_Object)(Stella_Object.accessInContext(self000.variableValue, self000.homeContext, false)));

            if (value != null) {
              return (Logic.groundValueOf(value));
            }
            else {
              return (null);
            }
          }
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate self000 = ((Surrogate)(self));

          { Stella_Object value = self000.surrogateValue;

            if (value != null) {
              return (Logic.groundValueOf(value));
            }
            else {
              return (null);
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_RELATION)) {
        { Relation self000 = ((Relation)(self));

          return (((NamedDescription)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))));
        }
      }
      else {
        return (self);
      }
    }
  }

  public static boolean skolemP(Stella_Object self) {
    return ((self != null) &&
        Stella_Object.isaP(self, Logic.SGT_LOGIC_SKOLEM));
  }

  public static boolean variableP(Stella_Object self) {
    return ((self != null) &&
        Stella_Object.isaP(self, Logic.SGT_LOGIC_PATTERN_VARIABLE));
  }

  public static boolean nativeValueP(Stella_Object self) {
    if (self != null) {
      return (!Stella_Object.isaP(self, Logic.SGT_LOGIC_LOGIC_OBJECT));
    }
    else {
      return (false);
    }
  }

  public static Stella_Object nativeValueOf(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable self000 = ((PatternVariable)(self));

          { Stella_Object value = Logic.groundValueOf(self000);

            if (value != null) {
              return (Logic.nativeValueOf(value));
            }
            else {
              return (null);
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
        { Skolem self000 = ((Skolem)(self));

          { Stella_Object value = ((Stella_Object)(Stella_Object.accessInContext(self000.variableValue, self000.homeContext, false)));

            if (value != null) {
              return (Logic.nativeValueOf(value));
            }
            else {
              return (null);
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          return (null);
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate self000 = ((Surrogate)(self));

          { Stella_Object value = self000.surrogateValue;

            if (value != null) {
              return (Logic.nativeValueOf(value));
            }
            else {
              return (null);
            }
          }
        }
      }
      else {
        return (self);
      }
    }
  }

  public static Stella_Object innermostOf(Stella_Object self) {
    if (Logic.descriptionModeP()) {
      { Stella_Object nextvalue = self;
        PatternVariable tightestvariable = null;
        Stella_Object equivalent = null;

        for (;;) {
          { Surrogate testValue000 = Stella_Object.safePrimaryType(nextvalue);

            if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
              { PatternVariable nextvalue000 = ((PatternVariable)(nextvalue));

                equivalent = ((Stella_Object)(Stella_Object.accessInContext(nextvalue000.variableValue, nextvalue000.homeContext, false)));
                if (equivalent == null) {
                  return (nextvalue000);
                }
                tightestvariable = nextvalue000;
              }
            }
            else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
              { Description nextvalue000 = ((Description)(nextvalue));

                return (nextvalue000);
              }
            }
            else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
              { LogicObject nextvalue000 = ((LogicObject)(nextvalue));

                return (tightestvariable);
              }
            }
            else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
              { Surrogate nextvalue000 = ((Surrogate)(nextvalue));

                return (nextvalue000);
              }
            }
            else {
              return (nextvalue);
            }
          }
          nextvalue = equivalent;
        }
      }
    }
    else {
      { Stella_Object tightestvalue = self;
        Stella_Object equivalent = null;

        for (;;) {
          { Surrogate testValue001 = Stella_Object.safePrimaryType(tightestvalue);

            if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_SKOLEM)) {
              { Skolem tightestvalue000 = ((Skolem)(tightestvalue));

                if (((Stella_Object)(Stella_Object.accessInContext(tightestvalue000.variableValue, tightestvalue000.homeContext, false))) == null) {
                  return (tightestvalue000);
                }
                equivalent = ((Stella_Object)(Stella_Object.accessInContext(tightestvalue000.variableValue, tightestvalue000.homeContext, false)));
              }
            }
            else if (Surrogate.subtypeOfSurrogateP(testValue001)) {
              { Surrogate tightestvalue000 = ((Surrogate)(tightestvalue));

                if (tightestvalue000.surrogateValue == null) {
                  return (tightestvalue000);
                }
                equivalent = tightestvalue000.surrogateValue;
              }
            }
            else {
              return (tightestvalue);
            }
          }
          tightestvalue = equivalent;
        }
      }
    }
  }

  public static Symbol yieldAnonymousSkolemName(boolean variableP) {
    { String suffix = (variableP ? Native.integerToString(((long)(Native.setIntSpecial(Logic.$VARIABLEIDCOUNTER$, ((Integer)(Logic.$VARIABLEIDCOUNTER$.get())).intValue() + 1)))) : Native.integerToString(((long)(Logic.$SKOLEM_ID_COUNTER$ = Logic.$SKOLEM_ID_COUNTER$ + 1))));

      return (Symbol.internSymbol(((variableP ? "?V" : "SK")) + (((suffix.length() == 1) ? "0" : "")) + suffix));
    }
  }

  public static Skolem createSkolem(Surrogate type, Symbol name) {
    { Skolem skolem = Skolem.newSkolem();

      if (((Cons)(Logic.$FREESKOLEMS$.get())) != null) {
        Native.setSpecial(Logic.$FREESKOLEMS$, Cons.cons(skolem, ((Cons)(Logic.$FREESKOLEMS$.get()))));
      }
      Skolem.helpCreateSkolem(skolem, type, name, true);
      return (skolem);
    }
  }

  public static PatternVariable createVariable(Surrogate type, Symbol name, boolean assertisaP) {
    { Keyword evaluationmode = ((Keyword)(Logic.$EVALUATIONMODE$.get()));

      { Object old$Evaluationmode$000 = Logic.$EVALUATIONMODE$.get();

        try {
          Native.setSpecial(Logic.$EVALUATIONMODE$, evaluationmode);
          if (assertisaP &&
              (!Logic.descriptionModeP())) {
            Native.setSpecial(Logic.$EVALUATIONMODE$, Logic.KWD_DESCRIPTION);
          }
          return (((PatternVariable)(Skolem.helpCreateSkolem(PatternVariable.newPatternVariable(), type, name, assertisaP))));

        } finally {
          Logic.$EVALUATIONMODE$.set(old$Evaluationmode$000);
        }
      }
    }
  }

  public static Skolem createVariableOrSkolem(Surrogate type, Symbol name) {
    if (Logic.descriptionModeP()) {
      return (Logic.createVariable(type, name, false));
    }
    else {
      { Skolem skolem = Skolem.newSkolem();

        { Object old$InvisibleassertionP$000 = Logic.$INVISIBLEASSERTIONp$.get();

          try {
            Native.setBooleanSpecial(Logic.$INVISIBLEASSERTIONp$, true);
            Skolem.helpCreateSkolem(skolem, type, name, false);

          } finally {
            Logic.$INVISIBLEASSERTIONp$.set(old$InvisibleassertionP$000);
          }
        }
        return (skolem);
      }
    }
  }

  public static TruthValue defaultifyTruthValue(boolean trueP, boolean bydefaultP) {
    return ((trueP ? ((bydefaultP ? Logic.DEFAULT_TRUE_TRUTH_VALUE : Logic.TRUE_TRUTH_VALUE)) : ((bydefaultP ? Logic.DEFAULT_FALSE_TRUTH_VALUE : Logic.FALSE_TRUTH_VALUE))));
  }

  public static Surrogate logicalType(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description self000 = ((Description)(self));

          if (Logic.monadicP(self000) &&
              ((BooleanWrapper)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_IOTAp, Stella.FALSE_WRAPPER))).wrapperValue) {
            return (((PatternVariable)((self000.ioVariables.theArray)[0])).skolemType);
          }
          else if (Logic.monadicP(self000) &&
              (self000.ioVariables.nonEmptyP() &&
               ((((PatternVariable)((self000.ioVariables.theArray)[0])).skolemType != null) &&
                NamedDescription.classDescriptionP(Logic.surrogateToDescription(((PatternVariable)((self000.ioVariables.theArray)[0])).skolemType))))) {
            return (Logic.SGT_PL_KERNEL_KB_CONCEPT);
          }
          else {
            return (Logic.SGT_PL_KERNEL_KB_RELATION);
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable self000 = ((PatternVariable)(self));

          { Surrogate type = self000.skolemType;

            if ((type != null) &&
                (!(type == Logic.SGT_STELLA_THING))) {
              return (type);
            }
          }
          { Proposition p = null;
            Iterator iter000 = Logic.unfilteredDependentIsaPropositions(self000).allocateIterator();

            while (iter000.nextP()) {
              p = ((Proposition)(iter000.value));
              if ((p.kind == Logic.KWD_ISA) &&
                  BooleanWrapper.coerceWrappedBooleanToBoolean(p.variableTypeP())) {
                return (((Surrogate)(p.operator)));
              }
            }
          }
          return (Logic.SGT_STELLA_THING);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
        { Skolem self000 = ((Skolem)(self));

          if (self000.skolemType != null) {
            return (self000.skolemType);
          }
          else {
            return (Logic.SGT_STELLA_THING);
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          return (Logic.SGT_STELLA_THING);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          return (Logic.SGT_LOGIC_PROPOSITION);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_LITERAL_WRAPPER)) {
        { LiteralWrapper self000 = ((LiteralWrapper)(self));

          return (Wrapper.wrapperValueType(self000));
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate self000 = ((Surrogate)(self));

          if ((self000.surrogateValue != null) &&
              (!(self000.surrogateValue == Logic.BOTTOM))) {
            return (Logic.logicalType(self000.surrogateValue));
          }
          else {
            return (Logic.SGT_STELLA_THING);
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_SET)) {
        { Set self000 = ((Set)(self));

          return (Logic.SGT_PL_KERNEL_KB_SET);
        }
      }
      else if (Surrogate.subtypeOfClassP(testValue000)) {
        { Stella_Class self000 = ((Stella_Class)(self));

          return (Logic.SGT_PL_KERNEL_KB_CONCEPT);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_SLOT)) {
        { Slot self000 = ((Slot)(self));

          if (Logic.booleanTypeP(self000.slotBaseType)) {
            return (Logic.SGT_PL_KERNEL_KB_RELATION);
          }
          else {
            return (Logic.SGT_PL_KERNEL_KB_FUNCTION);
          }
        }
      }
      else {
        return (self.primaryType());
      }
    }
  }

  public static Surrogate safeLogicalType(Stella_Object self) {
    { Object old$SuppressuntypedtypeerrorP$000 = Logic.$SUPPRESSUNTYPEDTYPEERRORp$.get();

      try {
        Native.setBooleanSpecial(Logic.$SUPPRESSUNTYPEDTYPEERRORp$, true);
        return (Logic.logicalType(self));

      } finally {
        Logic.$SUPPRESSUNTYPEDTYPEERRORp$.set(old$SuppressuntypedtypeerrorP$000);
      }
    }
  }

  public static Surrogate classLogicalType(Stella_Class self) {
    return (self.classType);
  }

  public static boolean hasEquivalentValuesP(Stella_Object term) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(term);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
        { Skolem term000 = ((Skolem)(term));

          return ((((Stella_Object)(Stella_Object.accessInContext(term000.variableValue, term000.homeContext, false))) != null) ||
              (!(term000.variableValueInverse() == Stella.NIL)));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject term000 = ((LogicObject)(term));

          return (!(term000.variableValueInverse() == Stella.NIL));
        }
      }
      else {
        { boolean foundP000 = false;

          { Proposition prop = null;
            Iterator iter000 = Logic.unfilteredDependentPropositions(term, Logic.SGT_PL_KERNEL_KB_EQUIVALENT).allocateIterator();

            loop000 : while (iter000.nextP()) {
              prop = ((Proposition)(iter000.value));
              if ((prop.operator == Logic.SGT_PL_KERNEL_KB_EQUIVALENT) &&
                  (Logic.descriptionModeP() ||
                   ((!prop.deletedP()) &&
                    ((((Boolean)(Logic.$REVERSEPOLARITYp$.get())).booleanValue() ? Proposition.falseP(prop) : (Proposition.trueP(prop) ||
                  Proposition.functionWithDefinedValueP(prop))))))) {
                foundP000 = true;
                break loop000;
              }
            }
          }
          { boolean value000 = foundP000;

            return (value000);
          }
        }
      }
    }
  }

  public static Cons getEquivalentValues(Stella_Object term) {
    { Cons equivs = Stella.NIL;

      if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(term), Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject term000 = ((LogicObject)(term));

          { Stella_Object rep = Logic.valueOf(term000);

            if (rep == term000) {
              equivs = term000.variableValueInverse();
            }
            else {
              equivs = Cons.cons(rep, equivs);
              { Stella_Object equiv = null;
                Cons iter000 = Logic.getEquivalentValues(rep);
                Cons collect000 = null;

                for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                  equiv = iter000.value;
                  if (!(equiv == term000)) {
                    if (collect000 == null) {
                      {
                        collect000 = Cons.cons(equiv, Stella.NIL);
                        if (equivs == Stella.NIL) {
                          equivs = collect000;
                        }
                        else {
                          Cons.addConsToEndOfConsList(equivs, collect000);
                        }
                      }
                    }
                    else {
                      {
                        collect000.rest = Cons.cons(equiv, Stella.NIL);
                        collect000 = collect000.rest;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      else {
        { Cons beenthere = Stella.NIL;
          Cons seeds = Cons.cons(term, Stella.NIL);
          Cons newequivs = Stella.NIL;

          while (!(seeds == Stella.NIL)) {
            { Stella_Object seed = null;
              Cons iter001 = seeds;

              for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                seed = iter001.value;
                { Proposition prop = null;
                  Iterator iter002 = Logic.unfilteredDependentPropositions(seed, Logic.SGT_PL_KERNEL_KB_EQUIVALENT).allocateIterator();

                  while (iter002.nextP()) {
                    prop = ((Proposition)(iter002.value));
                    if ((prop.operator == Logic.SGT_PL_KERNEL_KB_EQUIVALENT) &&
                        ((Logic.descriptionModeP() ||
                        ((!prop.deletedP()) &&
                         ((((Boolean)(Logic.$REVERSEPOLARITYp$.get())).booleanValue() ? Proposition.falseP(prop) : (Proposition.trueP(prop) ||
                        Proposition.functionWithDefinedValueP(prop)))))) &&
                         (!beenthere.membP(prop)))) {
                      beenthere = Cons.cons(prop, beenthere);
                      { Stella_Object arg = null;
                        Vector vector000 = prop.arguments;
                        int index000 = 0;
                        int length000 = vector000.length();
                        Cons collect001 = null;

                        for (;index000 < length000; index000 = index000 + 1) {
                          arg = (vector000.theArray)[index000];
                          if (!equivs.memberP(arg)) {
                            if (collect001 == null) {
                              {
                                collect001 = Cons.cons(arg, Stella.NIL);
                                if (newequivs == Stella.NIL) {
                                  newequivs = collect001;
                                }
                                else {
                                  Cons.addConsToEndOfConsList(newequivs, collect001);
                                }
                              }
                            }
                            else {
                              {
                                collect001.rest = Cons.cons(arg, Stella.NIL);
                                collect001 = collect001.rest;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            { Stella_Object equiv = null;
              Cons iter003 = newequivs;

              for (;!(iter003 == Stella.NIL); iter003 = iter003.rest) {
                equiv = iter003.value;
                equivs = Cons.cons(equiv, equivs);
              }
            }
            seeds = newequivs;
            newequivs = Stella.NIL;
          }
          equivs = equivs.remove(term);
        }
      }
      return (equivs);
    }
  }

  public static boolean logicCollectionP(Stella_Object term) {
    return (Logic.testTypeOnInstanceP(term, Logic.SGT_STELLA_COLLECTION));
  }

  public static boolean unequateValuesP(Stella_Object term1, Stella_Object term2) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(term1), Logic.SGT_LOGIC_SKOLEM)) {
      { Skolem term1000 = ((Skolem)(term1));

        if (Stella_Object.eqlP(((Stella_Object)(Stella_Object.accessInContext(term1000.variableValue, term1000.homeContext, false))), term2)) {
          Skolem.unbindSkolemValue(term1000, false);
          return (true);
        }
      }
    }
    else {
    }
    return (false);
  }

  public static Proposition findEquatingProposition(Stella_Object directobject, LogicObject indirectobject) {
    { Stella_Object indirectobjectvalue = Logic.valueOf(indirectobject);
      Stella_Object backlinkedindirectobject = indirectobjectvalue;

      if (!Stella_Object.isaP(backlinkedindirectobject, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        backlinkedindirectobject = indirectobject;
      }
      { Proposition value000 = null;

        { Proposition prop = null;
          Iterator iter000 = ((Iterator)((Logic.descriptionModeP() ? Logic.unfilteredDependentPropositions(backlinkedindirectobject, Logic.SGT_PL_KERNEL_KB_EQUIVALENT).allocateIterator() : Logic.allTrueDependentPropositions(backlinkedindirectobject, Logic.SGT_PL_KERNEL_KB_EQUIVALENT, false))));

          loop000 : while (iter000.nextP()) {
            prop = ((Proposition)(iter000.value));
            if ((prop.operator == Logic.SGT_PL_KERNEL_KB_EQUIVALENT) &&
                ((Stella_Object.eqlP((prop.arguments.theArray)[0], directobject) &&
                Stella_Object.eqlP(Logic.valueOf((prop.arguments.theArray)[1]), indirectobjectvalue)) ||
                 (Stella_Object.eqlP((prop.arguments.theArray)[1], directobject) &&
                  Stella_Object.eqlP(Logic.valueOf((prop.arguments.theArray)[0]), indirectobjectvalue)))) {
              value000 = prop;
              break loop000;
            }
          }
        }
        { Proposition value001 = value000;

          return (value001);
        }
      }
    }
  }

  public static Stella_Object evaluateTerm(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_LITERAL_WRAPPER)) {
        { LiteralWrapper self000 = ((LiteralWrapper)(self));

          return (Logic.evaluateLiteralWrapperTerm(self000));
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate self000 = ((Surrogate)(self));

          return (Logic.evaluateSurrogateTerm(self000));
        }
      }
      else if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol self000 = ((Symbol)(self));

          return (Logic.evaluateSymbolTerm(self000));
        }
      }
      else if (testValue000 == Logic.SGT_STELLA_CONS) {
        { Cons self000 = ((Cons)(self));

          { GeneralizedSymbol testValue001 = ((GeneralizedSymbol)(self000.value));

            if ((testValue001 == Logic.SYM_LOGIC_SETOFALL) ||
                ((testValue001 == Logic.SYM_LOGIC_THE_ONLY) ||
                 (testValue001 == Logic.SYM_LOGIC_KAPPA))) {
              return (LogicObject.evaluateLogicObjectTerm(Logic.evaluateDescriptionTerm(self000, true)));
            }
            else if (testValue001 == Logic.SYM_LOGIC_CREATE) {
              return (Logic.evaluateCreateTerm(self000));
            }
            else {
              return (Logic.evaluateFunctionTerm(self000));
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          return (LogicObject.evaluateLogicObjectTerm(self000));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          return (self000);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing self000 = ((Thing)(self));

          return (self000);
        }
      }
      else if (Surrogate.subtypeOfKeywordP(testValue000)) {
        { Keyword self000 = ((Keyword)(self));

          return (self000);
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("Can't evaluate the term `" + self + "'");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  public static Stella_Object evaluateLiteralWrapperTerm(LiteralWrapper self) {
    if (Logic.$BACKLINK_ALL_PROPOSITION_ARGUMENTSp$) {
      return (Logic.rewrapArgument(self));
    }
    else {
      return (self);
    }
  }

  public static Stella_Object evaluateSurrogateTerm(Surrogate self) {
    if (((Keyword)(Logic.$EVALUATIONMODE$.get())) == Logic.KWD_EXTENSIONAL_ASSERTION) {
      { Stella_Object value = self.surrogateValue;
        ObjectStore store = null;

        if (value != null) {
          if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(value), Logic.SGT_STELLA_RELATION)) {
            { Relation value000 = ((Relation)(value));

              return (Logic.getDescription(self));
            }
          }
          else {
            return (value);
          }
        }
        else {
          self = Logic.coerceToBoundOrLocalSurrogate(self);
          store = Logic.homeObjectStore(self);
          if (store != null) {
            store.fetchInstance(self);
          }
          if (self.surrogateValue == null) {
            Logic.createLogicInstance(self, null);
          }
          return (self.surrogateValue);
        }
      }
    }
    else if (((Keyword)(Logic.$EVALUATIONMODE$.get())) == Logic.KWD_DESCRIPTION) {
      { Stella_Object surrogatevalue = self.surrogateValue;
        ObjectStore store = null;

        if (surrogatevalue == null) {
          self = Logic.coerceToBoundOrLocalSurrogate(self);
          store = Logic.homeObjectStore(self);
          if (store != null) {
            store.fetchInstance(self);
          }
          if (self.surrogateValue == null) {
            Logic.createLogicInstance(self, null);
          }
          return (self);
        }
        else if (Stella_Object.isaP(surrogatevalue, Logic.SGT_STELLA_LITERAL_WRAPPER)) {
          return (surrogatevalue);
        }
        else {
          return (self);
        }
      }
    }
    else if (((Keyword)(Logic.$EVALUATIONMODE$.get())) == Logic.KWD_INTENSIONAL_ASSERTION) {
      { Stella_Object directvalue = self.surrogateValue;
        Skolem intensionalskolem = null;

        if (Logic.skolemP(directvalue)) {
          return (directvalue);
        }
        intensionalskolem = Logic.createSkolem(((directvalue != null) ? Logic.logicalType(Logic.valueOf(directvalue)) : null), null);
        self.surrogateValue = intensionalskolem;
        Skolem.bindSkolemToValue(intensionalskolem, directvalue, false);
        return (intensionalskolem);
      }
    }
    else {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        stream000.nativeStream.print("`" + ((Keyword)(Logic.$EVALUATIONMODE$.get())) + "' is not a valid case option");
        throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
      }
    }
  }

  public static Stella_Object evaluateSymbolTerm(Symbol self) {
    { Stella_Object value = Logic.lookupLogicVariableBinding(self);

      if (value != null) {
        return (value);
      }
      else if (self == Logic.ANONYMOUS_VARIABLE_NAME) {
        return (Logic.createVariable(null, Logic.ANONYMOUS_VARIABLE_NAME, false));
      }
      else if (Logic.questionMarkSymbolP(self)) {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream000.nativeStream.println("ERROR: Reference to undeclared variable: `" + self + "'.");
              Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
            }
          }
          throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      else if (Logic.automaticInstanceSymbolP(self)) {
        return (Logic.evaluateAutomaticInstance(self));
      }
      else {
        value = Symbol.symbolToSurrogate(self).surrogateValue;
        if (value != null) {
          return (value);
        }
        else {
          { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

            { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

              try {
                Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                stream001.nativeStream.println("ERROR: Reference to undeclared symbol: `" + self + "'.");
                Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

              } finally {
                Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
              }
            }
            throw ((PropositionError)(PropositionError.newPropositionError(stream001.theStringReader()).fillInStackTrace()));
          }
        }
      }
    }
  }

  public static Stella_Object evaluateAutomaticInstance(Symbol name) {
    if (((KeyValueList)(Logic.$AUTOMATICINSTANCETABLE$.get())) == Logic.$MISSING_KEY_VALUE_LIST$) {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

          try {
            Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
            {
              stream000.nativeStream.println("ERROR: Automatic instance `" + name + "' found outside");
              stream000.nativeStream.println("   the scope of an assertion..");
            }
;
            Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

          } finally {
            Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
          }
        }
        throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
      }
    }
    { LogicObject instance = ((((KeyValueList)(Logic.$AUTOMATICINSTANCETABLE$.get())) != null) ? ((LogicObject)(((KeyValueList)(Logic.$AUTOMATICINSTANCETABLE$.get())).lookup(name))) : ((LogicObject)(null)));

      if (instance == null) {
        { Surrogate surrogate = Stella.stringToSurrogate(Stella.gensym(Native.string_subsequence(name.symbolName, 1, Stella.NULL_INTEGER)).symbolName);

          instance = ((LogicObject)(Logic.createLogicInstance(surrogate, null)));
          if (((KeyValueList)(Logic.$AUTOMATICINSTANCETABLE$.get())) == null) {
            Native.setSpecial(Logic.$AUTOMATICINSTANCETABLE$, KeyValueList.newKeyValueList());
          }
          ((KeyValueList)(Logic.$AUTOMATICINSTANCETABLE$.get())).insertAt(name, instance);
        }
      }
      return (LogicObject.evaluateLogicObjectTerm(instance));
    }
  }

  public static void signalUndefinedTerm(Stella_Object term) {
    { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

      { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

        try {
          Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
          stream000.nativeStream.println("ERROR: Reference to undefined term: `" + term + "'.");
          Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

        } finally {
          Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
        }
      }
      throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
    }
  }

  public static void signalUntypedTerm(Stella_Object term) {
    if (!((Boolean)(Logic.$SUPPRESSUNTYPEDTYPEERRORp$.get())).booleanValue()) {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

          try {
            Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
            stream000.nativeStream.println("ERROR: Need a type for the untyped term: `" + term + "'.");
            Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

          } finally {
            Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
          }
        }
        throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
      }
    }
  }

  public static Stella_Object evaluateCreateTerm(Cons term) {
    { Symbol namesymbol = ((Symbol)(term.rest.value));
      Surrogate name = ((namesymbol != null) ? Symbol.symbolToSurrogate(namesymbol) : ((Surrogate)(null)));
      Symbol typesymbol = ((Symbol)(term.rest.rest.value));
      Surrogate type = ((typesymbol != null) ? Symbol.symbolToSurrogate(typesymbol) : ((Surrogate)(null)));
      Stella_Object term000 = null;

      try {
        term000 = Logic.createLogicInstance(name, type);
      } catch (LogicException e) {
        Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
      }
      return (term000);
    }
  }

  /** Create a logic object with name 'name' and return it.
   * If <code>type</code> is also supplied, assert that the object belongs to that type.
   * @param name
   * @param type
   * @return Stella_Object
   */
  public static Stella_Object create(GeneralizedSymbol name, Cons type) {
    { Cons createtree = Cons.list$(Cons.cons(Logic.SYM_LOGIC_CREATE, Cons.cons(name, Cons.cons(type.concatenate(Stella.NIL, Stella.NIL), Stella.NIL))));
      Stella_Object result = Logic.evaluateCreateTerm(createtree);

      return (result);
    }
  }

  public static Stella_Object createEvaluatorWrapper(Cons arguments) {
    return (Logic.create(((GeneralizedSymbol)(arguments.value)), arguments.rest));
  }

  /** Print the extension sizes of concepts visible in <code>module</code>.
   * If <code>module</code> is NULL the current module is used.  Do not report extensions
   * with size less than <code>sizecutoff</code> (default is 10).
   * @param module
   * @param sizecutoff
   */
  public static void printExtensionSizes(Module module, int sizecutoff) {
    if (sizecutoff == Stella.NULL_INTEGER) {
      sizecutoff = 10;
    }
    if (module == null) {
      module = ((Module)(Stella.$MODULE$.get()));
    }
    { List descriptions = List.newList();
      String size = null;

      { NamedDescription d = null;
        Iterator iter000 = Logic.allNamedDescriptions(module, false);
        Cons collect000 = null;

        while (iter000.nextP()) {
          d = ((NamedDescription)(iter000.value));
          if ((d.extension != null) &&
              (d.extension.estimatedLength() >= sizecutoff)) {
            if (collect000 == null) {
              {
                collect000 = Cons.cons(d, Stella.NIL);
                if (descriptions.theConsList == Stella.NIL) {
                  descriptions.theConsList = collect000;
                }
                else {
                  Cons.addConsToEndOfConsList(descriptions.theConsList, collect000);
                }
              }
            }
            else {
              {
                collect000.rest = Cons.cons(d, Stella.NIL);
                collect000 = collect000.rest;
              }
            }
          }
        }
      }
      descriptions.sort(Native.find_java_method("edu.isi.powerloom.logic.Description", "descriptionExtensionL", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.Description"), Native.find_java_class("edu.isi.powerloom.logic.Description")}));
      { NamedDescription desc = null;
        Cons iter001 = descriptions.reverse().theConsList;

        for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
          desc = ((NamedDescription)(iter001.value));
          size = Native.integerToString(((long)(desc.extension.estimatedLength())));
          size = Native.makeString(8 - size.length(), ' ') + size;
          Stella.STANDARD_OUTPUT.nativeStream.println(size + " : " + desc.descriptionName());
        }
      }
    }
  }

  public static void transferLogicInformationFromRelationHook(List relationslist) {
    { Relation oldrelation = ((Relation)(relationslist.first()));
      Relation newrelation = ((Relation)(relationslist.second()));
      NamedDescription olddescription = ((NamedDescription)(KeyValueList.dynamicSlotValue(oldrelation.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null)));
      NamedDescription newdescription = ((NamedDescription)(KeyValueList.dynamicSlotValue(newrelation.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null)));

      if (olddescription != null) {
        NamedDescription.retractRelationAxioms(olddescription);
        if (newdescription != null) {
          {
            Logic.transferPropositionsAndBacklinks(((NamedDescription)(KeyValueList.dynamicSlotValue(oldrelation.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))), ((NamedDescription)(KeyValueList.dynamicSlotValue(newrelation.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))));
            Logic.destroyInstance(olddescription);
          }
        }
        else {
          {
            KeyValueList.setDynamicSlotValue(newrelation.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, olddescription, null);
            olddescription.nativeRelationSetter(newrelation);
            Logic.finalizeSuperrelationLinks(newrelation);
          }
        }
        KeyValueList.setDynamicSlotValue(oldrelation.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null, null);
      }
      if (Surrogate.subtypeOfClassP(Stella_Object.safePrimaryType(oldrelation))) {
        { Stella_Class oldrelation000 = ((Stella_Class)(oldrelation));

          KeyValueList.setDynamicSlotValue(((Stella_Class)(newrelation)).dynamicSlots, Logic.SYM_STELLA_CLASS_EXTENSION, ((ClassExtension)(KeyValueList.dynamicSlotValue(oldrelation000.dynamicSlots, Logic.SYM_STELLA_CLASS_EXTENSION, null))), null);
          KeyValueList.setDynamicSlotValue(oldrelation000.dynamicSlots, Logic.SYM_STELLA_CLASS_EXTENSION, null, null);
        }
      }
      else {
      }
    }
  }

  public static void finalizeSuperrelationLinks(Relation self) {
    { NamedDescription subdescription = Logic.getDescription(self);

      { Object old$Evaluationmode$000 = Logic.$EVALUATIONMODE$.get();
        Object old$FillingconstraintpropagationqueuesP$000 = Logic.$FILLINGCONSTRAINTPROPAGATIONQUEUESp$.get();

        try {
          Native.setSpecial(Logic.$EVALUATIONMODE$, Logic.KWD_EXTENSIONAL_ASSERTION);
          Native.setBooleanSpecial(Logic.$FILLINGCONSTRAINTPROPAGATIONQUEUESp$, false);
          { Object old$Module$000 = Stella.$MODULE$.get();
            Object old$Context$000 = Stella.$CONTEXT$.get();

            try {
              Native.setSpecial(Stella.$MODULE$, ((Module)(subdescription.homeContext)));
              Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
              { Relation renamed_Super = null;
                Iterator iter000 = Logic.directSuperrelations(self);

                while (iter000.nextP()) {
                  renamed_Super = ((Relation)(iter000.value));
                  if (((NamedDescription)(KeyValueList.dynamicSlotValue(renamed_Super.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))) != null) {
                    NamedDescription.assertImpliesLinkBetweenRelations(subdescription, Logic.getDescription(renamed_Super));
                  }
                }
              }

            } finally {
              Stella.$CONTEXT$.set(old$Context$000);
              Stella.$MODULE$.set(old$Module$000);
            }
          }

        } finally {
          Logic.$FILLINGCONSTRAINTPROPAGATIONQUEUESp$.set(old$FillingconstraintpropagationqueuesP$000);
          Logic.$EVALUATIONMODE$.set(old$Evaluationmode$000);
        }
      }
    }
  }

  public static Proposition updateIsaProposition(Stella_Object self, Surrogate type, Keyword updatemode) {
    { Proposition value000 = null;

      { Proposition p = null;
        Iterator iter000 = Logic.unfilteredDependentIsaPropositions(self).allocateIterator();

        loop000 : while (iter000.nextP()) {
          p = ((Proposition)(iter000.value));
          if (((Surrogate)(p.operator)) == type) {
            value000 = p;
            break loop000;
          }
        }
      }
      { Proposition isaproposition = value000;

        if (isaproposition == null) {
          isaproposition = Logic.createProposition(Logic.SYM_STELLA_ISA, 1);
          isaproposition.operator = type;
          (isaproposition.arguments.theArray)[0] = self;
          Proposition.fastenDownOneProposition(isaproposition, false);
        }
        Proposition.updatePropositionTruthValue(isaproposition, updatemode);
        return (isaproposition);
      }
    }
  }

  public static Proposition assertIsaProposition(Stella_Object self, Surrogate type) {
    if (type != null) {
      return (Logic.updateIsaProposition(self, type, Logic.KWD_ASSERT_TRUE));
    }
    else {
      return (null);
    }
  }

  public static Proposition retractIsaProposition(Stella_Object self, Surrogate type) {
    if (type != null) {
      return (Logic.updateIsaProposition(self, type, Logic.KWD_RETRACT_TRUE));
    }
    else {
      return (null);
    }
  }

  /** Assert or retract a proposition that applies 'relation' to 'arguments'.
   * @param relation
   * @param arguments
   * @param updatemode
   * @return Proposition
   */
  public static Proposition updateTuple(Surrogate relation, Cons arguments, Keyword updatemode) {
    { boolean holdsP = relation == Logic.SGT_PL_KERNEL_KB_HOLDS;
      NamedDescription description = (holdsP ? Logic.getDescription(arguments.value) : Logic.getDescription(relation));
      Proposition proposition = null;

      if (holdsP) {
        relation = description.surrogateValueInverse;
        arguments = arguments.rest;
      }
      if (NamedDescription.functionDescriptionP(description)) {
        { Proposition definingproposition = Logic.findOrCreateFunctionProposition(relation, arguments.butLast().consify());

          proposition = Proposition.updateEquivalenceProposition(Logic.createEquivalenceProposition((definingproposition.arguments.theArray)[(definingproposition.arguments.length() - 1)], arguments.last()), updatemode);
          if (proposition == null) {
            return (definingproposition);
          }
        }
      }
      else if (NamedDescription.classDescriptionP(description)) {
        return (Logic.updateIsaProposition(arguments.value, relation, updatemode));
      }
      else {
        proposition = Logic.createProposition(Logic.SYM_STELLA_PREDICATE, arguments.length());
        proposition.operator = relation;
        { Stella_Object arg = null;
          Cons iter000 = arguments;
          int i = Stella.NULL_INTEGER;
          int iter001 = 0;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
            arg = iter000.value;
            i = iter001;
            (proposition.arguments.theArray)[i] = arg;
          }
        }
      }
      proposition = Proposition.fastenDownOneProposition(proposition, false);
      Proposition.updatePropositionTruthValue(proposition, updatemode);
      return (proposition);
    }
  }

  public static Proposition assertTuple(Surrogate relation, Cons arguments) {
    return (Logic.updateTuple(relation, arguments, Logic.KWD_ASSERT_TRUE));
  }

  public static Proposition updateBinaryValue(Surrogate relation, Stella_Object self, Stella_Object value, Keyword updatemode) {
    { Object old$ClippingenabledP$000 = Logic.$CLIPPINGENABLEDp$.get();

      try {
        Native.setBooleanSpecial(Logic.$CLIPPINGENABLEDp$, true);
        if (NamedDescription.functionDescriptionP(Logic.getDescription(relation))) {
          { Proposition value000 = null;

            { Proposition p = null;
              Iterator iter000 = Logic.unfilteredDependentPropositions(self, relation).allocateIterator();

              loop000 : while (iter000.nextP()) {
                p = ((Proposition)(iter000.value));
                if (((Surrogate)(p.operator)) == relation) {
                  value000 = p;
                  break loop000;
                }
              }
            }
            { Proposition proposition = value000;

              if ((proposition == null) ||
                  Logic.skolemP(value)) {
                return (Logic.updateTuple(relation, Cons.consList(Cons.cons(self, Cons.cons(value, Stella.NIL))), updatemode));
              }
              { Stella_Object skolemoutput = (proposition.arguments.theArray)[(proposition.arguments.length() - 1)];

                if (updatemode == Logic.KWD_ASSERT_TRUE) {
                  if (Logic.clipValueP(skolemoutput, value)) {
                  }
                  else {
                    Proposition.equateValues(proposition, Logic.valueOf(skolemoutput), Logic.valueOf(value));
                  }
                }
                else if (updatemode == Logic.KWD_RETRACT_TRUE) {
                  Logic.unequateValuesP(skolemoutput, value);
                }
                else {
                  { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

                    stream000.nativeStream.print("`" + updatemode + "' is not a valid case option");
                    throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
                  }
                }
                return (proposition);
              }
            }
          }
        }
        else {
          return (Logic.updateTuple(relation, Cons.consList(Cons.cons(self, Cons.cons(value, Stella.NIL))), updatemode));
        }

      } finally {
        Logic.$CLIPPINGENABLEDp$.set(old$ClippingenabledP$000);
      }
    }
  }

  public static Proposition assertBinaryValue(Surrogate relation, Stella_Object self, Stella_Object value) {
    return (Logic.updateBinaryValue(relation, self, value, Logic.KWD_ASSERT_TRUE));
  }

  public static Proposition retractBinaryValue(Surrogate relation, Stella_Object self, Stella_Object value) {
    return (Logic.updateBinaryValue(relation, self, value, Logic.KWD_RETRACT_TRUE));
  }

  public static Proposition assertMemberOfProposition(Stella_Object self, Stella_Object collection) {
    if (collection == null) {
      return (null);
    }
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(collection), Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
      { NamedDescription collection000 = ((NamedDescription)(collection));

        if (collection000.surrogateValueInverse == Logic.SGT_STELLA_THING) {
          return (null);
        }
        return (Logic.assertIsaProposition(self, collection000.surrogateValueInverse));
      }
    }
    else {
      return (Logic.assertTuple(Logic.SGT_PL_KERNEL_KB_MEMBER_OF, Cons.consList(Cons.cons(self, Cons.cons(collection, Stella.NIL)))));
    }
  }

  public static Stella_Object helpCreateLogicInstance(Surrogate name, Surrogate type) {
    Logic.enforceCodeOnly();
    if (type == null) {
      type = ((Surrogate)(Logic.$DEFAULTCREATIONTYPE$.get()));
    }
    { NamedDescription description = ((type != null) ? Logic.getDescription(type) : ((NamedDescription)(null)));
      Stella_Class nativeclass = null;
      Stella_Object newobject = null;

      if ((type != null) &&
          (description == null)) {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("Can't create an instance of the undefined class `" + type.symbolName + "'");
          throw ((UndefinedClassException)(UndefinedClassException.newUndefinedClassException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      if (description == null) {
        newobject = LogicObject.newLogicObject();
      }
      else {
        {
          if (!NamedDescription.classDescriptionP(description)) {
            { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

              stream001.nativeStream.print("Can't create an instance of a relation: `" + type.symbolName + "'");
              throw ((ObjectNotClassException)(ObjectNotClassException.newObjectNotClassException(stream001.theStringReader()).fillInStackTrace()));
            }
          }
          nativeclass = ((Stella_Class)(description.nativeRelation()));
          if ((nativeclass == null) ||
              nativeclass.abstractP) {
            newobject = LogicObject.newLogicObject();
          }
          else if (Surrogate.subtypeOfP(nativeclass.classType, Logic.SGT_STELLA_THING)) {
            newobject = Surrogate.createObject(type, Stella.NIL);
          }
          else {
            { OutputStringStream stream002 = OutputStringStream.newOutputStringStream();

              {
                stream002.nativeStream.println("Can't create an instance of the class `" + type.symbolName + "'");
                stream002.nativeStream.print("   because it doesn't inherit the class 'THING'.");
              }
;
              throw ((BadArgumentException)(BadArgumentException.newBadArgumentException(stream002.theStringReader()).fillInStackTrace()));
            }
          }
        }
      }
      if (name != null) {
        if (name.surrogateValue != null) {
          { ObjectAlreadyExistsException self008 = ObjectAlreadyExistsException.newObjectAlreadyExistsException("An object named " + name.symbolName + " already exists.");

            self008.existingObject = name.surrogateValue;
            { ObjectAlreadyExistsException error = self008;

              throw ((ObjectAlreadyExistsException)(error.fillInStackTrace()));
            }
          }
        }
        name.surrogateValue = newobject;
        { Surrogate testValue000 = Stella_Object.safePrimaryType(newobject);

          if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
            { LogicObject newobject000 = ((LogicObject)(newobject));

              newobject000.surrogateValueInverse = name;
            }
          }
          else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
            { Thing newobject000 = ((Thing)(newobject));

              newobject000.surrogateValueInverse = name;
            }
          }
          else {
            { OutputStringStream stream003 = OutputStringStream.newOutputStringStream();

              stream003.nativeStream.print("`" + testValue000 + "' is not a valid case option");
              throw ((StellaException)(StellaException.newStellaException(stream003.theStringReader()).fillInStackTrace()));
            }
          }
        }
      }
      return (newobject);
    }
  }

  public static Stella_Object createLogicInstance(Surrogate name, Surrogate type) {
    try {
      return (Logic.helpCreateLogicInstance(name, type));
    } catch (UndefinedClassException undefined) {
      Stella.STANDARD_OUTPUT.nativeStream.println("`" + Stella.exceptionMessage(undefined) + "'");
      return (null);
    } catch (ObjectNotClassException noClass) {
      Stella.STANDARD_OUTPUT.nativeStream.println("`" + Stella.exceptionMessage(noClass) + "'");
      return (null);
    } catch (BadArgumentException badArg) {
      Stella.STANDARD_OUTPUT.nativeStream.println("`" + Stella.exceptionMessage(badArg) + "'");
      return (null);
    } catch (ObjectAlreadyExistsException exists) {
      {
        Stella.STANDARD_OUTPUT.nativeStream.println(Stella.exceptionMessage(exists));
        Stella.STANDARD_OUTPUT.nativeStream.println("Redefining the surrogate " + name.symbolName + " will cause the existing");
        Stella.STANDARD_OUTPUT.nativeStream.print("   object named " + name.symbolName + " to be destroyed. ");
      }
;
      if (Stella.yOrNP("Do it? ")) {
        {
          Logic.destroyInstance(exists.existingObject);
          return (Logic.helpCreateLogicInstance(name, type));
        }
      }
      else {
        {
          Stella.STANDARD_OUTPUT.nativeStream.println("Returning existing object:");
          return (exists.existingObject);
        }
      }
    }
  }

  public static void cleanupStructuredObjectsIndex(Module clearmodule) {
    { IntegerWrapper key = null;
      List bucket = null;
      DictionaryIterator iter000 = ((DictionaryIterator)(Logic.$STRUCTURED_OBJECTS_INDEX$.allocateIterator()));

      while (iter000.nextP()) {
        key = ((IntegerWrapper)(iter000.key));
        bucket = ((List)(iter000.value));
        { ContextSensitiveObject obj = null;
          Cons iter001 = bucket.theConsList;

          for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
            obj = ((ContextSensitiveObject)(iter001.value));
            { Context context = obj.homeContext;

              if ((context != null) &&
                  (context.deletedP() ||
                   ((context == clearmodule) ||
                    context.allSuperContexts.membP(clearmodule)))) {
                Logic.destroyObject(obj);
              }
            }
          }
        }
        bucket.removeDeletedMembers();
        if (bucket.emptyP()) {
          Logic.$STRUCTURED_OBJECTS_INDEX$.removeAt(key);
        }
      }
    }
  }

  public static Proposition lookupMatchingPropositionInBucket(List bucket, Proposition self, KeyValueMap mapping) {
    { Module homemodule = self.homeContext.baseModule;
      boolean functionP = self.kind == Logic.KWD_FUNCTION;
      GeneralizedSymbol operator = self.operator;
      Vector arguments = self.arguments;
      int arity = arguments.length();
      boolean rewrappedP = false;

      bucket.removeDeletedMembers();
      { Stella_Object p = null;
        Cons iter000 = bucket.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          p = iter000.value;
          if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(p), Logic.SGT_LOGIC_PROPOSITION)) {
            { Proposition p000 = ((Proposition)(p));

              if ((operator == p000.operator) &&
                  (arity == p000.arguments.length())) {
                loop001 : for (;;) {
                  if ((functionP &&
                      Proposition.equivalentFunctionPropositionsP(self, p000, mapping)) ||
                      ((!functionP) &&
                       Proposition.equivalentPropositionsP(self, p000, mapping))) {
                    if (Context.subcontextP(homemodule, p000.homeContext.baseModule)) {
                      return (p000);
                    }
                    else {
                      break loop001;
                    }
                  }
                  if (rewrappedP) {
                    break loop001;
                  }
                  else {
                    Proposition.rewrapPropositionArguments(self);
                    rewrappedP = true;
                    continue loop001;
                  }
                }
              }
            }
          }
          else {
          }
        }
      }
      return (null);
    }
  }

  public static Proposition buildTopLevelProposition(Stella_Object tree, boolean trueassertionP) {
    if (Stella_Object.isaP(tree, Logic.SGT_STELLA_STRING_WRAPPER)) {
      return (Logic.buildTopLevelProposition(Stella.readSExpressionFromString(((StringWrapper)(tree)).wrapperValue), trueassertionP));
    }
    { Proposition proposition = null;
      Cons logicvariabletable = ((Cons)(Logic.$LOGICVARIABLETABLE$.get()));

      { Object old$Logicvariabletable$000 = Logic.$LOGICVARIABLETABLE$.get();
        Object old$Variableidcounter$000 = Logic.$VARIABLEIDCOUNTER$.get();
        Object old$Termunderconstruction$000 = Logic.$TERMUNDERCONSTRUCTION$.get();

        try {
          Native.setSpecial(Logic.$LOGICVARIABLETABLE$, ((Cons)(((logicvariabletable != null) ? logicvariabletable : Stella.NIL))));
          Native.setIntSpecial(Logic.$VARIABLEIDCOUNTER$, ((Integer)(Logic.$VARIABLEIDCOUNTER$.get())).intValue());
          Native.setSpecial(Logic.$TERMUNDERCONSTRUCTION$, tree);
          proposition = ((Proposition)(Logic.buildProposition(tree)));
          if (proposition != null) {
            Proposition.normalizeTopLevelProposition(proposition);
            Proposition.verifyForallPropositions(proposition);
            if (!(Proposition.collectUnresolvedSlotReferences(proposition) == Stella.NIL)) {
              if (trueassertionP) {
                Proposition.updateSkolemTypeFromIsaAssertions(proposition);
              }
              Logic.resolveUnresolvedSlotReferences(proposition);
            }
            if (trueassertionP &&
                ((proposition.kind == Logic.KWD_EXISTS) &&
                 (!Logic.descriptionModeP()))) {
              Proposition.instantiateUndefinedSurrogates(proposition);
            }
            proposition = Proposition.recursivelyFastenDownPropositions(proposition, false);
          }

        } finally {
          Logic.$TERMUNDERCONSTRUCTION$.set(old$Termunderconstruction$000);
          Logic.$VARIABLEIDCOUNTER$.set(old$Variableidcounter$000);
          Logic.$LOGICVARIABLETABLE$.set(old$Logicvariabletable$000);
        }
      }
      return (proposition);
    }
  }

  public static Stella_Object buildProposition(Stella_Object tree) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(tree);

      if (testValue000 == Logic.SGT_STELLA_CONS) {
        { Cons tree000 = ((Cons)(tree));

          return (Logic.consDbuildProposition(tree000));
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate tree000 = ((Surrogate)(tree));

          return (Logic.surrogateDbuildProposition(tree000));
        }
      }
      else if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol tree000 = ((Symbol)(tree));

          return (Logic.symbolDbuildProposition(tree000));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable tree000 = ((PatternVariable)(tree));

          return (tree000);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition tree000 = ((Proposition)(tree));

          return (tree000);
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream000.nativeStream.println("ERROR: Illegal logical sentence: `" + tree + "'.");
              Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
            }
          }
          throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  public static Proposition surrogateDbuildProposition(Surrogate self) {
    { Stella_Object value = self.surrogateValue;
      Proposition proposition = null;

      if (value != null) {
        if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(value), Logic.SGT_LOGIC_PROPOSITION)) {
          { Proposition value000 = ((Proposition)(value));

            proposition = value000;
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

              try {
                Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                stream000.nativeStream.println("ERROR: Expected `" + self.symbolName + "' to have type proposition.");
                Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

              } finally {
                Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
              }
            }
            throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
      else {
        {
          proposition = Logic.createProposition(Logic.SYM_LOGIC_CONSTANT, 0);
          proposition.operator = self;
          self.surrogateValue = proposition;
          KeyValueList.setDynamicSlotValue(proposition.dynamicSlots, Logic.SYM_STELLA_SURROGATE_VALUE_INVERSE, self, null);
        }
      }
      return (proposition);
    }
  }

  public static Stella_Object symbolDbuildProposition(Symbol symbol) {
    { Proposition proposition = null;

      if (symbol == Logic.SYM_STELLA_TRUE) {
        proposition = Logic.TRUE_PROPOSITION;
      }
      else if (symbol == Logic.SYM_STELLA_FALSE) {
        proposition = Logic.FALSE_PROPOSITION;
      }
      else {
        return (Logic.evaluateSymbolTerm(symbol));
      }
      return (proposition);
    }
  }

  public static Proposition consDbuildProposition(Cons tree) {
    { Proposition proposition = null;

      if (!Stella_Object.isaP(tree.value, Logic.SGT_STELLA_SYMBOL)) {
        System.err.print("Safety violation: INTERNAL ERROR: Illegal operator in proposition tree.");
      }
      { GeneralizedSymbol testValue000 = ((GeneralizedSymbol)(tree.value));

        if (testValue000 == Logic.SYM_STELLA_e) {
          proposition = Logic.buildEquivalenceProposition(tree);
        }
        else if ((testValue000 == Logic.SYM_STELLA_AND) ||
            ((testValue000 == Logic.SYM_STELLA_OR) ||
             (testValue000 == Logic.SYM_STELLA_NOT))) {
          proposition = Logic.buildAndOrNotProposition(tree);
        }
        else if (testValue000 == Logic.SYM_STELLA_ISA) {
          proposition = Logic.buildIsaProposition(tree);
        }
        else if (testValue000 == Logic.SYM_PL_KERNEL_KB_MEMBER_OF) {
          proposition = Logic.buildMemberOfProposition(tree);
        }
        else if ((testValue000 == Logic.SYM_LOGIC_IMPLIES) ||
            (testValue000 == Logic.SYM_PL_KERNEL_KB_SUBSET_OF)) {
          proposition = Logic.buildImpliesProposition(tree);
        }
        else if (testValue000 == Logic.SYM_STELLA_EXISTS) {
          proposition = Logic.buildExistsProposition(tree);
        }
        else if (testValue000 == Logic.SYM_STELLA_FORALL) {
          proposition = Logic.buildForallProposition(tree);
        }
        else if (testValue000 == Logic.SYM_LOGIC_FAIL) {
          proposition = Logic.buildFailProposition(tree);
        }
        else if (testValue000 == Logic.SYM_STELLA_COLLECT_INTO) {
          proposition = Logic.buildCollectIntoProposition(tree);
        }
        else if (testValue000 == Logic.SYM_LOGIC_ABOUT) {
          proposition = Logic.buildAnnotatedProposition(tree);
        }
        else {
          proposition = Logic.buildPredicateProposition(tree);
        }
      }
      if (proposition == null) {
        return (null);
      }
      if (Proposition.containsNestedArgumentP(proposition)) {
        proposition = Proposition.flattenNestedFunctionArguments(proposition);
      }
      return (proposition);
    }
  }

  public static void verifyNumberOfPropositionArguments(Cons tree, int correctnumber) {
    if (!(tree.rest.length() == correctnumber)) {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

          try {
            Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
            {
              stream000.nativeStream.println("ERROR: Wrong number of arguments in proposition: `" + tree + "'");
              stream000.nativeStream.println("   Expected `" + correctnumber + "' arguments..");
            }
;
            Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

          } finally {
            Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
          }
        }
        throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
      }
    }
  }

  public static Proposition buildIsaProposition(Cons tree) {
    Logic.verifyNumberOfPropositionArguments(tree, 2);
    { Proposition proposition = Logic.createProposition(Logic.SYM_STELLA_ISA, 1);
      Surrogate type = null;
      Stella_Object symbol = tree.rest.rest.value;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(symbol);

        if (Surrogate.subtypeOfSurrogateP(testValue000)) {
          { Surrogate symbol000 = ((Surrogate)(symbol));

            type = symbol000;
          }
        }
        else if (Surrogate.subtypeOfSymbolP(testValue000)) {
          { Symbol symbol000 = ((Symbol)(symbol));

            type = Symbol.symbolToSurrogate(symbol000);
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

              try {
                Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                stream000.nativeStream.println("ERROR: Illegal token where symbol expected: `" + symbol + "'.");
                Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

              } finally {
                Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
              }
            }
            throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
      { NamedDescription renamed_Class = Logic.getDescription(type);

        if (renamed_Class == null) {
          { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

            { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

              try {
                Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                stream001.nativeStream.println("ERROR: No class is associated with the term `" + type.symbolName + "'.");
                Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

              } finally {
                Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
              }
            }
            throw ((PropositionError)(PropositionError.newPropositionError(stream001.theStringReader()).fillInStackTrace()));
          }
        }
        if (!NamedDescription.classDescriptionP(renamed_Class)) {
          { OutputStringStream stream002 = OutputStringStream.newOutputStringStream();

            { Object old$PrintreadablyP$002 = Stella.$PRINTREADABLYp$.get();

              try {
                Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                stream002.nativeStream.println("ERROR: Term `" + type.symbolName + "' found where class expected..");
                Logic.helpSignalPropositionError(stream002, Logic.KWD_ERROR);

              } finally {
                Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$002);
              }
            }
            throw ((PropositionError)(PropositionError.newPropositionError(stream002.theStringReader()).fillInStackTrace()));
          }
        }
      }
      proposition.operator = type;
      (proposition.arguments.theArray)[0] = (Logic.evaluateTypedArgument(tree.rest.value, type));
      return (proposition);
    }
  }

  public static Proposition buildMemberOfProposition(Cons tree) {
    Logic.verifyNumberOfPropositionArguments(tree, 2);
    { Stella_Object collectionref = tree.rest.rest.value;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(collectionref);

        if (Surrogate.subtypeOfSurrogateP(testValue000)) {
          { Surrogate collectionref000 = ((Surrogate)(collectionref));

            if (collectionref000.getStellaClass(false) != null) {
              return (Logic.buildIsaProposition(tree));
            }
          }
        }
        else if (Surrogate.subtypeOfSymbolP(testValue000)) {
          { Symbol collectionref000 = ((Symbol)(collectionref));

            if (collectionref000.getStellaClass(false) != null) {
              return (Logic.buildIsaProposition(tree));
            }
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
          { Description collectionref000 = ((Description)(collectionref));

            if (Description.namedDescriptionP(collectionref000) &&
                NamedDescription.classDescriptionP(((NamedDescription)(collectionref000)))) {
              return (Logic.buildIsaProposition(Cons.list$(Cons.cons(Logic.SYM_STELLA_ISA, Cons.cons(tree.rest.value, Cons.cons(Cons.cons(collectionref000.descriptionSurrogate(), Stella.NIL), Stella.NIL))))));
            }
          }
        }
        else {
        }
      }
    }
    return (Logic.buildPredicateProposition(tree));
  }

  public static Stella_Object extractAnnotation(Stella_Object tree, Keyword option, Object [] MV_returnarray) {
    { Stella_Object value = null;

      if (Stella_Object.safePrimaryType(tree) == Logic.SGT_STELLA_CONS) {
        { Cons tree000 = ((Cons)(tree));

          if (tree000.value == Logic.SYM_LOGIC_ABOUT) {
            { PropertyList self000 = PropertyList.newPropertyList();

              self000.thePlist = tree000.rest.rest;
              { PropertyList options = self000;

                value = options.lookup(option);
                if (value != null) {
                  options.removeAt(option);
                  tree000.rest.rest = options.thePlist;
                }
              }
            }
          }
        }
      }
      else {
      }
      { Stella_Object _return_temp = tree;

        MV_returnarray[0] = value;
        return (_return_temp);
      }
    }
  }

  public static Proposition buildAnnotatedProposition(Cons tree) {
    { Proposition proposition = ((Proposition)(Logic.buildProposition(tree.rest.value)));
      Cons options = tree.rest.rest;

      while (!(options == Stella.NIL)) {
        if (Stella_Object.isaP(options.value, Logic.SGT_STELLA_GENERALIZED_SYMBOL)) {
          options.firstSetter(((GeneralizedSymbol)(options.value)).keywordify());
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

              try {
                Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                stream000.nativeStream.println("PARSING ERROR: Illegal annotation option: `" + options.value + "'.");
                Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

              } finally {
                Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
              }
            }
            throw ((ParsingError)(ParsingError.newParsingError(stream000.theStringReader()).fillInStackTrace()));
          }
        }
        if (!(options.rest.value != null)) {
          { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

            { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

              try {
                Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                stream001.nativeStream.println("PARSING ERROR: Missing annotation value for option: `" + options.value + "'.");
                Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

              } finally {
                Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
              }
            }
            throw ((ParsingError)(ParsingError.newParsingError(stream001.theStringReader()).fillInStackTrace()));
          }
        }
        options = options.rest.rest;
      }
      { PropertyList self004 = PropertyList.newPropertyList();

        self004.thePlist = tree.rest.rest;
        KeyValueList.setDynamicSlotValue(proposition.dynamicSlots, Logic.SYM_LOGIC_ANNOTATIONS, self004, null);
      }
      Proposition.finalizePropositionAnnotations(proposition);
      return (proposition);
    }
  }

  public static Proposition buildAndOrNotProposition(Cons tree) {
    { Stella_Object term = null;
      Cons arguments = Stella.NIL;
      Proposition proposition = null;
      Vector argumentsvector = null;

      { GeneralizedSymbol testValue000 = ((GeneralizedSymbol)(tree.value));

        if ((testValue000 == Logic.SYM_STELLA_AND) ||
            ((testValue000 == Logic.SYM_STELLA_OR) ||
             (testValue000 == Logic.SYM_STELLA_NOT))) {
          { Stella_Object arg = null;
            Cons iter000 = tree.rest;
            Cons collect000 = null;

            for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
              arg = iter000.value;
              { 
                term = Logic.buildProposition(arg);
                if (term != null) {
                  if (collect000 == null) {
                    {
                      collect000 = Cons.cons(term, Stella.NIL);
                      if (arguments == Stella.NIL) {
                        arguments = collect000;
                      }
                      else {
                        Cons.addConsToEndOfConsList(arguments, collect000);
                      }
                    }
                  }
                  else {
                    {
                      collect000.rest = Cons.cons(term, Stella.NIL);
                      collect000 = collect000.rest;
                    }
                  }
                }
              }
            }
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
      if ((arguments == Stella.NIL) &&
          (tree.value == Logic.SYM_STELLA_NOT)) {
        { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream001.nativeStream.println("ERROR: Missing argument in NOT proposition: `" + tree + "'.");
              Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
            }
          }
          throw ((PropositionError)(PropositionError.newPropositionError(stream001.theStringReader()).fillInStackTrace()));
        }
      }
      if ((tree.value == Logic.SYM_STELLA_NOT) &&
          (Stella_Object.isaP(arguments.value, Logic.SGT_LOGIC_PROPOSITION) &&
           Proposition.functionInducedExistsP(((Proposition)(arguments.value))))) {
        return (Proposition.embedNegationWithinFunctionInducedExists(((Proposition)(arguments.value))));
      }
      proposition = Logic.createProposition(((Symbol)(tree.value)), arguments.length());
      argumentsvector = proposition.arguments;
      { Stella_Object arg = null;
        Cons iter001 = arguments;
        int i = Stella.NULL_INTEGER;
        int iter002 = 0;

        for (;!(iter001 == Stella.NIL); iter001 = iter001.rest, iter002 = iter002 + 1) {
          arg = iter001.value;
          i = iter002;
          (argumentsvector.theArray)[i] = arg;
        }
      }
      return (proposition);
    }
  }

  public static boolean functionalTermP(Stella_Object term) {
    if (Stella_Object.safePrimaryType(term) == Logic.SGT_STELLA_CONS) {
      { Cons term000 = ((Cons)(term));

        { GeneralizedSymbol testValue000 = ((GeneralizedSymbol)(term000.value));

          if ((testValue000 == Logic.SYM_LOGIC_SETOFALL) ||
              ((testValue000 == Logic.SYM_LOGIC_THE_ONLY) ||
               ((testValue000 == Logic.SYM_STELLA_SETOF) ||
                ((testValue000 == Logic.SYM_LOGIC_LISTOF) ||
                 (testValue000 == Logic.SYM_LOGIC_KAPPA))))) {
            return (false);
          }
          else {
            return (true);
          }
        }
      }
    }
    else {
      return (false);
    }
  }

  public static boolean clipValueP(Stella_Object term1, Stella_Object term2) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(term1), Logic.SGT_LOGIC_SKOLEM)) {
      { Skolem term1000 = ((Skolem)(term1));

        { Stella_Object value1 = Logic.valueOf(term1000);

          if (Stella_Object.eqlP(value1, term2)) {
            return (true);
          }
          if ((!Logic.skolemP(value1)) &&
              ((term1000.definingProposition != null) &&
               ((Boolean)(Logic.$CLIPPINGENABLEDp$.get())).booleanValue())) {
            Skolem.unbindSkolemValue(term1000, true);
            Skolem.bindSkolemToValue(term1000, Logic.valueOf(term2), true);
            return (true);
          }
        }
      }
    }
    else {
    }
    return (false);
  }

  public static Proposition createEquivalenceProposition(Stella_Object term1, Stella_Object term2) {
    { Proposition proposition = Logic.createProposition(Logic.SYM_LOGIC_EQUIVALENT, 2);
      Vector argumentsvector = proposition.arguments;

      (argumentsvector.theArray)[0] = term1;
      (argumentsvector.theArray)[1] = term2;
      return (proposition);
    }
  }

  public static Proposition buildEquivalenceProposition(Cons tree) {
    switch (tree.length()) {
      case 3: 
        return (Logic.createEquivalenceProposition(Logic.evaluateTerm(tree.rest.value), Logic.evaluateTerm(tree.rest.rest.value)));
      case 1: 
      case 2: 
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream000.nativeStream.println("ERROR: Missing argument/s in `=' proposition..");
              Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
            }
          }
          throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
        }
      default:
        return (Logic.buildConjunctionOfEqualityPropositions(tree.rest, Stella.NIL));
    }
  }

  public static Proposition buildConjunctionOfEqualityPropositions(Cons remainingterms, Cons equivalences) {
    if (remainingterms.rest == Stella.NIL) {
      return (Logic.conjoinPropositions(equivalences));
    }
    equivalences = Cons.cons(Logic.buildEquivalenceProposition(Cons.list$(Cons.cons(Logic.SYM_STELLA_e, Cons.cons(remainingterms.value, Cons.cons(Cons.cons(remainingterms.rest.value, Stella.NIL), Stella.NIL))))), equivalences);
    return (Logic.buildConjunctionOfEqualityPropositions(remainingterms.rest, equivalences));
  }

  public static Proposition buildFailProposition(Cons tree) {
    { Proposition proposition = Logic.createProposition(Logic.SYM_LOGIC_FAIL, 1);
      Stella_Object argument = Logic.buildProposition(tree.rest.value);

      if (argument == null) {
        return (null);
      }
      (proposition.arguments.theArray)[0] = argument;
      return (proposition);
    }
  }

  public static Proposition buildCollectIntoProposition(Cons tree) {
    { Proposition proposition = Logic.createProposition(Logic.SYM_STELLA_COLLECT_INTO, 2);
      Vector argumentsvector = proposition.arguments;

      (argumentsvector.theArray)[0] = (Logic.evaluateTerm(tree.rest.value));
      (argumentsvector.theArray)[1] = (Logic.evaluateTerm(tree.rest.rest.value));
      return (proposition);
    }
  }

  public static boolean holdsOperatorP(Stella_Object operator) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(operator);

      if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol operator000 = ((Symbol)(operator));

          return ((operator000 == Logic.SYM_PL_KERNEL_KB_HOLDS) ||
              (Logic.lookupLogicVariableBinding(operator000) != null));
        }
      }
      else if (testValue000 == Logic.SGT_STELLA_CONS) {
        { Cons operator000 = ((Cons)(operator));

          return (true);
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  public static void verifyEvaluableOperator(Stella_Object operator, Keyword kind) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(operator), Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
      { PatternVariable operator000 = ((PatternVariable)(operator));

        if (kind == Logic.KWD_PREDICATE) {
          operator000.skolemType = Logic.SGT_PL_KERNEL_KB_RELATION;
        }
        else if (kind == Logic.KWD_FUNCTION) {
          operator000.skolemType = Logic.SGT_PL_KERNEL_KB_FUNCTION;
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + kind + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
    }
    else {
    }
  }

  public static Proposition buildHoldsProposition(Cons tree) {
    { Stella_Object operatorexpression = tree.value;
      boolean explicitholdsP = operatorexpression == Logic.SYM_PL_KERNEL_KB_HOLDS;
      int argcount = tree.rest.length();
      Proposition proposition = Logic.createProposition(Logic.SYM_STELLA_PREDICATE, (explicitholdsP ? argcount : (argcount + 1)));

      proposition.operator = Logic.SGT_PL_KERNEL_KB_HOLDS;
      if (explicitholdsP) {
        { Stella_Object arg = null;
          Cons iter000 = tree.rest;
          int i = Stella.NULL_INTEGER;
          int iter001 = 0;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
            arg = iter000.value;
            i = iter001;
            if (i == 0) {
              arg = Logic.evaluateFirstArgument(arg, Logic.SYM_PL_KERNEL_KB_HOLDS);
            }
            else if (Logic.propositionalArgumentP(arg)) {
              arg = Logic.evaluatePropositionTerm(arg);
            }
            else {
              arg = Logic.evaluateTerm(arg);
            }
            (proposition.arguments.theArray)[i] = arg;
          }
        }
        return (proposition);
      }
      { Stella_Object operator = null;

        { Surrogate testValue000 = Stella_Object.safePrimaryType(operatorexpression);

          if (Surrogate.subtypeOfSymbolP(testValue000)) {
            { Symbol operatorexpression000 = ((Symbol)(operatorexpression));

              operator = Logic.lookupLogicVariableBinding(operatorexpression000);
            }
          }
          else if (testValue000 == Logic.SGT_STELLA_CONS) {
            { Cons operatorexpression000 = ((Cons)(operatorexpression));

              operator = Logic.evaluateFirstArgument(operatorexpression000, Logic.SYM_PL_KERNEL_KB_HOLDS);
            }
          }
          else {
            { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

              stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
              throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
            }
          }
        }
        Logic.verifyEvaluableOperator(operator, Logic.KWD_PREDICATE);
        (proposition.arguments.theArray)[0] = operator;
        { Stella_Object arg = null;
          Cons iter002 = tree.rest;
          int i = Stella.NULL_INTEGER;
          int iter003 = 1;

          for (;!(iter002 == Stella.NIL); iter002 = iter002.rest, iter003 = iter003 + 1) {
            arg = iter002.value;
            i = iter003;
            (proposition.arguments.theArray)[i] = (Logic.evaluateTerm(arg));
          }
        }
        return (proposition);
      }
    }
  }

  public static Surrogate mostGeneralEquivalentSlotref(Surrogate surrogate) {
    { Slot slot = ((Slot)(surrogate.surrogateValue));

      if (slot == null) {
        return (null);
      }
      if (slot.slotDirectEquivalent != null) {
        while (slot.slotDirectEquivalent != null) {
          slot = slot.slotDirectEquivalent;
        }
        if (slot.slotSlotref == null) {
          Surrogate.lookupSlotref(slot.slotOwner, slot.slotName);
        }
      }
      return (slot.slotSlotref);
    }
  }

  public static boolean polymorphicRelationP(Relation self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfStorageSlotP(testValue000)) {
        { StorageSlot self000 = ((StorageSlot)(self));

          return (true);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_TABLE)) {
        { Table self000 = ((Table)(self));

          return (true);
        }
      }
      else {
        return (false);
      }
    }
  }

  public static LogicObject evaluatePredicate(GeneralizedSymbol name, Stella_Object firstargument) {
    { Surrogate surrogate = null;
      LogicObject predicatevalue = null;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(name);

        if (Surrogate.subtypeOfSymbolP(testValue000)) {
          { Symbol name000 = ((Symbol)(name));

            surrogate = Symbol.symbolToSurrogate(name000);
          }
        }
        else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
          { Surrogate name000 = ((Surrogate)(name));

            surrogate = name000;
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
      predicatevalue = Logic.getDescription(surrogate);
      if (predicatevalue != null) {
        return (predicatevalue);
      }
      else {
        {
          predicatevalue = ((LogicObject)(surrogate.surrogateValue));
          if ((predicatevalue != null) &&
              (Logic.testIsaP(predicatevalue, Logic.SGT_PL_KERNEL_KB_RELATION) &&
               LogicObject.nonPolymorphicPredicateP(predicatevalue))) {
            return (predicatevalue);
          }
        }
      }
      if (firstargument != null) {
        { Stella_Object firstargvalue = Logic.valueOf(firstargument);
          Symbol symbol = Surrogate.surrogateToSymbol(surrogate);

          if (firstargvalue == null) {
            Logic.signalUndefinedTerm(firstargument);
          }
          surrogate = Logic.lookupSlotrefOnInstance(firstargvalue, symbol);
          if (surrogate != null) {
            return (Logic.getDescription(Logic.mostGeneralEquivalentSlotref(surrogate)));
          }
        }
      }
      return (null);
    }
  }

  public static boolean $AutoCoercePropositionalArgumentsP$Setter(boolean value) {
    return (Logic.$AUTO_COERCE_PROPOSITIONAL_ARGUMENTSp$ = value);
  }

  public static boolean propositionalArgumentP(Stella_Object argument) {
    if (Stella_Object.safePrimaryType(argument) == Logic.SGT_STELLA_CONS) {
      { Cons argument000 = ((Cons)(argument));

        { Stella_Object operator = argument000.value;
          Stella_Object firstarg = argument000.rest.value;

          if ((!(operator == Logic.SYM_PL_KERNEL_KB_VALUE)) &&
              Logic.holdsOperatorP(operator)) {
            return (true);
          }
          if (Stella_Object.symbolP(operator)) {
            { GeneralizedSymbol testValue000 = ((GeneralizedSymbol)(operator));

              if ((testValue000 == Logic.SYM_STELLA_AND) ||
                  ((testValue000 == Logic.SYM_STELLA_OR) ||
                   ((testValue000 == Logic.SYM_STELLA_NOT) ||
                    ((testValue000 == Logic.SYM_STELLA_EXISTS) ||
                     ((testValue000 == Logic.SYM_STELLA_FORALL) ||
                      (testValue000 == Logic.SYM_STELLA_e)))))) {
                return (true);
              }
              else {
                { LogicObject predicate = Logic.evaluatePredicate(((GeneralizedSymbol)(operator)), firstarg);
                  int arity = 0;

                  if (predicate != null) {
                    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(predicate), Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
                      { NamedDescription predicate000 = ((NamedDescription)(predicate));

                        if (Logic.functionP(predicate000)) {
                          arity = predicate000.arity();
                          if ((arity == -1) ||
                              (arity == argument000.length())) {
                            return (false);
                          }
                          else {
                            return (true);
                          }
                        }
                        else {
                          return (true);
                        }
                      }
                    }
                    else {
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else {
    }
    return (false);
  }

  public static Stella_Object evaluateTypedArgument(Stella_Object argument, Surrogate type) {
    if ((type == Logic.SGT_LOGIC_PROPOSITION) ||
        (Logic.$AUTO_COERCE_PROPOSITIONAL_ARGUMENTSp$ &&
         Logic.propositionalArgumentP(argument))) {
      return (Logic.evaluatePropositionTerm(argument));
    }
    else if (type != null) {
      { Object old$Defaultcreationtype$000 = Logic.$DEFAULTCREATIONTYPE$.get();

        try {
          Native.setSpecial(Logic.$DEFAULTCREATIONTYPE$, type);
          return (Logic.evaluateTerm(argument));

        } finally {
          Logic.$DEFAULTCREATIONTYPE$.set(old$Defaultcreationtype$000);
        }
      }
    }
    else {
      return (Logic.evaluateTerm(argument));
    }
  }

  public static Stella_Object evaluatePropositionTerm(Stella_Object tree) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(tree);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition tree000 = ((Proposition)(tree));

          return (tree000);
        }
      }
      else if (testValue000 == Logic.SGT_STELLA_CONS) {
        { Cons tree000 = ((Cons)(tree));

          { LogicObject predicate = null;
            Stella_Object firstargument = null;

            { Object [] caller_MV_returnarray = new Object[1];

              predicate = Logic.evaluatePredicateAndFirstArgument(tree000, caller_MV_returnarray);
              firstargument = ((Stella_Object)(caller_MV_returnarray[0]));
            }
            if (firstargument != null) {
              tree000.secondSetter(firstargument);
            }
            if (Logic.functionP(predicate) &&
                (((NamedDescription)(predicate)).arity() == tree000.length())) {
              return (Logic.evaluateFunctionTerm(tree000));
            }
            else {
              return (Logic.buildProposition(tree000));
            }
          }
        }
      }
      else {
        return (Logic.buildProposition(tree));
      }
    }
  }

  public static LogicObject evaluatePredicateAndFirstArgument(Cons tree, Object [] MV_returnarray) {
    { Stella_Object predicate = tree.value;
      Stella_Object firstargument = tree.rest.value;

      if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(predicate), Logic.SGT_STELLA_GENERALIZED_SYMBOL)) {
        { GeneralizedSymbol predicate000 = ((GeneralizedSymbol)(predicate));

          if ((predicate000 == Logic.SYM_STELLA_EXISTS) ||
              (predicate000 == Logic.SYM_STELLA_FORALL)) {
            firstargument = null;
            predicate000 = null;
          }
          else if ((predicate000 == Logic.SYM_STELLA_AND) ||
              ((predicate000 == Logic.SYM_STELLA_OR) ||
               (predicate000 == Logic.SYM_STELLA_NOT))) {
            firstargument = null;
            predicate000 = null;
          }
          else {
          }
        }
      }
      else {
        predicate = null;
      }
      if (predicate != null) {
        if (firstargument != null) {
          firstargument = Logic.evaluateFirstArgument(tree.rest.value, ((Symbol)(predicate)));
        }
        predicate = Logic.evaluatePredicate(((GeneralizedSymbol)(predicate)), firstargument);
      }
      { LogicObject _return_temp = ((LogicObject)(predicate));

        MV_returnarray[0] = firstargument;
        return (_return_temp);
      }
    }
  }

  public static Stella_Object evaluateFirstArgument(Stella_Object argument, Symbol relationname) {
    { LogicObject predicatevalue = Logic.evaluatePredicate(relationname, null);
      Surrogate type = null;
      Stella_Object firstargument = null;

      if (argument == null) {
        return (null);
      }
      if ((predicatevalue != null) &&
          Stella_Object.isaP(predicatevalue, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        type = ((Surrogate)(((NamedDescription)(predicatevalue)).ioVariableTypes.first()));
      }
      firstargument = Logic.evaluateTypedArgument(argument, type);
      if ((relationname == Logic.SYM_PL_KERNEL_KB_VALUE) ||
          (relationname == Logic.SYM_PL_KERNEL_KB_HOLDS)) {
        if (Logic.descriptionModeP() &&
            Logic.variableP(firstargument)) {
          { Proposition fnprop = ((PatternVariable)(firstargument)).definingProposition;

            { boolean testValue000 = false;

              testValue000 = fnprop != null;
              if (testValue000) {
                { boolean foundP000 = false;

                  { int i = Stella.NULL_INTEGER;
                    int iter000 = 0;
                    int upperBound000 = fnprop.arguments.length() - 2;

                    loop000 : for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
                      i = iter000;
                      if (Logic.variableP((fnprop.arguments.theArray)[i])) {
                        foundP000 = true;
                        break loop000;
                      }
                    }
                  }
                  testValue000 = foundP000;
                }
                testValue000 = !testValue000;
              }
              if (testValue000) {
                { Object old$Evaluationmode$000 = Logic.$EVALUATIONMODE$.get();

                  try {
                    Native.setSpecial(Logic.$EVALUATIONMODE$, Logic.KWD_EXTENSIONAL_ASSERTION);
                    firstargument = Logic.evaluateTypedArgument(argument, type);

                  } finally {
                    Logic.$EVALUATIONMODE$.set(old$Evaluationmode$000);
                  }
                }
              }
            }
          }
        }
      }
      else {
      }
      if (firstargument == null) {
        Logic.signalUndefinedTerm(argument);
      }
      { Object old$SuppressnonlogicobjectwarningP$000 = Logic.$SUPPRESSNONLOGICOBJECTWARNINGp$.get();

        try {
          Native.setBooleanSpecial(Logic.$SUPPRESSNONLOGICOBJECTWARNINGp$, true);
          if (Logic.valueOf(firstargument) == Logic.BOTTOM) {
            Logic.signalUndefinedTerm(firstargument);
          }

        } finally {
          Logic.$SUPPRESSNONLOGICOBJECTWARNINGp$.set(old$SuppressnonlogicobjectwarningP$000);
        }
      }
      return (firstargument);
    }
  }

  public static boolean classOperatorP(GeneralizedSymbol operator) {
    { NamedDescription description = Logic.getDescription(operator);

      return ((description != null) &&
          NamedDescription.classDescriptionP(description));
    }
  }

  public static Proposition buildPredicateProposition(Cons tree) {
    if ((tree.length() == 2) &&
        Logic.classOperatorP(((GeneralizedSymbol)(tree.value)))) {
      return (Logic.buildIsaProposition(Cons.list$(Cons.cons(Logic.SYM_STELLA_ISA, Cons.cons(tree.rest.value, Cons.cons(Cons.cons(tree.value, Stella.NIL), Stella.NIL))))));
    }
    if (Logic.holdsOperatorP(tree.value)) {
      return (Logic.buildHoldsProposition(tree));
    }
    { Stella_Object predicatename = tree.value;
      Proposition proposition = Logic.createProposition(Logic.SYM_STELLA_PREDICATE, tree.rest.length());
      Stella_Object firstargument = null;
      LogicObject predicatevalue = null;

      { Object [] caller_MV_returnarray = new Object[1];

        predicatevalue = Logic.evaluatePredicateAndFirstArgument(tree, caller_MV_returnarray);
        firstargument = ((Stella_Object)(caller_MV_returnarray[0]));
      }
      if (firstargument != null) {
        tree.secondSetter(firstargument);
        (proposition.arguments.theArray)[0] = firstargument;
      }
      if ((predicatevalue != null) &&
          Logic.functionP(predicatevalue)) {
        if (Logic.descriptionModeP()) {
          proposition.kind = Logic.KWD_FUNCTION;
        }
        else {
          { int lastargindex = tree.length() - 1;
            Stella_Object resultargument = Logic.evaluateTypedArgument(tree.nth(lastargindex), ((Surrogate)(((NamedDescription)(predicatevalue)).ioVariableTypes.last())));

            tree.nthSetter(null, lastargindex);
            tree = tree.remove(null);
            return (((Proposition)(Logic.buildProposition(Cons.list$(Cons.cons(Logic.SYM_STELLA_e, Cons.cons(tree, Cons.cons(Cons.cons(resultargument, Stella.NIL), Stella.NIL))))))));
          }
        }
      }
      { Stella_Object arg = null;
        Cons iter000 = LogicObject.evaluateRemainingArguments(predicatevalue, tree.rest.rest);
        int i = Stella.NULL_INTEGER;
        int iter001 = 1;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
          arg = iter000.value;
          i = iter001;
          (proposition.arguments.theArray)[i] = arg;
        }
      }
      proposition.operator = ((predicatevalue != null) ? predicatevalue.surrogateValueInverse : ((GeneralizedSymbol)(predicatename)));
      if (proposition.operator == Logic.SGT_PL_KERNEL_KB_VALUE) {
        proposition = Proposition.normalizeValueFunction(proposition);
      }
      Proposition.verifyArgumentTypesAndCount(proposition);
      return (proposition);
    }
  }

  public static boolean checkStrictTypeP(Stella_Object self, Surrogate type, boolean shallowP) {
    shallowP = shallowP;
    if ((type == null) ||
        ((self == null) ||
         (type == Logic.SGT_STELLA_THING))) {
      return (true);
    }
    if ((type == Logic.SGT_STELLA_BOOLEAN) &&
        ((self == Logic.TRUE_PROPOSITION) ||
         (self == Logic.FALSE_PROPOSITION))) {
      return (true);
    }
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable self000 = ((PatternVariable)(self));

          return (true);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_LITERAL_WRAPPER)) {
        { LiteralWrapper self000 = ((LiteralWrapper)(self));

          if (Stella_Object.isaP(type.surrogateValue, Logic.SGT_STELLA_CLASS) &&
              Surrogate.subtypeOfP(Logic.logicalType(self000), type)) {
            return (true);
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          if (Stella_Object.isaP(type.surrogateValue, Logic.SGT_STELLA_CLASS) &&
              Surrogate.subtypeOfP(Logic.logicalType(self000), type)) {
            return (true);
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_QUANTITY_LOGIC_WRAPPER)) {
        { QuantityLogicWrapper self000 = ((QuantityLogicWrapper)(self));

          return (true);
        }
      }
      else {
      }
    }
    return (Logic.testIsaP(self, type) ||
        Logic.logicalSubtypeOfP(Logic.logicalType(self), type));
  }

  public static boolean checkTypeP(Stella_Object self, Surrogate type, boolean shallowP) {
    return (((((QueryIterator)(Logic.$QUERYITERATOR$.get())) != null) &&
        (((QueryIterator)(Logic.$QUERYITERATOR$.get())).partialMatchStrategy != null)) ||
        Logic.checkStrictTypeP(self, type, shallowP));
  }

  public static boolean checkCoercedTypeP(Stella_Object self, Surrogate type, boolean shallowP, Object [] MV_returnarray) {
    if (Logic.checkStrictTypeP(self, type, shallowP)) {
      { boolean _return_temp = true;

        MV_returnarray[0] = self;
        return (_return_temp);
      }
    }
    { Stella_Object substitutedvalue = Logic.coerceIncompatibleValue(self, type);

      if (substitutedvalue != null) {
        { boolean _return_temp = true;

          MV_returnarray[0] = substitutedvalue;
          return (_return_temp);
        }
      }
    }
    if ((((QueryIterator)(Logic.$QUERYITERATOR$.get())) != null) &&
        (((QueryIterator)(Logic.$QUERYITERATOR$.get())).partialMatchStrategy != null)) {
      { boolean _return_temp = true;

        MV_returnarray[0] = self;
        return (_return_temp);
      }
    }
    else {
      { boolean _return_temp = false;

        MV_returnarray[0] = self;
        return (_return_temp);
      }
    }
  }

  public static Stella_Object coerceIncompatibleValue(Stella_Object value, Surrogate type) {
    { Stella_Object substituteValue = null;

      if (Logic.relationrefSpecializesRelationrefP(type, Logic.SGT_PL_KERNEL_KB_QUANTITY)) {
        return (Logic.coerceQuantity(value, type));
      }
      else if (Logic.relationrefSpecializesRelationrefP(type, Logic.SGT_PL_KERNEL_KB_DATE)) {
        return (Logic.coerceDate(value, type));
      }
      else if (Stella_Object.isaP(value, Logic.SGT_STELLA_LITERAL_WRAPPER) &&
          Logic.testIsaP(Logic.rewrapArgument(value), type)) {
        return (Logic.rewrapArgument(value));
      }
      { Surrogate testValue000 = Stella_Object.safePrimaryType(value);

        if (Surrogate.subtypeOfIntegerP(testValue000)) {
          { IntegerWrapper value000 = ((IntegerWrapper)(value));

            if (type == Logic.SGT_STELLA_FLOAT) {
              { int intvalue = value000.wrapperValue;
                double floatvalue = ((double)(intvalue));

                substituteValue = FloatWrapper.wrapFloat(floatvalue);
              }
            }
          }
        }
        else if (Surrogate.subtypeOfFloatP(testValue000)) {
          { FloatWrapper value000 = ((FloatWrapper)(value));

            if (type == Logic.SGT_STELLA_INTEGER) {
              { double floatvalue = value000.wrapperValue;
                int intvalue = Native.floor(floatvalue);

                if (((double)(intvalue)) == floatvalue) {
                  substituteValue = IntegerWrapper.wrapInteger(intvalue);
                }
              }
            }
          }
        }
        else {
        }
      }
      return (substituteValue);
    }
  }

  public static Stella_Object coerceQuantity(Stella_Object value, Surrogate quantitytyperef) {
    return (value);
  }

  public static Stella_Object coerceDate(Stella_Object value, Surrogate datetyperef) {
    return (value);
  }

  public static void verifyOneArgumentType(Stella_Object arg, Surrogate type, Proposition proposition, NamedDescription description) {
    if ((((Keyword)(Logic.$TYPECHECKMODE$.get())) == Logic.KWD_IGNORE_TYPE_VIOLATIONS) ||
        (type.surrogateValue == null)) {
      return;
    }
    { Stella_Object argvalue = Logic.valueOf(arg);
      boolean typeisokP = false;
      Stella_Object substitutevalue = null;

      { Object [] caller_MV_returnarray = new Object[1];

        typeisokP = Logic.checkCoercedTypeP(argvalue, type, false, caller_MV_returnarray);
        substitutevalue = ((Stella_Object)(caller_MV_returnarray[0]));
      }
      if (!Stella_Object.eqlP(argvalue, substitutevalue)) {
        { Stella_Object argtoo = null;
          Vector vector000 = proposition.arguments;
          int index000 = 0;
          int length000 = vector000.length();
          Surrogate t = null;
          Cons iter000 = description.ioVariableTypes.theConsList;
          int i = Stella.NULL_INTEGER;
          int iter001 = 0;

          for (;(index000 < length000) &&
                    (!(iter000 == Stella.NIL)); 
                index000 = index000 + 1,
                iter000 = iter000.rest,
                iter001 = iter001 + 1) {
            argtoo = (vector000.theArray)[index000];
            t = ((Surrogate)(iter000.value));
            i = iter001;
            if (Stella_Object.eqlP(argtoo, arg) &&
                (t == type)) {
              (proposition.arguments.theArray)[i] = substitutevalue;
            }
          }
        }
      }
      else if (!typeisokP) {
        Proposition.handleArgumentTypeViolation(proposition, arg, type);
      }
    }
  }

  public static void processCheckTypesAgenda() {
    if ((Logic.$CHECK_TYPES_AGENDA$.sequenceLength == 0) ||
        ((Boolean)(Logic.$INHIBITOBJECTFINALIZATIONp$.get())).booleanValue()) {
      return;
    }
    Logic.plLog(Logic.KWD_MEDIUM, Cons.cons(StringWrapper.wrapString("Processing check-types agenda..."), Stella.NIL));
    { VectorSequence agenda = Logic.$CHECK_TYPES_AGENDA$;
      Proposition proposition = null;

      Logic.$CHECK_TYPES_AGENDA$ = VectorSequence.newVectorSequence(4);
      { CheckTypesRecord record = null;
        VectorSequence vector000 = agenda;
        int index000 = 0;
        int length000 = vector000.sequenceLength;

        loop000 : for (;index000 < length000; index000 = index000 + 1) {
          record = ((CheckTypesRecord)((vector000.theArray)[index000]));
          proposition = record.proposition;
          if (!proposition.deletedP()) {
            { Object old$Typecheckmode$000 = Logic.$TYPECHECKMODE$.get();
              Object old$Termunderconstruction$000 = Logic.$TERMUNDERCONSTRUCTION$.get();
              Object old$Descriptionunderconstruction$000 = Logic.$DESCRIPTIONUNDERCONSTRUCTION$.get();
              Object old$Evaluationmode$000 = Logic.$EVALUATIONMODE$.get();

              try {
                Native.setSpecial(Logic.$TYPECHECKMODE$, ((((BooleanWrapper)(KeyValueList.dynamicSlotValue(proposition.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTIVEp, Stella.FALSE_WRAPPER))).wrapperValue &&
                    (!(Logic.$TYPE_CHECK_POLICY$ == Logic.KWD_IGNORE_TYPE_VIOLATIONS))) ? Logic.KWD_REPORT_TYPE_VIOLATIONS : Logic.$TYPE_CHECK_POLICY$));
                Native.setSpecial(Logic.$TERMUNDERCONSTRUCTION$, record.parentProposition);
                Native.setSpecial(Logic.$DESCRIPTIONUNDERCONSTRUCTION$, record.parentDescription);
                Native.setSpecial(Logic.$EVALUATIONMODE$, Logic.KWD_EXTENSIONAL_ASSERTION);
                if (((((Stella_Object)(Logic.$TERMUNDERCONSTRUCTION$.get())) != null) &&
                    ((Stella_Object)(Logic.$TERMUNDERCONSTRUCTION$.get())).deletedP()) ||
                    ((((Stella_Object)(Logic.$DESCRIPTIONUNDERCONSTRUCTION$.get())) != null) &&
                     ((Stella_Object)(Logic.$DESCRIPTIONUNDERCONSTRUCTION$.get())).deletedP())) {
                  continue loop000;
                }
                try {
                  { Object old$Module$000 = Stella.$MODULE$.get();
                    Object old$Context$000 = Stella.$CONTEXT$.get();

                    try {
                      Native.setSpecial(Stella.$MODULE$, record.module);
                      Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
                      Proposition.verifyArgumentTypesAndCount(proposition);

                    } finally {
                      Stella.$CONTEXT$.set(old$Context$000);
                      Stella.$MODULE$.set(old$Module$000);
                    }
                  }
                } catch (LogicException e) {
                  Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
                }

              } finally {
                Logic.$EVALUATIONMODE$.set(old$Evaluationmode$000);
                Logic.$DESCRIPTIONUNDERCONSTRUCTION$.set(old$Descriptionunderconstruction$000);
                Logic.$TERMUNDERCONSTRUCTION$.set(old$Termunderconstruction$000);
                Logic.$TYPECHECKMODE$.set(old$Typecheckmode$000);
              }
            }
          }
        }
      }
    }
  }

  /** Finish processing all definitions and assertions that have
   * been evaluated/loaded since that last call to 'process-definitions'.
   * PowerLoom defers complete processing of definitions to make it easier
   * to support cyclic definitions.  Following finalization of definitions,
   * this call performs semantic validation of any assertions evaluated since
   * the last call to 'process-definitions'.  PowerLoom calls this function
   * internally before each query; the primary reason to call it explicitly
   * is to force the production of any diagnostic information that results from
   * the processing and validation.
   */
  public static void processDefinitions() {
    Logic.finalizeObjects();
    Logic.processCheckTypesAgenda();
  }

  public static Proposition buildExistsProposition(Cons tree) {
    { Cons variables = null;
      Proposition proposition = null;
      Proposition unused = null;

      { Object [] caller_MV_returnarray = new Object[2];

        variables = Logic.buildQuantifiedProposition(tree, true, caller_MV_returnarray);
        proposition = ((Proposition)(caller_MV_returnarray[0]));
        unused = ((Proposition)(caller_MV_returnarray[1]));
      }
      unused = unused;
      { Proposition existsprop = Logic.createProposition(Logic.SYM_STELLA_EXISTS, 1);

        existsprop.kind = Logic.KWD_EXISTS;
        (existsprop.arguments.theArray)[0] = proposition;
        KeyValueList.setDynamicSlotValue(existsprop.dynamicSlots, Logic.SYM_LOGIC_IO_VARIABLES, Logic.copyConsListToVariablesVector(variables), null);
        return (existsprop);
      }
    }
  }

  public static Proposition buildForallProposition(Cons tree) {
    { Proposition forallprop = Logic.createProposition(Logic.SYM_STELLA_FORALL, 2);

      { Cons variables = null;
        Proposition antecedent = null;
        Proposition consequent = null;

        { Object [] caller_MV_returnarray = new Object[2];

          variables = Logic.buildQuantifiedProposition(tree, true, caller_MV_returnarray);
          antecedent = ((Proposition)(caller_MV_returnarray[0]));
          consequent = ((Proposition)(caller_MV_returnarray[1]));
        }
        forallprop.kind = Logic.KWD_FORALL;
        KeyValueList.setDynamicSlotValue(forallprop.dynamicSlots, Logic.SYM_LOGIC_IO_VARIABLES, Logic.copyConsListToVariablesVector(variables), null);
        (forallprop.arguments.theArray)[0] = (((antecedent != null) ? antecedent : Logic.TRUE_PROPOSITION));
        (forallprop.arguments.theArray)[1] = consequent;
      }
      return (forallprop);
    }
  }

  public static Stella_Object maybeSubstituteSurrogateArgument(Stella_Object arg1, Stella_Object arg2) {
    if (Logic.skolemP(arg2) ||
        Logic.descriptionModeP()) {
      if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(arg1), Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description arg1000 = ((Description)(arg1));

          if (arg1000.descriptionSurrogate() != null) {
            return (arg1000.descriptionSurrogate());
          }
        }
      }
      else {
      }
    }
    return (arg1);
  }

  public static Proposition createImpliesProposition(Stella_Object tail, Stella_Object head) {
    { Proposition impliesprop = Logic.createProposition(Logic.SYM_LOGIC_IMPLIES, 2);

      (impliesprop.arguments.theArray)[0] = (Logic.maybeSubstituteSurrogateArgument(tail, head));
      (impliesprop.arguments.theArray)[1] = (Logic.maybeSubstituteSurrogateArgument(head, tail));
      Proposition.verifyArgumentTypesAndCount(impliesprop);
      return (impliesprop);
    }
  }

  public static Proposition buildImpliesProposition(Cons tree) {
    Logic.verifyNumberOfPropositionArguments(tree, 2);
    { Stella_Object tailarg = Logic.evaluateTerm(tree.rest.value);
      Stella_Object headarg = Logic.evaluateTerm(tree.rest.rest.value);

      return (Logic.createImpliesProposition(tailarg, headarg));
    }
  }

  public static Surrogate unwrapWrappedType(Surrogate type) {
    if ((type != null) &&
        ((type.surrogateValue != null) &&
         (Stella_Object.isaP(type.surrogateValue, Logic.SGT_STELLA_CLASS) &&
          Surrogate.subtypeOfP(type, Logic.SGT_STELLA_LITERAL_WRAPPER)))) {
      type = Surrogate.wrappedTypeToType(type);
    }
    return (type);
  }

  public static Proposition beginCreatingFunctionProposition(GeneralizedSymbol surrogate, Cons inputarguments) {
    { int argcount = inputarguments.length() + 1;
      Proposition proposition = Logic.createProposition(Logic.SYM_STELLA_FUNCTION, argcount);

      proposition.operator = surrogate;
      { Stella_Object arg = null;
        Cons iter000 = inputarguments;
        int i = Stella.NULL_INTEGER;
        int iter001 = 0;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
          arg = iter000.value;
          i = iter001;
          (proposition.arguments.theArray)[i] = arg;
        }
      }
      return (proposition);
    }
  }

  public static Proposition findOrCreateFunctionProposition(GeneralizedSymbol predicate, Cons inputarguments) {
    { Proposition proposition = Logic.beginCreatingFunctionProposition(predicate, inputarguments);
      Proposition duplicate = ((!Logic.descriptionModeP()) ? Proposition.findDuplicateFunctionProposition(proposition) : ((Proposition)(null)));

      if (duplicate != null) {
        return (duplicate);
      }
      proposition = Proposition.finishCreatingFunctionProposition(proposition);
      { boolean testValue000 = false;

        if (!((BooleanWrapper)(KeyValueList.dynamicSlotValue(proposition.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTIVEp, Stella.FALSE_WRAPPER))).wrapperValue) {
          testValue000 = true;
        }
        else {
          { boolean alwaysP000 = true;

            { int i = Stella.NULL_INTEGER;
              int iter000 = 0;
              int upperBound000 = proposition.arguments.length() - 2;

              loop000 : for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
                i = iter000;
                if (!(!Logic.variableP((proposition.arguments.theArray)[i]))) {
                  alwaysP000 = false;
                  break loop000;
                }
              }
            }
            testValue000 = alwaysP000;
          }
        }
        if (testValue000) {
          Proposition.runGoesTrueDemons(proposition);
        }
      }
      return (proposition);
    }
  }

  public static Proposition createFunctionProposition(GeneralizedSymbol predicate, Cons inputarguments) {
    { Proposition proposition = Logic.beginCreatingFunctionProposition(predicate, inputarguments);
      Proposition duplicate = ((!Logic.descriptionModeP()) ? Proposition.findDuplicateFunctionProposition(proposition) : ((Proposition)(null)));

      if (!(duplicate == null)) {
        System.err.print("Safety violation: INTERNAL ERROR: encountered unexpected duplicate function proposition: `" + duplicate + "'");
      }
      return (Proposition.finishCreatingFunctionProposition(proposition));
    }
  }

  public static Stella_Object evaluateFunctionTerm(Cons tree) {
    if (!(Stella_Object.isaP(tree.value, Logic.SGT_STELLA_GENERALIZED_SYMBOL))) {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

          try {
            Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
            stream000.nativeStream.println("ERROR: Illegal function name in function term: `" + tree + "'.");
            Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

          } finally {
            Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
          }
        }
        throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
      }
    }
    { GeneralizedSymbol name = ((GeneralizedSymbol)(tree.value));
      Stella_Object firstargument = Logic.evaluateFirstArgument(tree.rest.value, ((Symbol)(name)));
      LogicObject predicatevalue = Logic.evaluatePredicate(name, firstargument);
      Cons inputarguments = LogicObject.evaluateRemainingArguments(predicatevalue, tree.rest.rest);

      if ((predicatevalue != null) &&
          (Stella_Object.isaP(predicatevalue, Logic.SGT_LOGIC_DESCRIPTION) &&
           (!NamedDescription.functionDescriptionP(((NamedDescription)(predicatevalue)))))) {
        { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream001.nativeStream.println("ERROR: Relation `" + ((NamedDescription)(predicatevalue)).descriptionName() + "' found in function position..");
              Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
            }
          }
          throw ((PropositionError)(PropositionError.newPropositionError(stream001.theStringReader()).fillInStackTrace()));
        }
      }
      if (firstargument != null) {
        inputarguments = Cons.cons(firstargument, inputarguments);
      }
      if ((predicatevalue != null) &&
          (Logic.objectSurrogate(predicatevalue) == Logic.SGT_PL_KERNEL_KB_SETOF)) {
        inputarguments = Logic.normalizeSetofArguments(inputarguments);
      }
      { Proposition functionproposition = Logic.findOrCreateFunctionProposition(((predicatevalue != null) ? predicatevalue.surrogateValueInverse : name), inputarguments);

        if (Stella_Object.symbolP(functionproposition.operator) &&
            (!Logic.descriptionModeP())) {
          Proposition.complainAboutUndeclaredReference(functionproposition);
          Proposition.createDummyRelation(functionproposition);
        }
        return ((functionproposition.arguments.theArray)[(functionproposition.arguments.length() - 1)]);
      }
    }
  }

  public static boolean extensionalIndividualP(Stella_Object individual) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(individual);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable individual000 = ((PatternVariable)(individual));

          return (false);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
        { Skolem individual000 = ((Skolem)(individual));

          { Proposition definingproposition = individual000.definingProposition;

            { boolean foundP000 = false;

              { Proposition prop = null;
                Iterator iter000 = Logic.unfilteredDependentPropositions(individual000, null).allocateIterator();

                loop000 : while (iter000.nextP()) {
                  prop = ((Proposition)(iter000.value));
                  if ((!(prop == definingproposition)) &&
                      ((!prop.deletedP()) &&
                       ((((Boolean)(Logic.$REVERSEPOLARITYp$.get())).booleanValue() ? Proposition.falseP(prop) : (Proposition.trueP(prop) ||
                      Proposition.functionWithDefinedValueP(prop)))))) {
                    foundP000 = true;
                    break loop000;
                  }
                }
              }
              if (foundP000) {
                return (true);
              }
            }
          }
          { boolean foundP001 = false;

            { LogicObject sk = null;
              Cons iter001 = individual000.variableValueInverse();

              loop001 : for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                sk = ((LogicObject)(iter001.value));
                if (Logic.extensionalIndividualP(sk)) {
                  foundP001 = true;
                  break loop001;
                }
              }
            }
            { boolean value000 = foundP001;

              return (value000);
            }
          }
        }
      }
      else {
        return (true);
      }
    }
  }

  public static Cons normalizeSetofArguments(Cons args) {
    return (Cons.copyConsList(args).removeDuplicates().sort(Native.find_java_method("edu.isi.powerloom.logic.Logic", "logicFormLessP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object")})));
  }

  public static Skolem createEnumeratedSet(List set) {
    { Cons setelements = Logic.normalizeSetofArguments(set.theConsList);
      Proposition setprop = Logic.beginCreatingFunctionProposition(Logic.SGT_PL_KERNEL_KB_SETOF, setelements);
      Proposition duplicate = ((!Logic.descriptionModeP()) ? Proposition.findDuplicateFunctionProposition(setprop) : ((Proposition)(null)));
      Skolem skolem = null;

      if (duplicate != null) {
        return (((Skolem)((duplicate.arguments.theArray)[(duplicate.arguments.length() - 1)])));
      }
      { Object old$Context$000 = Stella.$CONTEXT$.get();
        Object old$Module$000 = Stella.$MODULE$.get();

        try {
          Native.setSpecial(Stella.$CONTEXT$, setprop.homeContext);
          Native.setSpecial(Stella.$MODULE$, ((Context)(Stella.$CONTEXT$.get())).baseModule);
          skolem = Logic.createSkolem(Logic.SGT_PL_KERNEL_KB_SET, null);

        } finally {
          Stella.$MODULE$.set(old$Module$000);
          Stella.$CONTEXT$.set(old$Context$000);
        }
      }
      (setprop.arguments.theArray)[(setprop.arguments.length() - 1)] = skolem;
      skolem.definingProposition = setprop;
      Logic.addDependentPropositionLink(skolem, setprop);
      KeyValueList.setDynamicSlotValue(setprop.dynamicSlots, Logic.SYM_LOGIC_UNFASTENEDp, null, null);
      return (skolem);
    }
  }

  public static Skolem createLogicalList(List list) {
    { Proposition listprop = Logic.beginCreatingFunctionProposition(Logic.SGT_PL_KERNEL_KB_LISTOF, list.theConsList);
      Proposition duplicate = ((!Logic.descriptionModeP()) ? Proposition.findDuplicateFunctionProposition(listprop) : ((Proposition)(null)));
      Skolem skolem = null;

      if (duplicate != null) {
        return (((Skolem)((duplicate.arguments.theArray)[(duplicate.arguments.length() - 1)])));
      }
      { Object old$Context$000 = Stella.$CONTEXT$.get();
        Object old$Module$000 = Stella.$MODULE$.get();

        try {
          Native.setSpecial(Stella.$CONTEXT$, listprop.homeContext);
          Native.setSpecial(Stella.$MODULE$, ((Context)(Stella.$CONTEXT$.get())).baseModule);
          skolem = Logic.createSkolem(Logic.SGT_PL_KERNEL_KB_LIST, null);

        } finally {
          Stella.$MODULE$.set(old$Module$000);
          Stella.$CONTEXT$.set(old$Context$000);
        }
      }
      (listprop.arguments.theArray)[(list.length())] = skolem;
      skolem.definingProposition = listprop;
      Logic.addDependentPropositionLink(skolem, listprop);
      KeyValueList.setDynamicSlotValue(listprop.dynamicSlots, Logic.SYM_LOGIC_UNFASTENEDp, null, null);
      return (skolem);
    }
  }

  public static boolean logicalCollectionP(Stella_Object self) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(self), Logic.SGT_LOGIC_SKOLEM)) {
      { Skolem self000 = ((Skolem)(self));

        { Proposition definingproposition = self000.definingProposition;

          return ((definingproposition != null) &&
              Proposition.collectionofPropositionP(definingproposition));
        }
      }
    }
    else {
      return (false);
    }
  }

  public static boolean functionOutputSkolemP(Stella_Object self) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(self), Logic.SGT_LOGIC_SKOLEM)) {
      { Skolem self000 = ((Skolem)(self));

        return (self000.definingProposition != null);
      }
    }
    else {
      return (false);
    }
  }

  public static boolean skolemDefinedByOperatorP(Stella_Object self, Surrogate operator) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(self), Logic.SGT_LOGIC_SKOLEM)) {
      { Skolem self000 = ((Skolem)(self));

        { Proposition definingproposition = self000.definingProposition;

          return ((definingproposition != null) &&
              (definingproposition.operator == operator));
        }
      }
    }
    else {
      return (false);
    }
  }

  public static boolean enumeratedSetP(Stella_Object self) {
    return (Logic.skolemDefinedByOperatorP(self, Logic.SGT_PL_KERNEL_KB_SETOF));
  }

  public static boolean enumeratedListP(Stella_Object self) {
    return (Logic.skolemDefinedByOperatorP(self, Logic.SGT_PL_KERNEL_KB_LISTOF));
  }

  public static Stella_Object canonicalizePropositionTree(Stella_Object tree) {
    return (tree);
  }

  public static Keyword invertUpdateMode(Keyword updatemode) {
    if (updatemode == Logic.KWD_ASSERT_TRUE) {
      return (Logic.KWD_ASSERT_FALSE);
    }
    else if (updatemode == Logic.KWD_PRESUME_TRUE) {
      return (Logic.KWD_PRESUME_FALSE);
    }
    else if (updatemode == Logic.KWD_RETRACT_TRUE) {
      return (Logic.KWD_RETRACT_FALSE);
    }
    else if (updatemode == Logic.KWD_ASSERT_FALSE) {
      return (Logic.KWD_ASSERT_TRUE);
    }
    else if (updatemode == Logic.KWD_PRESUME_FALSE) {
      return (Logic.KWD_PRESUME_TRUE);
    }
    else if (updatemode == Logic.KWD_RETRACT_FALSE) {
      return (Logic.KWD_RETRACT_TRUE);
    }
    else {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        stream000.nativeStream.print("`" + updatemode + "' is not a valid case option");
        throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
      }
    }
  }

  public static Keyword defaultifyUpdateMode(Keyword updatemode) {
    if (updatemode == Logic.KWD_ASSERT_TRUE) {
      return (Logic.KWD_PRESUME_TRUE);
    }
    else if (updatemode == Logic.KWD_ASSERT_FALSE) {
      return (Logic.KWD_PRESUME_FALSE);
    }
    else {
      return (updatemode);
    }
  }

  public static Cons updateTopLevelProposition(Stella_Object tree, Keyword updatemode) {
    if ((updatemode == Logic.KWD_ASSERT_FALSE) ||
        ((updatemode == Logic.KWD_PRESUME_FALSE) ||
         (updatemode == Logic.KWD_RETRACT_FALSE))) {
      tree = Cons.list$(Cons.cons(Logic.SYM_STELLA_NOT, Cons.cons(tree, Cons.cons(Stella.NIL, Stella.NIL))));
      updatemode = Logic.invertUpdateMode(updatemode);
    }
    else {
    }
    if (updatemode == Logic.KWD_ASSERT_TRUE) {
      { Object old$Automaticinstancetable$000 = Logic.$AUTOMATICINSTANCETABLE$.get();

        try {
          Native.setSpecial(Logic.$AUTOMATICINSTANCETABLE$, null);
          return (Proposition.helpUpdateTopLevelProposition(Logic.buildTopLevelProposition(tree, true), updatemode));

        } finally {
          Logic.$AUTOMATICINSTANCETABLE$.set(old$Automaticinstancetable$000);
        }
      }
    }
    else {
      return (Proposition.helpUpdateTopLevelProposition(Logic.buildTopLevelProposition(tree, false), updatemode));
    }
  }

  public static Stella_Object standardizePropositionTree(Stella_Object tree) {
    if (Stella_Object.stringP(tree)) {
      tree = Stella.readSExpressionFromString(((StringWrapper)(tree)).wrapperValue);
    }
    tree = Logic.standardizeLogicalParseTree(tree);
    if (Stella_Object.consP(tree)) {
      tree = Logic.canonicalizePropositionTree(tree);
    }
    return (tree);
  }

  public static Cons updateProposition(Stella_Object tree, Keyword updatemode) {
    try {
      { Object old$InhibitobjectfinalizationP$000 = Logic.$INHIBITOBJECTFINALIZATIONp$.get();

        try {
          Native.setBooleanSpecial(Logic.$INHIBITOBJECTFINALIZATIONp$, true);
          return (Logic.updateTopLevelProposition(Logic.standardizePropositionTree(tree), updatemode));

        } finally {
          Logic.$INHIBITOBJECTFINALIZATIONp$.set(old$InhibitobjectfinalizationP$000);
        }
      }
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
    } catch (ReadException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
    }
    return (null);
  }

  public static Stella_Object buildTopLevelTerm(Stella_Object tree) {
    { Stella_Object term = null;

      { Object old$Logicvariabletable$000 = Logic.$LOGICVARIABLETABLE$.get();
        Object old$Variableidcounter$000 = Logic.$VARIABLEIDCOUNTER$.get();
        Object old$Termunderconstruction$000 = Logic.$TERMUNDERCONSTRUCTION$.get();

        try {
          Native.setSpecial(Logic.$LOGICVARIABLETABLE$, Stella.NIL);
          Native.setIntSpecial(Logic.$VARIABLEIDCOUNTER$, 0);
          Native.setSpecial(Logic.$TERMUNDERCONSTRUCTION$, tree);
          if (Stella_Object.safePrimaryType(tree) == Logic.SGT_STELLA_CONS) {
            { Cons tree000 = ((Cons)(tree));

              if (Stella.getQuotedTree("((FORALL EXISTS IMPLIES AND OR NOT) \"/LOGIC\")", "/LOGIC").memberP(tree000.value)) {
                {
                  Stella.STANDARD_WARNING.nativeStream.println("Warning: Sentence where term expected: `" + tree000 + "'");
                  Stella.STANDARD_WARNING.nativeStream.println();
                }
;
                return (null);
              }
            }
          }
          else {
          }
          term = Logic.evaluateTerm(tree);

        } finally {
          Logic.$TERMUNDERCONSTRUCTION$.set(old$Termunderconstruction$000);
          Logic.$VARIABLEIDCOUNTER$.set(old$Variableidcounter$000);
          Logic.$LOGICVARIABLETABLE$.set(old$Logicvariabletable$000);
        }
      }
      return (term);
    }
  }

  /** <code>tree</code> is a term expression (a string or an s-expression),
   * or is a class reference (a symbol or surrogate).  Return a (possibly 
   * newly-conceived) term representing the internalized representation of that term.
   * @param tree
   * @return Stella_Object
   */
  public static Stella_Object conceiveTerm(Stella_Object tree) {
    try {
      { Stella_Object standardizedtree = Logic.standardizePropositionTree(tree);
        Stella_Object operator = null;
        Stella_Object term = null;

        if (Stella_Object.consP(standardizedtree)) {
          operator = ((Cons)(standardizedtree)).value;
        }
        if ((operator != null) &&
            ((Logic.getRelation(operator) != null) &&
             (!Logic.functionP(Logic.getRelation(operator))))) {
          term = Logic.conceiveSentence(tree);
        }
        else {
          term = Logic.buildTopLevelTerm(standardizedtree);
        }
        return (term);
      }
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
    } catch (ReadException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
    }
    return (null);
  }

  public static Stella_Object conceiveSentence(Stella_Object tree) {
    if (Surrogate.subtypeOfStringP(Stella_Object.safePrimaryType(tree))) {
      { StringWrapper tree000 = ((StringWrapper)(tree));

        return (Logic.conceiveSentence(Stella.readSExpressionFromString(tree000.wrapperValue)));
      }
    }
    else {
      return (Logic.smartUpdateProposition(tree, Logic.KWD_CONCEIVE));
    }
  }

  public static Stella_Object conceiveFormula(Stella_Object tree) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(tree);

      if (Surrogate.subtypeOfStringP(testValue000)) {
        { StringWrapper tree000 = ((StringWrapper)(tree));

          return (Logic.conceiveFormula(Stella.readSExpressionFromString(tree000.wrapperValue)));
        }
      }
      else if (testValue000 == Logic.SGT_STELLA_CONS) {
        { Cons tree000 = ((Cons)(tree));

          if (Stella_Object.symbolP(tree000.value)) {
            { GeneralizedSymbol testValue001 = ((GeneralizedSymbol)(tree000.value));

              if ((testValue001 == Logic.SYM_LOGIC_KAPPA) ||
                  ((testValue001 == Logic.SYM_LOGIC_LAMBDA) ||
                   ((testValue001 == Logic.SYM_LOGIC_SETOFALL) ||
                    ((testValue001 == Logic.SYM_PL_KERNEL_KB_SETOF) ||
                     ((testValue001 == Logic.SYM_PL_KERNEL_KB_LISTOF) ||
                      (testValue001 == Logic.SYM_LOGIC_BAGOF)))))) {
                return (Logic.conceiveTerm(tree000));
              }
              else {
              }
            }
          }
          return (Logic.conceiveSentence(tree000));
        }
      }
      else if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol tree000 = ((Symbol)(tree));

          return (Logic.conceiveTerm(tree000));
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate tree000 = ((Surrogate)(tree));

          return (Logic.conceiveTerm(Symbol.internSymbolInModule(tree000.symbolName, ((Module)(tree000.homeContext)), true)));
        }
      }
      else {
        return (Logic.conceiveSentence(tree));
      }
    }
  }

  public static Stella_Object smartUpdateProposition(Stella_Object tree, Keyword updatemode) {
    { Cons propositions = Logic.updateProposition(tree, updatemode);

      if ((propositions != null) &&
          (propositions.rest == Stella.NIL)) {
        return (((Proposition)(propositions.value)));
      }
      else {
        return (propositions);
      }
    }
  }

  /** Assert the truth of <code>proposition</code>.  Return the asserted proposition object.
   * KIF example:  &quot;(assert (happy Fred))&quot; asserts that Fred is indeed happy.
   * Note that for this assertion to succeed, the relation <code>happy</code> must already
   * be defined.  If the constant <code>Fred</code> has not yet been created, it is
   * automatically created as a side-effect of calling <code>renamed_Assert</code>.
   * @param proposition
   * @return Stella_Object
   */
  public static Stella_Object renamed_Assert(Stella_Object proposition) {
    return (Logic.smartUpdateProposition(proposition, Logic.KWD_ASSERT_TRUE));
  }

  /** Presume the default truth of <code>proposition</code>.  Return the presumed
   * proposition object.  KIF example:  &quot;(presume (happy Fred))&quot; states that Fred
   * is most probably happy.  Note, that for this to succeed, the relation
   * <code>happy</code> must already be defined (see <code>renamed_Assert</code>).
   * @param proposition
   * @return Stella_Object
   */
  public static Stella_Object presume(Stella_Object proposition) {
    return (Logic.smartUpdateProposition(proposition, Logic.KWD_PRESUME_TRUE));
  }

  /** Retract the truth of <code>proposition</code>.  Return the retracted proposition
   * object.  KIF example:  &quot;(retract (happy Fred))&quot; retracts that Fred is
   * happy.  Note that for this assertion to succeed, the relation <code>happy</code> must already
   * be defined.  If the constant <code>Fred</code> has not yet been created, it is
   * automatically created as a side-effect of calling <code>retract</code>.
   * @param proposition
   * @return Stella_Object
   */
  public static Stella_Object retract(Stella_Object proposition) {
    return (Logic.smartUpdateProposition(proposition, Logic.KWD_RETRACT_TRUE));
  }

  /** Assert the falsity of <code>proposition</code>.  Return the asserted proposition
   * object.  KIF example:  &quot;(deny (happy Fred))&quot; asserts that Fred is not happy,
   * which could have been done equivalently by &quot;(assert (not (happy Fred)))&quot;.
   * Note, that for this to succeed, the relation <code>happy</code> must already be defined
   * (see <code>renamed_Assert</code>).
   * @param proposition
   * @return Stella_Object
   */
  public static Stella_Object deny(Stella_Object proposition) {
    return (Logic.smartUpdateProposition(proposition, Logic.KWD_ASSERT_FALSE));
  }

  /** Guess whether 'formula' represents a term or a sentence/proposition.
   * If we are not sure, assume its a proposition.
   * If its, a term, return its internal representation.  If a proposition,
   * construct a proposition for 'formula' without asserting its truth value.
   * Return the conceived proposition object.  KIF example: &quot;(conceive (happy Fred))&quot;
   * builds the proposition expressing that Fred is happy without explictly asserting
   * or denying it.  Note, that for this to succeed, the relation <code>happy</code> must already
   * be defined (see <code>renamed_Assert</code>).  If the logic constant <code>Fred</code> has not yet been
   * created, it is automatically created as a side-effect of calling <code>conceive</code>.
   * @param formula
   * @return Stella_Object
   */
  public static Stella_Object conceive(Stella_Object formula) {
    return (Logic.conceiveFormula(formula));
  }

  /** Retract the truth, falsity or inconsistency of <code>proposition</code>.  This is a
   * more general version of <code>retract</code> that also handles falsity.  For example, if
   * we assert the proposition &quot;(not (sad Fred))&quot;, and then execute the statement
   * &quot;(unassert (sad Fred))&quot;, the truth value of the proposition &quot;(sad Fred)&quot;
   * will be set to UNKNOWN.  If we had called <code>retract</code> in place of <code>unassert</code>,
   * the proposition &quot;(sad Fred)&quot; would remain set to FALSE.   Note that for this
   * unassertion to succeed, the logic constant <code>Fred</code> and the relation <code>sad</code> must
   * already be defined.
   * @param proposition
   * @return Stella_Object
   */
  public static Stella_Object unassert(Stella_Object proposition) {
    { Cons parsedprops = Logic.updateProposition(proposition, Logic.KWD_CONCEIVE);
      Cons result = Stella.NIL;

      if (parsedprops != null) {
        { Proposition prop = null;
          Cons iter000 = parsedprops;
          Cons collect000 = null;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            prop = ((Proposition)(iter000.value));
            if (prop.kind == Logic.KWD_NOT) {
              prop = ((Proposition)((prop.arguments.theArray)[0]));
            }
            Proposition.unassertProposition(prop);
            if (collect000 == null) {
              {
                collect000 = Cons.cons(prop, Stella.NIL);
                if (result == Stella.NIL) {
                  result = collect000;
                }
                else {
                  Cons.addConsToEndOfConsList(result, collect000);
                }
              }
            }
            else {
              {
                collect000.rest = Cons.cons(prop, Stella.NIL);
                collect000 = collect000.rest;
              }
            }
          }
        }
      }
      return (((result.length() > 1) ? result : result.value));
    }
  }

  public static void destroyLogicInstance(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          if ((self000 == null) ||
              self000.deletedP()) {
            return;
          }
          self000.deletedPSetter(true);
          { Surrogate surrogate = self000.surrogateValueInverse;

            if ((surrogate != null) &&
                (surrogate.surrogateValue == self000)) {
              surrogate.surrogateValue = null;
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing self000 = ((Thing)(self));

          if ((self000 == null) ||
              self000.deletedP()) {
            return;
          }
          self000.deletedPSetter(true);
          { Surrogate surrogate = self000.surrogateValueInverse;

            if ((surrogate != null) &&
                (surrogate.surrogateValue == self000)) {
              surrogate.surrogateValue = null;
            }
          }
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
    { Proposition p = null;
      Iterator iter000 = Logic.unfilteredDependentPropositions(self, null).allocateIterator();

      while (iter000.nextP()) {
        p = ((Proposition)(iter000.value));
        Proposition.destroyProposition(p);
      }
    }
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(self), Logic.SGT_LOGIC_LOGIC_OBJECT)) {
      { LogicObject self000 = ((LogicObject)(self));

        LogicObject.unlinkEquivalentValue(self000);
        { LogicObject equivalent = null;
          Cons iter001 = self000.variableValueInverse();

          for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
            equivalent = ((LogicObject)(iter001.value));
            if (!equivalent.deletedP()) {
              { Surrogate testValue001 = Stella_Object.safePrimaryType(equivalent);

                if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_SKOLEM)) {
                  { Skolem equivalent000 = ((Skolem)(equivalent));

                    { Skolem object000 = equivalent000;
                      Stella_Object value000 = null;
                      Stella_Object oldValue000 = object000.variableValue;
                      Stella_Object newValue000 = Stella_Object.updateInContext(oldValue000, value000, object000.homeContext, false);

                      if (!((oldValue000 != null) &&
                          (oldValue000.primaryType() == Logic.SGT_STELLA_CS_VALUE))) {
                        object000.variableValue = newValue000;
                      }
                    }
                  }
                }
                else if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
                  { LogicObject equivalent000 = ((LogicObject)(equivalent));

                    { LogicObject object001 = equivalent000;
                      Description value001 = null;
                      Stella_Object oldValue001 = KeyValueList.dynamicSlotValue(object001.dynamicSlots, Logic.SYM_LOGIC_EQUIVALENT_VALUE, null);
                      Stella_Object newValue001 = Stella_Object.updateInContext(oldValue001, value001, object001.homeContext, false);

                      if (!((oldValue001 != null) &&
                          (oldValue001.primaryType() == Logic.SGT_STELLA_CS_VALUE))) {
                        KeyValueList.setDynamicSlotValue(object001.dynamicSlots, Logic.SYM_LOGIC_EQUIVALENT_VALUE, newValue001, null);
                      }
                    }
                  }
                }
                else {
                  { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

                    stream001.nativeStream.print("`" + testValue001 + "' is not a valid case option");
                    throw ((StellaException)(StellaException.newStellaException(stream001.theStringReader()).fillInStackTrace()));
                  }
                }
              }
            }
          }
        }
        { LogicObject object002 = self000;
          Cons value002 = null;
          Stella_Object oldValue002 = object002.variableValueInverse;
          Stella_Object newValue002 = Stella_Object.updateInContext(oldValue002, value002, object002.homeContext, false);

          if (!((oldValue002 != null) &&
              (oldValue002.primaryType() == Logic.SGT_STELLA_CS_VALUE))) {
            object002.variableValueInverse = newValue002;
          }
        }
      }
    }
    else {
    }
  }

  /** Destroy all propositions that reference 'self',
   * and mark it as 'deleted?', thereby making it invisible within class
   * extensions.
   * @param self
   */
  public static void destroyInstance(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          LogicObject.destroyTerm(self000);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing self000 = ((Thing)(self));

          Logic.destroyLogicInstance(self000);
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  /** Destroy <code>self</code> which can be a term or a proposition.  Destroy all
   * propositions that reference 'self' and mark it as 'deleted?' (thereby
   * making it invisible within class extensions).
   * @param self
   */
  public static void destroyObject(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          LogicObject.destroyTerm(self000);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing self000 = ((Thing)(self));

          Logic.destroyLogicInstance(self000);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          Proposition.destroyProposition(self000);
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  /** Find an object or proposition as specified by <code>objectspec</code>, and destroy all
   * propositions and indices that reference it.  <code>objectspec</code> must be a name or
   * a parse tree that evaluates to a proposition.  Return the deleted object, or
   * NULL if no matching object was found.
   * @param objectspec
   * @return Stella_Object
   */
  public static Stella_Object destroy(Stella_Object objectspec) {
    { Stella_Object renamed_Object = null;

      if (Stella_Object.safePrimaryType(objectspec) == Logic.SGT_STELLA_CONS) {
        { Cons objectspec000 = ((Cons)(objectspec));

          renamed_Object = Logic.conceiveFormula(objectspec000);
        }
      }
      else {
        renamed_Object = Logic.coerceToInstanceInModule(objectspec, null, false, null);
      }
      if (renamed_Object != null) {
        Logic.destroyObject(renamed_Object);
      }
      return (renamed_Object);
    }
  }

  public static void introduceModule(Module module) {
    module.surrogateValueInverse = null;
    { Object old$Context$000 = Stella.$CONTEXT$.get();
      Object old$Module$000 = Stella.$MODULE$.get();

      try {
        Native.setSpecial(Stella.$CONTEXT$, Logic.$PL_KERNEL_MODULE$);
        Native.setSpecial(Stella.$MODULE$, ((Context)(Stella.$CONTEXT$.get())).baseModule);
        if (module.surrogateValueInverse == null) {
          { boolean successP = false;
            Stella_Object unused = null;
            Surrogate surrogate = null;

            { Object [] caller_MV_returnarray = new Object[2];

              successP = Stella_Object.bindToSurrogateP(module, module.name(), true, true, caller_MV_returnarray);
              unused = ((Stella_Object)(caller_MV_returnarray[0]));
              surrogate = ((Surrogate)(caller_MV_returnarray[1]));
            }
            unused = unused;
            if (successP) {
              module.surrogateValueInverse = surrogate;
            }
          }
        }
        Logic.assertIsaProposition(module, Logic.SGT_STELLA_MODULE);

      } finally {
        Stella.$MODULE$.set(old$Module$000);
        Stella.$CONTEXT$.set(old$Context$000);
      }
    }
  }

  public static void clearLogicModuleHook(Module module) {
    { Object old$Module$000 = Stella.$MODULE$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setSpecial(Stella.$MODULE$, module);
        Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
        { Object old$DeferredTermsToUnlink$000 = Logic.$DEFERRED_TERMS_TO_UNLINK$.get();

          try {
            Native.setSpecial(Logic.$DEFERRED_TERMS_TO_UNLINK$, HashSet.newHashSet());
            Logic.destroyInferenceCaches(module);
            Logic.clearInlineQueryCaches();
            { Stella_Object term = null;
              Cons iter000 = Logic.allTerms(module, true).listify().theConsList;

              for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                term = iter000.value;
                Logic.destroyInstance(term);
              }
            }
            { Proposition proposition = null;
              Iterator iter001 = Logic.allPropositions(module, true);

              while (iter001.nextP()) {
                proposition = ((Proposition)(iter001.value));
                Proposition.destroyProposition(proposition);
              }
            }
            { Stella_Object term = null;
              DictionaryIterator iter002 = ((DictionaryIterator)(((HashSet)(Logic.$DEFERRED_TERMS_TO_UNLINK$.get())).allocateIterator()));

              while (iter002.nextP()) {
                term = iter002.value;
                if (!term.deletedP()) {
                  { BacklinksIndex index = Logic.getBacklinksIndex(term);

                    if (index != null) {
                      index.removeDeletedMembers();
                    }
                  }
                }
              }
            }
            Logic.cleanupStructuredObjectsIndex(module);
            Logic.locallyConceivedPropositions(module).removeDeletedMembers();
            Logic.locallyConceivedInstances(module).removeDeletedMembers();
            Logic.cleanupAllDescriptionExtensions();
            Logic.cleanupUnfinalizedObjects();
            { Proposition proposition = null;
              Iterator iter003 = Logic.allLocallyModifiedPropositions(module);

              while (iter003.nextP()) {
                proposition = ((Proposition)(iter003.value));
                { Stella_Object truthvalue = proposition.truthValue;

                  if ((truthvalue != null) &&
                      Stella_Object.isaP(truthvalue, Logic.SGT_STELLA_KEY_VALUE_LIST)) {
                    ((KeyValueList)(truthvalue)).removeAt(module);
                  }
                }
              }
            }
            Keyword.clearMemoizationTables(Logic.KWD_KB_UPDATE);
            Keyword.clearMemoizationTables(Logic.KWD_META_KB_UPDATE);

          } finally {
            Logic.$DEFERRED_TERMS_TO_UNLINK$.set(old$DeferredTermsToUnlink$000);
          }
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Stella.$MODULE$.set(old$Module$000);
      }
    }
  }

  /** Destroy all instances belonging to module <code>name</code> or any of its children.
   * Leave meta-objects, e.g., concepts and relations, alone.
   * If no <code>name</code> is supplied, the current module will be cleared after
   * confirming with the user.
   * @param name
   */
  public static void clearInstances(Cons name) {
    { Cons optionalname = name;
      Module module = Stella_Object.coerceToModule(optionalname.value, true);

      if (module != null) {
        if ((!(optionalname == Stella.NIL)) ||
            Stella.yOrNP("Really clear instances of module " + module.moduleFullName + "? ")) {
          Logic.doClearInstances(module);
        }
      }
    }
  }

  public static void clearInstancesEvaluatorWrapper(Cons arguments) {
    Logic.clearInstances(arguments);
  }

  /** Function version of <code>clearInstances</code> that evaluates its argument.
   * @param module
   */
  public static void doClearInstances(Module module) {
    { Context child = null;
      Cons iter000 = module.childContexts.theConsList;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        child = ((Context)(iter000.value));
        if (Stella_Object.isaP(child, Logic.SGT_STELLA_MODULE)) {
          Logic.doClearInstances(((Module)(child)));
        }
      }
    }
    { Object old$Module$000 = Stella.$MODULE$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setSpecial(Stella.$MODULE$, module);
        Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
        Logic.destroyInferenceCaches(module);
        { LogicObject instance = null;
          Iterator iter001 = Logic.allInstances(module, true);

          while (iter001.nextP()) {
            instance = ((LogicObject)(iter001.value));
            Logic.destroyInstance(instance);
          }
        }
        Logic.locallyConceivedPropositions(module).removeDeletedMembers();

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Stella.$MODULE$.set(old$Module$000);
      }
    }
  }

  public static void destroyLogicContextHook(Context self) {
    KeyValueList.setDynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_MONOTONICp, Stella.FALSE_WRAPPER, Stella.FALSE_WRAPPER);
    { Object old$Context$000 = Stella.$CONTEXT$.get();
      Object old$Module$000 = Stella.$MODULE$.get();

      try {
        Native.setSpecial(Stella.$CONTEXT$, self);
        Native.setSpecial(Stella.$MODULE$, ((Context)(Stella.$CONTEXT$.get())).baseModule);
        { LogicObject i = null;
          Iterator iter000 = Logic.locallyConceivedInstances(self).allocateIterator();

          while (iter000.nextP()) {
            i = ((LogicObject)(iter000.value));
            LogicObject.destroyTerm(i);
          }
        }

      } finally {
        Stella.$MODULE$.set(old$Module$000);
        Stella.$CONTEXT$.set(old$Context$000);
      }
    }
    if (Stella_Object.isaP(self, Logic.SGT_STELLA_MODULE)) {
      Logic.clearLogicModuleHook(((Module)(self)));
      self.surrogateValueInverse.surrogateValue = null;
    }
    if (Stella_Object.isaP(self, Logic.SGT_STELLA_WORLD)) {
      Logic.unlinkInferenceCache(((World)(self)));
      Logic.unlinkPropagationEnvironment(self);
    }
    self.dynamicSlots.clear();
  }

  /** Clear all query and memoization caches.
   */
  public static void clearCaches() {
    Logic.clearQueryResultsCache();
    Logic.clearInlineQueryCaches();
    Stella.clearAllMemoizationTables();
  }

  /** Reset PowerLoom to its initial state.
   * CAUTION: This will destroy all loaded knowledge bases and might break other
   * loaded STELLA systems if they do reference PowerLoom symbols in their code.
   */
  public static void resetPowerloom() {
    { Object old$Module$000 = Stella.$MODULE$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setSpecial(Stella.$MODULE$, Stella.$STELLA_MODULE$);
        Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
        { List modules = List.list(Cons.cons(Stella.getStellaModule("PLI", true), Cons.cons(Logic.$PL_ANONYMOUS_MODULE$, Cons.cons(Logic.$PL_KERNEL_MODULE$, Cons.cons(Logic.$LOGIC_MODULE$, Stella.NIL)))));

          { Module mod = null;
            Cons iter000 = modules.theConsList;

            for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
              mod = ((Module)(iter000.value));
              KeyValueList.setDynamicSlotValue(mod.dynamicSlots, Logic.SYM_STELLA_CLEARABLEp, Stella.TRUE_WRAPPER, Stella.FALSE_WRAPPER);
              KeyValueList.setDynamicSlotValue(mod.dynamicSlots, Logic.SYM_STELLA_PROTECT_SURROGATESp, Stella.FALSE_WRAPPER, Stella.FALSE_WRAPPER);
              { Context sub = null;
                AllPurposeIterator iter001 = Context.allSubcontexts(mod, Logic.KWD_PREORDER);

                while (iter001.nextP()) {
                  sub = ((Context)(iter001.value));
                  if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(sub), Logic.SGT_STELLA_MODULE)) {
                    { Module sub000 = ((Module)(sub));

                      KeyValueList.setDynamicSlotValue(sub000.dynamicSlots, Logic.SYM_STELLA_CLEARABLEp, Stella.TRUE_WRAPPER, Stella.FALSE_WRAPPER);
                      KeyValueList.setDynamicSlotValue(sub000.dynamicSlots, Logic.SYM_STELLA_PROTECT_SURROGATESp, Stella.FALSE_WRAPPER, Stella.FALSE_WRAPPER);
                    }
                  }
                  else {
                  }
                }
              }
            }
          }
          { Module mod = null;
            Cons iter002 = modules.theConsList;

            for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
              mod = ((Module)(iter002.value));
              Context.clearContext(mod);
            }
          }
          HookList.dropHook(Stella.$DEFINE_MODULE_HOOKS$, Logic.SYM_LOGIC_INTRODUCE_MODULE);
          HookList.dropHook(Stella.$CLEAR_MODULE_HOOKS$, Logic.SYM_LOGIC_CLEAR_LOGIC_MODULE_HOOK);
          HookList.dropHook(Stella.$DESTROY_CONTEXT_HOOKS$, Logic.SYM_LOGIC_DESTROY_LOGIC_CONTEXT_HOOK);
          HookList.dropHook(Stella.$REDEFINE_RELATION_HOOKS$, Logic.SYM_LOGIC_TRANSFER_LOGIC_INFORMATION_FROM_RELATION_HOOK);
          { Module mod = null;
            Cons iter003 = modules.theConsList;

            for (;!(iter003 == Stella.NIL); iter003 = iter003.rest) {
              mod = ((Module)(iter003.value));
              Module.destroyModule(mod);
            }
          }
          Logic.$PL_KERNEL_MODULE$ = null;
          Logic.$LOGIC_MODULE$ = null;
          Stella.clearAllMemoizationTables();
          StartupLogicSystem.startupLogicSystem();
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Stella.$MODULE$.set(old$Module$000);
      }
    }
    Stella.getStellaModule("PL-USER", true).changeModule();
  }

  public static boolean consLessThanP(Cons o1, Cons o2) {
    { Stella_Object i1 = null;
      Cons iter000 = o1;
      Stella_Object i2 = null;
      Cons iter001 = o2;

      for (;(!(iter000 == Stella.NIL)) &&
                (!(iter001 == Stella.NIL)); iter000 = iter000.rest, iter001 = iter001.rest) {
        i1 = iter000.value;
        i2 = iter001.value;
        if (Logic.logicFormLessP(i1, i2)) {
          return (true);
        }
        if (Logic.logicFormLessP(i2, i1)) {
          return (false);
        }
      }
    }
    return (o1.length() < o2.length());
  }

  public static boolean stringTermLessP(String s1, String s2) {
    return (Stella.stringCompareCaseNormalized(s1, s2) < 0);
  }

  public static boolean safeStringTermLessP(String s1, String s2) {
    if ((s1 != null) &&
        (s2 != null)) {
      return (Stella.stringCompareCaseNormalized(s1, s2) < 0);
    }
    else if (s2 != null) {
      return (false);
    }
    else {
      return (true);
    }
  }

  public static boolean safeQuantityLessP(Quantity q1, Stella_Object o2) {
    if ((q1 != null) &&
        (o2 != null)) {
      try {
        return (q1.lessP(o2));
      } catch (IncompatibleQuantityException e000) {
        return (false);
      }
    }
    else if (o2 != null) {
      return (false);
    }
    else {
      return (true);
    }
  }

  public static boolean safeQuantityGreaterEqualP(Quantity q1, Stella_Object o2) {
    if ((q1 != null) &&
        (o2 != null)) {
      try {
        return (q1.greaterEqualP(o2));
      } catch (IncompatibleQuantityException e000) {
        return (false);
      }
    }
    else if (o2 != null) {
      return (false);
    }
    else {
      return (true);
    }
  }

  public static boolean moduleNameLessThanP(Context m1, Context m2) {
    return (Logic.safeStringTermLessP(m1.contextName(), m2.contextName()));
  }

  public static String objectSortString(Stella_Object o) {
    if (o == null) {
      return ("NULL");
    }
    { Surrogate testValue000 = Stella_Object.safePrimaryType(o);

      if (Surrogate.subtypeOfIntegerP(testValue000)) {
        { IntegerWrapper o000 = ((IntegerWrapper)(o));

          return (Native.stringify(o000));
        }
      }
      else if (Surrogate.subtypeOfFloatP(testValue000)) {
        { FloatWrapper o000 = ((FloatWrapper)(o));

          return (Native.stringify(o000));
        }
      }
      else if (Surrogate.subtypeOfBooleanP(testValue000)) {
        { BooleanWrapper o000 = ((BooleanWrapper)(o));

          if (o000 == Stella.FALSE_WRAPPER) {
            return ("FALSE");
          }
          else if (o000 == Stella.TRUE_WRAPPER) {
            return ("TRUE");
          }
          else {
            return ("UNKNOWN");
          }
        }
      }
      else if (Surrogate.subtypeOfStringP(testValue000)) {
        { StringWrapper o000 = ((StringWrapper)(o));

          return (o000.wrapperValue);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_MUTABLE_STRING_WRAPPER)) {
        { MutableStringWrapper o000 = ((MutableStringWrapper)(o));

          return ((o000.wrapperValue).toString());
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_GENERALIZED_SYMBOL)) {
        { GeneralizedSymbol o000 = ((GeneralizedSymbol)(o));

          return (o000.symbolName);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
        { Skolem o000 = ((Skolem)(o));

          { Stella_Object val = ((Stella_Object)(Stella_Object.accessInContext(o000.variableValue, o000.homeContext, false)));

            if ((val == null) ||
                (val == o000)) {
              return (Native.stringify(o000));
            }
            else {
              return (Logic.objectSortString(((Stella_Object)(Stella_Object.accessInContext(o000.variableValue, o000.homeContext, false)))));
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject o000 = ((LogicObject)(o));

          return (Logic.objectStringName(o000));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_CONTEXT)) {
        { Context o000 = ((Context)(o));

          return (o000.contextName());
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_COMPUTED_PROCEDURE)) {
        { ComputedProcedure o000 = ((ComputedProcedure)(o));

          return (o000.surrogateValueInverse.symbolName);
        }
      }
      else {
        if (o.primaryType().homeModule() == Logic.$LOGIC_MODULE$) {
          Stella.STANDARD_WARNING.nativeStream.println("Warning: OBJECT-SORT-STRING: Doesn't specifically handle object `" + o + "' yet!");
        }
        return (Native.stringify(o));
      }
    }
  }

  /** A sorting predicate for objects <code>o1</code> and <code>o2</code> that can appear in logical
   * forms.  Performs a combined numeric and lexocographic sort that accounts
   * for lists, collections and propositions.  Numbers precede all other values,
   * <code>null</code> follows all other values.
   * @param o1
   * @param o2
   * @return boolean
   */
  public static boolean logicFormLessP(Stella_Object o1, Stella_Object o2) {
    if (o1 == o2) {
      return (false);
    }
    if (Stella_Object.isaP(o1, Logic.SGT_LOGIC_SKOLEM)) {
      { Stella_Object value = ((Stella_Object)(Stella_Object.accessInContext(((Skolem)(o1)).variableValue, ((Skolem)(o1)).homeContext, false)));

        if (value != null) {
          o1 = value;
        }
        else if (Logic.functionOutputSkolemP(o1)) {
          o1 = ((Skolem)(o1)).definingProposition;
        }
        else {
          o1 = ((Skolem)(o1)).skolemName;
        }
      }
    }
    if (Stella_Object.isaP(o2, Logic.SGT_LOGIC_SKOLEM)) {
      { Stella_Object value = ((Stella_Object)(Stella_Object.accessInContext(((Skolem)(o2)).variableValue, ((Skolem)(o2)).homeContext, false)));

        if (value != null) {
          o2 = value;
        }
        else if (Logic.functionOutputSkolemP(o2)) {
          o2 = ((Skolem)(o2)).definingProposition;
        }
        else {
          o2 = ((Skolem)(o2)).skolemName;
        }
      }
    }
    if (o1 == null) {
      return (false);
    }
    if (o2 == null) {
      return (true);
    }
    { Surrogate testValue000 = Stella_Object.safePrimaryType(o1);

      if (Surrogate.subtypeOfIntegerP(testValue000)) {
        { IntegerWrapper o1000 = ((IntegerWrapper)(o1));

          { Surrogate testValue001 = Stella_Object.safePrimaryType(o2);

            if (Surrogate.subtypeOfIntegerP(testValue001)) {
              { IntegerWrapper o2000 = ((IntegerWrapper)(o2));

                return (o1000.wrapperValue < o2000.wrapperValue);
              }
            }
            else if (Surrogate.subtypeOfFloatP(testValue001)) {
              { FloatWrapper o2000 = ((FloatWrapper)(o2));

                return (o1000.wrapperValue < o2000.wrapperValue);
              }
            }
            else if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_QUANTITY_LOGIC_WRAPPER)) {
              { QuantityLogicWrapper o2000 = ((QuantityLogicWrapper)(o2));

                return (!Logic.safeQuantityGreaterEqualP(o2000.wrapperValue, o1000));
              }
            }
            else {
              return (true);
            }
          }
        }
      }
      else if (Surrogate.subtypeOfFloatP(testValue000)) {
        { FloatWrapper o1000 = ((FloatWrapper)(o1));

          { Surrogate testValue002 = Stella_Object.safePrimaryType(o2);

            if (Surrogate.subtypeOfIntegerP(testValue002)) {
              { IntegerWrapper o2000 = ((IntegerWrapper)(o2));

                return (o1000.wrapperValue < o2000.wrapperValue);
              }
            }
            else if (Surrogate.subtypeOfFloatP(testValue002)) {
              { FloatWrapper o2000 = ((FloatWrapper)(o2));

                return (o1000.wrapperValue < o2000.wrapperValue);
              }
            }
            else if (Surrogate.subtypeOfP(testValue002, Logic.SGT_LOGIC_QUANTITY_LOGIC_WRAPPER)) {
              { QuantityLogicWrapper o2000 = ((QuantityLogicWrapper)(o2));

                return (!Logic.safeQuantityGreaterEqualP(o2000.wrapperValue, o1000));
              }
            }
            else {
              return (true);
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_QUANTITY_LOGIC_WRAPPER)) {
        { QuantityLogicWrapper o1000 = ((QuantityLogicWrapper)(o1));

          { Surrogate testValue003 = Stella_Object.safePrimaryType(o2);

            if (Surrogate.subtypeOfP(testValue003, Logic.SGT_LOGIC_QUANTITY_LOGIC_WRAPPER)) {
              { QuantityLogicWrapper o2000 = ((QuantityLogicWrapper)(o2));

                return (Logic.safeQuantityLessP(o1000.wrapperValue, o2000.wrapperValue));
              }
            }
            else if (Surrogate.subtypeOfP(testValue003, Logic.SGT_STELLA_NUMBER_WRAPPER)) {
              { NumberWrapper o2000 = ((NumberWrapper)(o2));

                return (Logic.safeQuantityLessP(o1000.wrapperValue, o2000));
              }
            }
            else {
              return (true);
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition o1000 = ((Proposition)(o1));

          { Surrogate testValue004 = Stella_Object.safePrimaryType(o2);

            if (Surrogate.subtypeOfP(testValue004, Logic.SGT_LOGIC_PROPOSITION)) {
              { Proposition o2000 = ((Proposition)(o2));

                return (Proposition.propositionLessThanP(o1000, o2000));
              }
            }
            else if (Surrogate.subtypeOfP(testValue004, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
              { NamedDescription o2000 = ((NamedDescription)(o2));

                return (Logic.stringTermLessP(Proposition.propositionHeadSortString(o1000), Logic.objectSortString(o2000)));
              }
            }
            else if (Surrogate.subtypeOfP(testValue004, Logic.SGT_LOGIC_DESCRIPTION)) {
              { Description o2000 = ((Description)(o2));

                return (Proposition.propositionLessThanP(o1000, o2000.proposition));
              }
            }
            else {
              return (Logic.stringTermLessP(Proposition.propositionHeadSortString(o1000), Logic.objectSortString(o2)));
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        { NamedDescription o1000 = ((NamedDescription)(o1));

          { Surrogate testValue005 = Stella_Object.safePrimaryType(o2);

            if (Surrogate.subtypeOfP(testValue005, Logic.SGT_LOGIC_PROPOSITION)) {
              { Proposition o2000 = ((Proposition)(o2));

                return (Logic.stringTermLessP(Logic.objectSortString(o1000), Proposition.propositionHeadSortString(o2000)));
              }
            }
            else if (Surrogate.subtypeOfP(testValue005, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
              { NamedDescription o2000 = ((NamedDescription)(o2));

                return (Logic.stringTermLessP(Logic.objectSortString(o1000), Logic.objectSortString(o2000)));
              }
            }
            else if (Surrogate.subtypeOfP(testValue005, Logic.SGT_LOGIC_DESCRIPTION)) {
              { Description o2000 = ((Description)(o2));

                return (Logic.stringTermLessP(Logic.objectSortString(o1000), Proposition.propositionHeadSortString(o2000.proposition)));
              }
            }
            else {
              return (Logic.stringTermLessP(Logic.objectSortString(o1000), Logic.objectSortString(o2)));
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description o1000 = ((Description)(o1));

          return (Logic.logicFormLessP(o1000.proposition, o2));
        }
      }
      else {
        { Surrogate testValue006 = Stella_Object.safePrimaryType(o2);

          if (Surrogate.subtypeOfP(testValue006, Logic.SGT_LOGIC_PROPOSITION)) {
            { Proposition o2000 = ((Proposition)(o2));

              return (!Logic.stringTermLessP(Logic.objectSortString(o1), Proposition.propositionHeadSortString(o2000)));
            }
          }
          else if (Surrogate.subtypeOfP(testValue006, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
            { NamedDescription o2000 = ((NamedDescription)(o2));

              return (Logic.stringTermLessP(Logic.objectSortString(o1), Logic.objectSortString(o2000)));
            }
          }
          else if (Surrogate.subtypeOfP(testValue006, Logic.SGT_LOGIC_DESCRIPTION)) {
            { Description o2000 = ((Description)(o2));

              return (Logic.stringTermLessP(Logic.objectSortString(o1), Proposition.propositionHeadSortString(o2000.proposition)));
            }
          }
          else {
            return (Logic.stringTermLessP(Logic.objectSortString(o1), Logic.objectSortString(o2)));
          }
        }
      }
    }
  }

  public static boolean typeHasBacklinksP(Surrogate type) {
    if (type.surrogateValue == null) {
      return (false);
    }
    else {
      return (!Logic.literalTypeP(type));
    }
  }

  public static BacklinksIndex createBacklinksIndex(Stella_Object self) {
    { BacklinksIndex index = BacklinksIndex.newBacklinksIndex();

      index.dependentPropositionsList = (Stella_Object.isaP(self, Logic.SGT_LOGIC_PATTERN_VARIABLE) ? Logic.createSequenceIndex(Logic.KWD_NON_PAGING, Stella.NIL) : Logic.createSequenceIndex(((Module)(Stella.$MODULE$.get())), Cons.cons(Logic.KWD_DEPENDENTS, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(self, Stella.NIL)))));
      return (index);
    }
  }

  public static BacklinksIndex getBacklinksIndex(Stella_Object self) {
    if (self == null) {
      return (null);
    }
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          { BacklinksIndex index = self000.dependentPropositionsIndex;

            if (index != null) {
              return (index);
            }
            index = Logic.createBacklinksIndex(self000);
            self000.dependentPropositionsIndex = index;
            return (index);
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing self000 = ((Thing)(self));

          { BacklinksIndex index = ((BacklinksIndex)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_DEPENDENT_PROPOSITIONS_INDEX, null)));

            if (index != null) {
              return (index);
            }
            index = Logic.createBacklinksIndex(self000);
            KeyValueList.setDynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_DEPENDENT_PROPOSITIONS_INDEX, index, null);
            return (index);
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          { BacklinksIndex index = ((BacklinksIndex)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_DEPENDENT_PROPOSITIONS_INDEX, null)));

            if (index != null) {
              return (index);
            }
            if (!(self000.dependentPropositions.emptyP() ||
                ((BooleanWrapper)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTIVEp, Stella.FALSE_WRAPPER))).wrapperValue)) {
              index = Logic.createBacklinksIndex(self000);
              KeyValueList.setDynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_DEPENDENT_PROPOSITIONS_INDEX, index, null);
              { Proposition prop = null;
                Iterator iter000 = self000.dependentPropositions.allocateIterator();

                while (iter000.nextP()) {
                  prop = ((Proposition)(iter000.value));
                  BacklinksIndex.helpAddDependentProposition(index, prop, self000);
                }
              }
            }
            return (index);
          }
        }
      }
      else if (Surrogate.subtypeOfWrapperP(testValue000)) {
        { Wrapper self000 = ((Wrapper)(self));

          { Surrogate testValue001 = Stella_Object.safePrimaryType(self000);

            if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_INTEGER_LOGIC_WRAPPER)) {
              { IntegerLogicWrapper self001 = ((IntegerLogicWrapper)(self000));

                { BacklinksIndex index = self001.dependentPropositionsIndex;

                  if (index != null) {
                    return (index);
                  }
                  index = Logic.createBacklinksIndex(self001);
                  self001.dependentPropositionsIndex = index;
                  return (index);
                }
              }
            }
            else if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_FLOAT_LOGIC_WRAPPER)) {
              { FloatLogicWrapper self001 = ((FloatLogicWrapper)(self000));

                { BacklinksIndex index = self001.dependentPropositionsIndex;

                  if (index != null) {
                    return (index);
                  }
                  index = Logic.createBacklinksIndex(self001);
                  self001.dependentPropositionsIndex = index;
                  return (index);
                }
              }
            }
            else if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_STRING_LOGIC_WRAPPER)) {
              { StringLogicWrapper self001 = ((StringLogicWrapper)(self000));

                { BacklinksIndex index = self001.dependentPropositionsIndex;

                  if (index != null) {
                    return (index);
                  }
                  index = Logic.createBacklinksIndex(self001);
                  self001.dependentPropositionsIndex = index;
                  return (index);
                }
              }
            }
            else {
            }
          }
        }
      }
      else {
      }
    }
    return (null);
  }

  public static void addDependentPropositionLink(Stella_Object self, Proposition proposition) {
    { boolean descriptionP = Logic.descriptionModeP() ||
          ((BooleanWrapper)(KeyValueList.dynamicSlotValue(proposition.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTIVEp, Stella.FALSE_WRAPPER))).wrapperValue;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

        if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
          { Proposition self000 = ((Proposition)(self));

            if (self000.kind == Logic.KWD_CONSTANT) {
            }
            else {
              { NonPagingIndex index = self000.dependentPropositions;
                BacklinksIndex backlinks = ((BacklinksIndex)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_DEPENDENT_PROPOSITIONS_INDEX, null)));

                if (index.first() == proposition) {
                  return;
                }
                if (index == Logic.NIL_NON_PAGING_INDEX) {
                  index = ((NonPagingIndex)(Logic.createSequenceIndex(Logic.KWD_NON_PAGING, Stella.NIL)));
                  self000.dependentPropositions = index;
                }
                index.insert(proposition);
                if (backlinks != null) {
                  BacklinksIndex.helpAddDependentProposition(backlinks, proposition, self000);
                }
              }
            }
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
          { LogicObject self000 = ((LogicObject)(self));

            if (!((!descriptionP) ||
                (Stella_Object.isaP(self000, Logic.SGT_LOGIC_SKOLEM) ||
                 (Stella_Object.isaP(self000, Logic.SGT_LOGIC_DESCRIPTION) &&
                  (self000.surrogateValueInverse == null))))) {
              System.err.print("Safety violation: INTERNAL ERROR: A named LOGIC-OBJECT such as `" + self000 + "' should never be argument to a description proposition such as `" + proposition + "'");
            }
            if ((Logic.$POWERLOOM_EXECUTION_MODE$ == Logic.KWD_DEBUGGING) &&
                (descriptionP &&
                 (Logic.skolemP(self000) &&
                  ((!Logic.variableP(self000)) &&
                   (!((BooleanWrapper)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_HYPOTHESIZED_INSTANCEp, Stella.FALSE_WRAPPER))).wrapperValue))))) {
              { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

                try {
                  Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                  Stella.STANDARD_WARNING.nativeStream.println("WARNING: Found skolem " + self000 + " in descriptive proposition " + proposition);
                  Logic.helpSignalPropositionError(Stella.STANDARD_WARNING, Logic.KWD_WARNING);

                } finally {
                  Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
                }
              }
            }
            if ((!descriptionP) ||
                Logic.variableP(self000)) {
              BacklinksIndex.helpAddDependentProposition(Logic.getBacklinksIndex(self000), proposition, self000);
            }
          }
        }
        else if (Surrogate.subtypeOfWrapperP(testValue000)) {
          { Wrapper self000 = ((Wrapper)(self));

            if (!descriptionP) {
              { BacklinksIndex index = Logic.getBacklinksIndex(self000);

                if (index != null) {
                  BacklinksIndex.helpAddDependentProposition(index, proposition, self000);
                }
              }
            }
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
          { Thing self000 = ((Thing)(self));

            if (!descriptionP) {
              BacklinksIndex.helpAddDependentProposition(Logic.getBacklinksIndex(self000), proposition, self000);
            }
          }
        }
        else {
        }
      }
    }
  }

  public static void removeDependentPropositionLink(Stella_Object self, Proposition proposition) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          self000.dependentPropositions.remove(proposition);
          { BacklinksIndex backlinks = ((BacklinksIndex)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_DEPENDENT_PROPOSITIONS_INDEX, null)));

            if (backlinks != null) {
              BacklinksIndex.helpRemoveDependentProposition(backlinks, proposition);
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          BacklinksIndex.helpRemoveDependentProposition(Logic.getBacklinksIndex(self000), proposition);
        }
      }
      else if (Surrogate.subtypeOfWrapperP(testValue000)) {
        { Wrapper self000 = ((Wrapper)(self));

          { BacklinksIndex index = Logic.getBacklinksIndex(self000);

            if (index != null) {
              BacklinksIndex.helpRemoveDependentProposition(index, proposition);
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing self000 = ((Thing)(self));

          BacklinksIndex.helpRemoveDependentProposition(Logic.getBacklinksIndex(self000), proposition);
        }
      }
      else {
      }
    }
  }

  public static Stella_Object rewrapArgument(Stella_Object argument) {
    { Stella_Object wrapper = null;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(argument);

        if (Surrogate.subtypeOfIntegerP(testValue000)) {
          { IntegerWrapper argument000 = ((IntegerWrapper)(argument));

            { int value = argument000.wrapperValue;

              wrapper = Logic.$INTEGER_LOGIC_WRAPPER_TABLE$.lookup(value);
              if (wrapper == null) {
                wrapper = IntegerLogicWrapper.newIntegerLogicWrapper(value);
                Logic.$INTEGER_LOGIC_WRAPPER_TABLE$.insertAt(value, wrapper);
              }
            }
          }
        }
        else if (Surrogate.subtypeOfFloatP(testValue000)) {
          { FloatWrapper argument000 = ((FloatWrapper)(argument));

            { double value = argument000.wrapperValue;

              wrapper = Logic.$FLOAT_LOGIC_WRAPPER_TABLE$.lookup(value);
              if (wrapper == null) {
                wrapper = FloatLogicWrapper.newFloatLogicWrapper(value);
                Logic.$FLOAT_LOGIC_WRAPPER_TABLE$.insertAt(value, wrapper);
              }
            }
          }
        }
        else if (Surrogate.subtypeOfStringP(testValue000)) {
          { StringWrapper argument000 = ((StringWrapper)(argument));

            { String value = argument000.wrapperValue;

              wrapper = Logic.$STRING_LOGIC_WRAPPER_TABLE$.lookup(value);
              if (wrapper == null) {
                wrapper = StringLogicWrapper.newStringLogicWrapper(value);
                Logic.$STRING_LOGIC_WRAPPER_TABLE$.insertAt(value, wrapper);
              }
            }
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_LITERAL_WRAPPER)) {
          { LiteralWrapper argument000 = ((LiteralWrapper)(argument));

            {
              Stella.STANDARD_OUTPUT.nativeStream.println("Backlinking not implemented on literal of type: `" + argument000.primaryType() + "'");
              Stella.STANDARD_OUTPUT.nativeStream.println();
            }
;
            return (argument000);
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
      return (wrapper);
    }
  }

  public static boolean rewrapIthArgumentP(Stella_Object argument, Proposition proposition, int i) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(argument);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject argument000 = ((LogicObject)(argument));

          return (false);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition argument000 = ((Proposition)(argument));

          return (false);
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate argument000 = ((Surrogate)(argument));

          return (false);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing argument000 = ((Thing)(argument));

          return (false);
        }
      }
      else if (Surrogate.subtypeOfKeywordP(testValue000)) {
        { Keyword argument000 = ((Keyword)(argument));

          return (false);
        }
      }
      else {
        return ((!Stella_Object.isaP(argument, Logic.SGT_LOGIC_BACKLINKS_MIXIN)) &&
            (Logic.$BACKLINK_ALL_PROPOSITION_ARGUMENTSp$ ||
             (Stella.getQuotedTree("((:PREDICATE :FUNCTION) \"/LOGIC\")", "/LOGIC").memberP(proposition.kind) &&
              NamedDescription.indexIthDomainP(Logic.getDescription(((Surrogate)(proposition.operator))), i))));
      }
    }
  }

  public static SequenceIndex helpUnfilteredDependentPropositions(Stella_Object self, Surrogate relation) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(self), Logic.SGT_LOGIC_PROPOSITION)) {
      { Proposition self000 = ((Proposition)(self));

        if (relation == null) {
          return (self000.dependentPropositions);
        }
        else {
          { SequenceIndex dependents = Logic.createSequenceIndex(Logic.KWD_NON_PAGING, null);

            { Proposition prop = null;
              Iterator iter000 = self000.dependentPropositions.allocateIterator();

              while (iter000.nextP()) {
                prop = ((Proposition)(iter000.value));
                if (((Surrogate)(prop.operator)) == relation) {
                  dependents.push(prop);
                }
              }
            }
            return (dependents);
          }
        }
      }
    }
    else {
      { BacklinksIndex index = Logic.getBacklinksIndex(self);
        SequenceIndex allpropositionsindex = null;

        if (index == null) {
          return (Logic.NIL_NON_PAGING_INDEX);
        }
        allpropositionsindex = index.dependentPropositionsList;
        if (relation == null) {
          return (allpropositionsindex);
        }
        { HashTable table = index.predicatePropositionsTable;
          SequenceIndex list = ((table == null) ? allpropositionsindex : ((SequenceIndex)(table.lookup(relation))));

          if (list == null) {
            list = index.dependentIsaPropositionsList;
          }
          if (list == null) {
            return (Logic.NIL_NON_PAGING_INDEX);
          }
          if ((list == allpropositionsindex) &&
              Stella_Object.isaP(list, Logic.SGT_LOGIC_PAGING_INDEX)) {
            { ObjectStore store = ((PagingIndex)(list)).store;
              SequenceIndex paginglist = ((store != null) ? Logic.createSequenceIndex(store, Cons.cons(Logic.KWD_RELATION, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(relation, Cons.cons(self, Stella.NIL))))) : ((SequenceIndex)(null)));

              if (paginglist != null) {
                { Cons value000 = Stella.NIL;

                  { Proposition prop = null;
                    Cons iter001 = ((Cons)(list.theSequence));
                    Cons collect000 = null;

                    for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                      prop = ((Proposition)(iter001.value));
                      if (prop.operator == relation) {
                        if (collect000 == null) {
                          {
                            collect000 = Cons.cons(prop, Stella.NIL);
                            if (value000 == Stella.NIL) {
                              value000 = collect000;
                            }
                            else {
                              Cons.addConsToEndOfConsList(value000, collect000);
                            }
                          }
                        }
                        else {
                          {
                            collect000.rest = Cons.cons(prop, Stella.NIL);
                            collect000 = collect000.rest;
                          }
                        }
                      }
                    }
                  }
                  paginglist.theSequence = value000;
                }
                list = paginglist;
              }
            }
          }
          return (list);
        }
      }
    }
  }

  public static SequenceIndex unfilteredDependentPropositions(Stella_Object self, Surrogate relation) {
    { SequenceIndex result = Logic.helpUnfilteredDependentPropositions(self, relation);

      if (!(Logic.$ALL_OBJECT_STORES$ == Stella.NIL_LIST)) {
        { SequenceIndex baseresult = result;

          if (relation == null) {
            result = SequenceIndex.maybeWrapSequenceIndex(baseresult, null, Logic.KWD_DEPENDENTS, self, null);
          }
          else {
            result = SequenceIndex.maybeWrapSequenceIndex(baseresult, null, Logic.KWD_RELATION, relation, self);
            if (!(result == baseresult)) {
              { BacklinksIndex index = Logic.getBacklinksIndex(self);

                if ((index != null) &&
                    ((baseresult == index.dependentPropositionsList) ||
                     (baseresult == index.dependentIsaPropositionsList))) {
                  { Cons value000 = Stella.NIL;

                    { Stella_Object prop = null;
                      Cons iter000 = baseresult.theSequence;
                      Cons collect000 = null;

                      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                        prop = iter000.value;
                        if (((Proposition)(prop)).operator == relation) {
                          if (collect000 == null) {
                            {
                              collect000 = Cons.cons(prop, Stella.NIL);
                              if (value000 == Stella.NIL) {
                                value000 = collect000;
                              }
                              else {
                                Cons.addConsToEndOfConsList(value000, collect000);
                              }
                            }
                          }
                          else {
                            {
                              collect000.rest = Cons.cons(prop, Stella.NIL);
                              collect000 = collect000.rest;
                            }
                          }
                        }
                      }
                    }
                    result.theSequence = value000;
                  }
                  result.theSequenceLength = Stella.NULL_INTEGER;
                }
              }
            }
          }
        }
      }
      return (result);
    }
  }

  public static boolean allSpecializingDependentPropositionsNextP(AllPurposeIterator self) {
    { Iterator iterator = self.iteratorNestedIterator;
      NamedDescription relation = ((NamedDescription)(self.iteratorConsList.value));

      for (;;) {
        while (iterator.nextP()) {
          { Proposition proposition = ((Proposition)(iterator.value));

            if (((Surrogate)(proposition.operator)) == relation.surrogateValueInverse) {
              self.value = proposition;
              return (true);
            }
          }
        }
        self.iteratorConsList = self.iteratorConsList.rest;
        relation = ((NamedDescription)(self.iteratorConsList.value));
        if (relation == null) {
          self.value = null;
          return (false);
        }
        iterator = Logic.unfilteredDependentPropositions(self.iteratorObject, relation.surrogateValueInverse).allocateIterator();
        self.iteratorNestedIterator = iterator;
      }
    }
  }

  public static Iterator allSpecializingDependentPropositions(Stella_Object self, Surrogate relationref) {
    { NamedDescription relation = Logic.getDescription(relationref);

      { AllPurposeIterator self000 = AllPurposeIterator.newAllPurposeIterator();

        self000.iteratorObject = self;
        self000.iteratorConsList = Cons.cons(relation, NamedDescription.allSubrelations(relation, false));
        self000.iteratorNestedIterator = Logic.unfilteredDependentPropositions(self, relationref).allocateIterator();
        self000.iteratorNextCode = Native.find_java_method("edu.isi.powerloom.logic.Logic", "allSpecializingDependentPropositionsNextP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.AllPurposeIterator")});
        { AllPurposeIterator value000 = self000;

          return (value000);
        }
      }
    }
  }

  public static SequenceIndex unfilteredDependentIsaPropositions(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          { BacklinksIndex index = Logic.getBacklinksIndex(self000);
            SequenceIndex list = ((index == null) ? Logic.NIL_NON_PAGING_INDEX : ((SequenceIndex)(index.dependentIsaPropositionsList)));

            if (list == null) {
              list = index.dependentPropositionsList;
              if (Stella_Object.isaP(list, Logic.SGT_LOGIC_PAGING_INDEX)) {
                { ObjectStore store = ((PagingIndex)(list)).store;
                  SequenceIndex paginglist = ((store != null) ? Logic.createSequenceIndex(store, Cons.cons(Logic.KWD_ISA, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(self000, Stella.NIL)))) : ((SequenceIndex)(null)));

                  if (paginglist != null) {
                    { Cons value000 = Stella.NIL;

                      { Proposition prop = null;
                        Cons iter000 = ((Cons)(list.theSequence));
                        Cons collect000 = null;

                        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                          prop = ((Proposition)(iter000.value));
                          if (prop.kind == Logic.KWD_ISA) {
                            if (collect000 == null) {
                              {
                                collect000 = Cons.cons(prop, Stella.NIL);
                                if (value000 == Stella.NIL) {
                                  value000 = collect000;
                                }
                                else {
                                  Cons.addConsToEndOfConsList(value000, collect000);
                                }
                              }
                            }
                            else {
                              {
                                collect000.rest = Cons.cons(prop, Stella.NIL);
                                collect000 = collect000.rest;
                              }
                            }
                          }
                        }
                      }
                      paginglist.theSequence = value000;
                    }
                    list = paginglist;
                  }
                }
              }
            }
            return (((SequenceIndex)(list)));
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing self000 = ((Thing)(self));

          { BacklinksIndex index = Logic.getBacklinksIndex(self000);
            SequenceIndex list = ((index == null) ? Logic.NIL_NON_PAGING_INDEX : ((SequenceIndex)(index.dependentIsaPropositionsList)));

            if (list == null) {
              list = index.dependentPropositionsList;
              if (Stella_Object.isaP(list, Logic.SGT_LOGIC_PAGING_INDEX)) {
                { ObjectStore store = ((PagingIndex)(list)).store;
                  SequenceIndex paginglist = ((store != null) ? Logic.createSequenceIndex(store, Cons.cons(Logic.KWD_ISA, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(self000, Stella.NIL)))) : ((SequenceIndex)(null)));

                  if (paginglist != null) {
                    { Cons value001 = Stella.NIL;

                      { Proposition prop = null;
                        Cons iter001 = ((Cons)(list.theSequence));
                        Cons collect001 = null;

                        for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                          prop = ((Proposition)(iter001.value));
                          if (prop.kind == Logic.KWD_ISA) {
                            if (collect001 == null) {
                              {
                                collect001 = Cons.cons(prop, Stella.NIL);
                                if (value001 == Stella.NIL) {
                                  value001 = collect001;
                                }
                                else {
                                  Cons.addConsToEndOfConsList(value001, collect001);
                                }
                              }
                            }
                            else {
                              {
                                collect001.rest = Cons.cons(prop, Stella.NIL);
                                collect001 = collect001.rest;
                              }
                            }
                          }
                        }
                      }
                      paginglist.theSequence = value001;
                    }
                    list = paginglist;
                  }
                }
              }
            }
            return (((SequenceIndex)(list)));
          }
        }
      }
      else {
        { BacklinksIndex index = Logic.getBacklinksIndex(self);
          SequenceIndex list = ((index == null) ? Logic.NIL_NON_PAGING_INDEX : ((SequenceIndex)(index.dependentIsaPropositionsList)));

          if (list != null) {
            return (((SequenceIndex)(list)));
          }
          else {
            return (index.dependentPropositionsList);
          }
        }
      }
    }
  }

  public static SequenceIndex unfilteredDependentImpliesPropositions(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          { BacklinksIndex index = Logic.getBacklinksIndex(self000);

            if (index == null) {
              return (Logic.NIL_NON_PAGING_INDEX);
            }
            else {
              { HashTable table = index.predicatePropositionsTable;
                SequenceIndex list = null;

                if (table != null) {
                  list = ((SequenceIndex)(table.lookup(Logic.SGT_PL_KERNEL_KB_SUBSET_OF)));
                  if (list == null) {
                    list = Logic.NIL_NON_PAGING_INDEX;
                  }
                }
                if (list == null) {
                  list = index.dependentPropositionsList;
                  if (Stella_Object.isaP(list, Logic.SGT_LOGIC_PAGING_INDEX)) {
                    { ObjectStore store = ((PagingIndex)(list)).store;
                      SequenceIndex paginglist = ((store != null) ? Logic.createSequenceIndex(store, Cons.cons(Logic.KWD_RELATION, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(Logic.SGT_PL_KERNEL_KB_SUBSET_OF, Cons.cons(self000, Stella.NIL))))) : ((SequenceIndex)(null)));

                      if (paginglist != null) {
                        { Cons value000 = Stella.NIL;

                          { Proposition prop = null;
                            Cons iter000 = ((Cons)(list.theSequence));
                            Cons collect000 = null;

                            for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                              prop = ((Proposition)(iter000.value));
                              if (prop.operator == Logic.SGT_PL_KERNEL_KB_SUBSET_OF) {
                                if (collect000 == null) {
                                  {
                                    collect000 = Cons.cons(prop, Stella.NIL);
                                    if (value000 == Stella.NIL) {
                                      value000 = collect000;
                                    }
                                    else {
                                      Cons.addConsToEndOfConsList(value000, collect000);
                                    }
                                  }
                                }
                                else {
                                  {
                                    collect000.rest = Cons.cons(prop, Stella.NIL);
                                    collect000 = collect000.rest;
                                  }
                                }
                              }
                            }
                          }
                          paginglist.theSequence = value000;
                        }
                        list = paginglist;
                      }
                    }
                  }
                }
                return (list);
              }
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing self000 = ((Thing)(self));

          { BacklinksIndex index = Logic.getBacklinksIndex(self000);

            if (index == null) {
              return (Logic.NIL_NON_PAGING_INDEX);
            }
            else {
              { HashTable table = index.predicatePropositionsTable;
                SequenceIndex list = null;

                if (table != null) {
                  list = ((SequenceIndex)(table.lookup(Logic.SGT_PL_KERNEL_KB_SUBSET_OF)));
                  if (list == null) {
                    list = Logic.NIL_NON_PAGING_INDEX;
                  }
                }
                if (list == null) {
                  list = index.dependentPropositionsList;
                  if (Stella_Object.isaP(list, Logic.SGT_LOGIC_PAGING_INDEX)) {
                    { ObjectStore store = ((PagingIndex)(list)).store;
                      SequenceIndex paginglist = ((store != null) ? Logic.createSequenceIndex(store, Cons.cons(Logic.KWD_RELATION, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(Logic.SGT_PL_KERNEL_KB_SUBSET_OF, Cons.cons(self000, Stella.NIL))))) : ((SequenceIndex)(null)));

                      if (paginglist != null) {
                        { Cons value001 = Stella.NIL;

                          { Proposition prop = null;
                            Cons iter001 = ((Cons)(list.theSequence));
                            Cons collect001 = null;

                            for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                              prop = ((Proposition)(iter001.value));
                              if (prop.operator == Logic.SGT_PL_KERNEL_KB_SUBSET_OF) {
                                if (collect001 == null) {
                                  {
                                    collect001 = Cons.cons(prop, Stella.NIL);
                                    if (value001 == Stella.NIL) {
                                      value001 = collect001;
                                    }
                                    else {
                                      Cons.addConsToEndOfConsList(value001, collect001);
                                    }
                                  }
                                }
                                else {
                                  {
                                    collect001.rest = Cons.cons(prop, Stella.NIL);
                                    collect001 = collect001.rest;
                                  }
                                }
                              }
                            }
                          }
                          paginglist.theSequence = value001;
                        }
                        list = paginglist;
                      }
                    }
                  }
                }
                return (list);
              }
            }
          }
        }
      }
      else {
        { BacklinksIndex index = Logic.getBacklinksIndex(self);

          if (index == null) {
            return (Logic.NIL_NON_PAGING_INDEX);
          }
          else {
            { HashTable table = index.predicatePropositionsTable;

              if (table != null) {
                { SequenceIndex temp000 = ((SequenceIndex)(table.lookup(Logic.SGT_PL_KERNEL_KB_SUBSET_OF)));

                  { SequenceIndex value002 = ((temp000 != null) ? ((SequenceIndex)(temp000)) : Logic.NIL_NON_PAGING_INDEX);

                    return (((SequenceIndex)(value002)));
                  }
                }
              }
              else {
                return (index.dependentPropositionsList);
              }
            }
          }
        }
      }
    }
  }

  public static Cons makeSelectionPattern(Keyword kind, Cons options, Cons arguments) {
    return (Cons.cons(kind, Cons.cons(((options == null) ? Stella.NIL : options), arguments)));
  }

  public static Keyword patternKind(Cons pattern) {
    return (((Keyword)(pattern.value)));
  }

  public static Cons patternOptions(Cons pattern) {
    return (((Cons)(pattern.rest.value)));
  }

  public static Cons patternArguments(Cons pattern) {
    return (pattern.rest.rest);
  }

  public static Cons makeDependentPropositionsPattern(Stella_Object argument) {
    return (Cons.cons(Logic.KWD_DEPENDENTS, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(argument, Stella.NIL))));
  }

  public static Cons makeIsaPattern(Stella_Object argument) {
    return (Cons.cons(Logic.KWD_ISA, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(argument, Stella.NIL))));
  }

  public static Cons makeRelationExtensionPattern(Surrogate relation) {
    return (Cons.cons(Logic.KWD_RELATION, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(relation, Stella.NIL))));
  }

  public static Cons makeRelationPattern(Surrogate relation, Stella_Object argument) {
    return (Cons.cons(Logic.KWD_RELATION, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(relation, Cons.cons(argument, Stella.NIL)))));
  }

  public static Cons makeRelationPattern1(Surrogate relation, Stella_Object argument) {
    return (Logic.makeRelationPattern2(relation, argument, null));
  }

  public static Cons makeRelationPattern2(Surrogate relation, Stella_Object argument1, Stella_Object argument2) {
    return (Cons.cons(Logic.KWD_RELATION, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(relation, Cons.cons(argument1, Cons.cons(argument2, Stella.NIL))))));
  }

  public static Cons makeRelationPattern3(Surrogate relation, Stella_Object argument1, Stella_Object argument2, Stella_Object argument3) {
    return (Cons.cons(Logic.KWD_RELATION, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(relation, Cons.cons(argument1, Cons.cons(argument2, Cons.cons(argument3, Stella.NIL)))))));
  }

  public static Cons makeRelationPattern4(Surrogate relation, Stella_Object argument1, Stella_Object argument2, Stella_Object argument3, Stella_Object argument4) {
    return (Cons.cons(Logic.KWD_RELATION, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(relation, Cons.cons(argument1, Cons.cons(argument2, Cons.cons(argument3, Cons.cons(argument4, Stella.NIL))))))));
  }

  public static Cons makeRelationPatternN(Surrogate relation, Cons arguments) {
    return (Cons.cons(Logic.KWD_RELATION, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(relation, arguments))));
  }

  public static Cons makeRulesPattern(Stella_Object posrelation, Stella_Object negrelation) {
    return (Cons.cons(Logic.KWD_RULES, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(posrelation, Cons.cons(negrelation, Stella.NIL)))));
  }

  public static Stella_Object findSelectionKeyWithEquivalents(Cons pattern) {
    { Cons candidatekeys = pattern.rest.rest;

      { Keyword testValue000 = ((Keyword)(pattern.value));

        if ((testValue000 == Logic.KWD_DEPENDENTS) ||
            (testValue000 == Logic.KWD_ISA)) {
        }
        else if (testValue000 == Logic.KWD_RELATION) {
          candidatekeys = candidatekeys.rest;
        }
        else if ((testValue000 == Logic.KWD_CONTEXT_PROPOSITIONS) ||
            (testValue000 == Logic.KWD_CONTEXT_INSTANCES)) {
          candidatekeys = candidatekeys.rest;
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("get-selection-key-equivalents: Can't yet handle pattern `" + pattern + "'");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
      { Stella_Object key = null;
        Cons iter000 = candidatekeys;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          key = iter000.value;
          if (Logic.hasEquivalentValuesP(key)) {
            return (key);
          }
        }
      }
      return (null);
    }
  }

  public static SequenceIndex selectPropositions(Cons pattern) {
    { Keyword kind = ((Keyword)(pattern.value));
      Cons arguments = pattern.rest.rest;
      SequenceIndex result = null;

      if (kind == Logic.KWD_DEPENDENTS) {
        result = Logic.unfilteredDependentPropositions(arguments.value, null);
      }
      else if (kind == Logic.KWD_ISA) {
        result = Logic.selectIsaPropositions(pattern);
      }
      else if (kind == Logic.KWD_RELATION) {
        result = Logic.selectRelationPropositions(pattern);
      }
      else if (kind == Logic.KWD_RULES) {
        return (Logic.selectRulePropositions(pattern));
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("select-propositions: Can't yet handle pattern `" + pattern + "'");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      if (!(Logic.$ALL_OBJECT_STORES$ == Stella.NIL_LIST)) {
        result = SequenceIndex.maybeWrapSequenceIndex(result, pattern, null, null, null);
      }
      return (result);
    }
  }

  public static SequenceIndex selectIsaPropositions(Cons pattern) {
    { Stella_Object renamed_Object = pattern.rest.rest.value;
      SequenceIndex index = Logic.unfilteredDependentIsaPropositions(renamed_Object);

      if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(index), Logic.SGT_LOGIC_PAGING_INDEX)) {
        { PagingIndex index000 = ((PagingIndex)(index));

          if (((Keyword)(index000.selectionPattern.value)) == Logic.KWD_ISA) {
            return (index000);
          }
        }
      }
      else {
      }
      { Cons sequence = index.theSequence;
        Cons filteredsequence = Stella.NIL;

        if (sequence == Stella.NIL) {
          return (Logic.NIL_NON_PAGING_INDEX);
        }
        { Proposition prop = null;
          Cons iter000 = sequence;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            prop = ((Proposition)(iter000.value));
            if ((prop.kind == Logic.KWD_ISA) &&
                (!prop.deletedP())) {
              filteredsequence = Cons.cons(prop, filteredsequence);
            }
          }
        }
        if (filteredsequence == Stella.NIL) {
          return (Logic.NIL_NON_PAGING_INDEX);
        }
        else {
          { NonPagingIndex self000 = NonPagingIndex.newNonPagingIndex();

            self000.theSequence = filteredsequence;
            { NonPagingIndex value000 = self000;

              return (value000);
            }
          }
        }
      }
    }
  }

  public static SequenceIndex helpSelectRelationPropositions(Cons pattern) {
    { Cons arguments = pattern.rest.rest;
      Stella_Object relation = arguments.value;
      Cons keys = arguments.rest;

      { Stella_Object value000 = null;

        { Stella_Object key = null;
          Cons iter000 = keys;

          loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            key = iter000.value;
            if ((key != null) &&
                Logic.instanceHasBacklinksP(key)) {
              value000 = key;
              break loop000;
            }
          }
        }
        { Stella_Object anchor = value000;
          Skolem functionSkolem = null;

          if (anchor == null) {
            { NamedDescription description = Logic.getDescription(relation);

              if (description != null) {
                return (NamedDescription.getDescriptionExtension(description, true));
              }
              else {
                return (Logic.NIL_NON_PAGING_INDEX);
              }
            }
          }
          { SequenceIndex index = Logic.unfilteredDependentPropositions(anchor, ((Surrogate)(relation)));
            Cons sequence = index.theSequence;
            Cons filteredsequence = Stella.NIL;
            Cons allkeyvalues = null;

            if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(index), Logic.SGT_LOGIC_PAGING_INDEX)) {
              { PagingIndex index000 = ((PagingIndex)(index));

                if ((index000.store != null) &&
                    (((Keyword)(index000.selectionPattern.value)) == Logic.KWD_RELATION)) {
                  index000.selectionPattern = pattern;
                  return (index000);
                }
              }
            }
            else {
            }
            if (sequence == Stella.NIL) {
              return (Logic.NIL_NON_PAGING_INDEX);
            }
            { Proposition prop = null;
              Cons iter001 = sequence;

              loop001 : for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                prop = ((Proposition)(iter001.value));
                if (!(Stella_Object.equalP(relation, prop.operator))) {
                  if (prop.kind == Logic.KWD_EQUIVALENT) {
                    functionSkolem = Proposition.getSkolemAndValueTerms(prop, new Object[1]);
                    if (functionSkolem != null) {
                      prop = functionSkolem.definingProposition;
                    }
                    if (!(Stella_Object.equalP(relation, prop.operator))) {
                      continue loop001;
                    }
                  }
                  else {
                    continue loop001;
                  }
                }
                if (allkeyvalues == null) {
                  allkeyvalues = Stella.NIL;
                  if (!(keys.rest == Stella.NIL)) {
                    { Stella_Object key = null;
                      Cons iter002 = keys;
                      Cons collect000 = null;

                      for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
                        key = iter002.value;
                        if (collect000 == null) {
                          {
                            collect000 = Cons.cons(Logic.valueOf(key), Stella.NIL);
                            if (allkeyvalues == Stella.NIL) {
                              allkeyvalues = collect000;
                            }
                            else {
                              Cons.addConsToEndOfConsList(allkeyvalues, collect000);
                            }
                          }
                        }
                        else {
                          {
                            collect000.rest = Cons.cons(Logic.valueOf(key), Stella.NIL);
                            collect000 = collect000.rest;
                          }
                        }
                      }
                    }
                  }
                }
                if (!(allkeyvalues == Stella.NIL)) {
                  { Vector arguments000 = prop.arguments;

                    { boolean testValue000 = false;

                      testValue000 = arguments000 != null;
                      if (testValue000) {
                        { boolean alwaysP000 = true;

                          { Stella_Object key = null;
                            Cons iter003 = allkeyvalues;
                            Stella_Object arg = null;
                            Vector vector000 = arguments000;
                            int index001 = 0;
                            int length000 = vector000.length();

                            loop003 : for (;(!(iter003 == Stella.NIL)) &&
                                      (index001 < length000); iter003 = iter003.rest, index001 = index001 + 1) {
                              key = iter003.value;
                              arg = (vector000.theArray)[index001];
                              if (!((key == null) ||
                                  (Stella_Object.equalP(key, Logic.valueOf(arg)) ||
                                   (Stella_Object.isaP(key, Logic.SGT_LOGIC_PROPOSITION) &&
                                    (Stella_Object.isaP(Logic.valueOf(arg), Logic.SGT_LOGIC_PROPOSITION) &&
                                     Proposition.unifyPropositionsP(((Proposition)(key)), ((Proposition)(Logic.valueOf(arg))), KeyValueMap.newKeyValueMap())))))) {
                                alwaysP000 = false;
                                break loop003;
                              }
                            }
                          }
                          testValue000 = alwaysP000;
                        }
                      }
                      if (!(testValue000)) {
                        continue loop001;
                      }
                    }
                  }
                }
                if (!(Proposition.deletedPropositionP(prop))) {
                  filteredsequence = Cons.cons(prop, filteredsequence);
                }
              }
            }
            if (filteredsequence == Stella.NIL) {
              return (Logic.NIL_NON_PAGING_INDEX);
            }
            else {
              { NonPagingIndex self001 = NonPagingIndex.newNonPagingIndex();

                self001.theSequence = filteredsequence;
                { NonPagingIndex value001 = self001;

                  return (value001);
                }
              }
            }
          }
        }
      }
    }
  }

  public static SequenceIndex selectRelationPropositions(Cons pattern) {
    { Cons arguments = pattern.rest.rest;
      Stella_Object relation = arguments.value;
      Stella_Object key1 = null;
      Stella_Object key2 = null;

      arguments = arguments.rest;
      if (arguments == Stella.NIL) {
        { MemoizationTable memoTable000 = null;
          Cons memoizedEntry000 = null;
          Stella_Object memoizedValue000 = null;

          if (Stella.$MEMOIZATION_ENABLEDp$) {
            memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_SELECT_RELATION_PROPOSITIONS_MEMO_TABLE_000.surrogateValue));
            if (memoTable000 == null) {
              Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_SELECT_RELATION_PROPOSITIONS_MEMO_TABLE_000, "(:MAX-VALUES 50 :TIMESTAMPS (:KB-UPDATE))");
              memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_SELECT_RELATION_PROPOSITIONS_MEMO_TABLE_000.surrogateValue));
            }
            memoizedEntry000 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable000)), relation, ((Context)(Stella.$CONTEXT$.get())), Stella.MEMOIZED_NULL_VALUE, null, 2);
            memoizedValue000 = memoizedEntry000.value;
          }
          if (memoizedValue000 != null) {
            if (memoizedValue000 == Stella.MEMOIZED_NULL_VALUE) {
              memoizedValue000 = null;
            }
          }
          else {
            memoizedValue000 = Logic.helpSelectRelationPropositions(pattern);
            if (Stella.$MEMOIZATION_ENABLEDp$) {
              memoizedEntry000.value = ((memoizedValue000 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue000);
            }
          }
          { SequenceIndex value000 = ((SequenceIndex)(memoizedValue000));

            return (value000);
          }
        }
      }
      key1 = arguments.value;
      arguments = arguments.rest;
      if (arguments == Stella.NIL) {
        { MemoizationTable memoTable001 = null;
          Cons memoizedEntry001 = null;
          Stella_Object memoizedValue001 = null;

          if (Stella.$MEMOIZATION_ENABLEDp$) {
            memoTable001 = ((MemoizationTable)(Logic.SGT_LOGIC_F_SELECT_RELATION_PROPOSITIONS_MEMO_TABLE_001.surrogateValue));
            if (memoTable001 == null) {
              Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_SELECT_RELATION_PROPOSITIONS_MEMO_TABLE_001, "(:MAX-VALUES 1000 :TIMESTAMPS (:KB-UPDATE))");
              memoTable001 = ((MemoizationTable)(Logic.SGT_LOGIC_F_SELECT_RELATION_PROPOSITIONS_MEMO_TABLE_001.surrogateValue));
            }
            memoizedEntry001 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable001)), relation, key1, ((Context)(Stella.$CONTEXT$.get())), Stella.MEMOIZED_NULL_VALUE, 4);
            memoizedValue001 = memoizedEntry001.value;
          }
          if (memoizedValue001 != null) {
            if (memoizedValue001 == Stella.MEMOIZED_NULL_VALUE) {
              memoizedValue001 = null;
            }
          }
          else {
            memoizedValue001 = Logic.helpSelectRelationPropositions(pattern);
            if (Stella.$MEMOIZATION_ENABLEDp$) {
              memoizedEntry001.value = ((memoizedValue001 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue001);
            }
          }
          { SequenceIndex value001 = ((SequenceIndex)(memoizedValue001));

            return (value001);
          }
        }
      }
      key2 = arguments.value;
      arguments = arguments.rest;
      if (arguments == Stella.NIL) {
        { MemoizationTable memoTable002 = null;
          Cons memoizedEntry002 = null;
          Stella_Object memoizedValue002 = null;

          if (Stella.$MEMOIZATION_ENABLEDp$) {
            memoTable002 = ((MemoizationTable)(Logic.SGT_LOGIC_F_SELECT_RELATION_PROPOSITIONS_MEMO_TABLE_002.surrogateValue));
            if (memoTable002 == null) {
              Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_SELECT_RELATION_PROPOSITIONS_MEMO_TABLE_002, "(:MAX-VALUES 1000 :TIMESTAMPS (:KB-UPDATE))");
              memoTable002 = ((MemoizationTable)(Logic.SGT_LOGIC_F_SELECT_RELATION_PROPOSITIONS_MEMO_TABLE_002.surrogateValue));
            }
            memoizedEntry002 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable002)), relation, key1, key2, ((Context)(Stella.$CONTEXT$.get())), 8);
            memoizedValue002 = memoizedEntry002.value;
          }
          if (memoizedValue002 != null) {
            if (memoizedValue002 == Stella.MEMOIZED_NULL_VALUE) {
              memoizedValue002 = null;
            }
          }
          else {
            memoizedValue002 = Logic.helpSelectRelationPropositions(pattern);
            if (Stella.$MEMOIZATION_ENABLEDp$) {
              memoizedEntry002.value = ((memoizedValue002 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue002);
            }
          }
          { SequenceIndex value002 = ((SequenceIndex)(memoizedValue002));

            return (value002);
          }
        }
      }
      return (Logic.helpSelectRelationPropositions(pattern));
    }
  }

  public static SequenceIndex selectRulePropositions(Cons pattern) {
    { Cons arguments = pattern.rest.rest;
      Stella_Object posrelation = arguments.value;
      Stella_Object negrelation = arguments.rest.value;
      Description description = null;
      ObjectStore store = null;

      if (posrelation != null) {
        if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(posrelation), Logic.SGT_LOGIC_DESCRIPTION)) {
          { Description posrelation000 = ((Description)(posrelation));

            description = posrelation000;
          }
        }
        else {
          description = Logic.getDescription(posrelation);
        }
        negrelation = null;
      }
      if (negrelation != null) {
        if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(negrelation), Logic.SGT_LOGIC_DESCRIPTION)) {
          { Description negrelation000 = ((Description)(negrelation));

            description = negrelation000;
          }
        }
        else {
          description = Logic.getDescription(negrelation);
        }
      }
      if (description != null) {
        Description.deriveDeferredSatelliteRules(description);
        store = Logic.homeObjectStore(description);
      }
      if (store != null) {
        return (Logic.createSequenceIndex(store, pattern));
      }
      else {
        if (description != null) {
          return (Logic.selectRelationPropositions(Logic.makeRelationPattern2(Logic.SGT_PL_KERNEL_KB_SUBSET_OF, negrelation, posrelation)));
        }
        else {
          return (Logic.NIL_NON_PAGING_INDEX);
        }
      }
    }
  }

  public static TruthValue evaluateSelectionPattern(Cons pattern) {
    pattern = Logic.makeSelectionPattern(((Keyword)(pattern.value)), Cons.list$(Cons.cons(Logic.KWD_EVALUATEp, Cons.cons(Logic.SYM_STELLA_TRUE, Cons.cons(((Cons)(pattern.rest.value)).concatenate(Stella.NIL, Stella.NIL), Stella.NIL)))), pattern.rest.rest);
    { Proposition proposition = null;
      Iterator iter000 = Logic.selectPropositions(pattern).allocateIterator();

      while (iter000.nextP()) {
        proposition = ((Proposition)(iter000.value));
        if (TruthValue.knownTruthValueP(((TruthValue)(Stella_Object.accessInContext(proposition.truthValue, proposition.homeContext, false))))) {
          return (((TruthValue)(Stella_Object.accessInContext(proposition.truthValue, proposition.homeContext, false))));
        }
      }
    }
    return (Logic.UNKNOWN_TRUTH_VALUE);
  }

  public static boolean evaluationSelectionPatternP(Cons pattern) {
    { Cons options = ((Cons)(pattern.rest.value));

      while (!(options == Stella.NIL)) {
        if ((options.value == Logic.KWD_EVALUATEp) &&
            (Stella_Object.coerceToBoolean(options.rest.value) == Stella.TRUE_WRAPPER)) {
          return (true);
        }
        options = options.rest.rest;
      }
      return (false);
    }
  }

  public static boolean argumentDiscouragesBacklinksP(Stella_Object self) {
    return (false);
  }

  public static int countBacklinksOnRelation(Stella_Object self, Keyword kind, Surrogate relation) {
    { BacklinksIndex index = Logic.getBacklinksIndex(self);
      Cons equivalents = (Stella_Object.isaP(self, Logic.SGT_LOGIC_LOGIC_OBJECT) ? ((LogicObject)(self)).variableValueInverse() : Stella.NIL);
      int count = 0;

      if (index == null) {
        return (Stella.NULL_INTEGER);
      }
      count = Logic.selectPropositions(Cons.cons(Logic.KWD_RELATION, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(relation, Cons.cons(self, Stella.NIL))))).estimatedLength();
      if ((count == 0) &&
          (!(NamedDescription.allDirectSubrelations(Logic.surrogateToDescription(relation), false) == Stella.NIL))) {
        count = 1;
      }
      { Stella_Object equiv = null;
        Cons iter000 = equivalents;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          equiv = iter000.value;
          count = count + Logic.countBacklinksOnRelation(equiv, kind, relation);
        }
      }
      return (count);
    }
  }

  public static boolean instanceHasBacklinksP(Stella_Object self) {
    return ((Logic.getBacklinksIndex(self) != null) ||
        Stella_Object.isaP(self, Logic.SGT_LOGIC_PROPOSITION));
  }

  public static Stella_Object selectInstanceWithBacklinks(Cons instances, Surrogate relation) {
    relation = relation;
    { Stella_Object i = null;
      Cons iter000 = instances;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        i = iter000.value;
        if ((i != null) &&
            (!false)) {
          { Stella_Object value = Logic.valueOf(i);

            if (Logic.instanceHasBacklinksP(value)) {
              return (value);
            }
          }
        }
      }
    }
    { Stella_Object i = null;
      Cons iter001 = instances;

      for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
        i = iter001.value;
        if ((i != null) &&
            false) {
          { Stella_Object value = Logic.valueOf(i);

            if (Logic.instanceHasBacklinksP(value)) {
              return (value);
            }
          }
        }
      }
    }
    return (null);
  }

  public static void transferPropositionsAndBacklinks(Stella_Object from, Stella_Object to) {
    Logic.transferPropositionsExceptFor(from, to, Stella.NIL_LIST);
  }

  public static void transferPropositionsExceptFor(Stella_Object from, Stella_Object to, List exceptpropositions) {
    if (((Boolean)(Logic.$LOADINGREGENERABLEOBJECTSp$.get())).booleanValue()) {
      return;
    }
    { Cons value000 = Stella.NIL;

      { Proposition p = null;
        Iterator iter000 = Logic.unfilteredDependentPropositions(to, null).allocateIterator();
        Cons collect000 = null;

        while (iter000.nextP()) {
          p = ((Proposition)(iter000.value));
          if (collect000 == null) {
            {
              collect000 = Cons.cons(p, Stella.NIL);
              if (value000 == Stella.NIL) {
                value000 = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(value000, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(p, Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      { Cons topropositions = value000;
        Stella_Object tovalue = null;

        if (exceptpropositions == null) {
          exceptpropositions = Stella.NIL_LIST;
        }
        { Object old$Evaluationmode$000 = Logic.$EVALUATIONMODE$.get();

          try {
            Native.setSpecial(Logic.$EVALUATIONMODE$, Logic.KWD_EXTENSIONAL_ASSERTION);
            { Proposition p = null;
              Iterator iter001 = Logic.unfilteredDependentPropositions(from, null).allocateIterator();

              while (iter001.nextP()) {
                p = ((Proposition)(iter001.value));
                if (!exceptpropositions.memberP(p)) {
                  if (((BooleanWrapper)(KeyValueList.dynamicSlotValue(p.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTIVEp, Stella.FALSE_WRAPPER))).wrapperValue) {
                    Native.setSpecial(Logic.$EVALUATIONMODE$, Logic.KWD_DESCRIPTION);
                  }
                  else {
                    Native.setSpecial(Logic.$EVALUATIONMODE$, Logic.KWD_EXTENSIONAL_ASSERTION);
                  }
                  tovalue = Logic.evaluateTerm(to);
                  { Stella_Object arg = null;
                    Vector vector000 = p.arguments;
                    int index000 = 0;
                    int length000 = vector000.length();
                    int i = Stella.NULL_INTEGER;
                    int iter002 = 0;

                    for (;index000 < length000; index000 = index000 + 1, iter002 = iter002 + 1) {
                      arg = (vector000.theArray)[index000];
                      i = iter002;
                      if (Stella_Object.eqlP(arg, from)) {
                        (p.arguments.theArray)[i] = tovalue;
                      }
                    }
                  }
                  { boolean testValue000 = false;

                    { boolean foundP000 = false;

                      { Stella_Object top = null;
                        Cons iter003 = topropositions;

                        loop003 : for (;!(iter003 == Stella.NIL); iter003 = iter003.rest) {
                          top = iter003.value;
                          if (Proposition.equivalentPropositionsP(p, ((Proposition)(top)), null)) {
                            foundP000 = true;
                            break loop003;
                          }
                        }
                      }
                      testValue000 = foundP000;
                    }
                    testValue000 = !testValue000;
                    if (testValue000) {
                      Logic.removeDependentPropositionLink(from, p);
                      Logic.addDependentPropositionLink(tovalue, p);
                    }
                  }
                }
              }
            }

          } finally {
            Logic.$EVALUATIONMODE$.set(old$Evaluationmode$000);
          }
        }
      }
    }
  }

  public static void cleanupAllDescriptionExtensions() {
    { NamedDescription description = null;
      Iterator iter000 = Logic.allNamedDescriptions(null, false);

      while (iter000.nextP()) {
        description = ((NamedDescription)(iter000.value));
        if ((description.extension != null) &&
            (!(description.extension == Logic.NIL_PAGING_INDEX))) {
          description.extension.removeDeletedMembers();
        }
      }
    }
  }

  public static boolean relationrefSpecializesRelationrefP(Surrogate relationref1, Surrogate relationref2) {
    if (relationref1 == relationref2) {
      return (true);
    }
    { NamedDescription desc1 = Logic.surrogateToDescription(relationref1);
      NamedDescription desc2 = Logic.surrogateToDescription(relationref2);

      return ((desc1 != null) &&
          ((desc2 != null) &&
           LogicObject.collectionImpliesCollectionP(desc1, desc2)));
    }
  }

  public static PropagationEnvironment getPropagationEnvironment(Context self) {
    { PropagationEnvironment environment = ((PropagationEnvironment)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_PROPAGATION_ENVIRONMENT, null)));

      if (environment == null) {
        environment = PropagationEnvironment.newPropagationEnvironment();
        KeyValueList.setDynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_PROPAGATION_ENVIRONMENT, environment, null);
      }
      return (environment);
    }
  }

  public static void unlinkPropagationEnvironment(Context self) {
    KeyValueList.setDynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_PROPAGATION_ENVIRONMENT, null, null);
  }

  public static void reactToKbUpdate(Context context, Stella_Object renamed_Object) {
    { boolean skolemP = false;
      boolean propositionP = false;
      boolean metapropositionP = false;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(renamed_Object);

        if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
          { Skolem object000 = ((Skolem)(renamed_Object));

            skolemP = true;
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
          { Proposition object000 = ((Proposition)(renamed_Object));

            propositionP = true;
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
      if (propositionP &&
          Proposition.metaPropositionP(((Proposition)(renamed_Object)))) {
        metapropositionP = true;
      }
      Keyword.bumpMemoizationTimestamp(Logic.KWD_KB_UPDATE);
      if (metapropositionP) {
        Keyword.bumpMemoizationTimestamp(Logic.KWD_META_KB_UPDATE);
      }
      if (((Boolean)(Logic.$INVISIBLEASSERTIONp$.get())).booleanValue()) {
        return;
      }
      else if (Logic.descriptionModeP()) {
        { Object old$FillingconstraintpropagationqueuesP$000 = Logic.$FILLINGCONSTRAINTPROPAGATIONQUEUESp$.get();

          try {
            Native.setBooleanSpecial(Logic.$FILLINGCONSTRAINTPROPAGATIONQUEUESp$, false);
            if (propositionP) {
              ((Proposition)(renamed_Object)).reactToInferenceUpdate();
            }
            else if (skolemP) {
              ((Skolem)(renamed_Object)).reactToInferenceUpdate();
            }

          } finally {
            Logic.$FILLINGCONSTRAINTPROPAGATIONQUEUESp$.set(old$FillingconstraintpropagationqueuesP$000);
          }
        }
        return;
      }
      else if (((Boolean)(Logic.$FILLINGCONSTRAINTPROPAGATIONQUEUESp$.get())).booleanValue()) {
        if (propositionP) {
          ((Proposition)(renamed_Object)).reactToInferenceUpdate();
        }
        else if (skolemP) {
          ((Skolem)(renamed_Object)).reactToInferenceUpdate();
        }
        return;
      }
      { World world = (metapropositionP ? Logic.lookupInferenceCache(context, Logic.KWD_META) : Logic.lookupConstraintPropagationWorld(context));

        if (world != null) {
          { Object old$Context$000 = Stella.$CONTEXT$.get();
            Object old$Module$000 = Stella.$MODULE$.get();

            try {
              Native.setSpecial(Stella.$CONTEXT$, world);
              Native.setSpecial(Stella.$MODULE$, ((Context)(Stella.$CONTEXT$.get())).baseModule);
              { Object old$FillingconstraintpropagationqueuesP$001 = Logic.$FILLINGCONSTRAINTPROPAGATIONQUEUESp$.get();

                try {
                  Native.setBooleanSpecial(Logic.$FILLINGCONSTRAINTPROPAGATIONQUEUESp$, true);
                  if (propositionP) {
                    ((Proposition)(renamed_Object)).reactToInferenceUpdate();
                  }
                  else if (skolemP) {
                    ((Skolem)(renamed_Object)).reactToInferenceUpdate();
                  }
                  Logic.executeConstraintPropagationQueues();

                } finally {
                  Logic.$FILLINGCONSTRAINTPROPAGATIONQUEUESp$.set(old$FillingconstraintpropagationqueuesP$001);
                }
              }

            } finally {
              Stella.$MODULE$.set(old$Module$000);
              Stella.$CONTEXT$.set(old$Context$000);
            }
          }
        }
      }
      if (Stella_Object.isaP(context, Logic.SGT_STELLA_MODULE)) {
        { Context child = null;
          Cons iter000 = context.childContexts.theConsList;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            child = ((Context)(iter000.value));
            if (Stella_Object.isaP(child, Logic.SGT_STELLA_MODULE)) {
              Logic.reactToKbUpdate(child, renamed_Object);
            }
          }
        }
      }
    }
  }

  public static void executeConstraintPropagationQueues() {
    Logic.getPropagationEnvironment(((Context)(Stella.$CONTEXT$.get()))).executePropagationQueues();
  }

  /** Resets the collection of clash exceptions
   */
  public static void resetClashExceptions() {
    Logic.$CLASH_EXCEPTIONS$ = List.newList();
  }

  public static void cullClashExceptions(Context self) {
    { Object old$Context$000 = Stella.$CONTEXT$.get();
      Object old$Module$000 = Stella.$MODULE$.get();

      try {
        Native.setSpecial(Stella.$CONTEXT$, self);
        Native.setSpecial(Stella.$MODULE$, ((Context)(Stella.$CONTEXT$.get())).baseModule);
        Logic.$CLASH_EXCEPTIONS$.removeIf(Native.find_java_method("edu.isi.powerloom.logic.ExceptionRecord", "exceptionRecordMatchesContextP", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.ExceptionRecord")}));

      } finally {
        Stella.$MODULE$.set(old$Module$000);
        Stella.$CONTEXT$.set(old$Context$000);
      }
    }
  }

  public static void elaborateMetaInstance(Stella_Object self) {
    { Context worldstate = Logic.getWorldState(((Context)(Stella.$CONTEXT$.get())));
      World metaworld = Logic.getInferenceCache(worldstate, Logic.KWD_META);

      { Object old$Context$000 = Stella.$CONTEXT$.get();

        try {
          Native.setSpecial(Stella.$CONTEXT$, metaworld);
          Logic.elaborateInstance(self);

        } finally {
          Stella.$CONTEXT$.set(old$Context$000);
        }
      }
    }
  }

  public static void elaborateInstance(Stella_Object self) {
    if (((Boolean)(Logic.$FILLINGCONSTRAINTPROPAGATIONQUEUESp$.get())).booleanValue()) {
      return;
    }
    if (Logic.$JUST_IN_TIME_FORWARD_INFERENCEp$) {
      if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(self), Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          { PropagationEnvironment environment = Logic.getPropagationEnvironment(((Context)(Stella.$CONTEXT$.get())));

            if (environment.elaboratedObjects.memberP(self000)) {
              return;
            }
            if ((Stella.$TRACED_KEYWORDS$ != null) &&
                Stella.$TRACED_KEYWORDS$.membP(Logic.KWD_ELABORATE)) {
              Stella.STANDARD_OUTPUT.nativeStream.println(" ELABORATING:  " + self000 + " in world " + ((Context)(Stella.$CONTEXT$.get())));
            }
            { Object old$Evaluationmode$000 = Logic.$EVALUATIONMODE$.get();
              Object old$InhibitobjectfinalizationP$000 = Logic.$INHIBITOBJECTFINALIZATIONp$.get();
              Object old$Queryiterator$000 = Logic.$QUERYITERATOR$.get();

              try {
                Native.setSpecial(Logic.$EVALUATIONMODE$, Logic.KWD_EXTENSIONAL_ASSERTION);
                Native.setBooleanSpecial(Logic.$INHIBITOBJECTFINALIZATIONp$, true);
                Native.setSpecial(Logic.$QUERYITERATOR$, null);
                try {
                  { Object old$FillingconstraintpropagationqueuesP$000 = Logic.$FILLINGCONSTRAINTPROPAGATIONQUEUESp$.get();

                    try {
                      Native.setBooleanSpecial(Logic.$FILLINGCONSTRAINTPROPAGATIONQUEUESp$, true);
                      Logic.postRelatedFacts(self000, environment);
                      LogicObject.evaluateReachableInequalities(self000, List.list(Stella.NIL));
                      { Object old$DeferingdefaultforwardinferencesP$000 = Logic.$DEFERINGDEFAULTFORWARDINFERENCESp$.get();

                        try {
                          Native.setBooleanSpecial(Logic.$DEFERINGDEFAULTFORWARDINFERENCESp$, true);
                          Logic.executeConstraintPropagationQueues();

                        } finally {
                          Logic.$DEFERINGDEFAULTFORWARDINFERENCESp$.set(old$DeferingdefaultforwardinferencesP$000);
                        }
                      }
                      { Proposition p = null;
                        Cons iter000 = environment.deferredDefaultPropositions.theConsList;

                        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                          p = ((Proposition)(iter000.value));
                          Proposition.assignTruthValue(p, Logic.DEFAULT_TRUE_TRUTH_VALUE);
                        }
                      }
                      environment.deferredDefaultPropositions.clear();
                      Logic.executeConstraintPropagationQueues();

                    } finally {
                      Logic.$FILLINGCONSTRAINTPROPAGATIONQUEUESp$.set(old$FillingconstraintpropagationqueuesP$000);
                    }
                  }
                } catch (Clash e) {
                  { ExceptionRecord self001 = ExceptionRecord.newExceptionRecord();

                    self001.exception = e;
                    self001.context = ((Context)(Stella.$CONTEXT$.get()));
                    self001.module = ((Module)(Stella.$MODULE$.get()));
                    Logic.$CLASH_EXCEPTIONS$.push(self001);
                  }
                  Stella.STANDARD_ERROR.nativeStream.println(Stella.exceptionMessage(e));
                }

              } finally {
                Logic.$QUERYITERATOR$.set(old$Queryiterator$000);
                Logic.$INHIBITOBJECTFINALIZATIONp$.set(old$InhibitobjectfinalizationP$000);
                Logic.$EVALUATIONMODE$.set(old$Evaluationmode$000);
              }
            }
          }
        }
      }
      else {
      }
    }
  }

  public static boolean doNotElaborateP(Stella_Object self, PropagationEnvironment environment) {
    environment = environment;
    { Surrogate donotelaboratesurrogate = Surrogate.lookupSurrogateInModule("DO-NOT-ELABORATE", Logic.$PL_KERNEL_MODULE$, false);

      return ((donotelaboratesurrogate != null) &&
          Logic.testIsaP(self, donotelaboratesurrogate));
    }
  }

  public static void postRelatedFacts(Stella_Object self, PropagationEnvironment environment) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          if (environment.elaboratedObjects.memberP(self000)) {
            return;
          }
          environment.elaboratedObjects.insert(self000);
          if (Logic.doNotElaborateP(self000, environment)) {
            return;
          }
          { Proposition p = null;
            Iterator iter000 = Logic.unfilteredDependentPropositions(self000, null).allocateIterator();

            while (iter000.nextP()) {
              p = ((Proposition)(iter000.value));
              Logic.postRelatedFacts(p, environment);
              { Stella_Object arg = null;
                Vector vector000 = p.arguments;
                int index000 = 0;
                int length000 = vector000.length();

                for (;index000 < length000; index000 = index000 + 1) {
                  arg = (vector000.theArray)[index000];
                  if ((!(arg == self000)) &&
                      Proposition.followDependentPropositionArgumentP(p, arg)) {
                    Logic.postRelatedFacts(arg, environment);
                  }
                }
              }
            }
          }
          { LogicObject equivalent = null;
            Cons iter001 = self000.variableValueInverse();

            for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
              equivalent = ((LogicObject)(iter001.value));
              Logic.postRelatedFacts(equivalent, environment);
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          if (((Keyword)(environment.evaluationStates.lookup(self000))) != null) {
            return;
          }
          { boolean assertedP = !Proposition.unknownP(self000);
            Skolem outputskolem = null;

            if ((!assertedP) &&
                (self000.kind == Logic.KWD_FUNCTION)) {
              assertedP = Proposition.functionWithDefinedValueP(self000);
            }
            if (assertedP) {
              Proposition.recursivelyReactToInferenceUpdate(self000);
            }
            { Proposition p = null;
              Iterator iter002 = self000.dependentPropositions.allocateIterator();

              while (iter002.nextP()) {
                p = ((Proposition)(iter002.value));
                Logic.postRelatedFacts(p, environment);
              }
            }
          }
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate self000 = ((Surrogate)(self));

          if (self000.surrogateValue != null) {
            Logic.postRelatedFacts(self000.surrogateValue, environment);
          }
        }
      }
      else if (Surrogate.subtypeOfClassP(testValue000)) {
        { Stella_Class self000 = ((Stella_Class)(self));

          if (((NamedDescription)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))) != null) {
            Logic.postRelatedFacts(((NamedDescription)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))), environment);
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_SLOT)) {
        { Slot self000 = ((Slot)(self));

          if (((NamedDescription)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))) != null) {
            Logic.postRelatedFacts(((NamedDescription)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))), environment);
          }
        }
      }
      else {
      }
    }
  }

  public static void helpCollectFacts(Stella_Object self, List facts, HashSet beenthere, boolean includeunknownP) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          if (beenthere.memberP(self000)) {
            return;
          }
          else {
            beenthere.insert(self000);
          }
          { Proposition p = null;
            Iterator iter000 = Logic.unfilteredDependentPropositions(self000, null).allocateIterator();

            while (iter000.nextP()) {
              p = ((Proposition)(iter000.value));
              Logic.helpCollectFacts(p, facts, beenthere, includeunknownP);
            }
          }
          { LogicObject equivalent = null;
            Cons iter001 = self000.variableValueInverse();

            for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
              equivalent = ((LogicObject)(iter001.value));
              Logic.helpCollectFacts(equivalent, facts, beenthere, includeunknownP);
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          if (beenthere.memberP(self000)) {
            return;
          }
          else {
            beenthere.insert(self000);
          }
          { boolean assertedP = includeunknownP ||
                (!Proposition.unknownP(self000));
            Skolem outputskolem = null;

            if ((!assertedP) &&
                (self000.kind == Logic.KWD_FUNCTION)) {
              outputskolem = ((Skolem)((self000.arguments.theArray)[(self000.arguments.length() - 1)]));
              assertedP = !(outputskolem == Logic.valueOf(outputskolem));
            }
            if (assertedP) {
              facts.insert(self000);
            }
            { Proposition p = null;
              Iterator iter002 = self000.dependentPropositions.allocateIterator();

              while (iter002.nextP()) {
                p = ((Proposition)(iter002.value));
                Logic.helpCollectFacts(p, facts, beenthere, includeunknownP);
              }
            }
          }
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate self000 = ((Surrogate)(self));

          if (self000.surrogateValue != null) {
            Logic.helpCollectFacts(self000.surrogateValue, facts, beenthere, includeunknownP);
          }
        }
      }
      else if (Surrogate.subtypeOfClassP(testValue000)) {
        { Stella_Class self000 = ((Stella_Class)(self));

          if (((NamedDescription)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))) != null) {
            Logic.helpCollectFacts(((NamedDescription)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))), facts, beenthere, includeunknownP);
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_SLOT)) {
        { Slot self000 = ((Slot)(self));

          if (((NamedDescription)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))) != null) {
            Logic.helpCollectFacts(((NamedDescription)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))), facts, beenthere, includeunknownP);
          }
        }
      }
      else {
      }
    }
  }

  /** Return a list of all definite (TRUE or FALSE) propositions
   * attached to <code>self</code>.
   * @param self
   * @param includeunknownfactsP
   * @param elaborateP
   * @return List
   */
  public static List allFactsOfInstance(Stella_Object self, boolean includeunknownfactsP, boolean elaborateP) {
    { List facts = List.newList();

      { Object old$Context$000 = Stella.$CONTEXT$.get();
        Object old$Module$000 = Stella.$MODULE$.get();

        try {
          Native.setSpecial(Stella.$CONTEXT$, Logic.getQueryContext());
          Native.setSpecial(Stella.$MODULE$, ((Context)(Stella.$CONTEXT$.get())).baseModule);
          if (elaborateP) {
            Logic.elaborateInstance(self);
          }
          Logic.helpCollectFacts(self, facts, HashSet.newHashSet(), includeunknownfactsP);

        } finally {
          Stella.$MODULE$.set(old$Module$000);
          Stella.$CONTEXT$.set(old$Context$000);
        }
      }
      return (facts);
    }
  }

  /** Return a cons list of all definite (TRUE or FALSE) propositions
   * that reference the instance <code>instanceref</code>.  This includes propositions
   * asserted to be true by default, but it does not include propositions
   * that are found to be TRUE only by running the query engine.  Facts
   * inferred to be TRUE by the forward chainer will be included.
   * Hence, the returned list of facts may be longer in a context where the
   * forward chainer has been run then in one where it has not (see
   * <code>runForwardRules</code>).  <code>instanceref</code> can be a regular name such as
   * <code>fred</code> as well as a function term such as <code>_fatherFred_</code>.
   * @param instanceref
   * @return Cons
   */
  public static Cons allFactsOf(Stella_Object instanceref) {
    { LogicObject instance = Logic.coerceToInstance(instanceref, null);

      if (instance != null) {
        return (Logic.allFactsOfInstance(instance, false, true).theConsList);
      }
      else {
        return (null);
      }
    }
  }

  /** Like <code>allFactsOf</code>, but sorts and prints each fact
   * on a separate line on the standard output stream.
   * @param instanceref
   */
  public static void printFacts(Stella_Object instanceref) {
    { LogicObject instance = Logic.coerceToInstance(instanceref, null);

      { Proposition fact = null;
        Cons iter000 = Logic.allFactsOfInstance(instance, false, false).sort(Native.find_java_method("edu.isi.powerloom.logic.Proposition", "propositionLessThanP", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.Proposition"), Native.find_java_class("edu.isi.powerloom.logic.Proposition")})).theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          fact = ((Proposition)(iter000.value));
          Logic.prettyPrintLogicalForm(fact, Stella.STANDARD_OUTPUT);
          Stella.STANDARD_OUTPUT.nativeStream.println();
        }
      }
    }
  }

  /** Return a list of all definite (TRUE or FALSE) propositions
   * that reference the instance <code>instanceref</code>.
   * @param instanceref
   * @return List
   */
  public static List callAllFactsOf(Stella_Object instanceref) {
    { LogicObject instance = Logic.coerceToInstance(instanceref, null);

      if (instance != null) {
        return (Logic.allFactsOfInstance(instance, false, true));
      }
      else {
        return (null);
      }
    }
  }

  /** Retract all definite (TRUE or FALSE) propositions
   * that reference the instance <code>instanceref</code>.
   * @param instanceref
   */
  public static void retractFactsOf(Stella_Object instanceref) {
    { LogicObject instance = Logic.coerceToInstance(instanceref, null);

      if (instance != null) {
        LogicObject.retractFactsOfInstance(instance);
      }
    }
  }

  public static List explodeVariablizedString(String string) {
    { List list = List.newList();
      int endofstring = string.length();
      int begin = 0;
      int end = Stella.NULL_INTEGER;
      String substring = null;
      Symbol symbol = null;

      for (;;) {
        if (begin >= endofstring) {
          return (list);
        }
        end = Native.string_position(string, '?', begin);
        if (end == Stella.NULL_INTEGER) {
          substring = Native.string_subsequence(string, begin, endofstring);
          list.insertLast(StringWrapper.wrapString(substring));
          return (list);
        }
        else if (end > begin) {
          substring = Native.string_subsequence(string, begin, end);
          list.insertLast(StringWrapper.wrapString(substring));
        }
        begin = end;
        end = Native.string_position(string, ' ', begin);
        if (end == Stella.NULL_INTEGER) {
          end = endofstring;
        }
        substring = Native.string_subsequence(string, begin, end);
        symbol = Symbol.internSymbol(Native.stringUpcase(substring));
        list.insertLast(symbol);
        begin = end;
      }
    }
  }

  /** Return a list of sentences describing facts about 'instanceRef'.
   * @param instanceref
   * @return Cons
   */
  public static Cons allSentencesOf(Stella_Object instanceref) {
    { LogicObject instance = Logic.coerceToInstance(instanceref, null);
      String sentence = null;

      if (instance != null) {
        { Cons list = Stella.NIL;

          { Proposition fact = null;
            Cons iter000 = Logic.allFactsOfInstance(instance, false, true).theConsList;
            Cons collect000 = null;

            loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
              fact = ((Proposition)(iter000.value));
              {
                sentence = Proposition.factToSentence(fact, true);
                if (sentence == null) {
                  continue loop000;
                }
              }
              if (collect000 == null) {
                {
                  collect000 = Cons.cons(StringWrapper.wrapString(sentence), Stella.NIL);
                  if (list == Stella.NIL) {
                    list = collect000;
                  }
                  else {
                    Cons.addConsToEndOfConsList(list, collect000);
                  }
                }
              }
              else {
                {
                  collect000.rest = Cons.cons(StringWrapper.wrapString(sentence), Stella.NIL);
                  collect000 = collect000.rest;
                }
              }
            }
          }
          return (list);
        }
      }
      else {
        return (null);
      }
    }
  }

  public static List callAllFactsOfN(int n, Cons seedrefs) {
    { HashTable visited = HashTable.newHashTable();
      HashTable facts = HashTable.newHashTable();
      List factlist = List.newList();
      List seeds = List.newList();
      List newseeds = List.newList();
      Stella_Object instance = null;

      { Stella_Object seedref = null;
        Cons iter000 = seedrefs;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          seedref = iter000.value;
          instance = Logic.coerceToInstance(seedref, null);
          if (instance != null) {
            seeds.insertNew(instance);
          }
        }
      }
      { int i = Stella.NULL_INTEGER;
        int iter001 = 0;
        int upperBound000 = ((n != Stella.NULL_INTEGER) ? n : 0);
        boolean unboundedP000 = upperBound000 == Stella.NULL_INTEGER;

        for (;unboundedP000 ||
                  (iter001 <= upperBound000); iter001 = iter001 + 1) {
          i = iter001;
          i = i;
          { Stella_Object seed = null;
            Cons iter002 = seeds.theConsList;

            for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
              seed = iter002.value;
              visited.insertAt(seed, seed);
            }
          }
          { Stella_Object seed = null;
            Cons iter003 = seeds.theConsList;

            for (;!(iter003 == Stella.NIL); iter003 = iter003.rest) {
              seed = iter003.value;
              { Proposition prop = null;
                Cons iter004 = Logic.allFactsOfInstance(seed, false, true).theConsList;

                loop004 : for (;!(iter004 == Stella.NIL); iter004 = iter004.rest) {
                  prop = ((Proposition)(iter004.value));
                  if (((Proposition)(facts.lookup(prop))) != null) {
                    continue loop004;
                  }
                  facts.insertAt(prop, prop);
                  factlist.insert(prop);
                  { Stella_Object arg = null;
                    Vector vector000 = prop.arguments;
                    int index000 = 0;
                    int length000 = vector000.length();

                    for (;index000 < length000; index000 = index000 + 1) {
                      arg = (vector000.theArray)[index000];
                      if (visited.lookup(arg) == null) {
                        newseeds.insertNew(arg);
                      }
                    }
                  }
                }
              }
            }
          }
          seeds = newseeds;
          newseeds = List.newList();
        }
      }
      return (factlist.reverse());
    }
  }

  public static List filteredAllFactsOfN(int n, Cons seedrefs, java.lang.reflect.Method filter) {
    { HashTable visited = HashTable.newHashTable();
      HashTable facts = HashTable.newHashTable();
      List factlist = List.newList();
      List seeds = List.newList();
      List newseeds = List.newList();
      Stella_Object instance = null;

      { Stella_Object seedref = null;
        Cons iter000 = seedrefs;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          seedref = iter000.value;
          instance = Logic.coerceToInstance(seedref, null);
          if (instance != null) {
            seeds.insertNew(instance);
          }
        }
      }
      { int i = Stella.NULL_INTEGER;
        int iter001 = 0;
        int upperBound000 = ((n != Stella.NULL_INTEGER) ? n : 0);
        boolean unboundedP000 = upperBound000 == Stella.NULL_INTEGER;

        for (;unboundedP000 ||
                  (iter001 <= upperBound000); iter001 = iter001 + 1) {
          i = iter001;
          i = i;
          { Stella_Object seed = null;
            Cons iter002 = seeds.theConsList;

            for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
              seed = iter002.value;
              visited.insertAt(seed, seed);
            }
          }
          { Stella_Object seed = null;
            Cons iter003 = seeds.theConsList;

            for (;!(iter003 == Stella.NIL); iter003 = iter003.rest) {
              seed = iter003.value;
              { Proposition prop = null;
                Cons iter004 = Logic.allFactsOfInstance(seed, false, true).theConsList;

                loop004 : for (;!(iter004 == Stella.NIL); iter004 = iter004.rest) {
                  prop = ((Proposition)(iter004.value));
                  if (((Proposition)(facts.lookup(prop))) != null) {
                    continue loop004;
                  }
                  { Cons filteroutput = ((Cons)(edu.isi.stella.javalib.Native.funcall(filter, null, new java.lang.Object [] {prop})));
                    Cons factprops = ((Cons)(filteroutput.value));
                    Cons propseeds = ((Cons)(filteroutput.rest.value));

                    { Proposition factprop = null;
                      Cons iter005 = factprops;

                      for (;!(iter005 == Stella.NIL); iter005 = iter005.rest) {
                        factprop = ((Proposition)(iter005.value));
                        facts.insertAt(factprop, factprop);
                        factlist.insert(factprop);
                      }
                    }
                    { Stella_Object arg = null;
                      Cons iter006 = propseeds;

                      for (;!(iter006 == Stella.NIL); iter006 = iter006.rest) {
                        arg = iter006.value;
                        if (visited.lookup(arg) == null) {
                          newseeds.insertNew(arg);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          seeds = newseeds;
          newseeds = List.newList();
        }
      }
      return (factlist.reverse());
    }
  }

  /** This is a generalization of <code>allFactsOf</code> (which see).  With <code>n</code> = 0
   * and only one instance this command behaves just like <code>allFactsOf</code>.
   * Otherwise, returns a cons list of all definite (TRUE or FALSE) propositions
   * that reference any of the instances listed in <code>instancerefs</code>, plus if <code>n</code> &gt;= 1
   * all propositions that reference any instances that are arguments of
   * propositions collected in the previous step, plus if <code>n</code> &gt;= 2... and so on.
   * That is, if we only consider binary propositions, this can be viewed as
   * growing a graph with instances as its nodes and predicates as its arcs
   * starting from the set of seed <code>instancerefs</code> to depth <code>n</code>-1.
   * Caution: with a fully connected KB and large enough <code>n</code> this could return
   * the whole knowledge base.
   * <p>
   * The returned propositions include those asserted to be true or false by
   * default, but it does not include propositions that are found to be
   * true only by running the query engine.  Facts inferred to be true by
   * the forward chainer will be included.  Hence, the returned list of
   * facts may be longer in a context where the forward chainer has been
   * run then in one where it has not (see <code>runForwardRules</code>).
   * @param n
   * @param instancerefs
   * @return Cons
   */
  public static Cons allFactsOfN(int n, Cons instancerefs) {
    return (Logic.callAllFactsOfN(n, instancerefs).theConsList);
  }

  public static Cons allFactsOfNEvaluatorWrapper(Cons arguments) {
    return (Logic.allFactsOfN(((IntegerWrapper)(arguments.value)).wrapperValue, arguments.rest));
  }

  public static boolean worldStateP(Context self) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(self), Logic.SGT_STELLA_WORLD)) {
      { World self000 = ((World)(self));

        return ((((Context)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_INFERENCE_CACHE_OF, null))) == null) &&
            (!((BooleanWrapper)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_MONOTONICp, Stella.FALSE_WRAPPER))).wrapperValue));
      }
    }
    else {
      return (true);
    }
  }

  public static Context getWorldState(Context self) {
    return ((Logic.worldStateP(self) ? self : ((World)(self)).baseModule));
  }

  public static World lookupInferenceCache(Context context, Keyword kind) {
    { Context cacheworld = null;

      if (kind == Logic.KWD_JUST_IN_TIME) {
        cacheworld = ((World)(KeyValueList.dynamicSlotValue(context.dynamicSlots, Logic.SYM_LOGIC_JUST_IN_TIME_INFERENCE_CACHE, null)));
      }
      else if (kind == Logic.KWD_META) {
        cacheworld = ((World)(KeyValueList.dynamicSlotValue(context.dynamicSlots, Logic.SYM_LOGIC_META_INFERENCE_CACHE, null)));
      }
      else if (kind == Logic.KWD_TMS) {
        cacheworld = ((World)(KeyValueList.dynamicSlotValue(context.dynamicSlots, Logic.SYM_LOGIC_TRUTH_MAINTAINED_INFERENCE_CACHE, null)));
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + kind + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      return (((World)(cacheworld)));
    }
  }

  public static void initializeInferenceWorld(World world) {
  }

  public static World createInferenceCache(Context context, Keyword kind) {
    { World world = Context.createWorld((Stella.getQuotedTree("((:JUST-IN-TIME :TMS) \"/LOGIC\")", "/LOGIC").memberP(kind) ? Logic.getInferenceCache(context, Logic.KWD_META) : context), null);

      if (kind == Logic.KWD_JUST_IN_TIME) {
        KeyValueList.setDynamicSlotValue(context.dynamicSlots, Logic.SYM_LOGIC_JUST_IN_TIME_INFERENCE_CACHE, world, null);
      }
      else if (kind == Logic.KWD_META) {
        KeyValueList.setDynamicSlotValue(world.dynamicSlots, Logic.SYM_LOGIC_MONOTONICp, Stella.TRUE_WRAPPER, Stella.FALSE_WRAPPER);
        KeyValueList.setDynamicSlotValue(world.dynamicSlots, Logic.SYM_LOGIC_UP_TO_DATE_INFERENCESp, ((!Logic.allPropositions(context.baseModule, true).nextP()) ? Stella.TRUE_WRAPPER : Stella.FALSE_WRAPPER), Stella.FALSE_WRAPPER);
        KeyValueList.setDynamicSlotValue(context.dynamicSlots, Logic.SYM_LOGIC_META_INFERENCE_CACHE, world, null);
      }
      else if (kind == Logic.KWD_TMS) {
        KeyValueList.setDynamicSlotValue(context.dynamicSlots, Logic.SYM_LOGIC_TRUTH_MAINTAINED_INFERENCE_CACHE, world, null);
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + kind + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      KeyValueList.setDynamicSlotValue(world.dynamicSlots, Logic.SYM_LOGIC_INFERENCE_CACHE_OF, context, null);
      Logic.initializeInferenceWorld(world);
      return (world);
    }
  }

  /** Return true if <code>self</code> is the JIT cache of some world state.
   * @param self
   * @return boolean
   */
  public static boolean justInTimeInferenceCacheP(Context self) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(self), Logic.SGT_STELLA_WORLD)) {
      { World self000 = ((World)(self));

        { Context worldstate = ((Context)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_INFERENCE_CACHE_OF, null)));

          return ((worldstate != null) &&
              (((World)(KeyValueList.dynamicSlotValue(worldstate.dynamicSlots, Logic.SYM_LOGIC_JUST_IN_TIME_INFERENCE_CACHE, null))) == self000));
        }
      }
    }
    else {
      return (false);
    }
  }

  /** Return true if <code>self</code> is the meta-JIT cache of some world state.
   * @param self
   * @return boolean
   */
  public static boolean metaInferenceCacheP(Context self) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(self), Logic.SGT_STELLA_WORLD)) {
      { World self000 = ((World)(self));

        { Context worldstate = ((Context)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_INFERENCE_CACHE_OF, null)));

          return ((worldstate != null) &&
              (((World)(KeyValueList.dynamicSlotValue(worldstate.dynamicSlots, Logic.SYM_LOGIC_META_INFERENCE_CACHE, null))) == self000));
        }
      }
    }
    else {
      return (false);
    }
  }

  public static World getInferenceCache(Context context, Keyword kind) {
    if (!Logic.worldStateP(context)) {
      return (((World)(context)));
    }
    { World world = Logic.lookupInferenceCache(context, kind);

      if (world != null) {
        return (world);
      }
      Logic.processCheckTypesAgenda();
      world = Logic.createInferenceCache(context, kind);
      if (kind == Logic.KWD_JUST_IN_TIME) {
      }
      else if ((kind == Logic.KWD_META) ||
          (kind == Logic.KWD_TMS)) {
        { Module parentmodule = null;
          Cons iter000 = context.baseModule.parentModules.theConsList;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            parentmodule = ((Module)(iter000.value));
            Logic.inheritCachedInferences(Logic.lookupInferenceCache(parentmodule, kind), world);
          }
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + kind + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      return (world);
    }
  }

  public static void destroyInferenceCache(Context context, Keyword kind) {
    { World cache = null;

      if (kind == Logic.KWD_JUST_IN_TIME) {
        cache = ((World)(KeyValueList.dynamicSlotValue(context.dynamicSlots, Logic.SYM_LOGIC_JUST_IN_TIME_INFERENCE_CACHE, null)));
        KeyValueList.setDynamicSlotValue(context.dynamicSlots, Logic.SYM_LOGIC_JUST_IN_TIME_INFERENCE_CACHE, null, null);
      }
      else if (kind == Logic.KWD_META) {
        cache = ((World)(KeyValueList.dynamicSlotValue(context.dynamicSlots, Logic.SYM_LOGIC_META_INFERENCE_CACHE, null)));
        KeyValueList.setDynamicSlotValue(context.dynamicSlots, Logic.SYM_LOGIC_META_INFERENCE_CACHE, null, null);
      }
      else if (kind == Logic.KWD_TMS) {
        cache = ((World)(KeyValueList.dynamicSlotValue(context.dynamicSlots, Logic.SYM_LOGIC_TRUTH_MAINTAINED_INFERENCE_CACHE, null)));
        KeyValueList.setDynamicSlotValue(context.dynamicSlots, Logic.SYM_LOGIC_TRUTH_MAINTAINED_INFERENCE_CACHE, null, null);
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + kind + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      if ((cache != null) &&
          (!cache.deletedP())) {
        World.destroyWorld(cache);
      }
    }
  }

  public static void destroyAllInferenceCaches(Context context, Keyword kind) {
    Logic.destroyInferenceCache(context, kind);
    { Context child = null;
      AllPurposeIterator iter000 = Context.allSubcontexts(((Context)(Stella.$CONTEXT$.get())), Logic.KWD_PREORDER);

      while (iter000.nextP()) {
        child = ((Context)(iter000.value));
        if (Logic.worldStateP(child)) {
          Logic.destroyInferenceCache(child, kind);
        }
      }
    }
  }

  public static void unlinkInferenceCache(World self) {
    if (((Context)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_INFERENCE_CACHE_OF, null))) != null) {
      { Context worldstate = ((Context)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_INFERENCE_CACHE_OF, null)));

        if (self == ((World)(KeyValueList.dynamicSlotValue(worldstate.dynamicSlots, Logic.SYM_LOGIC_JUST_IN_TIME_INFERENCE_CACHE, null)))) {
          KeyValueList.setDynamicSlotValue(worldstate.dynamicSlots, Logic.SYM_LOGIC_JUST_IN_TIME_INFERENCE_CACHE, null, null);
        }
        else if (self == ((World)(KeyValueList.dynamicSlotValue(worldstate.dynamicSlots, Logic.SYM_LOGIC_META_INFERENCE_CACHE, null)))) {
          KeyValueList.setDynamicSlotValue(worldstate.dynamicSlots, Logic.SYM_LOGIC_META_INFERENCE_CACHE, null, null);
        }
        else if (self == ((World)(KeyValueList.dynamicSlotValue(worldstate.dynamicSlots, Logic.SYM_LOGIC_TRUTH_MAINTAINED_INFERENCE_CACHE, null)))) {
          KeyValueList.setDynamicSlotValue(worldstate.dynamicSlots, Logic.SYM_LOGIC_TRUTH_MAINTAINED_INFERENCE_CACHE, null, null);
        }
        KeyValueList.setDynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_INFERENCE_CACHE_OF, null, null);
      }
    }
  }

  public static void destroyInferenceCaches(Context context) {
    Logic.destroyInferenceCache(context, Logic.KWD_JUST_IN_TIME);
    Logic.destroyInferenceCache(context, Logic.KWD_META);
    Logic.destroyInferenceCache(context, Logic.KWD_TMS);
  }

  public static void handleOutOfDateInferenceCache(Keyword assertorretract, Proposition proposition) {
    if (Logic.worldStateP(((Context)(Stella.$CONTEXT$.get())))) {
      if ((Logic.lookupInferenceCache(((Context)(Stella.$CONTEXT$.get())), Logic.KWD_META) == null) ||
          ((((QueryIterator)(Logic.$QUERYITERATOR$.get())) != null) ||
           (Logic.descriptionModeP() ||
            ((Boolean)(Logic.$INVISIBLEASSERTIONp$.get())).booleanValue()))) {
        return;
      }
      { NamedDescription description = ((proposition != null) ? Logic.getDescription(((Surrogate)(proposition.operator))) : ((NamedDescription)(null)));

        if ((description != null) &&
            Logic.testPropertyP(description, Logic.SGT_PL_KERNEL_KB_HIDDEN_RELATION)) {
          return;
        }
      }
      if (Proposition.metaPropositionP(proposition) &&
          ((assertorretract == Logic.KWD_RETRACT) &&
           (!((BooleanWrapper)(KeyValueList.dynamicSlotValue(Logic.lookupInferenceCache(((Context)(Stella.$CONTEXT$.get())), Logic.KWD_META).dynamicSlots, Logic.SYM_LOGIC_TRUTH_MAINTAINEDp, Stella.FALSE_WRAPPER))).wrapperValue))) {
        if ((Stella.$TRACED_KEYWORDS$ != null) &&
            Stella.$TRACED_KEYWORDS$.membP(Logic.KWD_PERFORMANCE_CLUES)) {
          Stella.STANDARD_OUTPUT.nativeStream.println("DELETING META CACHE");
        }
        Logic.destroyInferenceCache(((Context)(Stella.$CONTEXT$.get())), Logic.KWD_META);
      }
      else if (Logic.$JUST_IN_TIME_FORWARD_INFERENCEp$) {
        if (((World)(KeyValueList.dynamicSlotValue(((Context)(Stella.$CONTEXT$.get())).dynamicSlots, Logic.SYM_LOGIC_JUST_IN_TIME_INFERENCE_CACHE, null))) != null) {
          if ((Stella.$TRACED_KEYWORDS$ != null) &&
              Stella.$TRACED_KEYWORDS$.membP(Logic.KWD_PERFORMANCE_CLUES)) {
            Stella.STANDARD_OUTPUT.nativeStream.println("DELETING JIT CACHE");
          }
          Logic.destroyAllInferenceCaches(((Context)(Stella.$CONTEXT$.get())), Logic.KWD_JUST_IN_TIME);
        }
      }
      else {
        { World cache = Logic.lookupInferenceCache(((Context)(Stella.$CONTEXT$.get())), Logic.KWD_TMS);

          if ((cache != null) &&
              (!((BooleanWrapper)(KeyValueList.dynamicSlotValue(cache.dynamicSlots, Logic.SYM_LOGIC_TRUTH_MAINTAINEDp, Stella.FALSE_WRAPPER))).wrapperValue)) {
            Logic.destroyInferenceCache(((Context)(Stella.$CONTEXT$.get())), Logic.KWD_TMS);
          }
        }
      }
      return;
    }
    { World world = ((World)(((Context)(Stella.$CONTEXT$.get()))));

      if (((BooleanWrapper)(KeyValueList.dynamicSlotValue(world.dynamicSlots, Logic.SYM_LOGIC_MONOTONICp, Stella.FALSE_WRAPPER))).wrapperValue &&
          (assertorretract == Logic.KWD_RETRACT)) {
        if (proposition != null) {
          Stella.STANDARD_WARNING.nativeStream.println("Warning: Retraction of `" + proposition + "' occurred in world `" + world + "' which is marked monotonic.");
        }
        else {
          Stella.STANDARD_WARNING.nativeStream.println("Warning: Retraction occurred in world `" + world + "' which is marked monotonic.");
        }
      }
      if (!((BooleanWrapper)(KeyValueList.dynamicSlotValue(world.dynamicSlots, Logic.SYM_LOGIC_TRUTH_MAINTAINEDp, Stella.FALSE_WRAPPER))).wrapperValue) {
        KeyValueList.setDynamicSlotValue(world.dynamicSlots, Logic.SYM_LOGIC_UP_TO_DATE_INFERENCESp, Stella.FALSE_WRAPPER, Stella.FALSE_WRAPPER);
      }
    }
  }

  public static World bestInferenceCache(Context context) {
    if (Logic.$JUST_IN_TIME_FORWARD_INFERENCEp$) {
      return (Logic.getInferenceCache(context, Logic.KWD_JUST_IN_TIME));
    }
    { World cache = Logic.lookupInferenceCache(context, Logic.KWD_TMS);

      if (cache != null) {
        return (cache);
      }
      else {
        return (Logic.lookupInferenceCache(context, Logic.KWD_META));
      }
    }
  }

  public static Context getQueryContext() {
    if (!Logic.worldStateP(((Context)(Stella.$CONTEXT$.get())))) {
      return (((Context)(Stella.$CONTEXT$.get())));
    }
    { World cache = Logic.bestInferenceCache(((Context)(Stella.$CONTEXT$.get())));

      return (((cache != null) ? cache : ((Context)(Stella.$CONTEXT$.get()))));
    }
  }

  public static Context getPropertyTestContext() {
    { World constraintpropagationworld = Logic.lookupConstraintPropagationWorld(((Context)(Stella.$CONTEXT$.get())));

      if (constraintpropagationworld == null) {
        return (((Context)(Stella.$CONTEXT$.get())));
      }
      else {
        return (constraintpropagationworld);
      }
    }
  }

  public static Context getInferableTestContext() {
    if (!Logic.worldStateP(((Context)(Stella.$CONTEXT$.get())))) {
      return (((Context)(Stella.$CONTEXT$.get())));
    }
    else {
      { World temp000 = Logic.lookupInferenceCache(((Context)(Stella.$CONTEXT$.get())), Logic.KWD_META);

        { Context value000 = ((temp000 != null) ? temp000 : ((Context)(Stella.$CONTEXT$.get())));

          return (value000);
        }
      }
    }
  }

  public static Context getTopLevelUpdateContext() {
    return (Logic.getWorldState(((Context)(Stella.$CONTEXT$.get()))));
  }

  public static World lookupConstraintPropagationWorld(Context self) {
    if (Logic.worldStateP(self)) {
      if (Logic.$JUST_IN_TIME_FORWARD_INFERENCEp$) {
        if (((QueryIterator)(Logic.$QUERYITERATOR$.get())) != null) {
          return (Logic.getInferenceCache(self, Logic.KWD_JUST_IN_TIME));
        }
        else {
          return (Logic.lookupInferenceCache(self, Logic.KWD_JUST_IN_TIME));
        }
      }
      else {
        return (Logic.lookupInferenceCache(self, Logic.KWD_TMS));
      }
    }
    else {
      return (((World)(self)));
    }
  }

  public static void inheritCachedInferences(World fromworld, World toworld) {
    toworld = toworld;
    if (fromworld == null) {
      return;
    }
  }

  /** Trigger constraint propagation over all propositions
   * in the module or world <code>context</code>.
   * @param context
   */
  public static void callPropagateConstraints(Context context) {
    { Context worldstate = Logic.getWorldState(context);
      World propagationworld = Logic.getInferenceCache(worldstate, Logic.KWD_META);

      if (((BooleanWrapper)(KeyValueList.dynamicSlotValue(propagationworld.dynamicSlots, Logic.SYM_LOGIC_UP_TO_DATE_INFERENCESp, Stella.FALSE_WRAPPER))).wrapperValue) {
        return;
      }
      try {
        { Proposition p = null;
          Iterator iter000 = Logic.allPropositions(((Module)(worldstate)), true);

          while (iter000.nextP()) {
            p = ((Proposition)(iter000.value));
            Logic.reactToKbUpdate(propagationworld, p);
          }
        }
      } catch (Clash e) {
        Stella.STANDARD_ERROR.nativeStream.println(Stella.exceptionMessage(e));
        {
          Stella.STANDARD_ERROR.nativeStream.println("One or more facts need to be retracted to eliminate");
          Stella.STANDARD_ERROR.nativeStream.println("   the inconsistency.");
        }
;
      }
      KeyValueList.setDynamicSlotValue(propagationworld.dynamicSlots, Logic.SYM_LOGIC_UP_TO_DATE_INFERENCESp, Stella.TRUE_WRAPPER, Stella.FALSE_WRAPPER);
    }
  }

  /** Trigger constraint propagation over all propositions of module <code>name</code>.
   * If no <code>name</code> is supplied, the current module will be used.  This also
   * enables incremental constraint propagation for future monotonic updates to
   * the module.  Once a non-monotonic update is performed, i.e., a retraction
   * or clipping of a function value, all cached inferences will be discarded
   * and constraint propagation will be turned off until this function is
   * called again.
   * @param name
   */
  public static void propagateConstraints(Cons name) {
    Logic.processCheckTypesAgenda();
    { Cons optionalname = name;
      Module module = null;

      if (optionalname.value != null) {
        module = Stella_Object.coerceToModule(optionalname.value, true);
      }
      if (module != null) {
        Logic.callPropagateConstraints(module);
      }
      else {
        Logic.callPropagateConstraints(((Context)(Stella.$CONTEXT$.get())));
      }
    }
  }

  public static void propagateConstraintsEvaluatorWrapper(Cons arguments) {
    Logic.propagateConstraints(arguments);
  }

  /** Force non-incremental constraint propagation over all propositions of
   * module <code>name</code>.  If no <code>name</code> is supplied, the current module will be used.
   * This also enables incremental constraint propagation for future monotonic
   * updates to the module similar to <code>propagateConstraints</code>.
   * @param name
   */
  public static void repropagateConstraints(Cons name) {
    Logic.processCheckTypesAgenda();
    { Cons optionalname = name;
      Module context = Stella_Object.coerceToModule(optionalname.value, true);

      if (context == null) {
        context = ((Module)(((Context)(Stella.$CONTEXT$.get()))));
      }
      Logic.destroyInferenceCaches(context);
      Logic.callPropagateConstraints(context);
    }
  }

  public static void repropagateConstraintsEvaluatorWrapper(Cons arguments) {
    Logic.repropagateConstraints(arguments);
  }

  /** Run forward inference rules in module 'module'. If 'module'
   * is NULL, the current module will be used.  If forward inferencing is already
   * up-to-date in the designated module, no additional inferencing will occur,
   * unless 'force?' is set to TRUE, in which case all forward rules are run or rerun.
   * @param module
   * @param forceP
   */
  public static void callRunForwardRules(Module module, boolean forceP) {
    Logic.finalizeObjects();
    Logic.processCheckTypesAgenda();
    if (forceP) {
      Logic.destroyInferenceCaches(module);
    }
    { Context worldstate = Logic.getWorldState(module);
      World propagationworld = Logic.getInferenceCache(worldstate, Logic.KWD_META);

      if (((BooleanWrapper)(KeyValueList.dynamicSlotValue(propagationworld.dynamicSlots, Logic.SYM_LOGIC_UP_TO_DATE_INFERENCESp, Stella.FALSE_WRAPPER))).wrapperValue) {
        return;
      }
      { Proposition p = null;
        Iterator iter000 = Logic.allPropositions(((Module)(worldstate)), true);

        while (iter000.nextP()) {
          p = ((Proposition)(iter000.value));
          Logic.reactToKbUpdate(propagationworld, p);
        }
      }
      KeyValueList.setDynamicSlotValue(propagationworld.dynamicSlots, Logic.SYM_LOGIC_UP_TO_DATE_INFERENCESp, Stella.TRUE_WRAPPER, Stella.FALSE_WRAPPER);
    }
  }

  /** Run forward inference rules in the module defined by the :module option (which
   * defaults to the current module).  If forward inferencing is already up-to-date
   * in the designated module, no additional inferencing will occur, unless the :force?
   * option is specified as TRUE, in which case all forward rules are run or rerun.
   * For backwards compatibility, this command also supports the old &lt;module&gt; :force
   * arguments specified with a non-standard keyword notation.
   * <p>
   * Calling <code>runForwardRules</code> temporarily puts the module into a mode where
   * future assertional (monotonic) updates will trigger additional forward
   * inference.  Once a non-monotonic update is performed, i.e., a retraction
   * or clipping of relation value, all cached forward inferences will be discarded
   * and forward inferencing will be disabled until this function is called again.
   * @param options
   */
  public static void runForwardRules(Cons options) {
    { Cons optionslist = options;
      PropertyList theoptions = Stella_Object.parseOptions((Stella_Object.keywordP(optionslist.value) ? optionslist : Cons.consList(Cons.cons(Logic.KWD_MODULE, Cons.cons(optionslist.value, Cons.cons(Logic.KWD_FORCEp, Cons.cons(((optionslist.rest.value == Logic.KWD_FORCE) ? Stella.TRUE_WRAPPER : Stella.FALSE_WRAPPER), Stella.NIL)))))), Cons.list$(Cons.cons(Logic.KWD_MODULE, Cons.cons(Logic.SGT_STELLA_MODULE, Cons.cons(Logic.KWD_FORCEp, Cons.cons(Logic.SGT_STELLA_BOOLEAN, Cons.cons(Stella.NIL, Stella.NIL)))))), true, false);
      Module themodule = ((Module)(theoptions.lookupWithDefault(Logic.KWD_MODULE, ((Module)(Stella.$MODULE$.get())))));
      boolean forceP = BooleanWrapper.coerceWrappedBooleanToBoolean(((BooleanWrapper)(theoptions.lookupWithDefault(Logic.KWD_FORCEp, Stella.FALSE_WRAPPER))));

      try {
        Logic.callRunForwardRules(themodule, forceP);
      } catch (Clash e) {
        Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
        Stella.STANDARD_OUTPUT.nativeStream.println("   One or more facts need to be retracted to eliminate the inconsistency.");
      }
    }
  }

  public static void runForwardRulesEvaluatorWrapper(Cons arguments) {
    Logic.runForwardRules(arguments);
  }

  /** Return direct super classes/slots of 'self'.
   * @param self
   * @return Iterator
   */
  public static Iterator directSuperrelations(Relation self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfClassP(testValue000)) {
        { Stella_Class self000 = ((Stella_Class)(self));

          return (self000.directSuperClasses());
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_SLOT)) {
        { Slot self000 = ((Slot)(self));

          return (((ListIterator)(self000.slotDirectSupers().allocateIterator())));
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  public static Cons slotColumnTypes(Slot self, int count) {
    if (Surrogate.subtypeOfStorageSlotP(Stella_Object.safePrimaryType(self))) {
      { StorageSlot self000 = ((StorageSlot)(self));

        { Surrogate domain = self000.slotOwner;
          Surrogate range = self000.slotBaseType;
          Cons typeslist = (Logic.booleanTypeP(range) ? Cons.consList(Cons.cons(domain, Stella.NIL)) : Cons.consList(Cons.cons(domain, Cons.cons(range, Stella.NIL))));

          return (typeslist);
        }
      }
    }
    else {
      { List typespecifiers = (Stella_Object.isaP(self, Logic.SGT_STELLA_METHOD_SLOT) ? ((MethodSlot)(self)).methodParameterTypeSpecifiers() : ((Table)(self)).tupleDomains);
        Cons typeslist = Stella.NIL;
        Cons variabletypes = Stella.NIL;
        Cons returntypes = Stella.NIL;
        Surrogate returntype = Logic.unwrapWrappedType(self.slotBaseType);

        if ((returntype != null) &&
            (!Logic.booleanTypeP(returntype))) {
          returntypes = Cons.cons(returntype, returntypes);
        }
        if (self.arity() == Stella.NULL_INTEGER) {
          { StandardObject variableargumentstype = StandardObject.extractParameterType(((ParametricTypeSpecifier)(typespecifiers.last())), Logic.SYM_STELLA_ANY_VALUE, new Object[1]);

            { Stella_Object tspec = null;
              Iterator iter000 = typespecifiers.butLast();
              Cons collect000 = null;

              while (iter000.nextP()) {
                tspec = iter000.value;
                if (collect000 == null) {
                  {
                    collect000 = Cons.cons(Logic.unwrapWrappedType(StandardObject.typeSpecToBaseType(((StandardObject)(tspec)))), Stella.NIL);
                    if (typeslist == Stella.NIL) {
                      typeslist = collect000;
                    }
                    else {
                      Cons.addConsToEndOfConsList(typeslist, collect000);
                    }
                  }
                }
                else {
                  {
                    collect000.rest = Cons.cons(Logic.unwrapWrappedType(StandardObject.typeSpecToBaseType(((StandardObject)(tspec)))), Stella.NIL);
                    collect000 = collect000.rest;
                  }
                }
              }
            }
            if (count == Stella.NULL_INTEGER) {
              count = 1;
            }
            else {
              count = count - (typeslist.length() + returntypes.length());
            }
            { int i = Stella.NULL_INTEGER;
              int iter001 = 1;
              int upperBound000 = count;
              boolean unboundedP000 = upperBound000 == Stella.NULL_INTEGER;

              for (;unboundedP000 ||
                        (iter001 <= upperBound000); iter001 = iter001 + 1) {
                i = iter001;
                i = i;
                variabletypes = Cons.cons(variableargumentstype, variabletypes);
              }
            }
            typeslist = typeslist.concatenate(variabletypes, Stella.NIL);
          }
        }
        else {
          { Stella_Object tspec = null;
            Cons iter002 = typespecifiers.theConsList;
            Cons collect001 = null;

            for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
              tspec = iter002.value;
              if (collect001 == null) {
                {
                  collect001 = Cons.cons(Logic.unwrapWrappedType(StandardObject.typeSpecToBaseType(((StandardObject)(tspec)))), Stella.NIL);
                  if (typeslist == Stella.NIL) {
                    typeslist = collect001;
                  }
                  else {
                    Cons.addConsToEndOfConsList(typeslist, collect001);
                  }
                }
              }
              else {
                {
                  collect001.rest = Cons.cons(Logic.unwrapWrappedType(StandardObject.typeSpecToBaseType(((StandardObject)(tspec)))), Stella.NIL);
                  collect001 = collect001.rest;
                }
              }
            }
          }
        }
        typeslist = typeslist.concatenate(returntypes, Stella.NIL);
        return (typeslist);
      }
    }
  }

  public static Description createDescription(int arity, boolean namedP) {
    Logic.enforceCodeOnly();
    { Description description = (namedP ? NamedDescription.newNamedDescription() : Description.newDescription());

      description.ioVariables = ((arity != Stella.NULL_INTEGER) ? Vector.newVector(arity) : Logic.FAKE_IO_VARIABLES);
      return (description);
    }
  }

  public static Symbol yieldSystemDefinedParameterName(int index, Stella_Object referenceobject) {
    if (index < 100) {
      return (Symbol.internSymbolInModule(((Symbol)(Logic.SYSTEM_DEFINED_ARGUMENT_NAMES.nth(index))).symbolName, referenceobject.homeModule(), true));
    }
    else {
      return (Symbol.internSymbolInModule("?X" + Native.integerToString(((long)(index + 1))), referenceobject.homeModule(), true));
    }
  }

  public static NamedDescription createPrimitiveDescription(List iovariablenames, List iovariabletypes, boolean variablearityP, boolean classP, boolean functionP, Module module) {
    if (iovariabletypes.length() > Logic.SYSTEM_DEFINED_ARGUMENT_NAMES.length()) {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        stream000.nativeStream.println("PowerLoom can't handle relations with arity > `" + Logic.SYSTEM_DEFINED_ARGUMENT_NAMES.length() + "'");
        throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
      }
    }
    { Object old$Module$000 = Stella.$MODULE$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setSpecial(Stella.$MODULE$, module);
        Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
        { NamedDescription description = ((NamedDescription)(Logic.createDescription(Stella.NULL_INTEGER, true)));

          description.ioVariableNames = iovariablenames;
          description.ioVariableTypes = iovariabletypes;
          description.surrogateValueInverse = Logic.SGT_LOGIC_UNFINALIZED;
          { Object old$FillingconstraintpropagationqueuesP$000 = Logic.$FILLINGCONSTRAINTPROPAGATIONQUEUESp$.get();
            Object old$Evaluationmode$000 = Logic.$EVALUATIONMODE$.get();

            try {
              Native.setBooleanSpecial(Logic.$FILLINGCONSTRAINTPROPAGATIONQUEUESp$, false);
              Native.setSpecial(Logic.$EVALUATIONMODE$, Logic.KWD_EXTENSIONAL_ASSERTION);
              if (classP) {
                Logic.linkOriginatedProposition(description, Logic.assertIsaProposition(description, Logic.SGT_PL_KERNEL_KB_CONCEPT));
              }
              else if (functionP) {
                Logic.linkOriginatedProposition(description, Logic.assertIsaProposition(description, Logic.SGT_PL_KERNEL_KB_FUNCTION));
              }
              else {
                Logic.linkOriginatedProposition(description, Logic.assertIsaProposition(description, Logic.SGT_PL_KERNEL_KB_RELATION));
              }
              if (variablearityP) {
                Logic.linkOriginatedProposition(description, LogicObject.assertProperty(description, Logic.SGT_PL_KERNEL_KB_VARIABLE_ARITY));
              }
              description.surrogateValueInverse = null;
              return (description);

            } finally {
              Logic.$EVALUATIONMODE$.set(old$Evaluationmode$000);
              Logic.$FILLINGCONSTRAINTPROPAGATIONQUEUESp$.set(old$FillingconstraintpropagationqueuesP$000);
            }
          }
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Stella.$MODULE$.set(old$Module$000);
      }
    }
  }

  public static void linkStellaRelationAndDescription(Relation self, NamedDescription description) {
    KeyValueList.setDynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, description, null);
    description.nativeRelationSetter(self);
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfClassP(testValue000)) {
        { Stella_Class self000 = ((Stella_Class)(self));

          description.surrogateValueInverse = Logic.classLogicalType(self000);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_SLOT)) {
        { Slot self000 = ((Slot)(self));

          description.surrogateValueInverse = self000.slotSlotref;
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
    if (Logic.polymorphicRelationP(self)) {
      Description.createBaseRelationForPolymorphicDescription(description);
    }
    return;
  }

  public static NamedDescription createDescriptionForStellaRelation(Relation self) {
    { Relation renamed_Super = null;
      Iterator iter000 = Logic.directSuperrelations(self);

      while (iter000.nextP()) {
        renamed_Super = ((Relation)(iter000.value));
        if ((renamed_Super != null) &&
            ((!Stella_Object.isaP(renamed_Super, Logic.SGT_STELLA_CLASS)) ||
             Logic.logicClassP(((Stella_Class)(renamed_Super))))) {
          Logic.getDescription(renamed_Super);
        }
      }
    }
    { NamedDescription description = null;
      Module homemodule = null;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

        if (Surrogate.subtypeOfClassP(testValue000)) {
          { Stella_Class self000 = ((Stella_Class)(self));

            homemodule = Logic.classLogicalType(self000).homeModule();
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_SLOT)) {
          { Slot self000 = ((Slot)(self));

            homemodule = self000.homeModule();
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
      if (!(Context.visibleFromP(Logic.$PL_KERNEL_MODULE$, homemodule))) {
        homemodule = Logic.$PL_KERNEL_MODULE$;
      }
      { Surrogate testValue001 = Stella_Object.safePrimaryType(self);

        if (Surrogate.subtypeOfClassP(testValue001)) {
          { Stella_Class self000 = ((Stella_Class)(self));

            if (!Logic.logicClassP(self000)) {
              { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

                { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

                  try {
                    Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                    {
                      stream001.nativeStream.println("ERROR: Can't use the class `" + self000 + "' as a logic class because it");
                      stream001.nativeStream.println("   does not inherit the top-level class THING..");
                    }
;
                    Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

                  } finally {
                    Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
                  }
                }
                throw ((PropositionError)(PropositionError.newPropositionError(stream001.theStringReader()).fillInStackTrace()));
              }
            }
            description = Logic.createPrimitiveDescription(Stella.NIL_LIST, List.list(Cons.cons(Logic.classLogicalType(self000), Stella.NIL)), false, true, false, homemodule);
          }
        }
        else if (Surrogate.subtypeOfP(testValue001, Logic.SGT_STELLA_SLOT)) {
          { Slot self000 = ((Slot)(self));

            { Surrogate slotref = self000.slotSlotref;
              Surrogate superslotref = Logic.mostGeneralEquivalentSlotref(slotref);

              if (!(slotref == superslotref)) {
                self000 = ((Slot)(superslotref.surrogateValue));
                if (((NamedDescription)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))) != null) {
                  return (((NamedDescription)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))));
                }
              }
            }
            { List self005 = List.newList();

              self005.theConsList = Logic.slotColumnTypes(self000, Stella.NULL_INTEGER);
              description = Logic.createPrimitiveDescription(Stella.NIL_LIST, self005, false, false, !Logic.booleanTypeP(self000.slotBaseType), homemodule);
            }
          }
        }
        else {
          { OutputStringStream stream002 = OutputStringStream.newOutputStringStream();

            stream002.nativeStream.print("`" + testValue001 + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream002.theStringReader()).fillInStackTrace()));
          }
        }
      }
      Logic.linkStellaRelationAndDescription(self, description);
      Logic.finalizeSuperrelationLinks(self);
      Description.ensureDescriptionBody(description);
      return (description);
    }
  }

  public static NamedDescription surrogateToDescription(Surrogate self) {
    { Stella_Object surrogatevalue = self.surrogateValue;

      if (surrogatevalue == null) {
        return (null);
      }
      if (Stella_Object.isaP(surrogatevalue, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        return (((NamedDescription)(surrogatevalue)));
      }
      else {
        return (Logic.getDescription(self));
      }
    }
  }

  public static NamedDescription getDescription(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        { NamedDescription self000 = ((NamedDescription)(self));

          return (self000);
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate self000 = ((Surrogate)(self));

          return (Logic.surrogateDgetDescription(self000));
        }
      }
      else if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol self000 = ((Symbol)(self));

          return (Logic.getDescription(Symbol.symbolToSurrogate(self000)));
        }
      }
      else if (Surrogate.subtypeOfStringP(testValue000)) {
        { StringWrapper self000 = ((StringWrapper)(self));

          return (Logic.stringDgetDescription(self000.wrapperValue));
        }
      }
      else if (Surrogate.subtypeOfClassP(testValue000)) {
        { Stella_Class self000 = ((Stella_Class)(self));

          return (Logic.classDgetDescription(self000));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_SLOT)) {
        { Slot self000 = ((Slot)(self));

          return (Logic.slotDgetDescription(self000));
        }
      }
      else {
        return (null);
      }
    }
  }

  public static NamedDescription surrogateDgetDescription(Surrogate self) {
    { Stella_Object value = self.surrogateValue;
      ObjectStore store = null;

      if (value != null) {
        { Surrogate testValue000 = Stella_Object.safePrimaryType(value);

          if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
            { NamedDescription value000 = ((NamedDescription)(value));

              return (value000);
            }
          }
          else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_RELATION)) {
            { Relation value000 = ((Relation)(value));

              if (((NamedDescription)(KeyValueList.dynamicSlotValue(value000.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))) != null) {
                return (((NamedDescription)(KeyValueList.dynamicSlotValue(value000.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))));
              }
              else {
                return (Logic.createDescriptionForStellaRelation(value000));
              }
            }
          }
          else {
            return (null);
          }
        }
      }
      else if ((store = Logic.homeObjectStore(self)) != null) {
        return (store.fetchRelation(self));
      }
      else {
        return (null);
      }
    }
  }

  public static NamedDescription stringDgetDescription(String self) {
    { Surrogate surrogate = Surrogate.lookupSurrogate(self);
      ObjectStore store = null;

      if (surrogate != null) {
        return (Logic.getDescription(surrogate));
      }
      else if ((store = ((ObjectStore)(KeyValueList.dynamicSlotValue(((Module)(Stella.$MODULE$.get())).dynamicSlots, Logic.SYM_LOGIC_OBJECT_STORE, null)))) != null) {
        return (store.fetchRelation(StringWrapper.wrapString(self)));
      }
      else {
        return (null);
      }
    }
  }

  public static NamedDescription classDgetDescription(Stella_Class self) {
    if (((NamedDescription)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))) != null) {
      return (((NamedDescription)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))));
    }
    else if (!Logic.logicClassP(self)) {
      if (!(((Boolean)(Logic.$SUPPRESSNONLOGICOBJECTWARNINGp$.get())).booleanValue())) {
        {
          Stella.STANDARD_OUTPUT.nativeStream.println("Reference to non-logic class: `" + self.name() + "'");
          Stella.STANDARD_OUTPUT.nativeStream.println("Class must inherit 'THING' to be used by PowerLoom's logic.");
          Stella.STANDARD_OUTPUT.nativeStream.println();
        }
;
      }
      return (null);
    }
    else {
      return (Logic.getDescription(Logic.classLogicalType(self)));
    }
  }

  public static NamedDescription slotDgetDescription(Slot self) {
    if (((NamedDescription)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))) != null) {
      return (((NamedDescription)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))));
    }
    else if (self.slotSlotref != null) {
      return (Logic.getDescription(self.slotSlotref));
    }
    else {
      return (Logic.getDescription(Surrogate.lookupSlotref(self.slotOwner, self.slotName)));
    }
  }

  public static Surrogate ensureDeferredDescription(Surrogate self) {
    if ((self.surrogateValue == null) &&
        (Logic.homeObjectStore(self) != null)) {
      Logic.getDescription(self);
    }
    return (self);
  }

  /** Return TRUE if the class 'self' or one of its
   * supers supports indices that record extensions referenced by
   * the logic system. Also return true for literal classes.
   * @param self
   * @return boolean
   */
  public static boolean logicClassP(Stella_Class self) {
    { boolean testValue000 = false;

      if (((NamedDescription)(KeyValueList.dynamicSlotValue(self.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))) != null) {
        testValue000 = true;
      }
      else {
        {
          { boolean foundP000 = false;

            { Stella_Class c = null;
              Cons iter000 = self.classAllSuperClasses;

              loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                c = ((Stella_Class)(iter000.value));
                if ((((NamedDescription)(KeyValueList.dynamicSlotValue(c.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))) != null) ||
                    (c == ((Stella_Class)(Logic.SGT_STELLA_THING.surrogateValue)))) {
                  foundP000 = true;
                  break loop000;
                }
              }
            }
            testValue000 = foundP000;
          }
          if (!testValue000) {
            testValue000 = (self == ((Stella_Class)(Logic.SGT_STELLA_THING.surrogateValue))) ||
                (Stella_Class.subclassOfP(self, ((Stella_Class)(Logic.SGT_STELLA_LITERAL.surrogateValue))) ||
                 (self == ((Stella_Class)(Logic.SGT_LOGIC_PROPOSITION.surrogateValue))));
          }
        }
      }
      if (testValue000) {
        return (true);
      }
    }
    if (!self.classFinalizedP) {
      { List badsupers = Surrogate.collectBadSuperClasses(self.classType, List.list(Stella.NIL));

        if (badsupers.emptyP()) {
          { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              Stella.STANDARD_WARNING.nativeStream.println("WARNING: Could not determine whether " + self + " is a logic class, because it is not finalized.");
              Logic.helpSignalPropositionError(Stella.STANDARD_WARNING, Logic.KWD_WARNING);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
            }
          }
        }
        else {
          { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              {
                Stella.STANDARD_WARNING.nativeStream.println("WARNING: Could not determine whether " + self + " is a logic class, because it is not finalized.");
                Stella.STANDARD_WARNING.nativeStream.println("   It has these undefined or bad supers: " + badsupers.theConsList);
              }
;
              Logic.helpSignalPropositionError(Stella.STANDARD_WARNING, Logic.KWD_WARNING);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
            }
          }
        }
      }
    }
    return (false);
  }

  public static boolean variableArityDomainTypesNextP(AllPurposeIterator self) {
    { Iterator nestediterator = self.iteratorNestedIterator;

      if ((nestediterator != null) &&
          nestediterator.nextP()) {
        self.value = nestediterator.value;
      }
      else {
        {
          self.iteratorNestedIterator = null;
          self.value = self.iteratorObject;
        }
      }
      return (true);
    }
  }

  public static Iterator wrapIteratorForVariableArity(Iterator iterator) {
    { AllPurposeIterator allpurposeiterator = AllPurposeIterator.newAllPurposeIterator();

      allpurposeiterator.iteratorNextCode = Native.find_java_method("edu.isi.powerloom.logic.Logic", "variableArityDomainTypesNextP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.AllPurposeIterator")});
      allpurposeiterator.iteratorNestedIterator = iterator;
      return (allpurposeiterator);
    }
  }

  public static void popLogicVariableBinding() {
    { Cons headcons = ((Cons)(Logic.$LOGICVARIABLETABLE$.get()));

      Native.setSpecial(Logic.$LOGICVARIABLETABLE$, headcons.rest);
      headcons.free();
    }
  }

  public static void popLogicVariableBindings(Cons variables) {
    { int i = Stella.NULL_INTEGER;
      int iter000 = 1;
      int upperBound000 = variables.length();

      for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
        i = iter000;
        i = i;
        Logic.popLogicVariableBinding();
      }
    }
  }

  public static Stella_Object lookupLogicVariableBinding(Symbol variablename) {
    if (((Cons)(Logic.$LOGICVARIABLETABLE$.get())) != null) {
      { Skolem vbl = null;
        Cons iter000 = ((Cons)(Logic.$LOGICVARIABLETABLE$.get()));

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          vbl = ((Skolem)(iter000.value));
          if (vbl.skolemName == variablename) {
            return (vbl);
          }
        }
      }
    }
    return (null);
  }

  public static void parseOneVariableDeclaration(Stella_Object vdec, List localdeclarations) {
    { Symbol variablename = null;
      Cons isatree = null;
      PatternVariable variable = null;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(vdec);

        if (testValue000 == Logic.SGT_STELLA_CONS) {
          { Cons vdec000 = ((Cons)(vdec));

            variablename = ((Symbol)(vdec000.rest.value));
            isatree = vdec000;
          }
        }
        else if (Surrogate.subtypeOfSymbolP(testValue000)) {
          { Symbol vdec000 = ((Symbol)(vdec));

            variablename = vdec000;
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
      { PatternVariable v = null;
        Cons iter000 = localdeclarations.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          v = ((PatternVariable)(iter000.value));
          if (v.skolemName == variablename) {
            variable = v;
          }
        }
      }
      if (variable == null) {
        variable = Logic.createVariable(null, variablename, true);
      }
      Skolem.pushLogicVariableBinding(variable);
      localdeclarations.insertLast(variable);
      if (isatree != null) {
        { Proposition proposition = Logic.buildTopLevelProposition(isatree, false);

          if (proposition == null) {
            { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

              { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

                try {
                  Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                  stream001.nativeStream.println("ERROR: Error in declarations.");
                  Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

                } finally {
                  Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
                }
              }
              throw ((PropositionError)(PropositionError.newPropositionError(stream001.theStringReader()).fillInStackTrace()));
            }
          }
          if (proposition.kind == Logic.KWD_ISA) {
            KeyValueList.setDynamicSlotValue(proposition.dynamicSlots, Logic.SYM_LOGIC_VARIABLE_TYPEp, Stella.TRUE_WRAPPER, null);
            Skolem.updateSkolemType(((Skolem)((proposition.arguments.theArray)[0])), ((Surrogate)(proposition.operator)));
            Native.setSpecial(Logic.$VARIABLETYPEPROPOSITIONS$, Cons.cons(proposition, ((Cons)(Logic.$VARIABLETYPEPROPOSITIONS$.get()))));
          }
        }
      }
    }
  }

  public static Cons parseLogicVariableDeclarations(Stella_Object tree) {
    { Cons constree = (Stella_Object.isaP(tree, Logic.SGT_STELLA_CONS) ? ((Cons)(tree)) : Cons.consList(Cons.cons(tree, Stella.NIL)));
      List declarations = List.newList();

      { Stella_Object term = null;
        Cons iter000 = constree;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          term = iter000.value;
          Logic.parseOneVariableDeclaration(term, declarations);
        }
      }
      return (declarations.theConsList);
    }
  }

  public static Cons helpBuildQuantifiedProposition(Cons tree, boolean converttypestoconstraintsP, Object [] MV_returnarray) {
    { Object old$Variabletypepropositions$000 = Logic.$VARIABLETYPEPROPOSITIONS$.get();

      try {
        Native.setSpecial(Logic.$VARIABLETYPEPROPOSITIONS$, Stella.NIL);
        { Stella_Object quantifier = tree.value;
          Stella_Object antecedentclause = tree.rest.rest.value;
          Stella_Object consequentclause = tree.fourth();
          Cons variables = null;
          Proposition antecedentproposition = null;
          Proposition consequentproposition = null;

          variables = Logic.parseLogicVariableDeclarations(tree.rest.value);
          if (antecedentclause != null) {
            antecedentproposition = ((Proposition)(Logic.buildProposition(antecedentclause)));
          }
          if (consequentclause != null) {
            consequentproposition = ((Proposition)(Logic.buildProposition(consequentclause)));
          }
          Logic.popLogicVariableBindings(variables);
          if (converttypestoconstraintsP) {
            if (!(((Cons)(Logic.$VARIABLETYPEPROPOSITIONS$.get())) == Stella.NIL)) {
              if (antecedentproposition != null) {
                Native.setSpecial(Logic.$VARIABLETYPEPROPOSITIONS$, Cons.cons(antecedentproposition, ((Cons)(Logic.$VARIABLETYPEPROPOSITIONS$.get()))));
              }
              Native.setSpecial(Logic.$VARIABLETYPEPROPOSITIONS$, ((Cons)(Logic.$VARIABLETYPEPROPOSITIONS$.get())).reverse().removeDuplicates());
              antecedentproposition = Logic.conjoinPropositions(((Cons)(Logic.$VARIABLETYPEPROPOSITIONS$.get())));
            }
          }
          { Cons _return_temp = variables;

            MV_returnarray[0] = antecedentproposition;
            MV_returnarray[1] = consequentproposition;
            return (_return_temp);
          }
        }

      } finally {
        Logic.$VARIABLETYPEPROPOSITIONS$.set(old$Variabletypepropositions$000);
      }
    }
  }

  public static Cons buildQuantifiedProposition(Cons tree, boolean converttypestoconstraintsP, Object [] MV_returnarray) {
    if (((GeneralizedSymbol)(tree.value)) == Logic.SYM_STELLA_EXISTS) {
      { Object old$Evaluationmode$000 = Logic.$EVALUATIONMODE$.get();

        try {
          Native.setSpecial(Logic.$EVALUATIONMODE$, Logic.KWD_DESCRIPTION);
          return (Logic.helpBuildQuantifiedProposition(tree, converttypestoconstraintsP, MV_returnarray));

        } finally {
          Logic.$EVALUATIONMODE$.set(old$Evaluationmode$000);
        }
      }
    }
    else {
      { Object old$Evaluationmode$001 = Logic.$EVALUATIONMODE$.get();

        try {
          Native.setSpecial(Logic.$EVALUATIONMODE$, Logic.KWD_DESCRIPTION);
          return (Logic.helpBuildQuantifiedProposition(tree, converttypestoconstraintsP, MV_returnarray));

        } finally {
          Logic.$EVALUATIONMODE$.set(old$Evaluationmode$001);
        }
      }
    }
  }

  public static Vector copyConsListToVariablesVector(Cons conslist) {
    if (conslist == Stella.NIL) {
      return (Logic.ZERO_VARIABLES_VECTOR);
    }
    { Vector vector = Vector.newVector(conslist.length());

      { Stella_Object t = null;
        Cons iter000 = conslist;
        int i = Stella.NULL_INTEGER;
        int iter001 = 0;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
          t = iter000.value;
          i = iter001;
          (vector.theArray)[i] = (((PatternVariable)(t)));
        }
      }
      return (vector);
    }
  }

  public static boolean equivalentEnumerationsP(Collection self, Collection other) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_SET)) {
        { Set self000 = ((Set)(self));

          { boolean testValue001 = false;

            testValue001 = self000.length() == other.length();
            if (testValue001) {
              { boolean alwaysP000 = true;

                { Stella_Object m = null;
                  ListIterator iter000 = ((ListIterator)(self000.allocateIterator()));

                  loop000 : while (iter000.nextP()) {
                    m = iter000.value;
                    if (!other.memberP(m)) {
                      alwaysP000 = false;
                      break loop000;
                    }
                  }
                }
                testValue001 = alwaysP000;
              }
            }
            { boolean value000 = testValue001;

              return (value000);
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_LIST)) {
        { List self000 = ((List)(self));

          { boolean testValue002 = false;

            testValue002 = self000.length() == other.length();
            if (testValue002) {
              { boolean alwaysP001 = true;

                { Stella_Object m = null;
                  Cons iter001 = self000.theConsList;

                  loop001 : for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                    m = iter001.value;
                    if (!other.memberP(m)) {
                      alwaysP001 = false;
                      break loop001;
                    }
                  }
                }
                testValue002 = alwaysP001;
              }
            }
            { boolean value001 = testValue002;

              return (value001);
            }
          }
        }
      }
      else {
        return (false);
      }
    }
  }

  public static boolean equivalentFormulaeP(Stella_Object self, Stella_Object other, KeyValueMap mapping) {
    { Stella_Object surrogatevalue = null;

      if (Stella_Object.isaP(self, Logic.SGT_STELLA_SURROGATE)) {
        surrogatevalue = ((Surrogate)(self)).surrogateValue;
        if (surrogatevalue != null) {
          self = surrogatevalue;
        }
      }
      if (Stella_Object.isaP(other, Logic.SGT_STELLA_SURROGATE)) {
        surrogatevalue = ((Surrogate)(other)).surrogateValue;
        if (surrogatevalue != null) {
          other = surrogatevalue;
        }
      }
    }
    if ((mapping != null) &&
        (Stella_Object.eqlP(other, mapping.lookup(self)) ||
         Stella_Object.eqlP(self, mapping.lookup(other)))) {
      return (true);
    }
    if (Stella_Object.equalP(self, other)) {
      return (true);
    }
    if (mapping != null) {
      if (((Boolean)(Logic.$UNIFY_PROPOSITIONSp$.get())).booleanValue() &&
          (Logic.variableP(self) ||
           Logic.variableP(other))) {
        if (((QueryIterator)(Logic.$QUERYITERATOR$.get())) == null) {
          mapping.insertAt(self, other);
          return (true);
        }
        { Stella_Object value1 = Logic.argumentBoundTo(self);
          Stella_Object value2 = Logic.argumentBoundTo(other);

          if ((value1 == null) ||
              (value2 == null)) {
            mapping.insertAt(self, other);
            return (true);
          }
          else {
            return (Stella_Object.equalP(value1, value2));
          }
        }
      }
    }
    if (!(self.primaryType() == other.primaryType())) {
      return (false);
    }
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          return (Proposition.equivalentPropositionsP(self000, ((Proposition)(other)), mapping));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description self000 = ((Description)(self));

          return (Description.equivalentDescriptionsP(self000, ((Description)(other)), mapping));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_SET)) {
        { Set self000 = ((Set)(self));

          return (Logic.equivalentEnumerationsP(self000, ((Collection)(other))));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_LIST)) {
        { List self000 = ((List)(self));

          return (Logic.equivalentEnumerationsP(self000, ((Collection)(other))));
        }
      }
      else {
        return (false);
      }
    }
  }

  public static boolean sameAndUniqueArgumentsP(Vector variables, Vector arguments) {
    if (Stella_Object.equalP(variables, arguments)) {
      { int count = 0;

        { PatternVariable v = null;
          Vector vector000 = variables;
          int index000 = 0;
          int length000 = vector000.length();

          for (;index000 < length000; index000 = index000 + 1) {
            v = ((PatternVariable)((vector000.theArray)[index000]));
            { PatternVariable v2 = null;
              Vector vector001 = variables;
              int index001 = 0;
              int length001 = vector001.length();

              for (;index001 < length001; index001 = index001 + 1) {
                v2 = ((PatternVariable)((vector001.theArray)[index001]));
                if (v == v2) {
                  count = count + 1;
                }
              }
            }
          }
        }
        return (count == variables.length());
      }
    }
    return (false);
  }

  /** Return TRUE if 'self' is a description.
   * @param self
   * @return boolean
   */
  public static boolean descriptionP(Stella_Object self) {
    return ((self != null) &&
        Stella_Object.isaP(self, Logic.SGT_LOGIC_DESCRIPTION));
  }

  /** Return TRUE if 'self' is an unnamed description.
   * @param self
   * @return boolean
   */
  public static boolean unnamedDescriptionP(Stella_Object self) {
    return ((self != null) &&
        (Stella_Object.isaP(self, Logic.SGT_LOGIC_DESCRIPTION) &&
         (((Description)(self)).surrogateValueInverse == null)));
  }

  public static void collapseValueOfChainsForIoVariables(Vector iovariables) {
    { PatternVariable tightestvariable = null;

      { PatternVariable vbl = null;
        Vector vector000 = iovariables;
        int index000 = 0;
        int length000 = vector000.length();
        int i = Stella.NULL_INTEGER;
        int iter000 = 0;

        for (;index000 < length000; index000 = index000 + 1, iter000 = iter000 + 1) {
          vbl = ((PatternVariable)((vector000.theArray)[index000]));
          i = iter000;
          if (!(vbl == PatternVariable.innermostVariableOf(vbl))) {
            tightestvariable = PatternVariable.innermostVariableOf(vbl);
            (iovariables.theArray)[i] = tightestvariable;
            tightestvariable.skolemName = vbl.skolemName;
            { PatternVariable object000 = tightestvariable;
              Cons value000 = Stella.NIL;
              Stella_Object oldValue000 = object000.variableValueInverse;
              Stella_Object newValue000 = Stella_Object.updateInContext(oldValue000, value000, object000.homeContext, false);

              if (!((oldValue000 != null) &&
                  (oldValue000.primaryType() == Logic.SGT_STELLA_CS_VALUE))) {
                object000.variableValueInverse = newValue000;
              }
            }
          }
        }
      }
    }
  }

  public static Vector removeNullsInVariablesVector(Vector iovariables) {
    if (!iovariables.memberP(null)) {
      return (iovariables);
    }
    { Cons newvbllist = Stella.NIL;
      Vector result = null;

      { PatternVariable vbl = null;
        Vector vector000 = iovariables;
        int index000 = 0;
        int length000 = vector000.length();
        Cons collect000 = null;

        for (;index000 < length000; index000 = index000 + 1) {
          vbl = ((PatternVariable)((vector000.theArray)[index000]));
          if (vbl != null) {
            if (collect000 == null) {
              {
                collect000 = Cons.cons(vbl, Stella.NIL);
                if (newvbllist == Stella.NIL) {
                  newvbllist = collect000;
                }
                else {
                  Cons.addConsToEndOfConsList(newvbllist, collect000);
                }
              }
            }
            else {
              {
                collect000.rest = Cons.cons(vbl, Stella.NIL);
                collect000 = collect000.rest;
              }
            }
          }
        }
      }
      result = Logic.copyConsListToVariablesVector(newvbllist);
      return (result);
    }
  }

  public static Description evaluateDescriptionTerm(Cons term, boolean checkforduplicateP) {
    { Description description = Logic.createDescription(Stella.NULL_INTEGER, false);

      if (((GeneralizedSymbol)(term.value)) == Logic.SYM_LOGIC_THE_ONLY) {
        KeyValueList.setDynamicSlotValue(description.dynamicSlots, Logic.SYM_LOGIC_IOTAp, Stella.TRUE_WRAPPER, Stella.FALSE_WRAPPER);
      }
      else {
      }
      { Object old$Descriptionunderconstruction$000 = Logic.$DESCRIPTIONUNDERCONSTRUCTION$.get();
        Object old$Evaluationmode$000 = Logic.$EVALUATIONMODE$.get();
        Object old$Variableidcounter$000 = Logic.$VARIABLEIDCOUNTER$.get();

        try {
          Native.setSpecial(Logic.$DESCRIPTIONUNDERCONSTRUCTION$, description);
          Native.setSpecial(Logic.$EVALUATIONMODE$, Logic.KWD_DESCRIPTION);
          Native.setIntSpecial(Logic.$VARIABLEIDCOUNTER$, ((Integer)(Logic.$VARIABLEIDCOUNTER$.get())).intValue());
          { Cons iovars = null;
            Proposition proposition = null;
            Proposition unused = null;

            { Object [] caller_MV_returnarray = new Object[2];

              iovars = Logic.buildQuantifiedProposition(term, true, caller_MV_returnarray);
              proposition = ((Proposition)(caller_MV_returnarray[0]));
              unused = ((Proposition)(caller_MV_returnarray[1]));
            }
            unused = unused;
            description.ioVariables = Logic.copyConsListToVariablesVector(iovars);
            if (!(((Cons)(Logic.$LOGICVARIABLETABLE$.get())) == Stella.NIL)) {
              { Object old$Externalvariables$000 = Logic.$EXTERNALVARIABLES$.get();

                try {
                  Native.setSpecial(Logic.$EXTERNALVARIABLES$, Stella.NIL);
                  Proposition.collectExternalVariables(proposition);
                  if (!(((Cons)(Logic.$EXTERNALVARIABLES$.get())) == Stella.NIL)) {
                    KeyValueList.setDynamicSlotValue(description.dynamicSlots, Logic.SYM_LOGIC_EXTERNAL_VARIABLES, Logic.copyConsListToVariablesVector(((Cons)(Logic.$EXTERNALVARIABLES$.get()))), null);
                  }

                } finally {
                  Logic.$EXTERNALVARIABLES$.set(old$Externalvariables$000);
                }
              }
            }
            description.proposition = ((proposition != null) ? proposition : Logic.TRUE_PROPOSITION);
          }
          return (Description.finishBuildingDescription(description, checkforduplicateP, Logic.KWD_TOP_LEVEL));

        } finally {
          Logic.$VARIABLEIDCOUNTER$.set(old$Variableidcounter$000);
          Logic.$EVALUATIONMODE$.set(old$Evaluationmode$000);
          Logic.$DESCRIPTIONUNDERCONSTRUCTION$.set(old$Descriptionunderconstruction$000);
        }
      }
    }
  }

  public static void collectFreeVariables(Stella_Object self, List collection, List quantifiedvars, List beenthere) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable self000 = ((PatternVariable)(self));

          if ((!quantifiedvars.memberP(self000)) &&
              (!collection.memberP(self000))) {
            collection.insertLast(self000);
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          if (!(beenthere.memberP(self000))) {
            { Keyword testValue001 = self000.kind;

              if ((testValue001 == Logic.KWD_FORALL) ||
                  (testValue001 == Logic.KWD_EXISTS)) {
                { PatternVariable v = null;
                  Vector vector000 = ((Vector)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_IO_VARIABLES, null)));
                  int index000 = 0;
                  int length000 = vector000.length();

                  for (;index000 < length000; index000 = index000 + 1) {
                    v = ((PatternVariable)((vector000.theArray)[index000]));
                    quantifiedvars.insert(v);
                  }
                }
              }
              else {
              }
            }
            beenthere.insert(self000);
            { Stella_Object arg = null;
              Vector vector001 = self000.arguments;
              int index001 = 0;
              int length001 = vector001.length();

              for (;index001 < length001; index001 = index001 + 1) {
                arg = (vector001.theArray)[index001];
                Logic.collectFreeVariables(arg, collection, quantifiedvars, beenthere);
              }
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description self000 = ((Description)(self));

          { PatternVariable v = null;
            Vector vector002 = self000.ioVariables;
            int index002 = 0;
            int length002 = vector002.length();

            for (;index002 < length002; index002 = index002 + 1) {
              v = ((PatternVariable)((vector002.theArray)[index002]));
              quantifiedvars.insert(v);
            }
          }
          { PatternVariable v = null;
            Cons iter000 = Description.topLevelExistentialVariables(self000);

            for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
              v = ((PatternVariable)(iter000.value));
              quantifiedvars.insert(v);
            }
          }
          Logic.collectFreeVariables(self000.proposition, collection, quantifiedvars, beenthere);
        }
      }
      else {
      }
    }
  }

  public static List mostSpecificTypes(List types) {
    if (types.rest() == null) {
      return (types);
    }
    { Cons cursor1 = types.theConsList;
      Cons cursor2 = null;
      Stella_Object value1 = null;
      Stella_Object value2 = null;

      while (!(cursor1 == Stella.NIL)) {
        value1 = ((Surrogate)(cursor1.value));
        if (((Surrogate)(cursor1.value)) != null) {
          cursor2 = cursor1.rest;
          loop001 : while (!(cursor2 == Stella.NIL)) {
            value2 = cursor2.value;
            if (value2 != null) {
              if (Logic.logicalSubtypeOfP(((Surrogate)(value1)), ((Surrogate)(value2)))) {
                cursor2.value = null;
              }
              else {
                if (Logic.logicalSubtypeOfP(((Surrogate)(value2)), ((Surrogate)(value1)))) {
                  cursor1.value = null;
                  break loop001;
                }
              }
            }
            cursor2 = cursor2.rest;
          }
        }
        cursor1 = cursor1.rest;
      }
    }
    types.remove(null);
    return (types);
  }

  public static Stella_Object inferPredicateFromOperatorAndTypes(Stella_Object operator, List types) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(operator);

      if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate operator000 = ((Surrogate)(operator));

          if (Stella_Object.isaP(operator000.surrogateValue, Logic.SGT_STELLA_SLOT)) {
            { Slot slot = ((Slot)(operator000.surrogateValue));

              slot = ((Slot)(Logic.inferPredicateFromOperatorAndTypes(slot.slotName, types)));
              if (slot != null) {
                return (slot);
              }
              else {
                return (operator000.surrogateValue);
              }
            }
          }
          else {
            return (operator000.surrogateValue);
          }
        }
      }
      else if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol operator000 = ((Symbol)(operator));

          { Surrogate slotref = null;

            { Surrogate type = null;
              Cons iter000 = types.theConsList;

              for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                type = ((Surrogate)(iter000.value));
                if (Stella_Object.isaP(type.surrogateValue, Logic.SGT_STELLA_CLASS)) {
                  slotref = Surrogate.lookupSlotref(type, operator000);
                  if (slotref != null) {
                    return (slotref.surrogateValue);
                  }
                  if (Logic.logicalSubtypeOfLiteralP(type)) {
                    type = type.typeToWrappedType();
                    slotref = Surrogate.lookupSlotref(type, operator000);
                    if (slotref != null) {
                      return (slotref.surrogateValue);
                    }
                  }
                }
              }
            }
          }
        }
      }
      else {
      }
    }
    return (null);
  }

  public static void resolveUnresolvedSlotReferences(Stella_Object formula) {
    { Proposition proposition = null;
      Cons unresolvedpropositions = null;
      KeyValueList variabletypestable = null;
      Cons unresolvablepropositions = Stella.NIL;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(formula);

        if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
          { Description formula000 = ((Description)(formula));

            proposition = formula000.proposition;
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
          { Proposition formula000 = ((Proposition)(formula));

            proposition = formula000;
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
      unresolvedpropositions = Proposition.collectUnresolvedSlotReferences(proposition);
      if (unresolvedpropositions == Stella.NIL) {
        return;
      }
      { Surrogate testValue001 = Stella_Object.safePrimaryType(formula);

        if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_DESCRIPTION)) {
          { Description formula000 = ((Description)(formula));

            variabletypestable = Description.inferVariableTypesInDescription(formula000);
          }
        }
        else if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_PROPOSITION)) {
          { Proposition formula000 = ((Proposition)(formula));

            variabletypestable = Proposition.inferVariableTypesInProposition(formula000, Stella.NIL);
          }
        }
        else {
          { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

            stream001.nativeStream.print("`" + testValue001 + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream001.theStringReader()).fillInStackTrace()));
          }
        }
      }
      { Proposition prop = null;
        Cons iter000 = unresolvedpropositions;
        Cons collect000 = null;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          prop = ((Proposition)(iter000.value));
          if (Stella_Object.symbolP(prop.operator) &&
              (!Proposition.resolveOneSlotReferenceP(prop, variabletypestable))) {
            if (collect000 == null) {
              {
                collect000 = Cons.cons(prop, Stella.NIL);
                if (unresolvablepropositions == Stella.NIL) {
                  unresolvablepropositions = collect000;
                }
                else {
                  Cons.addConsToEndOfConsList(unresolvablepropositions, collect000);
                }
              }
            }
            else {
              {
                collect000.rest = Cons.cons(prop, Stella.NIL);
                collect000 = collect000.rest;
              }
            }
          }
        }
      }
      if (!(unresolvablepropositions == Stella.NIL)) {
        { Proposition p = null;
          Cons iter001 = unresolvablepropositions;

          for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
            p = ((Proposition)(iter001.value));
            Proposition.complainAboutUndeclaredReference(p);
            Proposition.createDummyRelation(p);
          }
        }
      }
    }
  }

  /** Return a list of as yet undefined concepts and relations in the module defined
   * by the :module option (which defaults to the current module).  These relations were
   * defined by the system, since they were referenced but have not yet been defined by
   * the user.  If <code>ClocalP</code> is specified as TRUE only look in the specified module but
   * not any modules it inherits.  For backwards compatibility, this command also supports
   * the old &lt;module&gt; &lt;local?&gt; arguments specified without keywords.
   * @param options
   * @return Cons
   */
  public static Cons listUndefinedRelations(Cons options) {
    { Cons optionslist = options;
      PropertyList theoptions = Stella_Object.parseOptions((Stella_Object.keywordP(optionslist.value) ? optionslist : Cons.consList(Cons.cons(Logic.KWD_MODULE, Cons.cons(optionslist.value, Cons.cons(Logic.KWD_LOCALp, Cons.cons(optionslist.rest.value, Stella.NIL)))))), Cons.list$(Cons.cons(Logic.KWD_MODULE, Cons.cons(Logic.SGT_STELLA_MODULE, Cons.cons(Logic.KWD_LOCALp, Cons.cons(Logic.SGT_STELLA_BOOLEAN, Cons.cons(Stella.NIL, Stella.NIL)))))), true, false);
      Module themodule = ((Module)(theoptions.lookupWithDefault(Logic.KWD_MODULE, ((Module)(Stella.$MODULE$.get())))));
      boolean localP = BooleanWrapper.coerceWrappedBooleanToBoolean(((BooleanWrapper)(theoptions.lookupWithDefault(Logic.KWD_LOCALp, Stella.FALSE_WRAPPER))));

      return (Logic.callListUndefinedRelations(themodule, localP));
    }
  }

  public static Cons listUndefinedRelationsEvaluatorWrapper(Cons arguments) {
    return (Logic.listUndefinedRelations(arguments));
  }

  /** Callable version of <code>listUndefinedRelations</code> (which see).
   * @param module
   * @param localP
   * @return Cons
   */
  public static Cons callListUndefinedRelations(Module module, boolean localP) {
    { Cons undefined = Stella.NIL;

      Logic.finalizeObjects();
      { Stella_Object term = null;
        Iterator iter000 = Logic.allNamedTerms(module, localP);

        while (iter000.nextP()) {
          term = iter000.value;
          { Surrogate testValue000 = Stella_Object.safePrimaryType(term);

            if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
              { NamedDescription term000 = ((NamedDescription)(term));

                if (!NamedDescription.definedRelationP(term000)) {
                  undefined = Cons.cons(term000, undefined);
                }
              }
            }
            else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
              { LogicObject term000 = ((LogicObject)(term));

                { Object old$Module$000 = Stella.$MODULE$.get();
                  Object old$Context$000 = Stella.$CONTEXT$.get();

                  try {
                    Native.setSpecial(Stella.$MODULE$, ((module == null) ? term000.homeModule() : module));
                    Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
                    if (Logic.applyCachedAsk(Cons.cons(Logic.SYM_LOGIC_pX, Stella.NIL), Cons.list$(Cons.cons(Logic.SYM_PL_KERNEL_KB_RELATION, Cons.cons(Logic.SYM_LOGIC_pX, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.consList(Cons.cons(term000, Stella.NIL)), Cons.consList(Stella.NIL), Logic.SYM_LOGIC_F_CALL_LIST_UNDEFINED_RELATIONS_QUERY_000, new Object[1])) {
                      undefined = Cons.cons(term000, undefined);
                    }

                  } finally {
                    Stella.$CONTEXT$.set(old$Context$000);
                    Stella.$MODULE$.set(old$Module$000);
                  }
                }
              }
            }
            else {
            }
          }
        }
      }
      return (undefined);
    }
  }

  public static boolean allNamedDescriptionsNextP(AllPurposeIterator self) {
    { int cursor = self.iteratorInteger;
      Surrogate surrogate = null;
      Stella_Object surrogatevalue = null;
      NamedDescription description = null;

      while (cursor < self.iteratorSecondInteger) {
        surrogate = ((Surrogate)((Stella.$SURROGATE_ARRAY$.theArray)[cursor]));
        if (surrogate != null) {
          surrogatevalue = surrogate.surrogateValue;
          if (surrogatevalue != null) {
            if (!(AllPurposeIterator.selectedMetaObjectP(self, surrogatevalue.homeModule()))) {
              surrogatevalue = null;
            }
          }
        }
        description = null;
        if (surrogatevalue != null) {
          { Surrogate testValue000 = Stella_Object.safePrimaryType(surrogatevalue);

            if (Surrogate.subtypeOfClassP(testValue000)) {
              { Stella_Class surrogatevalue000 = ((Stella_Class)(surrogatevalue));

                if (((Stella_Class)(surrogatevalue000)).classType == surrogate) {
                  description = ((NamedDescription)(KeyValueList.dynamicSlotValue(surrogatevalue000.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null)));
                }
              }
            }
            else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_RELATION)) {
              { Relation surrogatevalue000 = ((Relation)(surrogatevalue));

                description = ((NamedDescription)(KeyValueList.dynamicSlotValue(surrogatevalue000.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null)));
              }
            }
            else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
              { NamedDescription surrogatevalue000 = ((NamedDescription)(surrogatevalue));

                description = surrogatevalue000;
              }
            }
            else {
            }
          }
        }
        if (description != null) {
          self.value = description;
          self.iteratorInteger = cursor + 1;
          return (true);
        }
        cursor = cursor + 1;
      }
      return (false);
    }
  }

  /** Iterate over all named descriptions visible from 'module'.
   * If 'local?', return only named descriptions interned in 'module'.
   * If 'module' is null, return all named descriptions interned everywhere.
   * @param module
   * @param localP
   * @return Iterator
   */
  public static Iterator allNamedDescriptions(Module module, boolean localP) {
    return (Stella.allocateAllMetaObjectsIterator(Stella.$SURROGATE_ARRAY$.topSymbolOffset + 1, Native.find_java_method("edu.isi.powerloom.logic.Logic", "allNamedDescriptionsNextP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.AllPurposeIterator")}), module, localP));
  }

  public static Proposition conjoinPropositions(Cons conjuncts) {
    { List flatconjuncts = List.newList();
      Proposition result = null;

      { Proposition c = null;
        Cons iter000 = conjuncts;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          c = ((Proposition)(iter000.value));
          Proposition.collectFlatConjuncts(c, flatconjuncts);
        }
      }
      flatconjuncts.reverse();
      switch (flatconjuncts.length()) {
        case 0: 
          { Proposition proposition = Logic.createProposition(Logic.SYM_LOGIC_CONSTANT, 0);

            Proposition.overlayWithConstantProposition(proposition, Logic.TRUE_PROPOSITION);
            return (proposition);
          }
        case 1: 
          return (((Proposition)(flatconjuncts.first())));
        default:
        break;
      }
      result = Logic.createProposition(Logic.SYM_STELLA_AND, flatconjuncts.length());
      result.arguments = Logic.copyListToArgumentsVector(flatconjuncts);
      if (((BooleanWrapper)(KeyValueList.dynamicSlotValue(((Proposition)(flatconjuncts.first())).dynamicSlots, Logic.SYM_LOGIC_DESCRIPTIVEp, Stella.FALSE_WRAPPER))).wrapperValue) {
        KeyValueList.setDynamicSlotValue(result.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTIVEp, Stella.TRUE_WRAPPER, Stella.FALSE_WRAPPER);
      }
      return (result);
    }
  }

  public static Proposition disjoinPropositions(Cons disjuncts) {
    if (disjuncts == Stella.NIL) {
      return (Logic.FALSE_PROPOSITION);
    }
    { List flatdisjuncts = List.newList();
      Proposition result = null;

      { Proposition c = null;
        Cons iter000 = disjuncts;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          c = ((Proposition)(iter000.value));
          Proposition.collectFlatDisjuncts(c, flatdisjuncts);
        }
      }
      flatdisjuncts.reverse();
      switch (flatdisjuncts.length()) {
        case 0: 
          { Proposition proposition = Logic.createProposition(Logic.SYM_LOGIC_CONSTANT, 0);

            Proposition.overlayWithConstantProposition(proposition, Logic.FALSE_PROPOSITION);
            return (proposition);
          }
        case 1: 
          return (((Proposition)(flatdisjuncts.first())));
        default:
        break;
      }
      result = Logic.createProposition(Logic.SYM_STELLA_OR, flatdisjuncts.length());
      result.arguments = Logic.copyListToArgumentsVector(flatdisjuncts);
      if (((BooleanWrapper)(KeyValueList.dynamicSlotValue(((Proposition)(flatdisjuncts.first())).dynamicSlots, Logic.SYM_LOGIC_DESCRIPTIVEp, Stella.FALSE_WRAPPER))).wrapperValue) {
        KeyValueList.setDynamicSlotValue(result.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTIVEp, Stella.TRUE_WRAPPER, Stella.FALSE_WRAPPER);
      }
      return (result);
    }
  }

  public static Surrogate evaluateRelationTerm(Stella_Object relationterm, Proposition proposition) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(relationterm);

      if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate relationterm000 = ((Surrogate)(relationterm));

          return (relationterm000);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable relationterm000 = ((PatternVariable)(relationterm));

          return (null);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
        { Skolem relationterm000 = ((Skolem)(relationterm));

          if (!Logic.functionOutputSkolemP(relationterm000)) {
            return (null);
          }
          { Vector arguments = relationterm000.definingProposition.arguments;
            Surrogate relationtermsurrogate = null;
            Stella_Object relationtermvalue = Logic.valueOf(relationterm000);

            { boolean foundP000 = false;

              { Stella_Object arg = null;
                Vector vector000 = arguments;
                int index000 = 0;
                int length000 = vector000.length();

                loop000 : for (;index000 < length000; index000 = index000 + 1) {
                  arg = (vector000.theArray)[index000];
                  if (Stella_Object.isaP(arg, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
                    foundP000 = true;
                    break loop000;
                  }
                }
              }
              if (foundP000) {
                return (null);
              }
            }
            if (!(relationtermvalue == relationterm000)) {
              return (Logic.evaluateRelationTerm(relationtermvalue, proposition));
            }
            relationtermsurrogate = Skolem.computeRelationTermSurrogate(relationterm000, proposition);
            Logic.transferPropositionsAndBacklinks(relationterm000, Logic.valueOf(relationtermsurrogate));
            (arguments.theArray)[(arguments.length() - 1)] = relationtermsurrogate;
            return (relationtermsurrogate);
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        { NamedDescription relationterm000 = ((NamedDescription)(relationterm));

          return (relationterm000.surrogateValueInverse);
        }
      }
      else {
        return (null);
      }
    }
  }

  public static Cons deconstructForallTree(Cons foralltree, Object [] MV_returnarray) {
    { Cons antecedent = ((Cons)(foralltree.rest.rest.value));
      Stella_Object ifclause = antecedent.rest.value;

      if (ifclause == Logic.SYM_STELLA_TRUE) {
        ifclause = Stella.getQuotedTree("((AND) \"/LOGIC\")", "/LOGIC");
      }
      { Cons _return_temp = ((Cons)(foralltree.rest.value));

        MV_returnarray[0] = ifclause;
        MV_returnarray[1] = ((Cons)(antecedent.rest.rest.value));
        return (_return_temp);
      }
    }
  }

  public static Cons callGetRules(Stella_Object relationref) {
    { LogicObject description = Logic.getDescription(relationref);
      Cons rules = Stella.NIL;

      if (description == null) {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("Can't find a relation named `" + relationref + "'");
          throw ((NoSuchObjectException)(NoSuchObjectException.newNoSuchObjectException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(description), Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        { NamedDescription description000 = ((NamedDescription)(description));

          rules = LogicObject.applicableRulesOfDescription(description000, Logic.KWD_FORWARD, false).concatenate(LogicObject.applicableRulesOfDescription(description000, Logic.KWD_BACKWARD, false), Cons.cons(Description.helpGetForwardChainingRules(description000), Stella.NIL));
          { Description complement = ((Description)(KeyValueList.dynamicSlotValue(description000.dynamicSlots, Logic.SYM_LOGIC_COMPLEMENT_DESCRIPTION, null)));

            if (complement != null) {
              rules = rules.concatenate(LogicObject.applicableRulesOfDescription(complement, Logic.KWD_FORWARD, false), Cons.cons(LogicObject.applicableRulesOfDescription(complement, Logic.KWD_BACKWARD, false), Cons.cons(Description.helpGetForwardChainingRules(complement), Stella.NIL)));
            }
          }
        }
      }
      else {
      }
      return (rules);
    }
  }

  /** Return the list of rules associated with <code>relation</code>.
   * @param relation
   * @return Cons
   */
  public static Cons getRules(Stella_Object relation) {
    Logic.processDefinitions();
    return (Logic.callGetRules(relation));
  }

  /** Delete the list of rules associated with <code>relation</code>.
   * This function is included mainly for debugging purposes, when
   * a user wants to verify the behavior of different sets of rules.
   * @param relation
   */
  public static void deleteRules(Stella_Object relation) {
    Logic.processDefinitions();
    { Proposition r = null;
      Cons iter000 = Logic.callGetRules(relation);

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        r = ((Proposition)(iter000.value));
        Proposition.destroyProposition(r);
      }
    }
  }

  /** Print the list of true rules associated with <code>relation</code>.
   * @param relation
   */
  public static void printRules(Stella_Object relation) {
    Logic.processDefinitions();
    { Object old$Context$000 = Stella.$CONTEXT$.get();
      Object old$Module$000 = Stella.$MODULE$.get();

      try {
        Native.setSpecial(Stella.$CONTEXT$, Logic.getQueryContext());
        Native.setSpecial(Stella.$MODULE$, ((Context)(Stella.$CONTEXT$.get())).baseModule);
        { Proposition rule = null;
          Cons iter000 = Logic.callGetRules(relation);

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            rule = ((Proposition)(iter000.value));
            if ((!rule.deletedP()) &&
                ((((Boolean)(Logic.$REVERSEPOLARITYp$.get())).booleanValue() ? Proposition.falseP(rule) : (Proposition.trueP(rule) ||
                Proposition.functionWithDefinedValueP(rule))))) {
              Logic.prettyPrintLogicalForm(rule, Stella.STANDARD_OUTPUT);
              {
                Stella.STANDARD_OUTPUT.nativeStream.println("");
                Stella.STANDARD_OUTPUT.nativeStream.println();
              }
;
            }
          }
        }

      } finally {
        Stella.$MODULE$.set(old$Module$000);
        Stella.$CONTEXT$.set(old$Context$000);
      }
    }
  }

  public static Proposition getRule(Stella_Object rulename) {
    { Stella_Object renamed_Object = Logic.getInstance(rulename);

      if ((renamed_Object == null) ||
          (!Stella_Object.isaP(renamed_Object, Logic.SGT_LOGIC_PROPOSITION))) {
        {
          Stella.STANDARD_OUTPUT.nativeStream.println("Can't find a rule named `" + rulename + "'");
          Stella.STANDARD_OUTPUT.nativeStream.println();
        }
;
        return (null);
      }
      return (((Proposition)(renamed_Object)));
    }
  }

  /** Search for a rule named 'ruleName'.  Like 'get-rule',
   * but 'find-rule' implicity quotes its input argument.
   * @param rulename
   * @return Proposition
   */
  public static Proposition findRule(Stella_Object rulename) {
    return (Logic.getRule(rulename));
  }

  /** Set the truth value of the rule named 'ruleName' to 
   * TRUE.  The proposition having the name 'ruleName' may be
   * any arbitrary proposition, although we expect that it is probably
   * a material implication.  (See <code>retractRule</code>).
   * @param rulename
   * @return Proposition
   */
  public static Proposition assertRule(Stella_Object rulename) {
    { Proposition proposition = Logic.getRule(rulename);

      if (proposition == null) {
        return (null);
      }
      Proposition.updatePropositionTruthValue(proposition, Logic.KWD_ASSERT_TRUE);
      return (proposition);
    }
  }

  /** If it is currently TRUE, set the truth value 
   * of the rule named 'ruleName' to UNKNOWN  This
   * command may be used alternately with <code>assertRule</code> to
   * observe the effects of querying with or without a particular (named) rule
   * being asserted within the current context. The proposition having the name
   * 'ruleName' may be any arbitrary proposition, although we expect that it is
   * probably a material implication.
   * @param rulename
   * @return Proposition
   */
  public static Proposition retractRule(Stella_Object rulename) {
    { Proposition proposition = Logic.getRule(rulename);

      if (proposition == null) {
        return (null);
      }
      Proposition.updatePropositionTruthValue(proposition, Logic.KWD_RETRACT_TRUE);
      return (proposition);
    }
  }

  public static void deleteRuleCachesOnRelation(Relation relation) {
    { Proposition rule = null;
      Cons iter000 = Logic.callGetRules(relation);

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        rule = ((Proposition)(iter000.value));
        { Stella_Object arg = null;
          Vector vector000 = rule.arguments;
          int index000 = 0;
          int length000 = vector000.length();

          for (;index000 < length000; index000 = index000 + 1) {
            arg = (vector000.theArray)[index000];
            if (((Description)(arg)).queryPatterns != null) {
              { KvListIterator it = ((KvListIterator)(((Description)(arg)).queryPatterns.allocateIterator()));

                while (it.nextP()) {
                  it.valueSetter(null);
                }
              }
            }
          }
        }
      }
    }
  }

  /** Zero out all caches managed by the query optimizer,
   * so that it will reoptimize subgoal queries upon next invocation.
   */
  public static void resetQueryCaches() {
    { Slot slot = null;
      Iterator iter000 = Module.allSlots(null, true);

      while (iter000.nextP()) {
        slot = ((Slot)(iter000.value));
        if (((NamedDescription)(KeyValueList.dynamicSlotValue(slot.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))) != null) {
          Logic.deleteRuleCachesOnRelation(slot);
        }
      }
    }
    { NamedDescription description = null;
      Iterator iter001 = Logic.allNamedDescriptions(null, true);

      while (iter001.nextP()) {
        description = ((NamedDescription)(iter001.value));
        if (description.queryPatterns != null) {
          { KvListIterator it = ((KvListIterator)(description.queryPatterns.allocateIterator()));

            while (it.nextP()) {
              it.valueSetter(null);
            }
          }
        }
      }
    }
  }

  /** Return the current inference level that is active in the
   * current query, the current module, or, otherwise, globally.
   * @return NormalInferenceLevel
   */
  public static NormalInferenceLevel currentInferenceLevel() {
    { InferenceLevel level = ((((QueryIterator)(Logic.$QUERYITERATOR$.get())) != null) ? ((QueryIterator)(Logic.$QUERYITERATOR$.get())).inferenceLevel : ((InferenceLevel)(KeyValueList.dynamicSlotValue(((Module)(Stella.$MODULE$.get())).dynamicSlots, Logic.SYM_LOGIC_INFERENCE_LEVEL, null))));

      if (level != null) {
        return (((NormalInferenceLevel)(level)));
      }
      else {
        return (((NormalInferenceLevel)(Logic.$INFERENCELEVEL$.get())));
      }
    }
  }

  public static InferenceLevel getInferenceLevel(Keyword levelkeyword) {
    if (levelkeyword == Logic.KWD_NORMAL) {
      return (Logic.NORMAL_INFERENCE);
    }
    else if (levelkeyword == Logic.KWD_SHALLOW) {
      return (Logic.SHALLOW_INFERENCE);
    }
    else if (levelkeyword == Logic.KWD_ASSERTION) {
      return (Logic.ASSERTION_INFERENCE);
    }
    else if (levelkeyword == Logic.KWD_SUBSUMPTION) {
      return (Logic.SUBSUMPTION_INFERENCE);
    }
    else if (levelkeyword == Logic.KWD_BACKTRACKING) {
      return (Logic.BACKTRACKING_INFERENCE);
    }
    else if (levelkeyword == Logic.KWD_REFUTATION) {
      return (Logic.REFUTATION_INFERENCE);
    }
    else {
      {
        Stella.STANDARD_WARNING.nativeStream.println("Warning: Illegal inference level: `" + levelkeyword + "'.");
        Stella.STANDARD_WARNING.nativeStream.println("   Legal values are :ASSERTION :SHALLOW :SUBSUMPTION :BACKTRACKING :NORMAL :REFUTATION.");
        Stella.STANDARD_WARNING.nativeStream.println();
      }
;
    }
    return (((NormalInferenceLevel)(Logic.$INFERENCELEVEL$.get())));
  }

  /** Set the inference level of <code>module</code> to the level specified
   * by 'levelKeyword'.  If <code>module</code> is NULL, set the level globally.
   * @param level
   * @param module
   * @return Keyword
   */
  public static Keyword setInferenceLevel(Stella_Object level, Stella_Object module) {
    { Module themodule = Stella_Object.coerceToModule(module, true);
      Keyword thelevel = Stella.string_keywordify(Stella_Object.coerceToString(level));

      if (module == null) {
        themodule = null;
      }
      return (Logic.callSetInferenceLevel(thelevel, themodule));
    }
  }

  /** Set the inference level of <code>module</code> to the level specified
   * by 'levelKeyword'.  If <code>module</code> is NULL and we are inside a query, set the
   * level of the current query iterator.  Otherwise, set the level globally.
   * @param levelkeyword
   * @param module
   * @return Keyword
   */
  public static Keyword callSetInferenceLevel(Keyword levelkeyword, Module module) {
    { InferenceLevel level = Logic.getInferenceLevel(levelkeyword);

      if (module != null) {
        KeyValueList.setDynamicSlotValue(module.dynamicSlots, Logic.SYM_LOGIC_INFERENCE_LEVEL, level, null);
      }
      else if (((QueryIterator)(Logic.$QUERYITERATOR$.get())) != null) {
        ((QueryIterator)(Logic.$QUERYITERATOR$.get())).inferenceLevel = level;
      }
      else {
        Native.setSpecial(Logic.$INFERENCELEVEL$, ((NormalInferenceLevel)(level)));
      }
      return (level.keyword);
    }
  }

  public static boolean usingDefaultKnowledgeP() {
    return (!((Boolean)(Logic.$DONTUSEDEFAULTKNOWLEDGEp$.get())).booleanValue());
  }

  public static void traceSubgoals() {
    Logic.setFeature(Cons.cons(Logic.KWD_TRACE_SUBGOALS, Stella.NIL));
  }

  public static void untraceSubgoals() {
    Logic.unsetFeature(Cons.cons(Logic.KWD_TRACE_SUBGOALS, Stella.NIL));
  }

  public static void traceRules() {
    Stella.addTrace(Cons.cons(Logic.KWD_PROPAGATE, Stella.NIL));
  }

  public static void untraceRules() {
    Stella.dropTrace(Cons.cons(Logic.KWD_PROPAGATE, Stella.NIL));
  }

  public static String toggleTraceSubgoals() {
    if (Logic.$CURRENT_POWERLOOM_FEATURES$.memberP(Logic.KWD_TRACE_SUBGOALS)) {
      {
        Logic.unsetFeature(Cons.cons(Logic.KWD_TRACE_SUBGOALS, Stella.NIL));
        Stella.dropTrace(Cons.cons(Logic.KWD_STRATEGIES, Stella.NIL));
        return ("Subgoal tracing disabled.");
      }
    }
    else {
      {
        Logic.setFeature(Cons.cons(Logic.KWD_TRACE_SUBGOALS, Stella.NIL));
        Stella.addTrace(Cons.cons(Logic.KWD_STRATEGIES, Stella.NIL));
        return ("Subgoal tracing enabled.");
      }
    }
  }

  public static String toggleTraceRules() {
    if ((Stella.$TRACED_KEYWORDS$ != null) &&
        Stella.$TRACED_KEYWORDS$.memberP(Logic.KWD_PROPAGATE)) {
      {
        Stella.dropTrace(Cons.cons(Logic.KWD_PROPAGATE, Stella.NIL));
        return ("Rule tracing disabled.");
      }
    }
    else {
      {
        Stella.addTrace(Cons.cons(Logic.KWD_PROPAGATE, Stella.NIL));
        return ("Rule tracing enabled.");
      }
    }
  }

  public static void emitThinkingDot(Keyword kindofthinking) {
    if (Logic.$EMIT_THINKING_DOTSp$) {
      { CharacterWrapper character = ((CharacterWrapper)(Logic.$THINKING_DOT_TABLE$.lookup(kindofthinking)));

        if (character != null) {
          Stella.STANDARD_OUTPUT.nativeStream.print(character.wrapperValue);
          Logic.$THINKING_DOT_COUNTER$ = Logic.$THINKING_DOT_COUNTER$ + 1;
          if (Logic.$THINKING_DOT_COUNTER$ >= 70) {
            Stella.STANDARD_OUTPUT.nativeStream.println();
            Logic.$THINKING_DOT_COUNTER$ = 0;
          }
        }
      }
    }
  }

  public static BooleanVector argumentsVectorToBooleanVector(Vector argumentsvector) {
    { BooleanVectorIndexNode node = Logic.$BOOLEAN_VECTOR_INDEX$;
      BooleanVectorIndexNode nextnode = null;
      boolean boundP = false;

      { Stella_Object arg = null;
        Vector vector000 = argumentsvector;
        int index000 = 0;
        int length000 = vector000.length();

        for (;index000 < length000; index000 = index000 + 1) {
          arg = (vector000.theArray)[index000];
          boundP = true;
          if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(arg), Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
            { PatternVariable arg000 = ((PatternVariable)(arg));

              boundP = (((QueryIterator)(Logic.$QUERYITERATOR$.get())).currentPatternRecord.variableBindings.theArray)[(arg000.boundToOffset)] != null;
            }
          }
          else {
          }
          if (boundP) {
            {
              nextnode = node.trueLink;
              if (nextnode == null) {
                nextnode = BooleanVectorIndexNode.createBooleanVectorIndexNode(node, true);
              }
            }
          }
          else {
            {
              nextnode = node.falseLink;
              if (nextnode == null) {
                nextnode = BooleanVectorIndexNode.createBooleanVectorIndexNode(node, false);
              }
            }
          }
          node = nextnode;
        }
      }
      return (node.theVector);
    }
  }

  public static BooleanVector zeroOneListToBooleanVector(List zeroonelist) {
    { BooleanVectorIndexNode node = Logic.$BOOLEAN_VECTOR_INDEX$;
      BooleanVectorIndexNode nextnode = null;

      { IntegerWrapper bit = null;
        Cons iter000 = zeroonelist.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          bit = ((IntegerWrapper)(iter000.value));
          if (Stella_Object.eqlP(bit, Stella.ONE_WRAPPER)) {
            {
              nextnode = node.trueLink;
              if (nextnode == null) {
                nextnode = BooleanVectorIndexNode.createBooleanVectorIndexNode(node, true);
              }
            }
          }
          else {
            {
              nextnode = node.falseLink;
              if (nextnode == null) {
                nextnode = BooleanVectorIndexNode.createBooleanVectorIndexNode(node, false);
              }
            }
          }
          node = nextnode;
        }
      }
      return (node.theVector);
    }
  }

  public static void printEnvironmentStacks() {
    { ControlFrame frame = ((QueryIterator)(Logic.$QUERYITERATOR$.get())).currentControlFrame;
      PatternRecord currentpatternrecord = ((QueryIterator)(Logic.$QUERYITERATOR$.get())).currentPatternRecord;

      Stella.STANDARD_OUTPUT.nativeStream.println("-------------------------");
      Stella.STANDARD_OUTPUT.nativeStream.println("current-control-frame " + frame);
      Stella.STANDARD_OUTPUT.nativeStream.print("    ");
      { Stella_Object arg = null;
        Vector vector000 = currentpatternrecord.variableBindings;
        int index000 = 0;
        int length000 = vector000.length();

        for (;index000 < length000; index000 = index000 + 1) {
          arg = (vector000.theArray)[index000];
          if (arg != null) {
            Stella.STANDARD_OUTPUT.nativeStream.print(arg + " ");
          }
          else {
            Stella.STANDARD_OUTPUT.nativeStream.print("_ ");
          }
        }
      }
      Stella.STANDARD_OUTPUT.nativeStream.println();
      Stella.STANDARD_OUTPUT.nativeStream.println("    " + currentpatternrecord.unbindingStack);
      Stella.STANDARD_OUTPUT.nativeStream.println("-------------------------");
    }
  }

  public static Stella_Object argumentBoundTo(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable self000 = ((PatternVariable)(self));

          { Stella_Object value = (((QueryIterator)(Logic.$QUERYITERATOR$.get())).currentPatternRecord.variableBindings.theArray)[(self000.boundToOffset)];

            if ((value == null) &&
                (((Stella_Object)(Stella_Object.accessInContext(self000.variableValue, self000.homeContext, false))) != null)) {
              value = Logic.valueOf(self000);
              if (Logic.skolemP(value)) {
                return (null);
              }
              PatternVariable.bindVariableToValueP(self000, value, true);
            }
            return (value);
          }
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate self000 = ((Surrogate)(self));

          return (Logic.valueOf(self000));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description self000 = ((Description)(self));

          if ((((Vector)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_EXTERNAL_VARIABLES, null))) != null) &&
              Proposition.containsOperatorP(self000.proposition, Logic.SGT_PL_KERNEL_KB_HOLDS)) {
            { Description temp000 = Description.findDuplicateDescription(self000);

              { Description value000 = ((temp000 != null) ? temp000 : self000);

                return (value000);
              }
            }
          }
          return (Logic.valueOf(self000));
        }
      }
      else {
        return (Logic.valueOf(self));
      }
    }
  }

  public static Stella_Object safeArgumentBoundTo(Stella_Object self) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(self), Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
      { PatternVariable self000 = ((PatternVariable)(self));

        { Stella_Object value = null;

          if ((((QueryIterator)(Logic.$QUERYITERATOR$.get())) != null) &&
              (self000.boundToOffset != Stella.NULL_INTEGER)) {
            value = (((QueryIterator)(Logic.$QUERYITERATOR$.get())).currentPatternRecord.variableBindings.theArray)[(self000.boundToOffset)];
          }
          if ((value == null) &&
              (((Stella_Object)(Stella_Object.accessInContext(self000.variableValue, self000.homeContext, false))) != null)) {
            value = Logic.valueOf(self000);
            if (Logic.skolemP(value)) {
              value = null;
            }
          }
          return (value);
        }
      }
    }
    else {
      return (Logic.argumentBoundTo(self));
    }
  }

  public static boolean helpUnifyAttributesP(Stella_Object value1, Stella_Object value2) {
    return (Stella_Object.eqlP(value1, value2) ||
        (Logic.skolemP(value1) &&
         PatternVariable.helpBindVariableToValueP(((PatternVariable)(value1)), value2)));
  }

  public static boolean bindArgumentToValueP(Stella_Object argument, Stella_Object value, boolean autocleanupP) {
    if (value == null) {
      if (((((QueryIterator)(Logic.$QUERYITERATOR$.get())) != null) &&
          (((QueryIterator)(Logic.$QUERYITERATOR$.get())).partialMatchStrategy != null)) &&
          ((QueryIterator)(Logic.$QUERYITERATOR$.get())).partialMatchStrategy.allowUnboundVariablesP()) {
        return (true);
      }
      { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

        try {
          Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
          Stella.STANDARD_WARNING.nativeStream.println("WARNING: Tried to bind " + argument + " to NULL value.  Potentially a PowerLoom bug");
          Logic.helpSignalPropositionError(Stella.STANDARD_WARNING, Logic.KWD_WARNING);

        } finally {
          Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
        }
      }
      return (false);
    }
    value = Logic.instantiateExternalBindings(value);
    { Surrogate testValue000 = Stella_Object.safePrimaryType(argument);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable argument000 = ((PatternVariable)(argument));

          return (PatternVariable.bindVariableToValueP(argument000, value, autocleanupP));
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate argument000 = ((Surrogate)(argument));

          return (Stella_Object.eqlP(Logic.valueOf(argument000), value));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition argument000 = ((Proposition)(argument));

          if (Stella_Object.isaP(value, Logic.SGT_LOGIC_PROPOSITION)) {
            { KeyValueMap mapping = KeyValueMap.newKeyValueMap();

              { boolean testValue001 = false;

                testValue001 = Proposition.unifyPropositionsP(argument000, ((Proposition)(value)), mapping);
                if (testValue001) {
                  { boolean alwaysP000 = true;

                    { Stella_Object var = null;
                      Stella_Object val = null;
                      DictionaryIterator iter000 = ((DictionaryIterator)(mapping.allocateIterator()));

                      loop000 : while (iter000.nextP()) {
                        var = iter000.key;
                        val = iter000.value;
                        if (!PatternVariable.bindVariableToValueP(((PatternVariable)(var)), val, autocleanupP)) {
                          alwaysP000 = false;
                          break loop000;
                        }
                      }
                    }
                    testValue001 = alwaysP000;
                  }
                }
                if (testValue001) {
                  return (true);
                }
              }
            }
          }
          return (false);
        }
      }
      else {
        return (Stella_Object.eqlP(argument, value));
      }
    }
  }

  public static boolean bindVectorOfArgumentsToValuesP(Vector arguments, Cons values) {
    { PatternRecord patternrecord = ((QueryIterator)(Logic.$QUERYITERATOR$.get())).currentPatternRecord;
      int ubstackoffset = patternrecord.topUnbindingStackOffset;
      boolean successP = false;

      { boolean alwaysP000 = true;

        { Stella_Object arg = null;
          Vector vector000 = arguments;
          int index000 = 0;
          int length000 = vector000.length();
          Stella_Object v = null;
          Cons iter000 = values;

          loop000 : for (;(index000 < length000) &&
                    (!(iter000 == Stella.NIL)); index000 = index000 + 1, iter000 = iter000.rest) {
            arg = (vector000.theArray)[index000];
            v = iter000.value;
            if (!Logic.bindArgumentToValueP(arg, v, false)) {
              alwaysP000 = false;
              break loop000;
            }
          }
        }
        successP = alwaysP000;
      }
      if (!successP) {
        PatternRecord.unbindVariablesBeginningAt(patternrecord, ubstackoffset + 1);
      }
      return (successP);
    }
  }

  public static void pcs() {
    ControlFrame.printControlFrameStack(((QueryIterator)(Logic.$QUERYITERATOR$.get())).baseControlFrame);
  }

  public static void printVerticalBars(int depth) {
    { IntegerIntervalIterator i = Stella.interval(1, depth);

      while (i.nextP()) {
        Stella.STANDARD_OUTPUT.nativeStream.print("| ");
      }
    }
  }

  public static void traceGoal(Stella_Object name) {
    { NamedDescription description = Logic.getDescription(name);

      if (description == null) {
        Stella.STANDARD_WARNING.nativeStream.println("Warning: No such relation: `" + name + "'");
        return;
      }
      Logic.$TRACED_GOALS$.insert(description);
      Stella.addTrace(Cons.cons(Logic.KWD_GOAL_TREE, Stella.NIL));
    }
  }

  public static void untraceGoal(Stella_Object name) {
    { NamedDescription description = Logic.getDescription(name);

      if (description == null) {
        Stella.STANDARD_WARNING.nativeStream.println("Warning: No such relation: `" + name + "'");
        return;
      }
      Logic.$TRACED_GOALS$.remove(description);
      { boolean foundP000 = false;

        { NamedDescription goal = null;
          DictionaryIterator iter000 = ((DictionaryIterator)(Logic.$TRACED_GOALS$.allocateIterator()));

          loop000 : while (iter000.nextP()) {
            goal = ((NamedDescription)(iter000.value));
            if (!goal.deletedP()) {
              foundP000 = true;
              break loop000;
            }
          }
        }
        if (!(foundP000)) {
          Stella.dropTrace(Cons.cons(Logic.KWD_GOAL_TREE, Stella.NIL));
        }
      }
    }
  }

  public static void clearTracedGoals() {
    Stella.dropTrace(Cons.cons(Logic.KWD_GOAL_TREE, Stella.NIL));
    Logic.$TRACED_GOALS$.clear();
  }

  public static boolean restrictedGoalTracingP() {
    { boolean testValue000 = false;

      testValue000 = Stella_Object.traceKeywordP(Logic.KWD_GOAL_TREE);
      if (testValue000) {
        { boolean foundP000 = false;

          { NamedDescription goal = null;
            DictionaryIterator iter000 = ((DictionaryIterator)(Logic.$TRACED_GOALS$.allocateIterator()));

            loop000 : while (iter000.nextP()) {
              goal = ((NamedDescription)(iter000.value));
              if (!goal.deletedP()) {
                foundP000 = true;
                break loop000;
              }
            }
          }
          testValue000 = foundP000;
        }
      }
      { boolean value000 = testValue000;

        return (value000);
      }
    }
  }

  public static boolean partialMatchModeP() {
    return ((((QueryIterator)(Logic.$QUERYITERATOR$.get())) != null) &&
        (((QueryIterator)(Logic.$QUERYITERATOR$.get())).partialMatchStrategy != null));
  }

  public static Vector copyPatternArguments(Vector arguments, Description description) {
    if (arguments == null) {
      return (null);
    }
    { int argumentcount = description.arity();
      Vector copiedarguments = null;

      if (argumentcount == -1) {
        argumentcount = arguments.length();
      }
      copiedarguments = Vector.newVector(argumentcount);
      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = argumentcount - 1;

        for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
          i = iter000;
          (copiedarguments.theArray)[i] = ((arguments.theArray)[i]);
        }
      }
      return (copiedarguments);
    }
  }

  public static Cons computeExternalBindings(Vector externalarguments) {
    { Cons externalbindings = Stella.NIL;

      if (externalarguments == null) {
        return (Stella.NIL);
      }
      { Stella_Object arg = null;
        Vector vector000 = externalarguments;
        int index000 = 0;
        int length000 = vector000.length();
        Cons collect000 = null;

        for (;index000 < length000; index000 = index000 + 1) {
          arg = (vector000.theArray)[index000];
          if (collect000 == null) {
            {
              collect000 = Cons.cons(Logic.instantiateExternalBindings(Logic.safeArgumentBoundTo(arg)), Stella.NIL);
              if (externalbindings == Stella.NIL) {
                externalbindings = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(externalbindings, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(Logic.instantiateExternalBindings(Logic.safeArgumentBoundTo(arg)), Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      return (externalbindings);
    }
  }

  public static Stella_Object instantiateExternalBindings(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        { NamedDescription self000 = ((NamedDescription)(self));

        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description self000 = ((Description)(self));

          if (((Vector)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_EXTERNAL_VARIABLES, null))) != null) {
            { KeyValueMap mapping = KeyValueMap.newKeyValueMap();

              { PatternVariable var = null;
                Vector vector000 = ((Vector)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_EXTERNAL_VARIABLES, null)));
                int index000 = 0;
                int length000 = vector000.length();

                for (;index000 < length000; index000 = index000 + 1) {
                  var = ((PatternVariable)((vector000.theArray)[index000]));
                  if (Logic.argumentBoundP(var)) {
                    mapping.insertAt(var, Logic.safeArgumentBoundTo(var));
                  }
                }
              }
              if (!(mapping.emptyP())) {
                return (Description.instantiateExternalVariables(self000, mapping));
              }
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

        }
      }
      else {
      }
    }
    return (self);
  }

  public static boolean memberOfCollectionP(Stella_Object member, Stella_Object collection) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(collection);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        { NamedDescription collection000 = ((NamedDescription)(collection));

          return (Logic.allTrueDependentPropositions(member, collection000.surrogateValueInverse, true).nextP());
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_COLLECTION)) {
        { Collection collection000 = ((Collection)(collection));

          { boolean foundP000 = false;

            { Stella_Object m = null;
              Iterator iter000 = ((Iterator)(collection000.allocateIterator()));

              loop000 : while (iter000.nextP()) {
                m = iter000.value;
                if (Stella_Object.eqlP(Logic.valueOf(m), member)) {
                  foundP000 = true;
                  break loop000;
                }
              }
            }
            { boolean memberP = foundP000;

              if (((Boolean)(Logic.$REVERSEPOLARITYp$.get())).booleanValue()) {
                return (!memberP);
              }
              else {
                return (memberP);
              }
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
        { Skolem collection000 = ((Skolem)(collection));

          { boolean successP = false;
            Cons enumeratedcollections = Logic.allDefiningPropositions(collection000, Logic.SGT_PL_KERNEL_KB_COLLECTIONOF, true);

            if (!(enumeratedcollections == Stella.NIL)) {
              { Proposition col = null;
                Cons iter001 = enumeratedcollections;

                for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                  col = ((Proposition)(iter001.value));
                  { Stella_Object arg = null;
                    Vector vector000 = col.arguments;
                    int index000 = 0;
                    int length000 = vector000.length();
                    int i = Stella.NULL_INTEGER;
                    int iter002 = 2;
                    int upperBound000 = col.arguments.length();

                    loop002 : for (;(index000 < length000) &&
                              (iter002 <= upperBound000); index000 = index000 + 1, iter002 = iter002 + 1) {
                      arg = (vector000.theArray)[index000];
                      i = iter002;
                      if (Stella_Object.eqlP(Logic.valueOf(arg), member)) {
                        i = i;
                        successP = true;
                        break loop002;
                      }
                    }
                  }
                }
              }
              if (((Boolean)(Logic.$REVERSEPOLARITYp$.get())).booleanValue()) {
                return (!successP);
              }
              else {
                return (successP);
              }
            }
            else {
              { Proposition p = null;
                Iterator iter003 = Logic.allTrueDependentPropositions(member, Logic.SGT_PL_KERNEL_KB_MEMBER_OF, false);

                while (iter003.nextP()) {
                  p = ((Proposition)(iter003.value));
                  { LogicObject subcollection = ((LogicObject)(Logic.valueOf((p.arguments.theArray)[1])));

                    if ((((Boolean)(Logic.$REVERSEPOLARITYp$.get())).booleanValue() ? LogicObject.collectionImpliesCollectionP(collection000, subcollection) : LogicObject.collectionImpliesCollectionP(subcollection, collection000))) {
                      return (true);
                    }
                  }
                }
              }
              return (false);
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject collection000 = ((LogicObject)(collection));

          { Skolem equivalentskolem = ((Skolem)(((LogicObject)(collection000.variableValueInverse().value))));

            if (equivalentskolem != null) {
              return (Logic.memberOfCollectionP(member, equivalentskolem));
            }
          }
        }
      }
      else {
      }
    }
    {
      Stella.STANDARD_WARNING.nativeStream.println("Warning: member-of-collection?: Illegal collection type: `" + Surrogate.wrappedTypeToType(collection.primaryType()).symbolName + "'");
      Stella.STANDARD_WARNING.nativeStream.println("   member=`" + member + "' collection=`" + collection + "'");
      Stella.STANDARD_WARNING.nativeStream.println();
    }
;
    return (false);
  }

  public static List assertedCollectionMembers(Stella_Object self, boolean directP) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_COLLECTION)) {
        { Collection self000 = ((Collection)(self));

          { List members = List.newList();

            { Stella_Object m = null;
              Iterator iter000 = ((Iterator)(self000.allocateIterator()));
              Cons collect000 = null;

              while (iter000.nextP()) {
                m = iter000.value;
                if (collect000 == null) {
                  {
                    collect000 = Cons.cons(m, Stella.NIL);
                    if (members.theConsList == Stella.NIL) {
                      members.theConsList = collect000;
                    }
                    else {
                      Cons.addConsToEndOfConsList(members.theConsList, collect000);
                    }
                  }
                }
                else {
                  {
                    collect000.rest = Cons.cons(m, Stella.NIL);
                    collect000 = collect000.rest;
                  }
                }
              }
            }
            return (members);
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        { NamedDescription self000 = ((NamedDescription)(self));

          { List members = List.list(Stella.NIL);

            { Proposition prop = null;
              DescriptionExtensionIterator iter001 = NamedDescription.allTrueExtensionMembers(self000, !directP);
              Cons collect001 = null;

              while (iter001.nextP()) {
                prop = ((Proposition)(iter001.value));
                if (collect001 == null) {
                  {
                    collect001 = Cons.cons((prop.arguments.theArray)[0], Stella.NIL);
                    if (members.theConsList == Stella.NIL) {
                      members.theConsList = collect001;
                    }
                    else {
                      Cons.addConsToEndOfConsList(members.theConsList, collect001);
                    }
                  }
                }
                else {
                  {
                    collect001.rest = Cons.cons((prop.arguments.theArray)[0], Stella.NIL);
                    collect001 = collect001.rest;
                  }
                }
              }
            }
            return (members);
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description self000 = ((Description)(self));

          return (null);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
        { Skolem self000 = ((Skolem)(self));

          { List members = List.newList();
            Cons enumeratedcollections = Logic.allDefiningPropositions(self000, Logic.SGT_PL_KERNEL_KB_COLLECTIONOF, true);

            if (!(enumeratedcollections == Stella.NIL)) {
              { Proposition col = null;
                Cons iter002 = enumeratedcollections;

                for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
                  col = ((Proposition)(iter002.value));
                  { Stella_Object arg = null;
                    Vector vector000 = col.arguments;
                    int index000 = 0;
                    int length000 = vector000.length();
                    int i = Stella.NULL_INTEGER;
                    int iter003 = 2;
                    int upperBound000 = col.arguments.length();
                    Cons collect002 = null;

                    for (;(index000 < length000) &&
                              (iter003 <= upperBound000); index000 = index000 + 1, iter003 = iter003 + 1) {
                      arg = (vector000.theArray)[index000];
                      i = iter003;
                      if (collect002 == null) {
                        {
                          collect002 = Cons.cons(Logic.valueOf(arg), Stella.NIL);
                          if (members.theConsList == Stella.NIL) {
                            members.theConsList = collect002;
                          }
                          else {
                            Cons.addConsToEndOfConsList(members.theConsList, collect002);
                          }
                        }
                      }
                      else {
                        {
                          collect002.rest = Cons.cons(Logic.valueOf(arg), Stella.NIL);
                          collect002 = collect002.rest;
                        }
                      }
                    }
                  }
                }
              }
            }
            else {
              { Proposition p = null;
                Iterator iter004 = Logic.allTrueDependentPropositions(self000, Logic.SGT_PL_KERNEL_KB_MEMBER_OF, false);
                Cons collect003 = null;

                while (iter004.nextP()) {
                  p = ((Proposition)(iter004.value));
                  if ((directP &&
                      Stella_Object.eqlP(Logic.valueOf((p.arguments.theArray)[1]), Logic.valueOf(self000))) ||
                      ((!directP) &&
                       LogicObject.collectionImpliesCollectionP(((LogicObject)(Logic.valueOf((p.arguments.theArray)[1]))), ((LogicObject)(Logic.valueOf(self000)))))) {
                    if (collect003 == null) {
                      {
                        collect003 = Cons.cons((p.arguments.theArray)[0], Stella.NIL);
                        if (members.theConsList == Stella.NIL) {
                          members.theConsList = collect003;
                        }
                        else {
                          Cons.addConsToEndOfConsList(members.theConsList, collect003);
                        }
                      }
                    }
                    else {
                      {
                        collect003.rest = Cons.cons((p.arguments.theArray)[0], Stella.NIL);
                        collect003 = collect003.rest;
                      }
                    }
                  }
                }
              }
            }
            return (members);
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          { Skolem equivalentskolem = ((Skolem)(((LogicObject)(self000.variableValueInverse().value))));

            if (equivalentskolem != null) {
              return (Logic.assertedCollectionMembers(equivalentskolem, directP));
            }
          }
          {
            Stella.STANDARD_WARNING.nativeStream.println("Warning: Hmm. PowerLoom doesn't know how to interpret the LOGIC-OBJECT: `" + self000 + "'");
            Stella.STANDARD_WARNING.nativeStream.println("   as a collection.");
            Stella.STANDARD_WARNING.nativeStream.println();
          }
;
          return (Stella.NIL_LIST);
        }
      }
      else {
        return (null);
      }
    }
  }

  public static void pgs() {
    ControlFrame.printGoalStack(((QueryIterator)(Logic.$QUERYITERATOR$.get())).baseControlFrame, false);
  }

  public static void vpgs() {
    ControlFrame.printGoalStack(((QueryIterator)(Logic.$QUERYITERATOR$.get())).baseControlFrame, true);
  }

  public static QueryIterator allocateQueryIterator() {
    { QueryIterator queryiterator = QueryIterator.newQueryIterator();

      Logic.updateNowTimestamp(Logic.KWD_EXECUTE_QUERY);
      queryiterator.timestamp = Logic.getNowTimestamp();
      return (queryiterator);
    }
  }

  public static Cons standardizeQueryTree(Stella_Object iovariables, Stella_Object querybody, Cons externalvariables) {
    if (iovariables == null) {
      iovariables = Stella.NIL;
    }
    else if (!Stella_Object.consP(iovariables)) {
      iovariables = Cons.consList(Cons.cons(iovariables, Stella.NIL));
    }
    { Cons standardizedtree = null;
      Cons allvariables = ((Cons)(iovariables));

      { Stella_Object v = null;
        Cons iter000 = externalvariables.reverse();

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          v = iter000.value;
          allvariables = Cons.cons(v, allvariables);
        }
      }
      if (querybody == null) {
        querybody = Logic.SYM_STELLA_TRUE;
      }
      if (allvariables == Stella.NIL) {
        standardizedtree = Cons.list$(Cons.cons(Logic.SYM_LOGIC_KAPPA, Cons.cons(Stella.NIL, Cons.cons(querybody, Cons.cons(Stella.NIL, Stella.NIL)))));
      }
      else {
        standardizedtree = Cons.list$(Cons.cons(Logic.SYM_STELLA_EXISTS, Cons.cons(allvariables, Cons.cons(Cons.cons(querybody, Stella.NIL), Stella.NIL))));
      }
      standardizedtree = ((Cons)(Logic.standardizeLogicalParseTree(standardizedtree)));
      standardizedtree.firstSetter(Logic.SYM_LOGIC_KAPPA);
      return (standardizedtree);
    }
  }

  public static QueryIterator makeQuery(Stella_Object iovariables, Stella_Object querytree, Cons externalbindings, Stella_Object options) {
    Logic.finalizeObjects();
    Logic.processCheckTypesAgenda();
    { Cons prefixquerytree = Logic.standardizeQueryTree(iovariables, querytree, Stella.NIL);
      Vector externalvector = ((!(externalbindings == Stella.NIL)) ? Logic.copyListToArgumentsVector(externalbindings.listify()) : ((Vector)(null)));
      Description description = null;
      QueryIterator query = Logic.allocateQueryIterator();

      if ((!Stella_Object.consP(iovariables)) ||
          Stella_Object.surrogateP(((Cons)(iovariables)).rest.value)) {
        KeyValueList.setDynamicSlotValue(query.dynamicSlots, Logic.SYM_LOGIC_ATOMIC_SINGLETONSp, Stella.TRUE_WRAPPER, Stella.FALSE_WRAPPER);
      }
      { Object old$Evaluationmode$000 = Logic.$EVALUATIONMODE$.get();
        Object old$Logicvariabletable$000 = Logic.$LOGICVARIABLETABLE$.get();
        Object old$Termunderconstruction$000 = Logic.$TERMUNDERCONSTRUCTION$.get();
        Object old$Queryiterator$000 = Logic.$QUERYITERATOR$.get();

        try {
          Native.setSpecial(Logic.$EVALUATIONMODE$, Logic.KWD_DESCRIPTION);
          Native.setSpecial(Logic.$LOGICVARIABLETABLE$, Stella.NIL);
          Native.setSpecial(Logic.$TERMUNDERCONSTRUCTION$, prefixquerytree);
          Native.setSpecial(Logic.$QUERYITERATOR$, null);
          { Object old$Module$000 = Stella.$MODULE$.get();
            Object old$Context$000 = Stella.$CONTEXT$.get();

            try {
              Native.setSpecial(Stella.$MODULE$, ((Module)(Stella.$MODULE$.get())));
              Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
              description = Logic.evaluateDescriptionTerm(prefixquerytree, false);

            } finally {
              Stella.$CONTEXT$.set(old$Context$000);
              Stella.$MODULE$.set(old$Module$000);
            }
          }

        } finally {
          Logic.$QUERYITERATOR$.set(old$Queryiterator$000);
          Logic.$TERMUNDERCONSTRUCTION$.set(old$Termunderconstruction$000);
          Logic.$LOGICVARIABLETABLE$.set(old$Logicvariabletable$000);
          Logic.$EVALUATIONMODE$.set(old$Evaluationmode$000);
        }
      }
      Logic.processCheckTypesAgenda();
      if (options != null) {
        QueryIterator.processQueryOptions(query, options);
      }
      return (QueryIterator.initializeQueryIterator(query, description, externalvector));
    }
  }

  public static Stella_Object parseQueryAndOptions(Cons queryAoptions, Object [] MV_returnarray) {
    if ((queryAoptions == null) ||
        (queryAoptions == Stella.NIL)) {
      { Stella_Object _return_temp = null;

        MV_returnarray[0] = null;
        MV_returnarray[1] = PropertyList.newPropertyList();
        return (_return_temp);
      }
    }
    { Stella_Object firstarg = queryAoptions.value;
      Stella_Object variables = null;
      Stella_Object proposition = null;
      PropertyList options = PropertyList.newPropertyList();
      boolean handlenonmatchingvariablesP = false;
      List freevariables = null;
      Cons declaredvariables = null;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(firstarg);

        if (Surrogate.subtypeOfIntegerP(testValue000)) {
          { IntegerWrapper firstarg000 = ((IntegerWrapper)(firstarg));

            options.insertAt(Logic.KWD_HOW_MANY, firstarg000);
            queryAoptions = queryAoptions.rest;
          }
        }
        else if (Surrogate.subtypeOfSymbolP(testValue000)) {
          { Symbol firstarg000 = ((Symbol)(firstarg));

            if (Stella.stringEqualP(firstarg000.symbolName, "ALL")) {
              options.insertAt(Logic.KWD_HOW_MANY, IntegerWrapper.wrapInteger(Stella.NULL_INTEGER));
              queryAoptions = queryAoptions.rest;
            }
            else if (Stella.stringEqualP(firstarg000.symbolName, "BEST")) {
              options.insertAt(Logic.KWD_HOW_MANY, IntegerWrapper.wrapInteger(Stella.NULL_INTEGER));
              options.insertAt(Logic.KWD_SORT_BY, Logic.KWD_SCORE);
              queryAoptions = queryAoptions.rest;
            }
          }
        }
        else if (Surrogate.subtypeOfKeywordP(testValue000)) {
          { Keyword firstarg000 = ((Keyword)(firstarg));

            if (Stella.stringEqualP(firstarg000.symbolName, "ALL")) {
              options.insertAt(Logic.KWD_HOW_MANY, IntegerWrapper.wrapInteger(Stella.NULL_INTEGER));
              queryAoptions = queryAoptions.rest;
            }
            else if (Stella.stringEqualP(firstarg000.symbolName, "BEST")) {
              options.insertAt(Logic.KWD_HOW_MANY, IntegerWrapper.wrapInteger(Stella.NULL_INTEGER));
              options.insertAt(Logic.KWD_SORT_BY, Logic.KWD_SCORE);
              queryAoptions = queryAoptions.rest;
            }
          }
        }
        else {
        }
      }
      if (!Stella_Object.keywordP(queryAoptions.value)) {
        variables = queryAoptions.value;
        queryAoptions = queryAoptions.rest;
      }
      if (!Stella_Object.keywordP(queryAoptions.value)) {
        proposition = queryAoptions.value;
        queryAoptions = queryAoptions.rest;
      }
      if ((variables != null) &&
          ((proposition == null) &&
           (!Logic.kifVariableDeclarationP(variables)))) {
        proposition = variables;
        variables = null;
      }
      if (Stella_Object.consP(proposition)) {
        freevariables = List.newList();
        if (variables == null) {
          declaredvariables = Stella.NIL;
        }
        else if (!Stella_Object.consP(variables)) {
          declaredvariables = Cons.cons(variables, Stella.NIL);
        }
        else {
          declaredvariables = ((Cons)(variables));
        }
        declaredvariables = Logic.extractVariablesFromDeclarations(declaredvariables);
        Logic.collectUndeclaredVariables(proposition, Stella.NIL, freevariables);
        if ((declaredvariables == Stella.NIL) &&
            freevariables.nonEmptyP()) {
          if (freevariables.length() == 1) {
            variables = ((Symbol)(freevariables.first()));
          }
          else {
            variables = freevariables.theConsList;
          }
        }
        else if ((declaredvariables == Stella.NIL) &&
            freevariables.emptyP()) {
        }
        else if (!freevariables.theConsList.equivalentSetsP(declaredvariables)) {
          handlenonmatchingvariablesP = true;
        }
      }
      while (!(queryAoptions == Stella.NIL)) {
        if (!Stella_Object.keywordP(queryAoptions.value)) {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

              try {
                Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                stream000.nativeStream.println("PARSING ERROR: Illegal query option: `" + queryAoptions.value + "'.");
                Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

              } finally {
                Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
              }
            }
            throw ((ParsingError)(ParsingError.newParsingError(stream000.theStringReader()).fillInStackTrace()));
          }
        }
        if (queryAoptions.rest.value == null) {
          { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

            { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

              try {
                Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                stream001.nativeStream.println("PARSING ERROR: Missing value for option `" + queryAoptions.value + "'.");
                Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

              } finally {
                Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
              }
            }
            throw ((ParsingError)(ParsingError.newParsingError(stream001.theStringReader()).fillInStackTrace()));
          }
        }
        options.insertAt(queryAoptions.value, queryAoptions.rest.value);
        queryAoptions = queryAoptions.rest.rest;
      }
      if (handlenonmatchingvariablesP) {
        { Stella_Object temp000 = options.lookup(Logic.KWD_CHECK_VARIABLESp);

          if (BooleanWrapper.coerceWrappedBooleanToBoolean(Stella_Object.coerceToBoolean(((temp000 != null) ? temp000 : Stella.FALSE_WRAPPER)))) {
            { OutputStringStream stream002 = OutputStringStream.newOutputStringStream();

              { Object old$PrintreadablyP$002 = Stella.$PRINTREADABLYp$.get();

                try {
                  Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                  {
                    stream002.nativeStream.println("PARSING ERROR: Declared query variables `" + declaredvariables + "' do not match");
                    stream002.nativeStream.println("   the free variables `" + freevariables.theConsList + "' referenced in the query body.");
                    stream002.nativeStream.println("   To simply use the free variables, omit the declaration.");
                  }
;
                  Logic.helpSignalPropositionError(stream002, Logic.KWD_ERROR);

                } finally {
                  Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$002);
                }
              }
              throw ((ParsingError)(ParsingError.newParsingError(stream002.theStringReader()).fillInStackTrace()));
            }
          }
          else {
            proposition = Cons.list$(Cons.cons(Logic.SYM_STELLA_EXISTS, Cons.cons(freevariables.theConsList.difference(declaredvariables), Cons.cons(Cons.cons(proposition, Stella.NIL), Stella.NIL))));
          }
        }
      }
      { Stella_Object _return_temp = variables;

        MV_returnarray[0] = proposition;
        MV_returnarray[1] = options;
        return (_return_temp);
      }
    }
  }

  public static Stella_Object lookupQueryOption(Stella_Object queryoroptions, Keyword key) {
    { PropertyList options = null;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(queryoroptions);

        if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_PROPERTY_LIST)) {
          { PropertyList queryoroptions000 = ((PropertyList)(queryoroptions));

            options = queryoroptions000;
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_QUERY_ITERATOR)) {
          { QueryIterator queryoroptions000 = ((QueryIterator)(queryoroptions));

            options = queryoroptions000.options;
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
      return (options.lookup(key));
    }
  }

  public static Stella_Object lookupQueryOptionWithDefault(Stella_Object queryoroptions, Keyword key, Stella_Object renamed_Default) {
    { Stella_Object value = Logic.lookupQueryOption(queryoroptions, key);

      if (value != null) {
        return (value);
      }
      else {
        return (renamed_Default);
      }
    }
  }

  public static boolean testQueryOptionP(Stella_Object queryoroptions, Keyword key) {
    return (Stella_Object.eqlP(Logic.lookupQueryOption(queryoroptions, key), Stella.TRUE_WRAPPER));
  }

  public static boolean testQueryOptionValueP(Stella_Object queryoroptions, Keyword key, Stella_Object value) {
    return (Stella_Object.eqlP(Logic.lookupQueryOption(queryoroptions, key), value));
  }

  public static Stella_Object lookupDeferredQueryOption(Stella_Object queryoroptions, Keyword key, Surrogate coercetotype) {
    { PropertyList options = null;
      PropertyList deferredoptions = null;
      Stella_Object value = null;
      Stella_Object coercedvalue = null;
      boolean processeddeferredoptionP = false;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(queryoroptions);

        if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_PROPERTY_LIST)) {
          { PropertyList queryoroptions000 = ((PropertyList)(queryoroptions));

            options = queryoroptions000;
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_QUERY_ITERATOR)) {
          { QueryIterator queryoroptions000 = ((QueryIterator)(queryoroptions));

            options = queryoroptions000.options;
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
      deferredoptions = ((PropertyList)(options.lookup(Logic.KWD_DEFERRED_OPTIONS)));
      if (deferredoptions != null) {
        value = deferredoptions.lookup(key);
        if (value == null) {
          value = options.lookup(key);
        }
        else {
          processeddeferredoptionP = true;
        }
        if (value != null) {
          if (coercetotype != null) {
            coercedvalue = Stella_Object.coerceOptionValue(value, coercetotype);
            if (coercedvalue == null) {
              { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

                { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

                  try {
                    Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                    stream001.nativeStream.println("PARSING ERROR: Illegal `" + key + "' value: `" + value + "'.");
                    Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

                  } finally {
                    Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
                  }
                }
                throw ((ParsingError)(ParsingError.newParsingError(stream001.theStringReader()).fillInStackTrace()));
              }
            }
            else {
              value = coercedvalue;
            }
          }
          if (processeddeferredoptionP) {
            deferredoptions.removeAt(key);
            options.insertAt(key, value);
          }
        }
      }
      return (value);
    }
  }

  public static int lookupHowManySolutions(Stella_Object queryoroptions) {
    { Stella_Object howmany = Logic.lookupQueryOption(queryoroptions, Logic.KWD_HOW_MANY);

      if (howmany != null) {
        return (((IntegerWrapper)(howmany)).wrapperValue);
      }
      else {
        return (1);
      }
    }
  }

  public static Stella_Object coerceToTree(Stella_Object self) {
    if (Surrogate.subtypeOfStringP(Stella_Object.safePrimaryType(self))) {
      { StringWrapper self000 = ((StringWrapper)(self));

        return (Stella.readSExpressionFromString(self000.wrapperValue));
      }
    }
    else {
      return (self);
    }
  }

  public static QueryIterator createAskQuery(Stella_Object query) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(query);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_QUERY_ITERATOR)) {
        { QueryIterator query000 = ((QueryIterator)(query));

          return (query000);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition query000 = ((Proposition)(query));

          return (Logic.createAskQuery(Proposition.propositionToCons(query000)));
        }
      }
      else if (testValue000 == Logic.SGT_STELLA_CONS) {
        { Cons query000 = ((Cons)(query));

          { Stella_Object iovariables = null;
            Stella_Object proposition = null;
            PropertyList options = null;

            { Object [] caller_MV_returnarray = new Object[2];

              iovariables = Logic.parseQueryAndOptions(query000, caller_MV_returnarray);
              proposition = ((Stella_Object)(caller_MV_returnarray[0]));
              options = ((PropertyList)(caller_MV_returnarray[1]));
            }
            if ((iovariables == null) &&
                (proposition != null)) {
              return (Logic.makeQuery(Stella.NIL, proposition, Stella.NIL, options));
            }
            else {
              { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

                { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

                  try {
                    Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                    stream000.nativeStream.println("PARSING ERROR: Illegal ASK query: `" + query000 + "'.");
                    Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

                  } finally {
                    Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
                  }
                }
                throw ((ParsingError)(ParsingError.newParsingError(stream000.theStringReader()).fillInStackTrace()));
              }
            }
          }
        }
      }
      else {
        { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream001.nativeStream.println("PARSING ERROR: Illegal ASK query: `" + query + "'.");
              Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
            }
          }
          throw ((ParsingError)(ParsingError.newParsingError(stream001.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  /** Callable version of <code>ask</code> (which see).  Accepts queries
   * specified by a query iterator, or specified as a CONS-list of arguments as they
   * would be supplied to <code>ask</code>.  Raises LOGIC-EXCEPTIONs in case of illegal
   * queries and logical expressions.
   * @param query
   * @return TruthValue
   */
  public static TruthValue callAsk(Stella_Object query) {
    { Object old$Queryiterator$000 = Logic.$QUERYITERATOR$.get();
      Object old$ReversepolarityP$000 = Logic.$REVERSEPOLARITYp$.get();
      Object old$Inferencelevel$000 = Logic.$INFERENCELEVEL$.get();
      Object old$GenerateAllProofsP$000 = Logic.$GENERATE_ALL_PROOFSp$.get();

      try {
        Native.setSpecial(Logic.$QUERYITERATOR$, Logic.createAskQuery(query));
        Native.setBooleanSpecial(Logic.$REVERSEPOLARITYp$, false);
        Native.setSpecial(Logic.$INFERENCELEVEL$, Logic.currentInferenceLevel());
        Native.setBooleanSpecial(Logic.$GENERATE_ALL_PROOFSp$, false);
        { TruthValue truthValue = null;
          boolean threevaluedaskP = Logic.testQueryOptionP(((QueryIterator)(Logic.$QUERYITERATOR$.get())), Logic.KWD_THREE_VALUEDp);
          boolean fourvaluedaskP = Logic.testQueryOptionP(((QueryIterator)(Logic.$QUERYITERATOR$.get())), Logic.KWD_FOUR_VALUEDp);

          if (Logic.$MOST_RECENT_QUERY$ == null) {
            Logic.$MOST_RECENT_QUERY$ = ((QueryIterator)(Logic.$QUERYITERATOR$.get()));
          }
          ((QueryIterator)(Logic.$QUERYITERATOR$.get())).nextP();
          { TruthValue temp000 = ((QueryIterator)(Logic.$QUERYITERATOR$.get())).baseControlFrame.truthValue;

            truthValue = ((temp000 != null) ? temp000 : Logic.UNKNOWN_TRUTH_VALUE);
          }
          if (((truthValue == Logic.UNKNOWN_TRUTH_VALUE) ||
              (truthValue == null)) &&
              (threevaluedaskP ||
               fourvaluedaskP)) {
            ((QueryIterator)(Logic.$QUERYITERATOR$.get())).baseControlFrame.reversePolarityP = true;
            ((QueryIterator)(Logic.$QUERYITERATOR$.get())).reset();
            ((QueryIterator)(Logic.$QUERYITERATOR$.get())).nextP();
            { TruthValue temp001 = ((QueryIterator)(Logic.$QUERYITERATOR$.get())).baseControlFrame.truthValue;

              truthValue = ((temp001 != null) ? temp001 : Logic.UNKNOWN_TRUTH_VALUE);
            }
          }
          return (truthValue);
        }

      } finally {
        Logic.$GENERATE_ALL_PROOFSp$.set(old$GenerateAllProofsP$000);
        Logic.$INFERENCELEVEL$.set(old$Inferencelevel$000);
        Logic.$REVERSEPOLARITYp$.set(old$ReversepolarityP$000);
        Logic.$QUERYITERATOR$.set(old$Queryiterator$000);
      }
    }
  }

  /** Perform inference to determine whether the proposition specified in
   * <code>propositionAoptions</code> is true.  Return the truth-value found.  <code>ask</code>
   * will spend most of its effort to determine whether the proposition
   * is true and only a little effort via shallow inference strategies to
   * determine whether it is false.  To find out whether a proposition is
   * false with full inference effort <code>ask</code> its negation.
   * <p>
   * KIF example: <code>_ask__happy_Fred__</code> will return TRUE if Fred was indeed
   * found to be happy.  Note, that for this query to run, the logic
   * constant <code>Fred</code> and the relation <code>happy</code> must already be defined (see
   * <code>renamed_Assert</code>).  Use <code>_setSunsetFeatureGoalTrace_</code> to en/disable goal
   * tracing of the inference engine.
   * <p>
   * The <code>ask</code> command supports the following options: <code>CTIMEOUT</code> is an
   * integer or floating point time limit, specified in seconds.  For
   * example, the command <code>_ask__nervous_Fred__Ctimeout_2D0_</code> will cease
   * inference after two seconds if a proof has not been found by then.
   * If the <code>CDONT_OPTIMIZEP</code> is given as TRUE, it tells PowerLoom to
   * not optimize the order of clauses in the query before evaluating it.
   * This is useful for cases where a specific evaluation order of the
   * clauses is required (or the optimizer doesn't do the right thing).
   * If <code>CTHREE_VALUEDP</code> is given as TRUE, PowerLoom will try to prove
   * the negation of the query with full effort in case the given query
   * returned UNKNOWN.  By default, PowerLoom uses full effort to prove
   * the query as stated and only a little opportunistic effort to see
   * whether it is actually false.
   * @param propositionAoptions
   * @return TruthValue
   */
  public static TruthValue ask(Cons propositionAoptions) {
    Logic.$MOST_RECENT_QUERY$ = null;
    try {
      return (Logic.callAsk(propositionAoptions));
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
      Logic.$MOST_RECENT_QUERY$ = null;
      return (null);
    }
  }

  public static TruthValue askEvaluatorWrapper(Cons arguments) {
    return (Logic.ask(arguments));
  }

  public static QueryIterator retrieveBindings(Stella_Object query, int nofbindings) {
    { QueryIterator thequery = null;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(query);

        if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_QUERY_ITERATOR)) {
          { QueryIterator query000 = ((QueryIterator)(query));

            thequery = query000;
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
          { Proposition query000 = ((Proposition)(query));

            thequery = Logic.makeQuery(((Vector)(KeyValueList.dynamicSlotValue(query000.dynamicSlots, Logic.SYM_LOGIC_IO_VARIABLES, null))).consify(), Proposition.propositionToCons(query000), Stella.NIL, Cons.list$(Cons.cons(Logic.KWD_HOW_MANY, Cons.cons(IntegerWrapper.wrapInteger(nofbindings), Cons.cons(Stella.NIL, Stella.NIL)))));
          }
        }
        else if (testValue000 == Logic.SGT_STELLA_CONS) {
          { Cons query000 = ((Cons)(query));

            thequery = Logic.makeQuery(query000.value, query000.rest.value, Stella.NIL, query000.rest.rest);
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
      thequery.options.insertAt(Logic.KWD_HOW_MANY, IntegerWrapper.wrapInteger(nofbindings));
      return (Logic.callRetrieve(thequery));
    }
  }

  public static QueryIterator createRetrieveQuery(Stella_Object query) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(query);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_QUERY_ITERATOR)) {
        { QueryIterator query000 = ((QueryIterator)(query));

          return (query000);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition query000 = ((Proposition)(query));

          return (Logic.createRetrieveQuery(Proposition.propositionToCons(query000)));
        }
      }
      else if (testValue000 == Logic.SGT_STELLA_CONS) {
        { Cons query000 = ((Cons)(query));

          { Stella_Object iovariables = null;
            Stella_Object queryproposition = null;
            PropertyList options = null;

            { Object [] caller_MV_returnarray = new Object[2];

              iovariables = Logic.parseQueryAndOptions(query000, caller_MV_returnarray);
              queryproposition = ((Stella_Object)(caller_MV_returnarray[0]));
              options = ((PropertyList)(caller_MV_returnarray[1]));
            }
            if ((iovariables == null) &&
                (queryproposition == null)) {
              if (Logic.$MOST_RECENT_QUERY$ == null) {
                { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

                  { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

                    try {
                      Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                      stream000.nativeStream.println("PARSING ERROR: No preceding context for follow-up retrieval.");
                      Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

                    } finally {
                      Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
                    }
                  }
                  throw ((ParsingError)(ParsingError.newParsingError(stream000.theStringReader()).fillInStackTrace()));
                }
              }
              QueryIterator.processQueryOptions(Logic.$MOST_RECENT_QUERY$, options);
              return (Logic.$MOST_RECENT_QUERY$);
            }
            else if (iovariables == null) {
              { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

                { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

                  try {
                    Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                    stream001.nativeStream.println("PARSING ERROR: Missing IO-variable specification in retrieval query: `" + query000 + "'.");
                    Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

                  } finally {
                    Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
                  }
                }
                throw ((ParsingError)(ParsingError.newParsingError(stream001.theStringReader()).fillInStackTrace()));
              }
            }
            else {
              return (Logic.makeQuery(iovariables, queryproposition, Stella.NIL, options));
            }
          }
        }
      }
      else {
        { OutputStringStream stream002 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$002 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream002.nativeStream.println("PARSING ERROR: Illegal retrieval query: `" + query + "'.");
              Logic.helpSignalPropositionError(stream002, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$002);
            }
          }
          throw ((ParsingError)(ParsingError.newParsingError(stream002.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  /** Callable version of <code>retrieve</code> (which see).  Accepts queries
   * specified by a query iterator, or specified as a CONS-list of arguments as they
   * would be supplied to <code>retrieve</code>.  Raises LOGIC-EXCEPTIONs in case of illegal
   * queries and logical expressions.
   * @param query
   * @return QueryIterator
   */
  public static QueryIterator callRetrieve(Stella_Object query) {
    { QueryIterator thequery = Logic.createRetrieveQuery(query);
      Stella_Object matchmode = Logic.lookupQueryOption(thequery, Logic.KWD_MATCH_MODE);

      if ((matchmode != null) &&
          (!Stella.stringEqualP(Stella_Object.coerceToString(matchmode), "STRICT"))) {
        return (Logic.callRetrievePartial(thequery));
      }
      { Object old$Queryiterator$000 = Logic.$QUERYITERATOR$.get();
        Object old$ReversepolarityP$000 = Logic.$REVERSEPOLARITYp$.get();
        Object old$Inferencelevel$000 = Logic.$INFERENCELEVEL$.get();
        Object old$GenerateAllProofsP$000 = Logic.$GENERATE_ALL_PROOFSp$.get();

        try {
          Native.setSpecial(Logic.$QUERYITERATOR$, thequery);
          Native.setBooleanSpecial(Logic.$REVERSEPOLARITYp$, false);
          Native.setSpecial(Logic.$INFERENCELEVEL$, Logic.currentInferenceLevel());
          Native.setBooleanSpecial(Logic.$GENERATE_ALL_PROOFSp$, Logic.testQueryOptionP(thequery, Logic.KWD_ALL_PROOFSp));
          { int i = Stella.NULL_INTEGER;
            int iter000 = 1;
            int upperBound000 = Logic.lookupHowManySolutions(((QueryIterator)(Logic.$QUERYITERATOR$.get())));
            boolean unboundedP000 = upperBound000 == Stella.NULL_INTEGER;
            QuerySolution solution = null;
            QueryIterator iter001 = ((QueryIterator)(Logic.$QUERYITERATOR$.get()));

            for (;(unboundedP000 ||
                      (iter000 <= upperBound000)) &&
                      iter001.nextP(); iter000 = iter000 + 1) {
              i = iter000;
              solution = ((QuerySolution)(iter001.value));
              if (Stella_Object.traceKeywordP(Logic.KWD_TRACE_SOLUTIONS)) {
                QueryIterator.traceSolution(((QueryIterator)(Logic.$QUERYITERATOR$.get())), solution, i);
              }
            }
          }
          { Keyword sortoption = ((Keyword)(Logic.lookupQueryOption(thequery, Logic.KWD_SORT_BY)));

            if ((sortoption == Logic.KWD_VALUES) ||
                (sortoption == Logic.KWD_VALUES_ASCENDING)) {
              thequery.solutions.sort(Native.find_java_method("edu.isi.powerloom.logic.QuerySolution", "querySolutionLessThanP", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.QuerySolution"), Native.find_java_class("edu.isi.powerloom.logic.QuerySolution")}));
            }
            else if (sortoption == Logic.KWD_VALUES_DESCENDING) {
              thequery.solutions.sort(Native.find_java_method("edu.isi.powerloom.logic.QuerySolution", "querySolutionGreaterThanP", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.QuerySolution"), Native.find_java_class("edu.isi.powerloom.logic.QuerySolution")}));
            }
            else {
            }
          }
          if (((QueryIterator)(Logic.$QUERYITERATOR$.get())).timeoutP) {
            Logic.plLog(Logic.KWD_HIGH, Cons.cons(StringWrapper.wrapString("The query timed out"), Stella.NIL));
          }
          if (((QueryIterator)(Logic.$QUERYITERATOR$.get())).depthCutoffsP) {
            Logic.plLog(Logic.KWD_HIGH, Cons.cons(StringWrapper.wrapString("The query had depth cutoffs"), Stella.NIL));
          }
          return (((QueryIterator)(Logic.$QUERYITERATOR$.get())));

        } finally {
          Logic.$GENERATE_ALL_PROOFSp$.set(old$GenerateAllProofsP$000);
          Logic.$INFERENCELEVEL$.set(old$Inferencelevel$000);
          Logic.$REVERSEPOLARITYp$.set(old$ReversepolarityP$000);
          Logic.$QUERYITERATOR$.set(old$Queryiterator$000);
        }
      }
    }
  }

  /** Retrieve elements of a relation (tuples) that satisfy a proposition.
   * The accepted syntax is:
   * 	 
   *   (retrieve [&lt;integer&gt; | all]
   *             [[{&lt;vardecl&gt; | (&lt;vardecl&gt;+)}]
   *              &lt;proposition&gt;
   *              [&lt;option-keyword&gt; &lt;option-value&gt;]])
   * 	
   * The variables and proposition are similar to an <code>exists</code> sentence or
   * <code>kappa</code> term without the explicit quantifier.  If variables are declared,
   * they must match the free variables referenced by &lt;proposition&gt;.  Otherwise,
   * the free variables referenced in &lt;proposition&gt; will be used as the query
   * variables.  If &lt;proposition&gt; is omitted, the most recently asked query
   * will be continued.
   * <p>
   * A solution is a set of bindings for the listed variables for which
   * &lt;proposition&gt; is true.  The optional first argument controls how many
   * solutions should be generated before control is returned.  The keyword
   * <code>all</code> indicates that all solutions should be generated.  By default,
   * <code>retrieve</code> returns after it has found one new solution or if it cannot
   * find any more solutions.
   * <p>
   * <code>retrieve</code> returns an iterator which saves all the necessary state of
   * a query and stores all generated solutions.  When used interactively,
   * the returned iterator will print out with the set of solutions collected
   * so far.  Calling <code>retrieve</code> without any arguments (or only with the first
   * argument) will generate one (or more) solutions to the most recently
   * asked query.
   * <p>
   * <code>retrieve</code> supports the following options:
   *   :TIMEOUT Time limit on query effort in seconds.
   *   :MAXIMUM-DEPTH Inference depth cutoff in goal depth.
   *   :INFERENCE-LEVEL Level of inference to use.  The values in order of effort
   *      and power are ASSERTION, SHALLOW, SUBSUMPTION, BACKTRACKING, NORMAL
   *      and REFUTATION. Default is NORMAL.
   *   :FOUR-VALUED? Will attempt to disprove values and find conflicts.
   *   :ITERATIVE-DEEPENING? Controls whether the search strategy will use
   *      depth-first or breadth-first search.
   *   :DONT-OPTIMIZE? Option to disable re-arrangement of clauses by the query
   *      optimizer.  If TRUE, then use the order of clauses as given in the query.
   *   :SORT-BY one of SCORE, VALUES, VALUES-DESCENDING, VALUES-ASCENDING.  
   *      SCORE is only meaningful for partial match mode.  The value sorting
   *      is done by values in order in the tuple.  Default is ascending.
   *   :MATCH-MODE Allows choice of matching mode.  One of STRICT, INCREMENTAL, 
   *      NEURAL-NETWORK, or other plug-in partial-match mode.
   *      The default is STRICT.
   *   :MINIMUM-SCORE The minimum score to return.  Only useful in partial match
   *     mode.
   *   :MAXIMUM-UNKNOWNS The maximum number of unknown values to allow.  Only useful
   *     for whynot matching.
   * <p>
   * KIF examples:
   * 	 
   *   (retrieve (happy ?x))
   * 	
   * will try to find one happy entity and store it in the returned 
   * query iterator.
   * 	 
   *   (retrieve 10 (happy ?x))
   * 	
   * will try to find 10 happy entities.
   * 	 
   *   (retrieve 10)
   * 	
   * will try to find the next 10 happy entities..
   * 	 
   *   (retrieve all (happy ?x))
   * 	
   * will find all happy entities.
   * 	 
   *   (retrieve all (?x Person) (happy ?x))
   * 	
   * will to find all happy people.  Here we used the optional retrieve variable
   * syntax to restrict the acceptable solutions.  The above is equivalent to
   * the following query:
   * 	 
   *   (retrieve all (and (Person ?x) (happy ?x)))
   * 	
   * Similarly,
   * 	 
   *   (retrieve all (?x Person))
   *   (retrieve all (Person ?x))
   *   (retrieve all ?x (Person ?x))
   * 	
   * will find all people.  Note that in the first case we only specify a query
   * variable and its type but omit the logic sentence which defaults to TRUE.  This
   * somewhat impoverished looking query can be paraphrased as &quot;retrieve all ?x of
   * type Person such that TRUE.&quot;
   * 	 
   *   (retrieve ?x (or (happy ?x) (parent-of Fred ?x)))
   * 	
   * will try to find a person that is happy or has Fred as a parent.
   * 	 
   *   (retrieve (?y ?x) (parent-of ?x ?y))
   * 	
   * will try to find the one pair of parent/child and return it in the order
   * of child/parent.
   * 	 
   *   (retrieve all (?x Person)
   *             (exists (?y Person) (parent-of ?x ?y)))
   * 	
   * will generate the set of all parents.  Note, that for these queries to run,
   * the class <code>Person</code>, the relations <code>happy</code> and <code>parentOf</code>, and the logic
   * constant <code>Fred</code> must already be defined (see <code>renamed_Assert</code>).
   * <p>
   * Use <code>_setSunsetFeatureTraceSubgoals_</code> to en/disable goal tracing of the
   * inference engine.
   * @param query
   * @return QueryIterator
   */
  public static QueryIterator retrieve(Cons query) {
    try {
      return (Logic.$MOST_RECENT_QUERY$ = Logic.callRetrieve(query));
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
      return (Logic.$MOST_RECENT_QUERY$ = null);
    }
  }

  public static QueryIterator retrieveEvaluatorWrapper(Cons arguments) {
    return (Logic.retrieve(arguments));
  }

  public static void clearInlineQueryCaches() {
    Logic.$INLINE_QUERY_CACHE$.clear();
  }

  public static QueryIterator findCachedQuery(Symbol queryid) {
    { List queries = ((List)(Logic.$INLINE_QUERY_CACHE$.lookup(queryid)));

      if (queries != null) {
        return (((QueryIterator)(queries.pop())));
      }
      else {
        return (null);
      }
    }
  }

  public static QueryIterator makeCachedQuery(Cons variables, Cons querybody, Cons inputbindings, Stella_Object options, Symbol cacheid) {
    { QueryIterator queryiterator = Logic.findCachedQuery(cacheid);
      Cons cursor = inputbindings;

      if (!(variables.length() == inputbindings.length())) {
        Stella.STANDARD_OUTPUT.nativeStream.println("make-cached-query: number of variables does not equal number of input bindings.");
        return (null);
      }
      while (!(cursor == Stella.NIL)) {
        if (cursor.value != null) {
          cursor.value = Logic.valueOf(cursor.value);
        }
        cursor = cursor.rest;
      }
      if ((queryiterator != null) &&
          ((!(Logic.$QUERY_OPTIMIZATION_STRATEGY$ == Logic.KWD_NONE)) &&
           (!((Logic.$QUERY_OPTIMIZATION_STRATEGY$ == Logic.KWD_DYNAMIC) ||
          (Logic.$QUERY_OPTIMIZATION_STRATEGY$ == Logic.KWD_DYNAMIC_WITH_CLUSTERING))))) {
        { Stella_Object oldb = null;
          Vector vector000 = ((Vector)(KeyValueList.dynamicSlotValue(queryiterator.dynamicSlots, Logic.SYM_LOGIC_INITIAL_BINDINGS, null)));
          int index000 = 0;
          int length000 = vector000.length();
          Stella_Object newb = null;
          Cons iter000 = inputbindings;

          loop001 : for (;(index000 < length000) &&
                    (!(iter000 == Stella.NIL)); index000 = index000 + 1, iter000 = iter000.rest) {
            oldb = (vector000.theArray)[index000];
            newb = iter000.value;
            if (!((oldb == null) == (newb == null))) {
              queryiterator = null;
              break loop001;
            }
          }
        }
      }
      if (queryiterator == null) {
        {
          try {
            queryiterator = Logic.makeQuery(Cons.copyConsList(variables), ((Cons)(Stella_Object.copyConsTree(querybody))), inputbindings, options);
          } catch (LogicException e) {
            Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
            return (null);
          }
        }
      }
      else {
        {
          { Stella_Object newb = null;
            Cons iter001 = inputbindings;
            int i = Stella.NULL_INTEGER;
            int iter002 = 0;

            for (;!(iter001 == Stella.NIL); iter001 = iter001.rest, iter002 = iter002 + 1) {
              newb = iter001.value;
              i = iter002;
              (((Vector)(KeyValueList.dynamicSlotValue(queryiterator.dynamicSlots, Logic.SYM_LOGIC_INITIAL_BINDINGS, null))).theArray)[i] = newb;
            }
          }
          queryiterator.reset();
        }
      }
      if (options != null) {
        QueryIterator.processQueryOptions(queryiterator, options);
      }
      return (queryiterator);
    }
  }

  public static Cons applyCachedRetrieve(Cons variables, Cons querybody, Cons inputbindings, Stella_Object options, Symbol cacheid, Object [] MV_returnarray) {
    { QueryIterator queryiterator = null;
      int bindingscount = 0;
      Cons outputbindings = Stella.NIL;
      Cons truthvalues = Stella.NIL;
      Cons justifications = Stella.NIL;
      boolean forcesingletontuplesP = false;

      { ConsIterator it = inputbindings.allocateIterator();

        while (it.nextP()) {
          if (it.value != null) {
            bindingscount = bindingscount + 1;
          }
        }
      }
      queryiterator = Logic.makeCachedQuery(variables, querybody, inputbindings, options, cacheid);
      if (queryiterator == null) {
        { Cons _return_temp = Stella.NIL;

          MV_returnarray[0] = Stella.NIL;
          MV_returnarray[1] = Stella.NIL;
          return (_return_temp);
        }
      }
      if (Stella_Object.eqlP(queryiterator.options.lookup(Logic.KWD_SINGLETONSp), Stella.FALSE_WRAPPER) ||
          Stella_Object.eqlP(queryiterator.options.lookup(Logic.KWD_ATOMIC_SINGLETONSp), Stella.FALSE_WRAPPER)) {
        forcesingletontuplesP = true;
      }
      { Object old$Queryiterator$000 = Logic.$QUERYITERATOR$.get();
        Object old$ReversepolarityP$000 = Logic.$REVERSEPOLARITYp$.get();
        Object old$Inferencelevel$000 = Logic.$INFERENCELEVEL$.get();
        Object old$GenerateAllProofsP$000 = Logic.$GENERATE_ALL_PROOFSp$.get();

        try {
          Native.setSpecial(Logic.$QUERYITERATOR$, queryiterator);
          Native.setBooleanSpecial(Logic.$REVERSEPOLARITYp$, false);
          Native.setSpecial(Logic.$INFERENCELEVEL$, Logic.currentInferenceLevel());
          Native.setBooleanSpecial(Logic.$GENERATE_ALL_PROOFSp$, Logic.testQueryOptionP(queryiterator, Logic.KWD_ALL_PROOFSp));
          while (queryiterator.nextP()) {
          }

        } finally {
          Logic.$GENERATE_ALL_PROOFSp$.set(old$GenerateAllProofsP$000);
          Logic.$INFERENCELEVEL$.set(old$Inferencelevel$000);
          Logic.$REVERSEPOLARITYp$.set(old$ReversepolarityP$000);
          Logic.$QUERYITERATOR$.set(old$Queryiterator$000);
        }
      }
      { Stella_Object tuple = null;
        boolean atomicsingletonsP = (inputbindings.length() == (bindingscount + 1)) &&
            (!forcesingletontuplesP);

        { QuerySolution s = null;
          DictionaryIterator iter000 = ((DictionaryIterator)(queryiterator.solutions.allocateIterator()));

          while (iter000.nextP()) {
            s = ((QuerySolution)(iter000.value));
            if (atomicsingletonsP) {
              { Stella_Object v = null;
                Vector vector000 = s.bindings;
                int index000 = 0;
                int length000 = vector000.length();
                Stella_Object b = null;
                Cons iter001 = inputbindings;

                for (;(index000 < length000) &&
                          (!(iter001 == Stella.NIL)); index000 = index000 + 1, iter001 = iter001.rest) {
                  v = (vector000.theArray)[index000];
                  b = iter001.value;
                  if (b == null) {
                    tuple = v;
                  }
                }
              }
            }
            else {
              { Cons values = Stella.NIL;

                { Stella_Object v = null;
                  Vector vector001 = s.bindings;
                  int index001 = 0;
                  int length001 = vector001.length();
                  Stella_Object b = null;
                  Cons iter002 = inputbindings;
                  Cons collect000 = null;

                  for (;(index001 < length001) &&
                            (!(iter002 == Stella.NIL)); index001 = index001 + 1, iter002 = iter002.rest) {
                    v = (vector001.theArray)[index001];
                    b = iter002.value;
                    if (b == null) {
                      if (collect000 == null) {
                        {
                          collect000 = Cons.cons(v, Stella.NIL);
                          if (values == Stella.NIL) {
                            values = collect000;
                          }
                          else {
                            Cons.addConsToEndOfConsList(values, collect000);
                          }
                        }
                      }
                      else {
                        {
                          collect000.rest = Cons.cons(v, Stella.NIL);
                          collect000 = collect000.rest;
                        }
                      }
                    }
                  }
                }
                tuple = values;
              }
            }
            outputbindings = Cons.cons(tuple, outputbindings);
            truthvalues = Cons.cons(s.truthValue, truthvalues);
            if (((Boolean)(Logic.$RECORD_JUSTIFICATIONSp$.get())).booleanValue()) {
              justifications = Cons.cons(s.justification, justifications);
            }
          }
        }
      }
      QueryIterator.freeCachedQuery(queryiterator, cacheid);
      { Cons _return_temp = outputbindings.reverse();

        MV_returnarray[0] = truthvalues.reverse();
        MV_returnarray[1] = justifications.reverse();
        return (_return_temp);
      }
    }
  }

  public static boolean applyCachedAsk(Cons inputvariables, Cons querybody, Cons inputbindings, Stella_Object options, Symbol cacheid, Object [] MV_returnarray) {
    { QueryIterator queryiterator = Logic.makeCachedQuery(inputvariables, querybody, inputbindings, options, cacheid);

      if (queryiterator != null) {
        { Object old$Queryiterator$000 = Logic.$QUERYITERATOR$.get();
          Object old$ReversepolarityP$000 = Logic.$REVERSEPOLARITYp$.get();
          Object old$Inferencelevel$000 = Logic.$INFERENCELEVEL$.get();
          Object old$GenerateAllProofsP$000 = Logic.$GENERATE_ALL_PROOFSp$.get();

          try {
            Native.setSpecial(Logic.$QUERYITERATOR$, queryiterator);
            Native.setBooleanSpecial(Logic.$REVERSEPOLARITYp$, false);
            Native.setSpecial(Logic.$INFERENCELEVEL$, Logic.currentInferenceLevel());
            Native.setBooleanSpecial(Logic.$GENERATE_ALL_PROOFSp$, false);
            { TruthValue truthvalue = Logic.callAsk(queryiterator);

              QueryIterator.freeCachedQuery(queryiterator, cacheid);
              { boolean _return_temp = (truthvalue == Logic.TRUE_TRUTH_VALUE) ||
                    (truthvalue == Logic.DEFAULT_TRUE_TRUTH_VALUE);

                MV_returnarray[0] = truthvalue;
                return (_return_temp);
              }
            }

          } finally {
            Logic.$GENERATE_ALL_PROOFSp$.set(old$GenerateAllProofsP$000);
            Logic.$INFERENCELEVEL$.set(old$Inferencelevel$000);
            Logic.$REVERSEPOLARITYp$.set(old$ReversepolarityP$000);
            Logic.$QUERYITERATOR$.set(old$Queryiterator$000);
          }
        }
      }
      else {
        { boolean _return_temp = false;

          MV_returnarray[0] = null;
          return (_return_temp);
        }
      }
    }
  }

  public static TruthValue vectorSatisfiesDescriptionP(Vector vector, Description description) {
    if (!(vector.length() == description.arity())) {
      if (((Boolean)(Logic.$REVERSEPOLARITYp$.get())).booleanValue()) {
        return (Logic.TRUE_TRUTH_VALUE);
      }
      else {
        return (Logic.FALSE_TRUTH_VALUE);
      }
    }
    if (((Boolean)(Logic.$REVERSEPOLARITYp$.get())).booleanValue()) {
      return (Logic.UNKNOWN_TRUTH_VALUE);
    }
    try {
      { boolean alwaysP000 = true;

        { Stella_Object value = null;
          Vector vector000 = vector;
          int index000 = 0;
          int length000 = vector000.length();

          loop000 : for (;index000 < length000; index000 = index000 + 1) {
            value = (vector000.theArray)[index000];
            if (!(value != null)) {
              alwaysP000 = false;
              break loop000;
            }
          }
        }
        if (alwaysP000) {
          return (Logic.callAsk(Description.createQueryIterator(description, vector)));
        }
      }
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
    }
    return (Logic.UNKNOWN_TRUTH_VALUE);
  }

  public static TruthValue instanceSatisfiesDescriptionP(Stella_Object instance, Description description) {
    return (Logic.vectorSatisfiesDescriptionP(Stella.vector(Cons.cons(instance, Stella.NIL)), description));
  }

  public static Description coerceToDescription(Stella_Object self, Stella_Object original) {
    if (original == null) {
      original = self;
    }
    if (self == null) {
      Stella.STANDARD_OUTPUT.nativeStream.println("Can't find a description for the object `" + original + "'.");
      return (null);
    }
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description self000 = ((Description)(self));

          return (self000);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_RELATION)) {
        { Relation self000 = ((Relation)(self));

          return (Logic.getDescription(self000));
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate self000 = ((Surrogate)(self));

          return (Logic.coerceToDescription(self000.surrogateValue, original));
        }
      }
      else if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol self000 = ((Symbol)(self));

          return (Logic.coerceToDescription(Surrogate.lookupSurrogateInModule(self000.symbolName, ((Module)(self000.homeContext)), false), original));
        }
      }
      else if (Surrogate.subtypeOfKeywordP(testValue000)) {
        { Keyword self000 = ((Keyword)(self));

          return (Logic.coerceToDescription(Surrogate.lookupSurrogate(self000.symbolName), original));
        }
      }
      else if (Surrogate.subtypeOfStringP(testValue000)) {
        { StringWrapper self000 = ((StringWrapper)(self));

          return (Logic.coerceToDescription(Surrogate.lookupSurrogate(self000.wrapperValue), original));
        }
      }
      else {
        return (Logic.coerceToDescription(null, original));
      }
    }
  }

  /** Try to prove if the description associated with <code>subobject</code>
   * specializes the description for <code>superobject</code> and return the result truth
   * value of the query.
   * @param subobject
   * @param superobject
   * @return TruthValue
   */
  public static TruthValue specializesP(Stella_Object subobject, Stella_Object superobject) {
    { Description subdescription = Logic.coerceToDescription(subobject, null);
      Description superdescription = Logic.coerceToDescription(superobject, null);

      Logic.finalizeObjects();
      { Object old$Context$000 = Stella.$CONTEXT$.get();

        try {
          Native.setSpecial(Stella.$CONTEXT$, Logic.getInferenceCache(((Module)(Stella.$MODULE$.get())), Logic.KWD_META));
          if ((subdescription != null) &&
              (superdescription != null)) {
            return (Description.descriptionSpecializesDescriptionP(subdescription, superdescription));
          }

        } finally {
          Stella.$CONTEXT$.set(old$Context$000);
        }
      }
      return (Logic.UNKNOWN_TRUTH_VALUE);
    }
  }

  /** Return the logic instance referred to by 'self'.
   * @param self
   * @param original
   * @return LogicObject
   */
  public static LogicObject coerceToInstance(Stella_Object self, Stella_Object original) {
    if (original == null) {
      original = self;
    }
    if (self == null) {
      Stella.STANDARD_OUTPUT.nativeStream.println("Can't find a logic object `" + original + "'.");
      return (null);
    }
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          return (self000);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_RELATION)) {
        { Relation self000 = ((Relation)(self));

          return (Logic.getDescription(self000));
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate self000 = ((Surrogate)(self));

          { Stella_Object value = self000.surrogateValue;
            ObjectStore store = null;

            if (value == null) {
              store = Logic.homeObjectStore(self000);
              if (store != null) {
                value = store.fetchInstance(self000);
              }
            }
            return (Logic.coerceToInstance(value, original));
          }
        }
      }
      else if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol self000 = ((Symbol)(self));

          return (Logic.coerceToInstance(Symbol.symbolToSurrogate(self000), original));
        }
      }
      else if (Surrogate.subtypeOfKeywordP(testValue000)) {
        { Keyword self000 = ((Keyword)(self));

          return (Logic.coerceToInstance(Surrogate.lookupSurrogate(self000.symbolName), original));
        }
      }
      else if (Surrogate.subtypeOfStringP(testValue000)) {
        { StringWrapper self000 = ((StringWrapper)(self));

          return (Logic.coerceToInstance(Surrogate.lookupSurrogate(self000.wrapperValue), original));
        }
      }
      else if (testValue000 == Logic.SGT_STELLA_CONS) {
        { Cons self000 = ((Cons)(self));

          return (Logic.coerceToInstance(Logic.evaluateTerm(self000), original));
        }
      }
      else {
        return (Logic.coerceToInstance(null, original));
      }
    }
  }

  /** Return the logic instance referred to by <code>self</code>, or <code>self</code> if it is a
   * literal (e.g., string or number) that can't be coerced.
   * @param self
   * @param original
   * @return Stella_Object
   */
  public static Stella_Object coerceToInstanceOrLiteral(Stella_Object self, Stella_Object original) {
    if (original == null) {
      if (self != null) {
        original = self;
      }
      else {
        return (null);
      }
    }
    if (self == null) {
      if (Stella_Object.wrapperP(original)) {
        return (original);
      }
      else {
        Stella.STANDARD_OUTPUT.nativeStream.println("Can't find a logic object `" + original + "'.");
        return (null);
      }
    }
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          return (self000);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_RELATION)) {
        { Relation self000 = ((Relation)(self));

          return (Logic.getDescription(self000));
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate self000 = ((Surrogate)(self));

          return (Logic.coerceToInstanceOrLiteral(self000.surrogateValue, original));
        }
      }
      else if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol self000 = ((Symbol)(self));

          return (Logic.coerceToInstanceOrLiteral(Symbol.symbolToSurrogate(self000), original));
        }
      }
      else if (Surrogate.subtypeOfKeywordP(testValue000)) {
        { Keyword self000 = ((Keyword)(self));

          return (Logic.coerceToInstanceOrLiteral(Surrogate.lookupSurrogate(self000.symbolName), original));
        }
      }
      else if (Surrogate.subtypeOfStringP(testValue000)) {
        { StringWrapper self000 = ((StringWrapper)(self));

          return (Logic.coerceToInstanceOrLiteral(Surrogate.lookupSurrogate(self000.wrapperValue), original));
        }
      }
      else {
        return (Logic.coerceToInstanceOrLiteral(null, original));
      }
    }
  }

  /** Return a vector containing the elements in <code>self</code>.
   * Coerce each element of <code>self</code> to be a logic object or literal.
   * @param self
   * @return Vector
   */
  public static Vector coerceToVector(Stella_Object self) {
    { Vector vector = null;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

        if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_VECTOR)) {
          { Vector self000 = ((Vector)(self));

            vector = self000;
            { Stella_Object m = null;
              Vector vector000 = self000;
              int index000 = 0;
              int length000 = vector000.length();
              int i = Stella.NULL_INTEGER;
              int iter000 = 0;

              for (;index000 < length000; index000 = index000 + 1, iter000 = iter000 + 1) {
                m = (vector000.theArray)[index000];
                i = iter000;
                (vector.theArray)[i] = (Logic.coerceToInstanceOrLiteral(m, null));
              }
            }
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_LIST)) {
          { List self000 = ((List)(self));

            vector = Vector.newVector(self000.length());
            { Stella_Object m = null;
              Cons iter001 = self000.theConsList;
              int i = Stella.NULL_INTEGER;
              int iter002 = 0;

              for (;!(iter001 == Stella.NIL); iter001 = iter001.rest, iter002 = iter002 + 1) {
                m = iter001.value;
                i = iter002;
                (vector.theArray)[i] = (Logic.coerceToInstanceOrLiteral(m, null));
              }
            }
          }
        }
        else if (testValue000 == Logic.SGT_STELLA_CONS) {
          { Cons self000 = ((Cons)(self));

            vector = Vector.newVector(self000.length());
            { Stella_Object m = null;
              Cons iter003 = self000;
              int i = Stella.NULL_INTEGER;
              int iter004 = 0;

              for (;!(iter003 == Stella.NIL); iter003 = iter003.rest, iter004 = iter004 + 1) {
                m = iter003.value;
                i = iter004;
                (vector.theArray)[i] = (Logic.coerceToInstanceOrLiteral(m, null));
              }
            }
          }
        }
        else {
          {
            Stella.STANDARD_OUTPUT.nativeStream.println("Don't know how to coerce `" + self + "' of type `" + self.primaryType() + "'");
            Stella.STANDARD_OUTPUT.nativeStream.println("   into a vector.");
          }
;
        }
      }
      return (vector);
    }
  }

  /** Try to prove whether <code>instanceortuple</code> satisfies the
   * definition of the relation <code>relationref</code> and return the result truth value
   * of the query.  <code>instanceortuple</code> can be a single object, the name or surrogate
   * of an object, or a collection (a list or vector) of objects.  <code>relationref</code>
   * can be a relation, description, surrogate or relation name.
   * @param instanceortuple
   * @param relationref
   * @return TruthValue
   */
  public static TruthValue satisfiesP(Stella_Object instanceortuple, Stella_Object relationref) {
    { Description description = Logic.coerceToDescription(relationref, null);

      if (description != null) {
        Logic.finalizeObjects();
        { Object old$Context$000 = Stella.$CONTEXT$.get();
          Object old$Module$000 = Stella.$MODULE$.get();

          try {
            Native.setSpecial(Stella.$CONTEXT$, Logic.getQueryContext());
            Native.setSpecial(Stella.$MODULE$, ((Context)(Stella.$CONTEXT$.get())).baseModule);
            if (Stella_Object.isaP(instanceortuple, Logic.SGT_STELLA_COLLECTION) ||
                Stella_Object.consP(instanceortuple)) {
              { Vector vector = Logic.coerceToVector(instanceortuple);

                if (vector != null) {
                  return (Logic.vectorSatisfiesDescriptionP(vector, description));
                }
              }
            }
            else {
              { LogicObject instance = Logic.coerceToInstance(instanceortuple, null);

                if (instance != null) {
                  return (Logic.instanceSatisfiesDescriptionP(instance, description));
                }
              }
            }

          } finally {
            Stella.$MODULE$.set(old$Module$000);
            Stella.$CONTEXT$.set(old$Context$000);
          }
        }
      }
      return (Logic.UNKNOWN_TRUTH_VALUE);
    }
  }

  public static QueryIterator getQueryIteratorFromCommand(Cons query) {
    { Stella_Object queryiterator = Logic.evaluateLogicCommand(query, true);

      if ((!Stella_Object.isaP(queryiterator, Logic.SGT_LOGIC_QUERY_ITERATOR)) &&
          (Stella_Object.symbolP(query.value) &&
           Stella.stringEqualP(Native.string_subsequence(((Symbol)(query.value)).symbolName, 0, 3), "ASK"))) {
        queryiterator = Logic.$MOST_RECENT_QUERY$;
      }
      if (!Stella_Object.isaP(queryiterator, Logic.SGT_LOGIC_QUERY_ITERATOR)) {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream000.nativeStream.println("ERROR: Couldn't generate a query iterator result from `" + query + "'.");
              Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
            }
          }
          throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      return (((QueryIterator)(queryiterator)));
    }
  }

  /** Evaluate <code>query</code>, instantiate the query proposition for each generated
   * solution and assert the resulting propositions.  The accepted syntax
   * is as follows:
   * 	 
   *  (assert-from-query &lt;query-command&gt;
   *                     [:relation &lt;relation-name&gt;]
   *                     [:pattern &lt;description-term&gt;]
   *                     [:module &lt;module-name&gt;]
   *                     [:record-justifications? TRUE|FALSE])
   * 	
   * &lt;query-command&gt; has to be a strict or partial retrieval command. If a
   * :relation option is supplied, &lt;relation-name&gt; is used as the relation
   * of the resulting propositions.  In this case the bindings of each
   * solution will become arguments to the specified relation in the order
   * of <code>query</code>s output variables (the arities have to match).  The
   * :pattern option is a generalization of this mechanism that specifies
   * an arbitrary proposition pattern to be instantiated by the query's
   * solution.  In this case &lt;description-term&gt; has to be a SETOFALL or
   * KAPPA expression whose IO-variables will be bound in sequence to the
   * bindings of a query solution to generate the resulting proposition.
   * Finally, if a :module option is specified, the assertions will be
   * generated in that module.  Note that for this to work the relations
   * referenced in the query proposition or pattern have to be visible in
   * the module.  Also, instances will not be copied to the target module,
   * therefore, the resulting propositions might reference external
   * out-of-module objects in case they are not visible there.  If
   * :record-justifications? is TRUE, justifications will be recorded
   * for the query and the resulting justifications will be linked to
   * the asserted propositions.  Here are some examples:
   * 	 
   *  (assert-from-query (retrieve all (foo ?x ?y)))
   *  (assert-from-query (retrieve all (?y ?x)
   *                              (exists ?z
   *                                (and (foo ?x ?z)
   *                                     (foo ?z ?y))))
   *                     :relation bar :module other)
   *  (assert-from-query
   *    (retrieve all (and (relation ?x) (symmetric ?x)))
   *    :pattern (kappa (?pred)
   *               (forall (?x ?y)
   *                 (=&gt; (holds ?pred ?x ?y)
   *                     (holds ?pred ?y ?x))))))
   * 	
   * 
   * @param query
   * @param options
   * @return Cons
   */
  public static Cons assertFromQuery(Cons query, Cons options) {
    try {
      { PropertyList theoptions = Logic.parseLogicCommandOptions(options, Cons.list$(Cons.cons(Logic.KWD_MODULE, Cons.cons(Logic.SGT_STELLA_MODULE, Cons.cons(Logic.KWD_RELATION, Cons.cons(Logic.SGT_STELLA_SYMBOL, Cons.cons(Logic.KWD_PATTERN, Cons.cons(Logic.SGT_STELLA_CONS, Cons.cons(Logic.KWD_RECORD_JUSTIFICATIONSp, Cons.cons(Logic.SGT_STELLA_BOOLEAN, Cons.cons(Stella.NIL, Stella.NIL)))))))))), true, false);
        Description pattern = null;
        Stella_Object recordjustificationsP = theoptions.lookupWithDefault(Logic.KWD_RECORD_JUSTIFICATIONSp, Stella.FALSE_WRAPPER);

        if (theoptions.lookup(Logic.KWD_PATTERN) != null) {
          pattern = ((Description)(Logic.conceiveTerm(theoptions.lookup(Logic.KWD_PATTERN))));
        }
        { Object old$RecordJustificationsP$000 = Logic.$RECORD_JUSTIFICATIONSp$.get();

          try {
            Native.setBooleanSpecial(Logic.$RECORD_JUSTIFICATIONSp$, ((Boolean)(Logic.$RECORD_JUSTIFICATIONSp$.get())).booleanValue() ||
                BooleanWrapper.coerceWrappedBooleanToBoolean(((BooleanWrapper)(recordjustificationsP))));
            return (QueryIterator.updatePropositionsFromQuery(Logic.getQueryIteratorFromCommand(query), Logic.coerceToDescription(((pattern != null) ? pattern : theoptions.lookup(Logic.KWD_RELATION)), null), ((Module)(theoptions.lookup(Logic.KWD_MODULE))), Logic.KWD_ASSERT_TRUE, BooleanWrapper.coerceWrappedBooleanToBoolean(((BooleanWrapper)(recordjustificationsP)))));

          } finally {
            Logic.$RECORD_JUSTIFICATIONSp$.set(old$RecordJustificationsP$000);
          }
        }
      }
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
    }
    return (null);
  }

  public static Cons assertFromQueryEvaluatorWrapper(Cons arguments) {
    return (Logic.assertFromQuery(((Cons)(arguments.value)), arguments.rest));
  }

  /** Evaluate <code>query</code> which has to be a strict or partial retrieval
   * command, instantiate the query proposition for each generated solution
   * and retract the resulting propositions.  See <code>assertFromQuery</code> for
   * available command options.
   * @param query
   * @param options
   * @return Cons
   */
  public static Cons retractFromQuery(Cons query, Cons options) {
    try {
      { PropertyList theoptions = Logic.parseLogicCommandOptions(options, Cons.list$(Cons.cons(Logic.KWD_MODULE, Cons.cons(Logic.SGT_STELLA_MODULE, Cons.cons(Logic.KWD_RELATION, Cons.cons(Logic.SGT_STELLA_SYMBOL, Cons.cons(Logic.KWD_PATTERN, Cons.cons(Logic.SGT_STELLA_CONS, Cons.cons(Stella.NIL, Stella.NIL)))))))), true, false);
        QueryIterator queryiterator = Logic.getQueryIteratorFromCommand(query);
        Description pattern = null;

        if (theoptions.lookup(Logic.KWD_PATTERN) != null) {
          pattern = ((Description)(Logic.conceiveTerm(theoptions.lookup(Logic.KWD_PATTERN))));
        }
        return (QueryIterator.updatePropositionsFromQuery(queryiterator, Logic.coerceToDescription(((pattern != null) ? pattern : theoptions.lookup(Logic.KWD_RELATION)), null), ((Module)(theoptions.lookup(Logic.KWD_MODULE))), Logic.KWD_RETRACT_TRUE, false));
      }
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
    }
    return (null);
  }

  public static Cons retractFromQueryEvaluatorWrapper(Cons arguments) {
    return (Logic.retractFromQuery(((Cons)(arguments.value)), arguments.rest));
  }

  public static String displaySettings() {
    {
      Stella.STANDARD_OUTPUT.nativeStream.println();
      Stella.STANDARD_OUTPUT.nativeStream.println("*LAZY-SATELLITE-RULES?* =  " + Logic.$LAZY_SATELLITE_RULESp$);
      Stella.STANDARD_OUTPUT.nativeStream.println("*CACHE-SUCCEEDED-GOALS?* =  " + Logic.$CACHE_SUCCEEDED_GOALSp$);
      Stella.STANDARD_OUTPUT.nativeStream.println("*CACHE-FAILED-GOALS?* =  " + Logic.$CACHE_FAILED_GOALSp$);
      Stella.STANDARD_OUTPUT.nativeStream.println("*CACHE-GOAL-QUANTUM* =  " + Logic.$CACHE_GOAL_QUANTUM$);
      Stella.STANDARD_OUTPUT.nativeStream.println("*CACHE-INFERABLE-SUBCOLLECTIONS?* =  " + Logic.$CACHE_INFERABLE_SUBCOLLECTIONSp$);
      Stella.STANDARD_OUTPUT.nativeStream.println("*INFERENCELEVEL* =  " + ((NormalInferenceLevel)(Logic.$INFERENCELEVEL$.get())));
      Stella.STANDARD_OUTPUT.nativeStream.println("*MAXIMUM-BACKTRACKING-DEPTH* =  " + Logic.$MAXIMUM_BACKTRACKING_DEPTH$);
      Stella.STANDARD_OUTPUT.nativeStream.println("*TYPE-CHECK-STRATEGY* =  " + ((Keyword)(Logic.$TYPE_CHECK_STRATEGY$.get())));
      Stella.STANDARD_OUTPUT.nativeStream.println("*DUPLICATE-SUBGOAL-STRATEGY* =  " + Logic.$DUPLICATE_SUBGOAL_STRATEGY$);
      Stella.STANDARD_OUTPUT.nativeStream.println("*DUPLICATE-GOAL-SEARCH-DEPTH* =  " + Logic.$DUPLICATE_GOAL_SEARCH_DEPTH$);
      Stella.STANDARD_OUTPUT.nativeStream.println("*DUPLICATE-RULE-SEARCH-DEPTH* =  " + Logic.$DUPLICATE_RULE_SEARCH_DEPTH$);
      Stella.STANDARD_OUTPUT.nativeStream.println("*GLOBALLY-CLOSED-COLLECTIONS?* =  " + Logic.$GLOBALLY_CLOSED_COLLECTIONSp$);
      Stella.STANDARD_OUTPUT.nativeStream.println("*DEFAULT-MAXIMUM-DEPTH* =  " + Logic.$DEFAULT_MAXIMUM_DEPTH$);
      Stella.STANDARD_OUTPUT.nativeStream.println("*INITIAL-BACKTRACKING-DEPTH* =  " + Logic.$INITIAL_BACKTRACKING_DEPTH$);
      Stella.STANDARD_OUTPUT.nativeStream.println("*ITERATIVE-DEEPENING-MODE?* =  " + Logic.$ITERATIVE_DEEPENING_MODEp$);
      Stella.STANDARD_OUTPUT.nativeStream.println("*DUPLICATEINSTANCESCACHECROSSOVERPOINT* =  " + Logic.$DUPLICATEINSTANCESCACHECROSSOVERPOINT$);
      Stella.STANDARD_OUTPUT.nativeStream.println("*CLASSIFY-FROM-NON-INFERABLE-PARENTS-ONLY?* =  " + ((Boolean)(Logic.$CLASSIFY_FROM_NON_INFERABLE_PARENTS_ONLYp$.get())).booleanValue());
      Stella.STANDARD_OUTPUT.nativeStream.println();
    }
;
    return ("");
  }

  public static void setPartialMatchMode(Keyword k) {
    Logic.$PARTIAL_MATCH_MODE$ = k;
  }

  public static void setRuleCombination(Keyword k) {
    Logic.$RULE_COMBINATION$ = k;
  }

  public static void setGreedyNetworkPruning(boolean b) {
    Logic.$GREEDY_NETWORK_PRUNING$ = b;
  }

  public static void setGreedyNetworkPruningEvaluatorWrapper(Cons arguments) {
    Logic.setGreedyNetworkPruning(((BooleanWrapper)(arguments.value)).wrapperValue);
  }

  public static void setMaximumScoreCutoff(double c) {
    Logic.$MAXIMUM_SCORE_CUTOFF$ = c;
  }

  public static void setMaximumScoreCutoffEvaluatorWrapper(Cons arguments) {
    Logic.setMaximumScoreCutoff(((FloatWrapper)(arguments.value)).wrapperValue);
  }

  public static void setMinimumScoreCutoff(double c) {
    Logic.$MAXIMUM_SCORE_CUTOFF$ = c;
  }

  public static void setMinimumScoreCutoffEvaluatorWrapper(Cons arguments) {
    Logic.setMinimumScoreCutoff(((FloatWrapper)(arguments.value)).wrapperValue);
  }

  public static double probabilisticSumN(Cons form) {
    switch (form.length()) {
      case 0: 
        return (0.0);
      case 1: 
        return (((FloatWrapper)(form.value)).wrapperValue);
      default:
        { double sum = Logic.probabilisticSumN(form.rest);

          return (((FloatWrapper)(form.value)).wrapperValue + sum + (0 - (((FloatWrapper)(form.value)).wrapperValue * sum)));
        }
    }
  }

  public static double probabilisticSum(double x, double y) {
    return (x + y + (0 - (x * y)));
  }

  /** Partial-match version of <code>retrieve</code> (which see) that generates scored
   * partial solutions based on the current partial match strategy.  By supplying
   * <code>BEST</code> instead of <code>ALL</code>, or by adding the option <code>CSORT_BY_CSCORE</code>, the generated
   * solutions will be sorted so that solutions with higher scores come first.
   * Use the <code>CMATCH_MODE</code> option to override the global default setting established
   * by <code>setPartialMatchMode</code>, e.g., use <code>CMATCH_MODE_CNN</code> to use the neural
   * net partial match mode.  The <code>CMINIMUM_SCORE</code> option can be used to only
   * retrieve solutions that have at least the specified minimum match score.
   * By default, <code>retrievePartial</code> does not maximize the match scores of its returned
   * bindings.  To only get maximal scores use <code>CMAXIMIZE_SCOREP_TRUE</code> (this is not
   * yet implemented - you can use <code>askPartial</code> to maximize scores for individual
   * solutions by hand).
   * @param tree
   * @return QueryIterator
   */
  public static QueryIterator retrievePartial(Cons tree) {
    try {
      return (Logic.$MOST_RECENT_QUERY$ = Logic.callRetrievePartial(tree));
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
      return (Logic.$MOST_RECENT_QUERY$ = null);
    }
  }

  public static QueryIterator retrievePartialEvaluatorWrapper(Cons arguments) {
    return (Logic.retrievePartial(arguments));
  }

  /** Callable version of <code>retrievePartial</code> (which see).  Accepts queries
   * specified by a query iterator, or specified as a CONS-list of arguments as they
   * would be supplied to <code>retrievePartial</code>.  Raises LOGIC-EXCEPTIONs in case of
   * illegal queries and logical expressions.
   * @param query
   * @return QueryIterator
   */
  public static QueryIterator callRetrievePartial(Stella_Object query) {
    { QueryIterator thequery = Logic.createRetrieveQuery(query);

      QueryIterator.initializePartialQuery(thequery);
      thequery.partialMatchStrategy.retrievePartialSolutions(thequery);
      if (Logic.lookupQueryOption(thequery, Logic.KWD_SORT_BY) == Logic.KWD_SCORE) {
        QueryIterator.sortSolutionsByScore(thequery);
      }
      return (thequery);
    }
  }

  /** Similar to <code>ask</code> (which see), but return the highest partial match score
   * for the supplied proposition instead of a truth value.  If the option
   * :MAXIMIZE-SCORE? is set to FALSE, return after the first partial match score
   * has been generated.
   * @param propositionAoptions
   * @return double
   */
  public static double askPartial(Cons propositionAoptions) {
    Logic.$MOST_RECENT_QUERY$ = null;
    try {
      return (Logic.callAskPartial(propositionAoptions));
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
      Logic.$MOST_RECENT_QUERY$ = null;
      return (Stella.NULL_FLOAT);
    }
  }

  public static FloatWrapper askPartialEvaluatorWrapper(Cons arguments) {
    { double result = Logic.askPartial(arguments);

      if (result != Stella.NULL_FLOAT) {
        return (FloatWrapper.wrapFloat(result));
      }
      else {
        return (null);
      }
    }
  }

  public static double callAskPartial(Stella_Object query) {
    { QueryIterator thequery = Logic.createAskQuery(query);

      QueryIterator.initializePartialQuery(thequery);
      if (Logic.$MOST_RECENT_QUERY$ == null) {
        Logic.$MOST_RECENT_QUERY$ = thequery;
      }
      return (thequery.partialMatchStrategy.computePartialTruth(thequery));
    }
  }

  public static boolean nullInstanceP(Stella_Object x) {
    return (Logic.objectSurrogate(x) == Logic.SGT_PL_KERNEL_KB_NULL);
  }

  public static LogicObject getNullInstance() {
    return (((LogicObject)(Logic.SGT_PL_KERNEL_KB_NULL.surrogateValue)));
  }

  public static boolean nullInstancePropositionsExistP() {
    { BacklinksIndex index = Logic.getBacklinksIndex(Logic.getNullInstance());

      return ((index.predicatePropositionsTable != null) ||
          (!index.dependentPropositionsList.emptyP()));
    }
  }

  public static void setClosedWorldTrainingExamples(boolean b) {
    Logic.$CLOSED_WORLD_TRAINING_EXAMPLES$ = b;
  }

  public static void setClosedWorldTrainingExamplesEvaluatorWrapper(Cons arguments) {
    Logic.setClosedWorldTrainingExamples(((BooleanWrapper)(arguments.value)).wrapperValue);
  }

  /** Add a query and score pair to the master list of 
   *   training examples
   * @param form
   * @param score
   */
  public static void addTrainingExample(Cons form, double score) {
    { TrainingExample example = TrainingExample.newTrainingExample();

      example.query = Cons.copyConsList(form);
      example.score = score;
      Logic.$TRAINING_EXAMPLES$.push(example);
    }
  }

  public static void addTrainingExampleEvaluatorWrapper(Cons arguments) {
    Logic.addTrainingExample(((Cons)(arguments.value)), ((FloatWrapper)(arguments.rest.value)).wrapperValue);
  }

  public static void addTrainingExampleInModule(Cons form, double score, Symbol module) {
    module = ((Symbol)(module.permanentify()));
    { TrainingExample example = TrainingExample.newTrainingExample();

      example.query = Cons.copyConsList(form);
      example.score = score;
      example.module = Logic.getModule(module);
      Logic.$TRAINING_EXAMPLES$.push(example);
    }
  }

  public static void addTrainingExampleInModuleEvaluatorWrapper(Cons arguments) {
    Logic.addTrainingExampleInModule(((Cons)(arguments.value)), ((FloatWrapper)(arguments.rest.value)).wrapperValue, ((Symbol)(arguments.rest.rest.value)));
  }

  /** Add a query and score pair to the master list of 
   *   testing examples
   * @param form
   * @param score
   */
  public static void addTestingExample(Cons form, double score) {
    { TrainingExample example = TrainingExample.newTrainingExample();

      example.query = Cons.copyConsList(form);
      example.score = score;
      Logic.$TESTING_EXAMPLES$.push(example);
    }
  }

  public static void addTestingExampleEvaluatorWrapper(Cons arguments) {
    Logic.addTestingExample(((Cons)(arguments.value)), ((FloatWrapper)(arguments.rest.value)).wrapperValue);
  }

  public static void clearTrainingExamples() {
    Logic.$TRAINING_EXAMPLES$ = List.newList();
  }

  public static void shuffleList(List cards) {
    { int num = cards.length();
      double stop = num / 2.0;
      Stella_Object temp = null;
      int i = 0;
      int one = 0;
      int two = 0;

      while (i < stop) {
        i = i + 1;
        one = Stella.random(num);
        two = Stella.random(num);
        temp = cards.nth(one);
        cards.nthSetter(cards.nth(two), one);
        cards.nthSetter(temp, two);
      }
    }
  }

  public static void shuffleVector(Vector cards) {
    { int num = cards.length();
      double stop = num / 2.0;
      Stella_Object temp = null;
      int i = 0;
      int one = 0;
      int two = 0;

      while (i < stop) {
        i = i + 1;
        one = Stella.random(num);
        two = Stella.random(num);
        temp = (cards.theArray)[one];
        (cards.theArray)[one] = ((cards.theArray)[two]);
        (cards.theArray)[two] = temp;
      }
    }
  }

  public static void saveTrainingExamples() {
    { OutputFileStream nameFile = OutputFileStream.newOutputFileStream("training.names");
      OutputFileStream dataFile = OutputFileStream.newOutputFileStream("training.data");

      Logic.createPropositionalTrainingExamples(Logic.$TRAINING_EXAMPLES$, nameFile, dataFile);
      nameFile.free();
      dataFile.free();
    }
  }

  public static int createPropositionalTrainingExamples(List examples, OutputFileStream nameFile, OutputFileStream dataFile) {
    { int numInputs = 0;
      Module home = ((Module)(Stella.$MODULE$.get()));
      int temp = 0;
      Vector input = null;

      { TrainingExample example = null;
        Cons iter000 = examples.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          example = ((TrainingExample)(iter000.value));
          if (!(example.module == null)) {
            example.module.changeModule();
          }
          input = Logic.createInputSignature(example.query);
          example.input = input;
          home.changeModule();
          { IntegerWrapper ele = null;
            Vector vector000 = input;
            int index000 = 0;
            int length000 = vector000.length();

            for (;index000 < length000; index000 = index000 + 1) {
              ele = ((IntegerWrapper)((vector000.theArray)[index000]));
              temp = ele.wrapperValue;
              dataFile.nativeStream.print(temp + ",");
            }
          }
          dataFile.nativeStream.println(example.output.toString());
        }
      }
      numInputs = input.length();
      nameFile.nativeStream.println("true,false");
      { int i = Stella.NULL_INTEGER;
        int iter001 = 0;
        int upperBound000 = numInputs - 1;

        for (;iter001 <= upperBound000; iter001 = iter001 + 1) {
          i = iter001;
          nameFile.nativeStream.println("A" + Native.stringify(IntegerWrapper.wrapInteger(i)) + ":  1,0");
        }
      }
      return (numInputs);
    }
  }

  public static void fillInExampleOutputs(List examples, Symbol slotName) {
    { Surrogate slot = Logic.getDescription(slotName).surrogateValueInverse;
      Stella_Object slotValue = null;
      LogicObject instance = null;

      { TrainingExample example = null;
        Cons iter000 = examples.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          example = ((TrainingExample)(iter000.value));
          if (example.module != null) {
            example.module.changeModule();
          }
          instance = ((LogicObject)(Logic.getInstance(example.query.rest.value)));
          slotValue = LogicObject.getSlotValue(instance, slot);
          example.output = slotValue;
        }
      }
    }
  }

  public static void detectNoiseInTrainingExamples(List examples) {
    { Module home = ((Module)(Stella.$MODULE$.get()));
      int sigLength = 0;
      boolean same = true;

      { TrainingExample example = null;
        Cons iter000 = examples.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          example = ((TrainingExample)(iter000.value));
          if (example.input == null) {
            if (!(example.module == null)) {
              example.module.changeModule();
            }
            example.input = Logic.createInputSignature(example.query);
            home.changeModule();
          }
        }
      }
      sigLength = ((TrainingExample)(examples.first())).input.length();
      { TrainingExample example1 = null;
        Cons iter001 = examples.theConsList;

        for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
          example1 = ((TrainingExample)(iter001.value));
          { TrainingExample example2 = null;
            Cons iter002 = examples.theConsList;

            for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
              example2 = ((TrainingExample)(iter002.value));
              same = true;
              { int k = Stella.NULL_INTEGER;
                int iter003 = 0;
                int upperBound000 = sigLength - 1;

                loop003 : for (;iter003 <= upperBound000; iter003 = iter003 + 1) {
                  k = iter003;
                  if (!Stella_Object.eqlP((example1.input.theArray)[k], (example2.input.theArray)[k])) {
                    same = false;
                    break loop003;
                  }
                }
              }
              if (same &&
                  (!Stella_Object.eqlP(example1.output, example2.output))) {
                Stella.STANDARD_OUTPUT.nativeStream.println(example1.query.last() + " and " + example2.query.last() + " have the same input but different output");
              }
            }
          }
        }
      }
    }
  }

  public static List getClassificationRelations(Cons consQuery) {
    { QueryIterator query = Logic.makeQuery(Stella.NIL, ((Cons)(Stella_Object.copyConsTree(consQuery))), Stella.NIL, Stella.NIL);
      List result = List.newList();
      IncrementalPartialMatch pmf = null;

      query.options.insertAt(Logic.KWD_MATCH_MODE, Logic.KWD_BASIC);
      query.options.insertAt(Logic.KWD_MAXIMIZE_SCOREp, Stella.TRUE_WRAPPER);
      Logic.callAskPartial(query);
      pmf = ((IncrementalPartialMatch)(query.baseControlFrame.partialMatchFrame.child.child));
      { Proposition prop = null;
        Vector vector000 = ((Vector)(pmf.controlFrame.proposition.arguments));
        int index000 = 0;
        int length000 = vector000.length();
        Cons collect000 = null;

        for (;index000 < length000; index000 = index000 + 1) {
          prop = ((Proposition)((vector000.theArray)[index000]));
          if (collect000 == null) {
            {
              collect000 = Cons.cons(prop, Stella.NIL);
              if (result.theConsList == Stella.NIL) {
                result.theConsList = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(result.theConsList, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(prop, Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      return (result);
    }
  }

  public static Vector createInputSignature(Cons consQuery) {
    { QueryIterator query = Logic.makeQuery(Stella.NIL, ((Cons)(Stella_Object.copyConsTree(consQuery))), Stella.NIL, Stella.NIL);
      IncrementalPartialMatch pmf = null;
      Cons argScores = Stella.NIL;
      Vector signature = null;

      Logic.$FAIL_UNBOUND_CLAUSESp$ = true;
      query.options.insertAt(Logic.KWD_MATCH_MODE, Logic.KWD_BASIC);
      query.options.insertAt(Logic.KWD_MAXIMIZE_SCOREp, Stella.TRUE_WRAPPER);
      Logic.callAskPartial(query);
      pmf = ((IncrementalPartialMatch)(query.baseControlFrame.partialMatchFrame.child.child));
      argScores = pmf.argumentScores;
      signature = Vector.newVector(argScores.length());
      { Stella_Object score = null;
        Cons iter000 = argScores.reverse();
        int i = Stella.NULL_INTEGER;
        int iter001 = 0;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
          score = iter000.value;
          i = iter001;
          if (Stella_Object.eqlP(score, FloatWrapper.wrapFloat(1.0))) {
            (signature.theArray)[i] = (IntegerWrapper.wrapInteger(1));
          }
          else {
            (signature.theArray)[i] = (IntegerWrapper.wrapInteger(0));
          }
        }
      }
      return (signature);
    }
  }

  public static void generateClassificationRule(Vector instances, Symbol conceptName, Symbol className, boolean buildRuleP) {
    { int numInstances = instances.length();
      Surrogate kind = Logic.getDescription(className).surrogateValueInverse;
      Symbol name = null;
      Proposition prop = null;
      boolean functionValuesP = Logic.$DROP_FUNCTION_VALUESp$;

      Logic.$DROP_FUNCTION_VALUESp$ = false;
      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = numInstances - 1;

        for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
          i = iter000;
          name = Logic.objectName(((LogicObject)((instances.theArray)[i])));
          prop = ((Proposition)(Logic.conceiveFormula(Cons.consList(Cons.cons(conceptName, Cons.cons(name, Stella.NIL))))));
          if (Proposition.trueP(prop)) {
            Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_RETRACT_TRUE);
            LogicObject.buildCaseFromInstance(((LogicObject)((instances.theArray)[i])), kind);
            Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_ASSERT_TRUE);
          }
          if (Proposition.falseP(prop)) {
            Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_RETRACT_FALSE);
            LogicObject.buildCaseFromInstance(((LogicObject)((instances.theArray)[i])), kind);
            Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_ASSERT_FALSE);
          }
        }
      }
      Logic.$DROP_FUNCTION_VALUESp$ = functionValuesP;
      if (buildRuleP) {
        Logic.buildClassificationRule(conceptName, className);
      }
    }
  }

  public static void buildClassificationRule(Symbol kind, Symbol className) {
    { Symbol ruleName = Symbol.internSymbol(kind.symbolName + "-Classification-Rule");
      Symbol relationName = Symbol.internSymbol(kind.symbolName + "-Classification");
      String index = className.symbolName + "-match";
      List ruleAntecedent = ((List)(Logic.$CASE_ANTECEDENT_TABLE$.lookup(index)));
      Cons convertedAntecedent = Stella.NIL;
      List ruleTypes = ((List)(Logic.$CASE_TYPES_TABLE$.lookup(index)));
      Cons convertedTypes = Stella.NIL;
      Cons relation = Cons.list$(Cons.cons(Logic.SYM_LOGIC_DEFRELATION, Cons.cons(relationName, Cons.cons(Cons.cons(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_pP, Cons.cons(Logic.SYM_STELLA_THING, Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL), Stella.NIL), Stella.NIL))));
      Cons rule = Stella.NIL;

      { Cons clause = null;
        Cons iter000 = ruleAntecedent.theConsList;
        Cons collect000 = null;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          clause = ((Cons)(iter000.value));
          if (collect000 == null) {
            {
              collect000 = Cons.cons(clause, Stella.NIL);
              if (convertedAntecedent == Stella.NIL) {
                convertedAntecedent = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(convertedAntecedent, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(clause, Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      { Symbol type = null;
        Cons iter001 = ruleTypes.theConsList;
        Cons collect001 = null;

        for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
          type = ((Symbol)(iter001.value));
          if (collect001 == null) {
            {
              collect001 = Cons.cons(type, Stella.NIL);
              if (convertedTypes == Stella.NIL) {
                convertedTypes = collect001;
              }
              else {
                Cons.addConsToEndOfConsList(convertedTypes, collect001);
              }
            }
          }
          else {
            {
              collect001.rest = Cons.cons(type, Stella.NIL);
              collect001 = collect001.rest;
            }
          }
        }
      }
      rule = Cons.list$(Cons.cons(Logic.SYM_LOGIC_DEFRULE, Cons.cons(ruleName, Cons.cons(Cons.list$(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_FORALL, Cons.cons(convertedTypes, Cons.cons(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_eg, Cons.cons(Cons.cons(Logic.SYM_STELLA_AND, convertedAntecedent.concatenate(Stella.NIL, Stella.NIL)), Cons.cons(Cons.cons(relationName, Cons.cons(Logic.SYM_LOGIC_pY, Stella.NIL)), Cons.cons(Stella.NIL, Stella.NIL))))), Stella.NIL), Stella.NIL)))), Cons.cons(Logic.KWD_DONT_OPTIMIZEp, Cons.cons(Logic.SYM_STELLA_TRUE, Cons.cons(Stella.NIL, Stella.NIL))))), Stella.NIL))));
      if (Logic.$LOG_MATCH_RULES$) {
        Stella.STANDARD_OUTPUT.nativeStream.println(rule.toString());
      }
      Stella.STANDARD_OUTPUT.nativeStream.println("Building classification rule with " + convertedAntecedent.length() + " clauses and " + convertedTypes.length() + " variables");
      if (!ruleAntecedent.emptyP()) {
        Logic.evaluateLogicCommand(relation, false);
        Logic.evaluateLogicCommand(rule, false);
      }
    }
  }

  public static int oldGenerateClassificationTrainingExamples(Vector instances, Surrogate concept) {
    { int numInstances = instances.length();
      Cons consQuery = Stella.NIL;
      boolean target = false;
      Symbol conceptName = Symbol.internSymbol(concept.symbolName);

      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = numInstances - 1;

        for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
          i = iter000;
          { TrainingExample example = TrainingExample.newTrainingExample();

            target = TruthValue.trueTruthValueP(Logic.callAsk(Logic.makeQuery(Stella.NIL, Cons.consList(Cons.cons(conceptName, Cons.cons(Logic.objectName(((LogicObject)((instances.theArray)[i]))), Stella.NIL))), Stella.NIL, Stella.NIL)));
            consQuery = Cons.consList(Cons.cons(Symbol.internSymbol(conceptName.symbolName + "-Classification"), Cons.cons(Logic.objectName(((LogicObject)((instances.theArray)[i]))), Stella.NIL)));
            example.query = consQuery;
            example.output = (target ? Stella.TRUE_WRAPPER : Stella.FALSE_WRAPPER);
            example.concept = conceptName;
            example.name = Logic.objectName(((LogicObject)((instances.theArray)[i])));
            example.module = ((Module)(Stella.$MODULE$.get()));
            example.input = Logic.createInputSignature(consQuery);
            example.timestamp = -1;
            Logic.$TRAINING_EXAMPLES$.push(example);
          }
        }
      }
      return (numInstances);
    }
  }

  public static void testDomainTheory(Symbol relationName, Symbol className) {
    { Surrogate renamed_Class = Logic.getDescription(className).surrogateValueInverse;
      Proposition prop = null;
      Cons consQuery = Stella.NIL;
      QueryIterator query = null;
      List instances = Logic.allClassInstances(renamed_Class).listify();
      boolean correctP = true;
      int numCorrect = 0;

      { Stella_Object instance = null;
        Cons iter000 = instances.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          instance = iter000.value;
          consQuery = Cons.consList(Cons.cons(relationName, Cons.cons(Logic.objectName(instance), Stella.NIL)));
          prop = ((Proposition)(Logic.conceiveFormula(((Cons)(Stella_Object.copyConsTree(consQuery))))));
          correctP = true;
          if (Proposition.trueP(prop)) {
            Stella.STANDARD_OUTPUT.nativeStream.println(consQuery + " is true");
            Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_RETRACT_TRUE);
            query = Logic.makeQuery(Stella.NIL, ((Cons)(Stella_Object.copyConsTree(Cons.list$(Cons.cons(Logic.SYM_STELLA_NOT, Cons.cons(consQuery, Cons.cons(Stella.NIL, Stella.NIL))))))), Stella.NIL, Stella.NIL);
            if (TruthValue.trueTruthValueP(Logic.callAsk(query))) {
              correctP = false;
              Stella.STANDARD_OUTPUT.nativeStream.println("  **Theory disproves " + consQuery + " true");
            }
            query = Logic.makeQuery(Stella.NIL, ((Cons)(Stella_Object.copyConsTree(consQuery))), Stella.NIL, Stella.NIL);
            if (TruthValue.unknownTruthValueP(Logic.callAsk(query))) {
              correctP = false;
              Stella.STANDARD_OUTPUT.nativeStream.println("  **Theory cannot prove " + consQuery);
            }
            Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_ASSERT_TRUE);
          }
          if (Proposition.falseP(prop)) {
            Stella.STANDARD_OUTPUT.nativeStream.println(consQuery + " is false");
            Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_RETRACT_FALSE);
            query = Logic.makeQuery(Stella.NIL, ((Cons)(Stella_Object.copyConsTree(consQuery))), Stella.NIL, Stella.NIL);
            if (TruthValue.trueTruthValueP(Logic.callAsk(query))) {
              correctP = false;
              Stella.STANDARD_OUTPUT.nativeStream.println("  **Theory proves " + consQuery + "true");
            }
            query = Logic.makeQuery(Stella.NIL, ((Cons)(Stella_Object.copyConsTree(Cons.list$(Cons.cons(Logic.SYM_STELLA_NOT, Cons.cons(consQuery, Cons.cons(Stella.NIL, Stella.NIL))))))), Stella.NIL, Stella.NIL);
            if (TruthValue.unknownTruthValueP(Logic.callAsk(query))) {
              correctP = false;
              Stella.STANDARD_OUTPUT.nativeStream.println("  **Theory cannot disprove " + consQuery);
            }
            Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_ASSERT_FALSE);
          }
          if (correctP) {
            numCorrect = numCorrect + 1;
          }
        }
      }
      {
        Stella.STANDARD_OUTPUT.nativeStream.println();
        Stella.STANDARD_OUTPUT.nativeStream.println("Theory got " + numCorrect + " out of " + instances.length());
      }
;
    }
  }

  public static double testTheoryOverExamples(List examples) {
    { double correct = 0.0;
      QueryIterator query = null;
      Cons consQuery = Stella.NIL;
      Proposition prop = null;

      { TrainingExample example = null;
        Cons iter000 = examples.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          example = ((TrainingExample)(iter000.value));
          consQuery = ((Cons)(Stella_Object.copyConsTree(example.query)));
          prop = ((Proposition)(Logic.conceiveFormula(((Cons)(Stella_Object.copyConsTree(consQuery))))));
          query = Logic.makeQuery(Stella.NIL, ((Cons)(Stella_Object.copyConsTree(example.query))), Stella.NIL, Stella.NIL);
          if (Surrogate.subtypeOfBooleanP(Stella_Object.safePrimaryType(example.output))) {
            if (BooleanWrapper.coerceWrappedBooleanToBoolean(((BooleanWrapper)(example.output)))) {
              {
                Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_RETRACT_TRUE);
                if (TruthValue.trueTruthValueP(Logic.callAsk(query))) {
                  correct = correct + 1;
                }
                Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_ASSERT_TRUE);
              }
            }
            else {
              {
                Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_RETRACT_FALSE);
                if (TruthValue.unknownTruthValueP(Logic.callAsk(query))) {
                  correct = correct + 1;
                }
                Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_ASSERT_FALSE);
              }
            }
          }
          else {
          }
        }
      }
      return (correct / examples.length());
    }
  }

  public static int generateTrainingExamples(Vector instances, Surrogate concept) {
    { int numInstances = instances.length();
      Cons consQuery = Stella.NIL;
      int numExamples = 0;
      TrainingExample example = null;
      Proposition prop = null;
      QueryIterator query = null;
      Symbol conceptName = Symbol.internSymbol(concept.symbolName);

      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = numInstances - 1;

        for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
          i = iter000;
          consQuery = Cons.consList(Cons.cons(conceptName, Cons.cons(Logic.objectName(((LogicObject)((instances.theArray)[i]))), Stella.NIL)));
          prop = ((Proposition)(Logic.conceiveFormula(((Cons)(Stella_Object.copyConsTree(consQuery))))));
          example = null;
          if (Proposition.trueP(prop)) {
            {
              Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_RETRACT_TRUE);
              query = Logic.makeQuery(Stella.NIL, ((Cons)(Stella_Object.copyConsTree(consQuery))), Stella.NIL, Stella.NIL);
              if (TruthValue.unknownTruthValueP(Logic.callAsk(query))) {
                example = TrainingExample.newTrainingExample();
                example.query = consQuery;
                example.output = Stella.TRUE_WRAPPER;
                example.concept = conceptName;
                example.name = Logic.objectName(((LogicObject)((instances.theArray)[i])));
                example.score = 1.0;
              }
              Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_ASSERT_TRUE);
            }
          }
          else {
            if (Proposition.falseP(prop) ||
                Logic.$CLOSED_WORLD_TRAINING_EXAMPLES$) {
              {
                example = TrainingExample.newTrainingExample();
                example.query = consQuery;
                example.output = Stella.FALSE_WRAPPER;
                example.concept = conceptName;
                example.name = Logic.objectName(((LogicObject)((instances.theArray)[i])));
                example.score = 0.0;
              }
            }
          }
          if (!(example == null)) {
            example.module = ((Module)(Stella.$MODULE$.get()));
            example.timestamp = -1;
            numExamples = numExamples + 1;
            Logic.$TRAINING_EXAMPLES$.push(example);
          }
        }
      }
      return (numExamples);
    }
  }

  public static int generateClassificationTrainingExamples(Vector instances, Surrogate concept, boolean createSignatureP) {
    { int numInstances = instances.length();
      Cons consQuery = Stella.NIL;
      int numExamples = 0;
      TrainingExample example = null;
      Proposition prop = null;
      Cons classificationQuery = Stella.NIL;
      QueryIterator query = null;
      Symbol conceptName = Symbol.internSymbol(concept.symbolName);

      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = numInstances - 1;

        for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
          i = iter000;
          consQuery = Cons.consList(Cons.cons(conceptName, Cons.cons(Logic.objectName(((LogicObject)((instances.theArray)[i]))), Stella.NIL)));
          classificationQuery = Cons.consList(Cons.cons(Symbol.internSymbol(conceptName.symbolName + "-Classification"), Cons.cons(Logic.objectName(((LogicObject)((instances.theArray)[i]))), Stella.NIL)));
          prop = ((Proposition)(Logic.conceiveFormula(((Cons)(Stella_Object.copyConsTree(consQuery))))));
          example = null;
          if (Proposition.trueP(prop)) {
            {
              Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_RETRACT_TRUE);
              query = Logic.makeQuery(Stella.NIL, ((Cons)(Stella_Object.copyConsTree(consQuery))), Stella.NIL, Stella.NIL);
              if (TruthValue.unknownTruthValueP(Logic.callAsk(query))) {
                example = TrainingExample.newTrainingExample();
                example.query = classificationQuery;
                example.output = Stella.TRUE_WRAPPER;
                example.concept = conceptName;
                example.name = Logic.objectName(((LogicObject)((instances.theArray)[i])));
                example.score = 1.0;
              }
              Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_ASSERT_TRUE);
            }
          }
          else {
            if (Proposition.falseP(prop) ||
                Logic.$CLOSED_WORLD_TRAINING_EXAMPLES$) {
              {
                example = TrainingExample.newTrainingExample();
                example.query = classificationQuery;
                example.output = Stella.FALSE_WRAPPER;
                example.concept = conceptName;
                example.name = Logic.objectName(((LogicObject)((instances.theArray)[i])));
                example.score = 0.0;
              }
            }
          }
          if (!(example == null)) {
            if (createSignatureP) {
              example.input = Logic.createInputSignature(classificationQuery);
            }
            example.module = ((Module)(Stella.$MODULE$.get()));
            example.timestamp = -1;
            numExamples = numExamples + 1;
            Logic.$TRAINING_EXAMPLES$.push(example);
          }
        }
      }
      return (numExamples);
    }
  }

  public static void generateRegressionRuleWoSlot(Vector cases, Symbol slotName, Symbol className, boolean reallyBuildRule) {
    { int numCases = cases.length();
      Surrogate kind = Logic.getDescription(className).surrogateValueInverse;
      List caseNames = List.newList();
      Surrogate slot = Logic.getDescription(slotName).surrogateValueInverse;
      Vector slotValues = Vector.newVector(numCases);
      boolean functionValuesP = Logic.$DROP_FUNCTION_VALUESp$;

      Logic.$DROP_FUNCTION_VALUESp$ = false;
      { LogicObject renamed_Case = null;
        Vector vector000 = cases;
        int index000 = 0;
        int length000 = vector000.length();
        Cons collect000 = null;

        for (;index000 < length000; index000 = index000 + 1) {
          renamed_Case = ((LogicObject)((vector000.theArray)[index000]));
          if (collect000 == null) {
            {
              collect000 = Cons.cons(Logic.objectName(renamed_Case), Stella.NIL);
              if (caseNames.theConsList == Stella.NIL) {
                caseNames.theConsList = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(caseNames.theConsList, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(Logic.objectName(renamed_Case), Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      { LogicObject renamed_Case = null;
        Vector vector001 = cases;
        int index001 = 0;
        int length001 = vector001.length();
        Symbol caseName = null;
        Cons iter000 = caseNames.theConsList;
        int i = Stella.NULL_INTEGER;
        int iter001 = 0;

        for (;(index001 < length001) &&
                  (!(iter000 == Stella.NIL)); 
              index001 = index001 + 1,
              iter000 = iter000.rest,
              iter001 = iter001 + 1) {
          renamed_Case = ((LogicObject)((vector001.theArray)[index001]));
          caseName = ((Symbol)(iter000.value));
          i = iter001;
          { Stella_Object val = LogicObject.getSlotValue(renamed_Case, slot);

            (slotValues.theArray)[i] = val;
            if (!(val == null)) {
              Logic.smartUpdateProposition(Cons.cons(slotName, Cons.cons(caseName, Cons.cons(val, Stella.NIL))), Logic.KWD_RETRACT_TRUE);
            }
          }
        }
      }
      { int i = Stella.NULL_INTEGER;
        int iter002 = 0;
        int upperBound000 = numCases - 1;

        for (;iter002 <= upperBound000; iter002 = iter002 + 1) {
          i = iter002;
          if (!((slotValues.theArray)[i] == null)) {
            LogicObject.buildCaseFromInstance(((LogicObject)((cases.theArray)[i])), kind);
          }
        }
      }
      if (reallyBuildRule) {
        Logic.buildClassificationRule(slotName, className);
      }
      Logic.$DROP_FUNCTION_VALUESp$ = functionValuesP;
      { Stella_Object val = null;
        Vector vector002 = slotValues;
        int index002 = 0;
        int length002 = vector002.length();
        Symbol caseName = null;
        Cons iter003 = caseNames.theConsList;

        for (;(index002 < length002) &&
                  (!(iter003 == Stella.NIL)); index002 = index002 + 1, iter003 = iter003.rest) {
          val = (vector002.theArray)[index002];
          caseName = ((Symbol)(iter003.value));
          if (!(val == null)) {
            Logic.smartUpdateProposition(Cons.cons(slotName, Cons.cons(caseName, Cons.cons(val, Stella.NIL))), Logic.KWD_ASSERT_TRUE);
          }
        }
      }
    }
  }

  public static int generateRegressionTrainingExamples(Vector instances, Surrogate slot) {
    { int numInstances = instances.length();
      Symbol predName = Symbol.internSymbol(slot.symbolName + "-Classification");
      Vector slotValues = Vector.newVector(numInstances);

      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = numInstances - 1;
        LogicObject inst = null;
        Vector vector000 = instances;
        int index000 = 0;
        int length000 = vector000.length();

        for (;(iter000 <= upperBound000) &&
                  (index000 < length000); iter000 = iter000 + 1, index000 = index000 + 1) {
          i = iter000;
          inst = ((LogicObject)((vector000.theArray)[index000]));
          (slotValues.theArray)[i] = (((FloatWrapper)(LogicObject.getSlotValue(inst, slot))));
        }
      }
      Logic.normalizeNumbers(slotValues);
      { int i = Stella.NULL_INTEGER;
        int iter001 = 0;
        int upperBound001 = numInstances - 1;

        for (;iter001 <= upperBound001; iter001 = iter001 + 1) {
          i = iter001;
          if (!(((FloatWrapper)((slotValues.theArray)[i])) == null)) {
            { TrainingExample example = TrainingExample.newTrainingExample();

              example.query = Cons.cons(predName, Cons.cons(Logic.logicSymbol(((LogicObject)((instances.theArray)[i]))), Stella.NIL));
              example.concept = Symbol.internSymbol(slot.symbolName);
              example.name = Logic.objectName(((LogicObject)((instances.theArray)[i])));
              example.score = ((FloatWrapper)((slotValues.theArray)[i])).wrapperValue;
              example.timestamp = -1;
              Logic.$TRAINING_EXAMPLES$.push(example);
            }
          }
        }
      }
      return (numInstances);
    }
  }

  public static double approximate(Symbol instName, Symbol slotName) {
    instName = ((Symbol)(instName.permanentify()));
    slotName = ((Symbol)(slotName.permanentify()));
    { Surrogate slot = Logic.getDescription(slotName).surrogateValueInverse;

      if (Logic.floatFunctionP(slot)) {
        return (Logic.generateSlotApproximation(instName, slot));
      }
      else {
        {
          Stella.STANDARD_ERROR.nativeStream.println("ERROR " + slotName + " is not a function of type float or integer");
          return (0.0);
        }
      }
    }
  }

  public static FloatWrapper approximateEvaluatorWrapper(Cons arguments) {
    { double result = Logic.approximate(((Symbol)(arguments.value)), ((Symbol)(arguments.rest.value)));

      if (result != Stella.NULL_FLOAT) {
        return (FloatWrapper.wrapFloat(result));
      }
      else {
        return (null);
      }
    }
  }

  public static double generateSlotApproximation(Symbol instName, Surrogate slot) {
    { Stella_Object probe = Logic.getInstance(instName);
      Surrogate renamed_Class = ((LogicObject)(LogicObject.getMostSpecificClasses(((LogicObject)(probe))).last())).surrogateValueInverse;
      Symbol ruleName = Symbol.internSymbol(slot.symbolName + "-Classification");
      List instances = Logic.allClassInstances(renamed_Class).listify();
      double max = 0.0;
      double score = 0.0;
      double min = 999999.0;
      double range = 0.0;
      Cons prop = Cons.cons(ruleName, Cons.cons(instName, Stella.NIL));

      { Stella_Object instance = null;
        Cons iter000 = instances.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          instance = iter000.value;
          { Stella_Object value = LogicObject.getSlotValue(((LogicObject)(instance)), slot);

            if (!(value == null)) {
              { double flValue = ((FloatWrapper)(value)).wrapperValue;

                if (flValue > max) {
                  max = ((FloatWrapper)(value)).wrapperValue;
                }
                if (flValue < min) {
                  min = flValue;
                }
              }
            }
          }
        }
      }
      range = max - min;
      score = QueryIterator.returnPartialTruth(Logic.makeQuery(Stella.NIL, Logic.coerceToTree(prop), Stella.NIL, Stella.NIL), true);
      return ((score * range) + min);
    }
  }

  public static boolean floatFunctionP(Surrogate relation) {
    { NamedDescription des = ((NamedDescription)(relation.surrogateValue));

      if (NamedDescription.functionDescriptionP(des) &&
          (((Surrogate)(des.ioVariableTypes.last())) == Logic.SGT_STELLA_FLOAT)) {
        return (true);
      }
      else {
        return (false);
      }
    }
  }

  public static void setStructureDepth(int d) {
    Logic.$MAX_STRUCTURE_DEPTH$ = d;
  }

  public static void setStructureDepthEvaluatorWrapper(Cons arguments) {
    Logic.setStructureDepth(((IntegerWrapper)(arguments.value)).wrapperValue);
  }

  public static void addTabooOperators(Symbol s) {
    Logic.$TABOO_OPERATORS$.insertNew(s.surrogatify());
  }

  public static List getAssertionStructure(Symbol inst, int depth) {
    Logic.$VISITED_PROPOSITIONS$ = List.newList();
    Logic.$VISITED_INSTANCES$ = List.newList();
    return (Logic.helpGetAssertionStructure(inst, depth));
  }

  public static List helpGetAssertionStructure(Symbol inst, int depth) {
    Logic.$VISITED_INSTANCES$.push(inst);
    { Module home = ((Module)(inst.homeContext));
      List facts = List.newList();
      List antecedent = List.newList();
      List children = null;

      { Object old$Module$000 = Stella.$MODULE$.get();
        Object old$Context$000 = Stella.$CONTEXT$.get();

        try {
          Native.setSpecial(Stella.$MODULE$, home);
          Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
          facts = Logic.allFactsOfInstance(Logic.getInstance(inst), false, false);

        } finally {
          Stella.$CONTEXT$.set(old$Context$000);
          Stella.$MODULE$.set(old$Module$000);
        }
      }
      { Proposition fact = null;
        Cons iter000 = facts.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          fact = ((Proposition)(iter000.value));
          if ((!Logic.$VISITED_PROPOSITIONS$.memberP(fact)) &&
              ((Logic.$TABOO_OPERATORS$ == null) ||
               (!Logic.$TABOO_OPERATORS$.memberP(fact.operator)))) {
            Logic.$VISITED_PROPOSITIONS$.push(fact);
            { Cons consProp = Proposition.propositionToCons(fact);
              Cons consProps = Stella.NIL;

              if (fact.kind == Logic.KWD_ISA) {
                consProps = Cons.cons(consProp, consProps);
              }
              else if (depth < Logic.$MAX_STRUCTURE_DEPTH$) {
                if (fact.kind == Logic.KWD_FUNCTION) {
                  consProps = Cons.cons(consProp, consProps);
                  if (Stella_Object.isaP(consProp.last(), Logic.SGT_STELLA_NUMBER_WRAPPER)) {
                    { Cons skolemName = ((Cons)(Stella_Object.copyConsTree(consProp))).reverse().rest.reverse();
                      Stella_Object skolemValue = consProp.last();

                      consProps = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_ge, Cons.cons(((Cons)(Stella_Object.copyConsTree(skolemName))), Cons.cons(Cons.cons(skolemValue, Stella.NIL), Stella.NIL)))), consProps);
                      consProps = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_el, Cons.cons(((Cons)(Stella_Object.copyConsTree(skolemName))), Cons.cons(Cons.cons(skolemValue, Stella.NIL), Stella.NIL)))), consProps);
                    }
                  }
                }
                else {
                  if (!((consProp.value == Logic.SYM_STELLA_e) &&
                      Stella_Object.eqlP(consProp.rest.value, consProp.rest.rest.value))) {
                    consProps = Cons.cons(consProp, consProps);
                  }
                }
              }
              else {
              }
              if (!(consProps == Stella.NIL)) {
                { Cons prop = null;
                  Cons iter001 = consProps;

                  for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                    prop = ((Cons)(iter001.value));
                    antecedent.push(prop);
                  }
                }
                { Stella_Object ele = null;
                  Cons iter002 = consProp.rest;

                  for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
                    ele = iter002.value;
                    if (Stella_Object.isaP(ele, Logic.SGT_STELLA_SYMBOL) &&
                        ((!Logic.$VISITED_INSTANCES$.memberP(ele)) &&
                         (depth < Logic.$MAX_STRUCTURE_DEPTH$))) {
                      if (children == null) {
                        children = Logic.helpGetAssertionStructure(((Symbol)(ele)), depth + 1);
                      }
                      else {
                        children = Logic.helpGetAssertionStructure(((Symbol)(ele)), depth + 1).concatenate(children, Stella.NIL);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (children == null) {
        return (antecedent);
      }
      else {
        return (antecedent.concatenate(children, Stella.NIL));
      }
    }
  }

  public static void collectFactsInExamples(List examples) {
    { Proposition prop = null;

      { TrainingExample example = null;
        Cons iter000 = examples.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          example = ((TrainingExample)(iter000.value));
          if (example.module != null) {
            example.module.changeModule();
          }
          prop = ((Proposition)(Logic.conceiveFormula(example.query)));
          if (Proposition.trueP(prop)) {
            Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_RETRACT_TRUE);
            example.facts = Logic.getAssertionStructure(example.name, 1).consify();
            Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_ASSERT_TRUE);
          }
          if (Proposition.falseP(prop)) {
            Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_RETRACT_FALSE);
            example.facts = Logic.getAssertionStructure(example.name, 1).consify();
            Proposition.helpUpdateTopLevelProposition(prop, Logic.KWD_ASSERT_FALSE);
          }
        }
      }
    }
  }

  public static Cons oldRecursiveBuildAntecedent(Symbol inst, int depth) {
    Logic.$VISITED_INSTANCES$.push(inst);
    { Module home = ((Module)(inst.homeContext));
      List facts = List.newList();
      Cons antecedent = Stella.NIL;
      Cons children = Stella.NIL;

      { Object old$Module$000 = Stella.$MODULE$.get();
        Object old$Context$000 = Stella.$CONTEXT$.get();

        try {
          Native.setSpecial(Stella.$MODULE$, home);
          Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
          facts = Logic.allFactsOfInstance(Logic.getInstance(inst), false, false);

        } finally {
          Stella.$CONTEXT$.set(old$Context$000);
          Stella.$MODULE$.set(old$Module$000);
        }
      }
      { Proposition fact = null;
        Cons iter000 = facts.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          fact = ((Proposition)(iter000.value));
          if ((!Logic.$VISITED_PROPOSITIONS$.memberP(fact)) &&
              (!Logic.$TABOO_OPERATORS$.memberP(fact.operator))) {
            Logic.$VISITED_PROPOSITIONS$.push(fact);
            { Cons consProp = Proposition.propositionToCons(fact);

              { Keyword testValue000 = fact.kind;

                if (testValue000 == Logic.KWD_FUNCTION) {
                  if (Logic.$DROP_FUNCTION_VALUESp$) {
                    consProp = Cons.list$(Cons.cons(Logic.SYM_STELLA_e, Cons.cons(consProp.reverse().rest.reverse(), Cons.cons(Stella.NIL, Stella.NIL))));
                  }
                  else {
                    consProp = Cons.list$(Cons.cons(Logic.SYM_STELLA_AND, Cons.cons(consProp, Cons.cons(Stella.NIL, Stella.NIL))));
                  }
                }
                else if (testValue000 == Logic.KWD_ISA) {
                  consProp = Cons.list$(Cons.cons(Logic.SYM_STELLA_AND, Cons.cons(consProp, Cons.cons(Stella.NIL, Stella.NIL))));
                }
                else {
                  if (depth < Logic.$MAX_STRUCTURE_DEPTH$) {
                    consProp = Cons.list$(Cons.cons(Logic.SYM_STELLA_AND, Cons.cons(consProp, Cons.cons(Stella.NIL, Stella.NIL))));
                  }
                  else {
                    consProp = Stella.NIL;
                  }
                }
              }
              if (!(consProp == Stella.NIL)) {
                antecedent = Cons.cons(consProp, antecedent);
                { Stella_Object ele = null;
                  Cons iter001 = ((Cons)(consProp.rest.value)).rest;

                  for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                    ele = iter001.value;
                    if (Stella_Object.isaP(ele, Logic.SGT_STELLA_SYMBOL) &&
                        ((!Logic.$VISITED_INSTANCES$.memberP(ele)) &&
                         (depth < Logic.$MAX_STRUCTURE_DEPTH$))) {
                      children = Logic.oldRecursiveBuildAntecedent(((Symbol)(ele)), depth + 1).concatenate(children, Stella.NIL);
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (children == Stella.NIL) {
        return (antecedent);
      }
      else {
        return (antecedent.concatenate(children, Stella.NIL));
      }
    }
  }

  public static Stella_Object getArgumentBinding(Stella_Object arg) {
    { Stella_Object bind = Logic.argumentBoundTo(arg);

      if (bind == null) {
        return (Symbol.internSymbol(Skolem.getSkolemPrintName(((Skolem)(arg)))));
      }
      else {
        { Surrogate testValue000 = Stella_Object.safePrimaryType(bind);

          if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
            { Description bind000 = ((Description)(bind));

              return (bind000.nativeRelation());
            }
          }
          else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
            { Skolem bind000 = ((Skolem)(bind));

              if (bind000.definingProposition != null) {
                return (Proposition.propositionToCons(bind000.definingProposition));
              }
              else if (Stella.stringEqlP(Skolem.getSkolemPrintName(bind000), "ANONYMOUS")) {
                return (Symbol.internSymbol(Skolem.getSkolemPrintName(((Skolem)(arg)))));
              }
              else {
                return (bind000);
              }
            }
          }
          else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
            { LogicObject bind000 = ((LogicObject)(bind));

              return (Symbol.internSymbol(bind000.surrogateValueInverse.symbolName));
            }
          }
          else {
            return (bind);
          }
        }
      }
    }
  }

  public static Stella_Object consifyArgument(Stella_Object arg) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(arg);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition arg000 = ((Proposition)(arg));

          return (Proposition.propositionToCons(arg000));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable arg000 = ((PatternVariable)(arg));

          if (((QueryIterator)(Logic.$QUERYITERATOR$.get())) == null) {
            return (Symbol.internSymbol(Skolem.getSkolemPrintName(arg000)));
          }
          else {
            return (Logic.getArgumentBinding(arg000));
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        { NamedDescription arg000 = ((NamedDescription)(arg));

          return (Symbol.internSymbol(arg000.surrogateValueInverse.symbolName));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description arg000 = ((Description)(arg));

          throw ((LogicException)(LogicException.newLogicException("Can't consify").fillInStackTrace()));
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate arg000 = ((Surrogate)(arg));

          return (Symbol.internSymbol(((Surrogate)(arg000)).symbolName));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
        { Skolem arg000 = ((Skolem)(arg));

          if (((Stella_Object)(Stella_Object.accessInContext(arg000.variableValue, arg000.homeContext, false))) != null) {
            return (Logic.consifyArgument(((Stella_Object)(Stella_Object.accessInContext(arg000.variableValue, arg000.homeContext, false)))));
          }
          else {
            if (arg000.definingProposition != null) {
              { Proposition prop = arg000.definingProposition;
                Vector skArgs = prop.arguments;
                Cons consArgs = Stella.NIL;

                { int i = Stella.NULL_INTEGER;
                  int iter000 = 0;
                  int upperBound000 = skArgs.length() - 2;
                  Cons collect000 = null;

                  for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
                    i = iter000;
                    if (collect000 == null) {
                      {
                        collect000 = Cons.cons(Logic.consifyArgument((skArgs.theArray)[i]), Stella.NIL);
                        if (consArgs == Stella.NIL) {
                          consArgs = collect000;
                        }
                        else {
                          Cons.addConsToEndOfConsList(consArgs, collect000);
                        }
                      }
                    }
                    else {
                      {
                        collect000.rest = Cons.cons(Logic.consifyArgument((skArgs.theArray)[i]), Stella.NIL);
                        collect000 = collect000.rest;
                      }
                    }
                  }
                }
                return (Cons.cons(Symbol.internSymbol(Proposition.stringifiedKifOperator(prop)), consArgs));
              }
            }
            else {
              return (arg000);
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject arg000 = ((LogicObject)(arg));

          return (Symbol.internSymbol(arg000.surrogateValueInverse.symbolName));
        }
      }
      else {
        return (arg);
      }
    }
  }

  public static void thingifyUntypedInstances() {
    { LogicObject item = null;
      Iterator iter000 = Logic.allNamedInstances(((Module)(Stella.$MODULE$.get())), true);

      while (iter000.nextP()) {
        item = ((LogicObject)(iter000.value));
        if (Logic.allAssertedTypes(item) == Stella.NIL) {
          Logic.assertIsaProposition(item, Logic.SGT_STELLA_THING);
        }
      }
    }
  }

  public static void setSignatureStrategy(Keyword k) {
    Logic.$SIGNATURE_STRATEGY$ = k;
  }

  public static void setSignatureRules(boolean b) {
    Logic.$INDUCE_RULES_FROM_SIGNATURES$ = b;
  }

  public static void setSignatureRulesEvaluatorWrapper(Cons arguments) {
    Logic.setSignatureRules(((BooleanWrapper)(arguments.value)).wrapperValue);
  }

  public static void setRuleInductionStrategy(Keyword k) {
    Logic.$RULE_INDUCTION_STRATEGY$ = k;
  }

  public static void setRecursiveDecisionNodes(boolean b) {
    Logic.$ALLOW_RECURSIVE_DECISION_NODES$ = b;
  }

  public static void setRecursiveDecisionNodesEvaluatorWrapper(Cons arguments) {
    Logic.setRecursiveDecisionNodes(((BooleanWrapper)(arguments.value)).wrapperValue);
  }

  public static void induceInferenceRules(Symbol relationName, Symbol className) {
    relationName = ((Symbol)(relationName.permanentify()));
    Logic.clearCases();
    Logic.clearTrainingExamples();
    Logic.$INDUCED_DECISION_RULES$ = List.newList();
    className = ((Symbol)(className.permanentify()));
    { Surrogate renamed_Class = Logic.getDescription(className).surrogateValueInverse;
      Surrogate relation = Logic.getDescription(relationName).surrogateValueInverse;
      List ilist = Logic.allClassInstances(renamed_Class).listify();
      int num = ilist.length();
      Vector instances = Vector.newVector(num);

      { Stella_Object instance = null;
        Cons iter000 = ilist.theConsList;
        int i = Stella.NULL_INTEGER;
        int iter001 = 0;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
          instance = iter000.value;
          i = iter001;
          (instances.theArray)[i] = (((LogicObject)(instance)));
        }
      }
      if (Logic.$RULE_INDUCTION_STRATEGY$ == Logic.KWD_TOP_DOWN) {
        Logic.$ENABLE_USER_THING$ = true;
        if (!Logic.$ALLOW_RECURSIVE_DECISION_NODES$) {
          Logic.$TABOO_OPERATORS$.insertNew(relation);
        }
        Logic.generateClassificationRule(instances, relationName, className, true);
        { List clauses = ((List)(Logic.$CASE_ANTECEDENT_TABLE$.lookup(className.symbolName + "-match")));

          Logic.$CANDIDATE_CLAUSES$ = Vector.newVector(clauses.length());
          { Cons clause = null;
            Cons iter002 = clauses.theConsList;
            int i = Stella.NULL_INTEGER;
            int iter003 = 0;

            for (;!(iter002 == Stella.NIL); iter002 = iter002.rest, iter003 = iter003 + 1) {
              clause = ((Cons)(iter002.value));
              i = iter003;
              (Logic.$CANDIDATE_CLAUSES$.theArray)[i] = clause;
            }
          }
        }
        Stella.STANDARD_OUTPUT.nativeStream.println("Generating Training Examples");
        Logic.generateClassificationTrainingExamples(instances, relation, Logic.$INDUCE_RULES_FROM_SIGNATURES$);
        Logic.$OPTIMIZE_INDUCED_QUERIES$ = true;
        Stella.STANDARD_OUTPUT.nativeStream.println("Generating Decision Rules");
        Logic.topDownRuleInduction(Logic.$TRAINING_EXAMPLES$);
      }
      else if (Logic.$RULE_INDUCTION_STRATEGY$ == Logic.KWD_BOTTOM_UP) {
        Logic.$ENABLE_USER_THING$ = false;
        Logic.generateTrainingExamples(instances, relation);
        Logic.$OPTIMIZE_INDUCED_QUERIES$ = true;
        Logic.bottomUpRuleInduction(Logic.$TRAINING_EXAMPLES$, Logic.$SIMPLIFY_RULE_ANTECEDENTp$);
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + Logic.$RULE_INDUCTION_STRATEGY$ + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  public static void modularInduceInferenceRules(Symbol relationName, Symbol className, List modules) {
    Logic.clearTrainingExamples();
    Logic.clearCases();
    { Surrogate renamed_Class = Logic.getDescription(className).surrogateValueInverse;
      Surrogate relation = Logic.getDescription(relationName).surrogateValueInverse;
      List ilist = List.newList();
      Module home = ((Module)(Stella.$MODULE$.get()));
      boolean failUnbound = Logic.$FAIL_UNBOUND_CLAUSESp$;
      int num = ilist.length();
      Vector instanceVec = Vector.newVector(modules.length());
      Vector instances = null;

      Logic.$FAIL_UNBOUND_CLAUSESp$ = true;
      if (!Logic.$ALLOW_RECURSIVE_DECISION_NODES$) {
        Logic.$TABOO_OPERATORS$.insertNew(relation);
      }
      if (Logic.$RULE_INDUCTION_STRATEGY$ == Logic.KWD_TOP_DOWN) {
        Stella.STANDARD_OUTPUT.nativeStream.println("Building Classification Rule");
        Logic.$ENABLE_USER_THING$ = true;
        { Module module = null;
          Cons iter000 = modules.theConsList;
          int j = Stella.NULL_INTEGER;
          int iter001 = 0;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
            module = ((Module)(iter000.value));
            j = iter001;
            module.changeModule();
            ilist = Logic.allClassInstances(renamed_Class).listify();
            num = ilist.length();
            instances = Vector.newVector(num);
            { Stella_Object instance = null;
              Cons iter002 = ilist.theConsList;
              int i = Stella.NULL_INTEGER;
              int iter003 = 0;

              for (;!(iter002 == Stella.NIL); iter002 = iter002.rest, iter003 = iter003 + 1) {
                instance = iter002.value;
                i = iter003;
                (instances.theArray)[i] = (((LogicObject)(instance)));
              }
            }
            (instanceVec.theArray)[j] = instances;
            Logic.generateClassificationRule(instances, relationName, className, false);
          }
        }
        home.changeModule();
        Logic.buildClassificationRule(relationName, className);
        { List clauses = ((List)(Logic.$CASE_ANTECEDENT_TABLE$.lookup(className.symbolName + "-match")));

          Logic.$CANDIDATE_CLAUSES$ = Vector.newVector(clauses.length());
          { Cons clause = null;
            Cons iter004 = clauses.theConsList;
            int i = Stella.NULL_INTEGER;
            int iter005 = 0;

            for (;!(iter004 == Stella.NIL); iter004 = iter004.rest, iter005 = iter005 + 1) {
              clause = ((Cons)(iter004.value));
              i = iter005;
              (Logic.$CANDIDATE_CLAUSES$.theArray)[i] = clause;
            }
          }
        }
        Stella.STANDARD_OUTPUT.nativeStream.println("Generating Training Examples");
        { Module module = null;
          Cons iter006 = modules.theConsList;
          Vector vec = null;
          Vector vector000 = instanceVec;
          int index000 = 0;
          int length000 = vector000.length();

          for (;(!(iter006 == Stella.NIL)) &&
                    (index000 < length000); iter006 = iter006.rest, index000 = index000 + 1) {
            module = ((Module)(iter006.value));
            vec = ((Vector)((vector000.theArray)[index000]));
            module.changeModule();
            Logic.generateClassificationTrainingExamples(vec, relation, true);
          }
        }
        Stella.STANDARD_OUTPUT.nativeStream.println("Generating Inference Rules");
        Logic.topDownRuleInduction(Logic.$TRAINING_EXAMPLES$);
        Logic.$FAIL_UNBOUND_CLAUSESp$ = failUnbound;
      }
      else if (Logic.$RULE_INDUCTION_STRATEGY$ == Logic.KWD_BOTTOM_UP) {
        Logic.$ENABLE_USER_THING$ = false;
        { Module module = null;
          Cons iter007 = modules.theConsList;
          Vector vec = null;
          Vector vector001 = instanceVec;
          int index001 = 0;
          int length001 = vector001.length();

          for (;(!(iter007 == Stella.NIL)) &&
                    (index001 < length001); iter007 = iter007.rest, index001 = index001 + 1) {
            module = ((Module)(iter007.value));
            vec = ((Vector)((vector001.theArray)[index001]));
            vec = vec;
            module.changeModule();
            Logic.generateTrainingExamples(instances, relation);
          }
        }
        Logic.$OPTIMIZE_INDUCED_QUERIES$ = true;
        Logic.bottomUpRuleInduction(Logic.$TRAINING_EXAMPLES$, Logic.$SIMPLIFY_RULE_ANTECEDENTp$);
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + Logic.$RULE_INDUCTION_STRATEGY$ + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  public static void bottomUpRuleInduction(List examples, boolean simplifyRuleP) {
    { List positive = List.newList();
      List negative = List.newList();
      List allPositive = null;
      List allNegative = null;
      List rules = List.newList();
      Symbol concept = ((TrainingExample)(examples.first())).concept;
      Cons rule = Stella.NIL;

      { TrainingExample example = null;
        Cons iter000 = examples.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          example = ((TrainingExample)(iter000.value));
          if (BooleanWrapper.coerceWrappedBooleanToBoolean(((BooleanWrapper)(example.output)))) {
            positive.push(example);
          }
          else {
            negative.push(example);
          }
        }
      }
      allPositive = positive.copy();
      allNegative = negative.copy();
      Logic.collectFactsInExamples(positive);
      { TrainingExample example = null;
        Cons iter001 = positive.theConsList;

        for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
          example = ((TrainingExample)(iter001.value));
          example.facts = ((Cons)(Stella_Object.substituteConsTree(example.facts, Logic.SYM_LOGIC_pY, example.name)));
        }
      }
      Stella.STANDARD_OUTPUT.nativeStream.println("Starting rule induction with " + positive.length() + " positive and " + negative.length() + " negative examples");
      loop002 : while (!positive.emptyP()) {
        rule = Logic.learnOneRuleBottomUp(positive, negative);
        if (rule == Stella.NIL) {
          Stella.STANDARD_OUTPUT.nativeStream.println("Quiting with " + positive.length() + " examples uncovered");
          break loop002;
        }
        else if (simplifyRuleP &&
            allNegative.nonEmptyP()) {
          rule = Logic.simplifyAntecedent(rule, Stella.getQuotedTree("((?Y) \"/LOGIC\")", "/LOGIC"), allPositive, allNegative);
        }
        else {
        }
        rules.push(Cons.list$(Cons.cons(Logic.SYM_STELLA_eg, Cons.cons(Cons.cons(Logic.SYM_STELLA_AND, ((Cons)(Stella_Object.copyConsTree(rule))).concatenate(Stella.NIL, Stella.NIL)), Cons.cons(Cons.cons(concept, Cons.cons(Logic.SYM_LOGIC_pY, Stella.NIL)), Cons.cons(Stella.NIL, Stella.NIL))))));
      }
      {
        Stella.STANDARD_OUTPUT.nativeStream.println();
        Stella.STANDARD_OUTPUT.nativeStream.println("PowerLoom has induced the following rules");
        Stella.STANDARD_OUTPUT.nativeStream.println();
      }
;
      if (rules != null) {
        { Cons rule000 = null;
          Cons iter002 = rules.theConsList;

          for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
            rule000 = ((Cons)(iter002.value));
            Stella.STANDARD_OUTPUT.nativeStream.println(rule000.toString());
          }
        }
        Logic.$INDUCED_DECISION_RULES$ = rules;
      }
    }
  }

  public static void bottomUpRuleInductionEvaluatorWrapper(Cons arguments) {
    Logic.bottomUpRuleInduction(((List)(arguments.value)), ((BooleanWrapper)(arguments.rest.value)).wrapperValue);
  }

  public static Cons learnOneRuleBottomUp(List positive, List negative) {
    { Cons lgg = Stella.NIL;
      Cons rule = Stella.NIL;
      int score = 0;
      int numPositive = positive.length();
      int index1 = 0;
      int index2 = 0;
      Cons facts1 = Stella.NIL;
      Cons facts2 = Stella.NIL;
      int max = 0;
      int cover = 0;
      int numLggs = positive.length() * 5;
      Cons bestLgg = Stella.NIL;

      Stella.STANDARD_OUTPUT.nativeStream.println("Learning rule bottom up over " + positive.length() + " positives");
      max = 0;
      bestLgg = Stella.NIL;
      if (positive.length() == 1) {
        rule = ((TrainingExample)(positive.first())).facts;
        positive.pop();
        return (rule);
      }
      while (positive.nonEmptyP() &&
          ((max > 0) ||
           (rule == Stella.NIL))) {
        cover = max + cover;
        max = 0;
        Stella.STANDARD_OUTPUT.nativeStream.println("   Current rule covers " + cover + " positive examples");
        Stella.STANDARD_OUTPUT.nativeStream.println("           rule is " + rule);
        if (!(rule == Stella.NIL)) {
          Logic.removeCoveredExamples(rule, positive);
        }
        numLggs = positive.length() * 5;
        { int i = Stella.NULL_INTEGER;
          int iter000 = 1;
          int upperBound000 = numLggs;
          boolean unboundedP000 = upperBound000 == Stella.NULL_INTEGER;

          for (;unboundedP000 ||
                    (iter000 <= upperBound000); iter000 = iter000 + 1) {
            i = iter000;
            i = i;
            index1 = Stella.random(positive.length());
            facts1 = ((TrainingExample)(positive.nth(index1))).facts;
            if (rule == Stella.NIL) {
              {
                index2 = Stella.random(positive.length());
                while (index1 == index2) {
                  index2 = Stella.random(positive.length());
                }
                facts2 = ((TrainingExample)(positive.nth(index2))).facts;
              }
            }
            else {
              facts2 = rule;
            }
            lgg = Logic.leastGeneralGeneralization(facts1, facts2);
            if (!Logic.ruleCoversAnyExampleP(lgg, negative)) {
              score = Logic.numExamplesCovered(lgg, positive);
              if (score > max) {
                Stella.STANDARD_OUTPUT.nativeStream.println("   Best covers " + score + " positives");
                bestLgg = lgg;
                if ((cover + score) >= numPositive) {
                  Logic.removeCoveredExamples(lgg, positive);
                  return (Logic.removeRedundantClauses(lgg));
                }
                max = score;
              }
            }
          }
        }
        rule = bestLgg;
      }
      return (Logic.removeRedundantClauses(rule));
    }
  }

  public static boolean containsOutputVariableP(Cons clause, Cons outputVariables) {
    { Stella_Object term = null;
      Cons iter000 = clause;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        term = iter000.value;
        { Surrogate testValue000 = Stella_Object.safePrimaryType(term);

          if (Surrogate.subtypeOfSymbolP(testValue000)) {
            { Symbol term000 = ((Symbol)(term));

              if (outputVariables.memberP(term000)) {
                return (true);
              }
            }
          }
          else if (testValue000 == Logic.SGT_STELLA_CONS) {
            { Cons term000 = ((Cons)(term));

              if (Logic.containsOutputVariableP(term000, outputVariables)) {
                return (true);
              }
            }
          }
          else {
          }
        }
      }
    }
    return (false);
  }

  public static Cons simplifyAntecedent(Cons antecedent, Cons outputVariables, List positive, List negative) {
    { Cons newAntecedent = Stella.NIL;
      Cons candidate = Stella.NIL;
      Cons discardedPotentialGenerators = Stella.NIL;
      int coveredExamples = 0;
      int previousCoveredExamples = 0;
      int score = Logic.numExamplesCovered(antecedent, positive);

      while (!(antecedent == Stella.NIL)) {
        { Cons head000 = ((Cons)(antecedent.value));

          antecedent = antecedent.rest;
          candidate = head000;
        }
        if (Logic.ruleCoversAnyExampleP(Cons.append(newAntecedent, antecedent), negative)) {
          newAntecedent = Cons.cons(candidate, newAntecedent);
        }
        else {
          {
            Stella.STANDARD_OUTPUT.nativeStream.println("Removing clause " + candidate);
            if (Logic.containsOutputVariableP(candidate, outputVariables)) {
              discardedPotentialGenerators = Cons.cons(candidate, discardedPotentialGenerators);
            }
          }
        }
      }
      coveredExamples = Logic.numExamplesCovered(newAntecedent, positive);
      while ((!(discardedPotentialGenerators == Stella.NIL)) &&
          (coveredExamples < score)) {
        { Stella_Object head001 = discardedPotentialGenerators.value;

          discardedPotentialGenerators = discardedPotentialGenerators.rest;
          candidate = ((Cons)(head001));
        }
        previousCoveredExamples = coveredExamples;
        coveredExamples = Logic.numExamplesCovered(Cons.cons(candidate, newAntecedent), positive);
        if (coveredExamples > previousCoveredExamples) {
          Stella.STANDARD_OUTPUT.nativeStream.println("Reinserting clause " + candidate);
          newAntecedent = Cons.cons(candidate, newAntecedent);
        }
      }
      return (newAntecedent);
    }
  }

  public static Cons leastGeneralGeneralization(Cons clause1, Cons clause2) {
    { List matches = List.newList();
      Cons probe = Stella.NIL;
      Symbol operator = null;
      List bindings = List.newList();
      Cons newClause = Stella.NIL;
      List vars1 = Logic.getVariablesFromConsPropositions(Cons.consList(Cons.cons(clause1, Stella.NIL)));
      List vars2 = Logic.getVariablesFromConsPropositions(Cons.consList(Cons.cons(clause2, Stella.NIL)));
      boolean notP = false;
      Symbol var = null;
      Cons result = Stella.NIL;

      { Symbol var000 = null;
        Cons iter000 = vars1.theConsList;
        int i = Stella.NULL_INTEGER;
        int iter001 = 0;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
          var000 = ((Symbol)(iter000.value));
          i = iter001;
          if (!(var000 == Logic.SYM_LOGIC_pY)) {
            clause1 = ((Cons)(Stella_Object.substituteConsTree(clause1, var000, Symbol.internSymbol("?A" + Native.stringify(IntegerWrapper.wrapInteger(i))))));
          }
        }
      }
      { Symbol var000 = null;
        Cons iter002 = vars2.theConsList;
        int i = Stella.NULL_INTEGER;
        int iter003 = 0;

        for (;!(iter002 == Stella.NIL); iter002 = iter002.rest, iter003 = iter003 + 1) {
          var000 = ((Symbol)(iter002.value));
          i = iter003;
          if (!(var000 == Logic.SYM_LOGIC_pY)) {
            clause2 = ((Cons)(Stella_Object.substituteConsTree(clause1, var000, Symbol.internSymbol("?B" + Native.stringify(IntegerWrapper.wrapInteger(i))))));
          }
        }
      }
      Native.setIntSpecial(Logic.$BOTTOM_UP_VARIABLE_COUNTER$, 0);
      { Cons clause = null;
        Cons iter004 = ((Cons)(Stella_Object.copyConsTree(clause1)));

        for (;!(iter004 == Stella.NIL); iter004 = iter004.rest) {
          clause = ((Cons)(iter004.value));
          if (clause.value == Logic.SYM_STELLA_NOT) {
            {
              notP = true;
              probe = ((Cons)(clause.rest.value));
            }
          }
          else {
            {
              notP = false;
              probe = clause;
            }
          }
          operator = ((Symbol)(probe.value));
          matches = List.newList();
          { Cons potentialMatch = null;
            Cons iter005 = ((Cons)(Stella_Object.copyConsTree(clause2)));

            for (;!(iter005 == Stella.NIL); iter005 = iter005.rest) {
              potentialMatch = ((Cons)(iter005.value));
              if (notP &&
                  ((potentialMatch.value == Logic.SYM_STELLA_NOT) &&
                   (((Cons)(potentialMatch.rest.value)).value == operator))) {
                matches.push(((Cons)(potentialMatch.rest.value)));
              }
              if ((!notP) &&
                  (potentialMatch.value == operator)) {
                matches.push(potentialMatch);
              }
            }
          }
          if (!matches.emptyP()) {
            { Cons match = null;
              Cons iter006 = matches.theConsList;

              for (;!(iter006 == Stella.NIL); iter006 = iter006.rest) {
                match = ((Cons)(iter006.value));
                if ((operator == Logic.SYM_STELLA_g) ||
                    ((operator == Logic.SYM_STELLA_l) ||
                     ((operator == Logic.SYM_STELLA_ge) ||
                      (operator == Logic.SYM_STELLA_el)))) {
                  newClause = Logic.generalizeInequality(probe, match, bindings);
                }
                else {
                  newClause = Cons.cons(operator, Stella.NIL);
                  { Stella_Object arg1 = null;
                    Cons iter007 = probe.rest;
                    Stella_Object arg2 = null;
                    Cons iter008 = match.rest;

                    for (;(!(iter007 == Stella.NIL)) &&
                              (!(iter008 == Stella.NIL)); iter007 = iter007.rest, iter008 = iter008.rest) {
                      arg1 = iter007.value;
                      arg2 = iter008.value;
                      if (!Stella_Object.equalConsTreesP(arg1, arg2)) {
                        {
                          var = ((Symbol)(Logic.lookupVariableInBindings(arg1, arg2, bindings)));
                          if (var == null) {
                            var = Symbol.internSymbol("?X" + Native.stringify(IntegerWrapper.wrapInteger(((Integer)(Logic.$BOTTOM_UP_VARIABLE_COUNTER$.get())).intValue())));
                            if (!Logic.eitherNumbersP(arg1, arg2)) {
                              bindings.push(Cons.consList(Cons.cons(arg1, Cons.cons(arg2, Cons.cons(var, Stella.NIL)))));
                            }
                            Native.setIntSpecial(Logic.$BOTTOM_UP_VARIABLE_COUNTER$, ((Integer)(Logic.$BOTTOM_UP_VARIABLE_COUNTER$.get())).intValue() + 1);
                          }
                          newClause = Cons.cons(var, newClause);
                        }
                      }
                      else {
                        newClause = Cons.cons(arg1, newClause);
                      }
                    }
                  }
                  newClause = newClause.reverse();
                }
                if (notP) {
                  newClause = Cons.list$(Cons.cons(Logic.SYM_STELLA_NOT, Cons.cons(newClause, Cons.cons(Stella.NIL, Stella.NIL))));
                }
                result = Cons.cons(newClause, result);
              }
            }
          }
        }
      }
      return (Logic.removeRedundantClauses(result.reverse()));
    }
  }

  public static Cons generalizeInequality(Cons probe, Cons match, List bindings) {
    { Stella_Object operator = probe.value;
      Cons newClause = Cons.consList(Cons.cons(operator, Stella.NIL));
      Symbol var = null;

      { Stella_Object arg1 = null;
        Cons iter000 = probe.rest;
        Stella_Object arg2 = null;
        Cons iter001 = match.rest;

        for (;(!(iter000 == Stella.NIL)) &&
                  (!(iter001 == Stella.NIL)); iter000 = iter000.rest, iter001 = iter001.rest) {
          arg1 = iter000.value;
          arg2 = iter001.value;
          if (!Stella_Object.equalConsTreesP(arg1, arg2)) {
            if (Logic.bothNumbersP(arg1, arg2)) {
              { GeneralizedSymbol testValue000 = ((GeneralizedSymbol)(operator));

                if ((testValue000 == Logic.SYM_STELLA_g) ||
                    (testValue000 == Logic.SYM_STELLA_ge)) {
                  newClause = Cons.cons(((NumberWrapper)(arg1)).min(((NumberWrapper)(arg2))), newClause);
                }
                else if ((testValue000 == Logic.SYM_STELLA_l) ||
                    (testValue000 == Logic.SYM_STELLA_el)) {
                  newClause = Cons.cons(((NumberWrapper)(arg1)).max(((NumberWrapper)(arg2))), newClause);
                }
                else {
                  Stella.STANDARD_OUTPUT.nativeStream.println("Bug in generalize-inequality.");
                }
              }
            }
            else {
              {
                var = ((Symbol)(Logic.lookupVariableInBindings(arg1, arg2, bindings)));
                if (var == null) {
                  var = Symbol.internSymbol("?X" + Native.stringify(IntegerWrapper.wrapInteger(((Integer)(Logic.$BOTTOM_UP_VARIABLE_COUNTER$.get())).intValue())));
                  if (!Logic.eitherNumbersP(arg1, arg2)) {
                    bindings.push(Cons.consList(Cons.cons(arg1, Cons.cons(arg2, Cons.cons(var, Stella.NIL)))));
                  }
                  Native.setIntSpecial(Logic.$BOTTOM_UP_VARIABLE_COUNTER$, ((Integer)(Logic.$BOTTOM_UP_VARIABLE_COUNTER$.get())).intValue() + 1);
                }
                newClause = Cons.cons(var, newClause);
              }
            }
          }
          else {
            newClause = Cons.cons(arg1, newClause);
          }
        }
      }
      return (newClause.reverse());
    }
  }

  public static boolean bothNumbersP(Stella_Object t1, Stella_Object t2) {
    if (Stella_Object.isaP(t1, Logic.SGT_STELLA_NUMBER_WRAPPER) &&
        Stella_Object.isaP(t2, Logic.SGT_STELLA_NUMBER_WRAPPER)) {
      return (true);
    }
    else {
      return (false);
    }
  }

  public static boolean eitherNumbersP(Stella_Object t1, Stella_Object t2) {
    if (Stella_Object.isaP(t1, Logic.SGT_STELLA_NUMBER_WRAPPER) ||
        Stella_Object.isaP(t2, Logic.SGT_STELLA_NUMBER_WRAPPER)) {
      return (true);
    }
    else {
      return (false);
    }
  }

  public static Cons removeRedundantClauses(Cons clauses) {
    { Cons result = Stella.NIL;
      HashTable trueTable = HashTable.newHashTable();
      HashTable notTable = HashTable.newHashTable();
      List entries = null;
      List sharedVariables = List.newList();
      List knownVariables = List.newList();
      Symbol operator = null;
      boolean subsumedP = false;
      List operators = List.newList();

      { Cons clause = null;
        Cons iter000 = ((Cons)(Stella_Object.copyConsTree(clauses)));

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          clause = ((Cons)(iter000.value));
          if (clause.value == Logic.SYM_STELLA_NOT) {
            {
              operator = ((Symbol)(((Cons)(clause.rest.value)).value));
              operators.insertNew(operator);
              entries = ((List)(notTable.lookup(operator)));
              if (entries == null) {
                entries = List.newList();
              }
              entries.push(((Cons)(clause.rest.value)));
              notTable.insertAt(operator, entries);
            }
          }
          else {
            {
              operator = ((Symbol)(clause.value));
              operators.insertNew(operator);
              entries = ((List)(trueTable.lookup(operator)));
              if (entries == null) {
                entries = List.newList();
              }
              entries.push(clause);
              trueTable.insertAt(operator, entries);
            }
          }
          { Symbol v = null;
            Cons iter001 = Logic.getVariablesFromConsPropositions(Cons.consList(Cons.cons(clause, Stella.NIL))).theConsList;

            for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
              v = ((Symbol)(iter001.value));
              if (knownVariables.memberP(v)) {
                sharedVariables.insertNew(v);
              }
              else {
                knownVariables.push(v);
              }
            }
          }
        }
      }
      { Symbol operator000 = null;
        Cons iter002 = operators.theConsList;

        for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
          operator000 = ((Symbol)(iter002.value));
          entries = ((List)(trueTable.lookup(operator000)));
          if (entries != null) {
            { Cons clause1 = null;
              Cons iter003 = entries.theConsList;

              for (;!(iter003 == Stella.NIL); iter003 = iter003.rest) {
                clause1 = ((Cons)(iter003.value));
                subsumedP = false;
                { Cons clause2 = null;
                  Cons iter004 = entries.theConsList;

                  loop004 : for (;!(iter004 == Stella.NIL); iter004 = iter004.rest) {
                    clause2 = ((Cons)(iter004.value));
                    if (!(clause1 == clause2)) {
                      subsumedP = true;
                      { Stella_Object arg1 = null;
                        Cons iter005 = clause1.rest;
                        Stella_Object arg2 = null;
                        Cons iter006 = clause2.rest;

                        loop005 : for (;(!(iter005 == Stella.NIL)) &&
                                  (!(iter006 == Stella.NIL)); iter005 = iter005.rest, iter006 = iter006.rest) {
                          arg1 = iter005.value;
                          arg2 = iter006.value;
                          if ((!Stella_Object.equalConsTreesP(arg1, arg2)) &&
                              ((Stella_Object.symbolP(arg1) &&
                              sharedVariables.memberP(arg1)) ||
                               Stella_Object.consP(arg1))) {
                            subsumedP = false;
                            break loop005;
                          }
                        }
                      }
                      if (subsumedP) {
                        break loop004;
                      }
                    }
                  }
                }
                if (!subsumedP) {
                  result = Cons.cons(clause1, result);
                }
              }
            }
          }
          entries = ((List)(notTable.lookup(operator000)));
          if (entries != null) {
            { Cons clause1 = null;
              Cons iter007 = entries.theConsList;

              for (;!(iter007 == Stella.NIL); iter007 = iter007.rest) {
                clause1 = ((Cons)(iter007.value));
                subsumedP = false;
                { Cons clause2 = null;
                  Cons iter008 = entries.theConsList;

                  loop007 : for (;!(iter008 == Stella.NIL); iter008 = iter008.rest) {
                    clause2 = ((Cons)(iter008.value));
                    if (!(clause1 == clause2)) {
                      subsumedP = true;
                      { Stella_Object arg1 = null;
                        Cons iter009 = clause1.rest;
                        Stella_Object arg2 = null;
                        Cons iter010 = clause2.rest;

                        loop008 : for (;(!(iter009 == Stella.NIL)) &&
                                  (!(iter010 == Stella.NIL)); iter009 = iter009.rest, iter010 = iter010.rest) {
                          arg1 = iter009.value;
                          arg2 = iter010.value;
                          if ((!Stella_Object.equalConsTreesP(arg1, arg2)) &&
                              ((Stella_Object.symbolP(arg1) &&
                              sharedVariables.memberP(arg1)) ||
                               Stella_Object.consP(arg1))) {
                            subsumedP = false;
                            break loop008;
                          }
                        }
                      }
                      if (subsumedP) {
                        break loop007;
                      }
                    }
                  }
                }
                if (!subsumedP) {
                  result = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_NOT, Cons.cons(clause1, Cons.cons(Stella.NIL, Stella.NIL)))), result);
                }
              }
            }
          }
        }
      }
      return (result);
    }
  }

  public static Stella_Object lookupVariableInBindings(Stella_Object obj1, Stella_Object obj2, List bindings) {
    { Cons bind = null;
      Cons iter000 = bindings.theConsList;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        bind = ((Cons)(iter000.value));
        if (Stella_Object.equalConsTreesP(bind.value, obj1) &&
            Stella_Object.equalConsTreesP(bind.rest.value, obj2)) {
          return (bind.rest.rest.value);
        }
      }
    }
    if (Stella_Object.consP(obj1) &&
        Stella_Object.consP(obj2)) {
      { Cons answer = Stella.NIL;
        Stella_Object bind = null;

        { Stella_Object arg1 = null;
          Cons iter001 = ((Cons)(obj1));
          Stella_Object arg2 = null;
          Cons iter002 = ((Cons)(obj2));

          for (;(!(iter001 == Stella.NIL)) &&
                    (!(iter002 == Stella.NIL)); iter001 = iter001.rest, iter002 = iter002.rest) {
            arg1 = iter001.value;
            arg2 = iter002.value;
            if (Stella_Object.eqlP(arg1, arg2)) {
              answer = Cons.cons(arg1, answer);
            }
            else {
              {
                bind = Logic.lookupVariableInBindings(arg1, arg2, bindings);
                if (bind == null) {
                  return (null);
                }
                answer = Cons.cons(bind, answer);
              }
            }
          }
        }
        return (answer.reverse());
      }
    }
    return (null);
  }

  public static Cons learnOneRuleBottomUpFromSignatures(List positive, List negative, List covered, Vector consProps) {
    { List tempPositive = positive.copy();
      int max = 0;
      int cover = 0;
      int index1 = 0;
      int index2 = 0;
      int vecSize = ((TrainingExample)(negative.first())).input.length();
      List indices = null;
      List bestIndices = List.newList();
      Vector lgg = null;
      Vector sig1 = null;
      Vector sig2 = null;
      boolean stop = false;
      Cons result = Stella.NIL;
      int score = 0;
      int numLggs = 0;

      while ((max > 0) ||
          (lgg == null)) {
        cover = cover + max;
        Stella.STANDARD_OUTPUT.nativeStream.println("   Current rule covers " + cover + " positive examples");
        if (lgg != null) {
          { TrainingExample example = null;
            Cons iter000 = Logic.removeSignatureCoveredExamples(bestIndices, tempPositive).theConsList;

            for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
              example = ((TrainingExample)(iter000.value));
              covered.push(example);
            }
          }
        }
        numLggs = tempPositive.length() * 1;
        max = 0;
        { int i = Stella.NULL_INTEGER;
          int iter001 = 1;
          int upperBound000 = numLggs;
          boolean unboundedP000 = upperBound000 == Stella.NULL_INTEGER;

          for (;unboundedP000 ||
                    (iter001 <= upperBound000); iter001 = iter001 + 1) {
            i = iter001;
            i = i;
            index1 = Stella.random(tempPositive.length());
            sig1 = ((TrainingExample)(tempPositive.nth(index1))).input;
            if (lgg == null) {
              {
                index2 = Stella.random(tempPositive.length());
                while (index1 == index2) {
                  index2 = Stella.random(tempPositive.length());
                }
                sig2 = ((TrainingExample)(tempPositive.nth(index2))).input;
              }
            }
            else {
              sig2 = lgg;
            }
            indices = Logic.intersectSignatures(sig1, sig2);
            if (!Logic.signatureIndicesCoverAnyExampleP(indices, negative)) {
              score = Logic.numSignatureIndicesCovered(indices, tempPositive);
              if (score > max) {
                Stella.STANDARD_OUTPUT.nativeStream.println("    New best: " + score + " examples");
                bestIndices = indices;
                max = score;
              }
            }
          }
        }
        lgg = Vector.newVector(vecSize);
        { int i = Stella.NULL_INTEGER;
          int iter002 = 0;
          int upperBound001 = vecSize - 1;

          for (;iter002 <= upperBound001; iter002 = iter002 + 1) {
            i = iter002;
            (lgg.theArray)[i] = (IntegerWrapper.wrapInteger(2));
          }
        }
        { IntegerWrapper index = null;
          Cons iter003 = bestIndices.theConsList;

          for (;!(iter003 == Stella.NIL); iter003 = iter003.rest) {
            index = ((IntegerWrapper)(iter003.value));
            if (index.wrapperValue > 0) {
              (lgg.theArray)[(index.wrapperValue - 1)] = (IntegerWrapper.wrapInteger(1));
            }
            else {
              (lgg.theArray)[((0 - index.wrapperValue) - 1)] = (IntegerWrapper.wrapInteger(0));
            }
          }
        }
      }
      while (stop) {
        stop = true;
        { IntegerWrapper index = null;
          Cons iter004 = bestIndices.copy().theConsList;

          loop007 : for (;!(iter004 == Stella.NIL); iter004 = iter004.rest) {
            index = ((IntegerWrapper)(iter004.value));
            if (!Logic.signatureIndicesCoverAnyExampleP(((List)(bestIndices.copy().remove(index))), negative)) {
              Stella.STANDARD_OUTPUT.nativeStream.println("     Removing clause");
              bestIndices = ((List)(bestIndices.remove(index)));
              stop = false;
              break loop007;
            }
          }
        }
      }
      { IntegerWrapper index = null;
        Cons iter005 = bestIndices.theConsList;

        for (;!(iter005 == Stella.NIL); iter005 = iter005.rest) {
          index = ((IntegerWrapper)(iter005.value));
          if (index.wrapperValue > 0) {
            result = Cons.cons(((Cons)((consProps.theArray)[(index.wrapperValue - 1)])), result);
          }
          else {
            result = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_FAIL, Cons.cons(((Cons)((consProps.theArray)[((0 - index.wrapperValue) - 1)])), Cons.cons(Stella.NIL, Stella.NIL)))), result);
          }
        }
      }
      return (result);
    }
  }

  public static List intersectSignatures(Vector sig1, Vector sig2) {
    { List result = List.newList();

      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = sig1.length() - 1;

        for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
          i = iter000;
          if (Stella_Object.eqlP((sig1.theArray)[i], Stella.ONE_WRAPPER) &&
              Stella_Object.eqlP((sig2.theArray)[i], Stella.ONE_WRAPPER)) {
            result.push(IntegerWrapper.wrapInteger(i + 1));
          }
          if (Stella_Object.eqlP((sig1.theArray)[i], Stella.ZERO_WRAPPER) &&
              Stella_Object.eqlP((sig2.theArray)[i], Stella.ZERO_WRAPPER)) {
            result.push(IntegerWrapper.wrapInteger(0 - (i + 1)));
          }
        }
      }
      return (result);
    }
  }

  public static List removeSignatureCoveredExamples(List indices, List examples) {
    { List removed = List.newList();

      { TrainingExample example = null;
        Cons iter000 = examples.copy().theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          example = ((TrainingExample)(iter000.value));
          if (Logic.signatureIndicesCoverExampleP(indices, example)) {
            removed.push(example);
            examples = ((List)(examples.remove(example)));
          }
        }
      }
      return (removed);
    }
  }

  public static int numSignatureIndicesCovered(List indices, List examples) {
    { int count = 0;

      { TrainingExample example = null;
        Cons iter000 = examples.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          example = ((TrainingExample)(iter000.value));
          if (Logic.signatureIndicesCoverExampleP(indices, example)) {
            count = count + 1;
          }
        }
      }
      return (count);
    }
  }

  public static boolean signatureIndicesCoverAnyExampleP(List indices, List examples) {
    { TrainingExample example = null;
      Cons iter000 = examples.theConsList;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        example = ((TrainingExample)(iter000.value));
        if (Logic.signatureIndicesCoverExampleP(indices, example)) {
          return (true);
        }
      }
    }
    return (false);
  }

  public static boolean signatureIndicesCoverExampleP(List indices, TrainingExample example) {
    { int actual = 0;

      { IntegerWrapper index = null;
        Cons iter000 = indices.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          index = ((IntegerWrapper)(iter000.value));
          actual = Stella.integer_abs(index.wrapperValue) - 1;
          if (index.wrapperValue > 0) {
            if (Stella_Object.eqlP((example.input.theArray)[actual], Stella.ZERO_WRAPPER)) {
              return (false);
            }
          }
          else {
            if (Stella_Object.eqlP((example.input.theArray)[actual], Stella.ONE_WRAPPER)) {
              return (false);
            }
          }
        }
      }
    }
    return (true);
  }

  public static void topDownRuleInduction(List examples) {
    { List positive = List.newList();
      List allPositives = List.newList();
      List negative = List.newList();
      List uncovered = null;
      List covered = List.newList();
      Cons antecedent = Stella.NIL;
      List linkedAntecedents = null;
      Symbol concept = ((TrainingExample)(examples.first())).concept;
      int numRules = 0;
      int loopCheck = 0;
      boolean signaturesP = Logic.$INDUCE_RULES_FROM_SIGNATURES$;
      Vector consProps = null;
      List props = List.newList();
      Vector propositionVector = null;

      Logic.$INDUCED_DECISION_RULES$ = List.newList();
      if (((TrainingExample)(Logic.$TRAINING_EXAMPLES$.first())).module != null) {
        ((TrainingExample)(Logic.$TRAINING_EXAMPLES$.first())).module.changeModule();
      }
      props = Logic.getClassificationRelations(((TrainingExample)(Logic.$TRAINING_EXAMPLES$.first())).query);
      consProps = Vector.newVector(props.length());
      propositionVector = Vector.newVector(props.length());
      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = props.length() - 1;
        Proposition prop = null;
        Cons iter001 = props.theConsList;

        for (;(iter000 <= upperBound000) &&
                  (!(iter001 == Stella.NIL)); iter000 = iter000 + 1, iter001 = iter001.rest) {
          i = iter000;
          prop = ((Proposition)(iter001.value));
          (propositionVector.theArray)[i] = prop;
          (consProps.theArray)[i] = (Proposition.propositionToCons(prop));
        }
      }
      { TrainingExample example = null;
        Cons iter002 = examples.theConsList;

        for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
          example = ((TrainingExample)(iter002.value));
          if (BooleanWrapper.coerceWrappedBooleanToBoolean(((BooleanWrapper)(example.output)))) {
            {
              positive.push(example);
              allPositives.push(example);
            }
          }
          else {
            negative.push(example);
          }
        }
      }
      Stella.STANDARD_OUTPUT.nativeStream.println("Starting rule induction with " + positive.length() + " positive and " + negative.length() + " negative examples");
      loop002 : while (!positive.emptyP()) {
        {
          Stella.STANDARD_OUTPUT.nativeStream.println("");
          Stella.STANDARD_OUTPUT.nativeStream.println(positive.length() + " positive examples left to be covered");
        }
;
        covered = List.newList();
        linkedAntecedents = List.list(Cons.cons(Stella.NIL, Stella.NIL));
        if (Logic.$INDUCE_RULES_FROM_SIGNATURES$) {
          if (Logic.$SIGNATURE_STRATEGY$ == Logic.KWD_BOTTOM_UP) {
            antecedent = Logic.learnOneRuleBottomUpFromSignatures(positive, negative, covered, consProps);
            linkedAntecedents = Logic.linkVariablesInInducedRule(antecedent, covered, consProps);
          }
          else if (Logic.$SIGNATURE_STRATEGY$ == Logic.KWD_DECISION_TREE) {
            uncovered = List.newList();
            { TrainingExample example = null;
              Cons iter003 = positive.theConsList;

              for (;!(iter003 == Stella.NIL); iter003 = iter003.rest) {
                example = ((TrainingExample)(iter003.value));
                uncovered.push(example);
              }
            }
            { TrainingExample example = null;
              Cons iter004 = negative.theConsList;

              for (;!(iter004 == Stella.NIL); iter004 = iter004.rest) {
                example = ((TrainingExample)(iter004.value));
                uncovered.push(example);
              }
            }
            { Cons treeRule = null;
              Cons iter005 = Logic.getRulesFromTree(((TrainingExample)(uncovered.first())).query, Logic.induceDecisionTree(uncovered)).theConsList;
              Cons collect000 = null;

              for (;!(iter005 == Stella.NIL); iter005 = iter005.rest) {
                treeRule = ((Cons)(iter005.value));
                if (BooleanWrapper.coerceWrappedBooleanToBoolean(((BooleanWrapper)(treeRule.value)))) {
                  if (collect000 == null) {
                    {
                      collect000 = Cons.cons(treeRule.rest, Stella.NIL);
                      if (linkedAntecedents.theConsList == Stella.NIL) {
                        linkedAntecedents.theConsList = collect000;
                      }
                      else {
                        Cons.addConsToEndOfConsList(linkedAntecedents.theConsList, collect000);
                      }
                    }
                  }
                  else {
                    {
                      collect000.rest = Cons.cons(treeRule.rest, Stella.NIL);
                      collect000 = collect000.rest;
                    }
                  }
                }
              }
            }
            linkedAntecedents = ((List)(linkedAntecedents.remove(Stella.NIL)));
          }
          else if (Logic.$SIGNATURE_STRATEGY$ == Logic.KWD_TOP_DOWN) {
            antecedent = Logic.learnOneRuleTopDownFromSignatures(positive, negative, covered, consProps);
            linkedAntecedents = Logic.linkVariablesInInducedRule(antecedent, covered, consProps);
          }
          else {
            { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

              stream000.nativeStream.print("`" + Logic.$SIGNATURE_STRATEGY$ + "' is not a valid case option");
              throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
            }
          }
        }
        { Cons ant = null;
          Cons iter006 = linkedAntecedents.theConsList;

          for (;!(iter006 == Stella.NIL); iter006 = iter006.rest) {
            ant = ((Cons)(iter006.value));
            covered = Logic.getCoveredExamples(ant, negative);
            if ((covered.length() < 10) ||
                ((covered.length() < positive.length()) ||
                 (ant == Stella.NIL))) {
              if (covered.length() > 0) {
                ant = Logic.specializeRule(ant, Logic.$CANDIDATE_CLAUSES$, positive, covered);
                loopCheck = 0;
                loop007 : while ((!(ant == Stella.NIL)) &&
                    Logic.ruleCoversAnyExampleP(ant, negative)) {
                  loopCheck = loopCheck + 1;
                  if (loopCheck == 4) {
                    ant = Stella.NIL;
                    covered = negative;
                    break loop007;
                  }
                  ant = Logic.specializeRule(ant, Logic.$CANDIDATE_CLAUSES$, positive, covered);
                }
                if (!(ant == Stella.NIL)) {
                  covered = null;
                }
              }
              if ((covered == null) ||
                  covered.emptyP()) {
                covered = Logic.getCoveredExamples(ant, positive);
                { TrainingExample example = null;
                  Cons iter007 = covered.theConsList;

                  for (;!(iter007 == Stella.NIL); iter007 = iter007.rest) {
                    example = ((TrainingExample)(iter007.value));
                    positive = ((List)(positive.remove(example)));
                  }
                }
                if (covered.length() == 0) {
                  Stella.STANDARD_OUTPUT.nativeStream.println("No Positives Covered by" + ant);
                }
                if (covered.length() > 0) {
                  Logic.$INDUCED_DECISION_RULES$.push(Cons.list$(Cons.cons(Logic.SYM_STELLA_eg, Cons.cons(Cons.cons(Logic.SYM_STELLA_AND, ((Cons)(Stella_Object.copyConsTree(ant))).reverse().concatenate(Stella.NIL, Stella.NIL)), Cons.cons(Cons.cons(concept, Cons.cons(Logic.SYM_LOGIC_pY, Stella.NIL)), Cons.cons(Stella.NIL, Stella.NIL))))));
                  Stella.STANDARD_OUTPUT.nativeStream.println("Adding rule to cover " + covered.length() + " examples");
                }
              }
            }
          }
        }
        if (Logic.$INDUCED_DECISION_RULES$.length() == numRules) {
          {
            if (!Logic.$INDUCE_RULES_FROM_SIGNATURES$) {
              Stella.STANDARD_OUTPUT.nativeStream.println("Stopping with " + positive.length() + " examples uncovered");
              break loop002;
            }
            Stella.STANDARD_OUTPUT.nativeStream.println(positive.length() + " examples uncovered, switching to full query-based induction");
            Logic.$INDUCE_RULES_FROM_SIGNATURES$ = false;
          }
        }
        else {
          Logic.$INDUCE_RULES_FROM_SIGNATURES$ = signaturesP;
        }
        numRules = Logic.$INDUCED_DECISION_RULES$.length();
      }
      Logic.$INDUCE_RULES_FROM_SIGNATURES$ = signaturesP;
      {
        Stella.STANDARD_OUTPUT.nativeStream.println();
        Stella.STANDARD_OUTPUT.nativeStream.println("PowerLoom has induced the following rules");
        Stella.STANDARD_OUTPUT.nativeStream.println();
      }
;
      { Cons rule = null;
        Cons iter008 = Logic.$INDUCED_DECISION_RULES$.theConsList;

        for (;!(iter008 == Stella.NIL); iter008 = iter008.rest) {
          rule = ((Cons)(iter008.value));
          Stella.STANDARD_OUTPUT.nativeStream.println(rule.toString());
        }
      }
    }
  }

  public static Cons buildAntecedentFromRuleIndex(Vector props, List ruleIndex) {
    { Cons antecedent = Stella.NIL;
      Cons consProp = Stella.NIL;

      { IntegerWrapper index = null;
        Cons iter000 = ruleIndex.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          index = ((IntegerWrapper)(iter000.value));
          if (index.wrapperValue < 0) {
            consProp = Cons.list$(Cons.cons(Logic.SYM_LOGIC_FAIL, Cons.cons(((Cons)((props.theArray)[(Stella.integer_abs(index.wrapperValue) - 1)])), Cons.cons(Stella.NIL, Stella.NIL))));
          }
          else {
            consProp = ((Cons)((props.theArray)[(Stella.integer_abs(index.wrapperValue) - 1)]));
          }
          antecedent = Cons.cons(consProp, antecedent);
        }
      }
      return (antecedent);
    }
  }

  public static Cons learnOneRuleTopDownFromSignatures(List positive, List negative, List covered_pos, Vector consProps) {
    { double current_utility = 0.0;
      List rule = List.newList();
      double gain = 0.0;
      double max_gain = 0.0;
      List used_features = List.newList();
      int num_features = 0;
      List vars = List.newList();
      Vector variableTable = null;
      int feature_index = 0;
      List covered_neg = List.newList();

      Stella.STANDARD_OUTPUT.nativeStream.println("Learning rule top down from signatures over " + positive.length() + " positives");
      if (positive.emptyP()) {
        return (Stella.NIL);
      }
      num_features = ((TrainingExample)(positive.first())).input.length();
      variableTable = Vector.newVector(num_features + 1);
      { int i = Stella.NULL_INTEGER;
        int iter000 = 1;
        int upperBound000 = num_features;
        boolean unboundedP000 = upperBound000 == Stella.NULL_INTEGER;

        for (;unboundedP000 ||
                  (iter000 <= upperBound000); iter000 = iter000 + 1) {
          i = iter000;
          (variableTable.theArray)[i] = (Logic.getVariablesFromConsPropositions(Cons.consList(Cons.cons(((Cons)((consProps.theArray)[(i - 1)])), Stella.NIL))));
        }
      }
      vars.push(Logic.SYM_LOGIC_pY);
      { TrainingExample example = null;
        Cons iter001 = negative.theConsList;
        Cons collect000 = null;

        for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
          example = ((TrainingExample)(iter001.value));
          if (collect000 == null) {
            {
              collect000 = Cons.cons(example, Stella.NIL);
              if (covered_neg.theConsList == Stella.NIL) {
                covered_neg.theConsList = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(covered_neg.theConsList, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(example, Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      { TrainingExample example = null;
        Cons iter002 = positive.theConsList;
        Cons collect001 = null;

        for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
          example = ((TrainingExample)(iter002.value));
          if (collect001 == null) {
            {
              collect001 = Cons.cons(example, Stella.NIL);
              if (covered_pos.theConsList == Stella.NIL) {
                covered_pos.theConsList = collect001;
              }
              else {
                Cons.addConsToEndOfConsList(covered_pos.theConsList, collect001);
              }
            }
          }
          else {
            {
              collect001.rest = Cons.cons(example, Stella.NIL);
              collect001 = collect001.rest;
            }
          }
        }
      }
      while (!covered_neg.emptyP()) {
        current_utility = Logic.foilUtility(covered_pos.length(), covered_neg.length());
        max_gain = 0.0;
        { int i = Stella.NULL_INTEGER;
          int iter003 = 1;
          int upperBound001 = num_features;
          boolean unboundedP001 = upperBound001 == Stella.NULL_INTEGER;

          for (;unboundedP001 ||
                    (iter003 <= upperBound001); iter003 = iter003 + 1) {
            i = iter003;
            if (!used_features.memberP(IntegerWrapper.wrapInteger(i))) {
              { boolean testValue000 = false;

                testValue000 = Logic.$ENFORCE_LINKED_VARIABLES$;
                if (testValue000) {
                  { boolean foundP000 = false;

                    { Symbol ele = null;
                      Cons iter004 = ((List)((variableTable.theArray)[i])).theConsList;

                      loop005 : for (;!(iter004 == Stella.NIL); iter004 = iter004.rest) {
                        ele = ((Symbol)(iter004.value));
                        if (vars.memberP(ele)) {
                          foundP000 = true;
                          break loop005;
                        }
                      }
                    }
                    testValue000 = foundP000;
                  }
                  testValue000 = !testValue000;
                }
                if (testValue000) {
                  gain = -9999.0;
                }
                else {
                  gain = Logic.foilGain(i, current_utility, covered_pos, covered_neg);
                }
              }
              if (Logic.$TRACE_FOIL$) {
                Stella.STANDARD_OUTPUT.nativeStream.println("Foil gain on feature " + i + ": " + gain);
              }
              if (gain > max_gain) {
                feature_index = i;
                max_gain = gain;
              }
              { boolean testValue001 = false;

                testValue001 = Logic.$ENFORCE_LINKED_VARIABLES$;
                if (testValue001) {
                  { boolean foundP001 = false;

                    { Symbol ele = null;
                      Cons iter005 = ((List)((variableTable.theArray)[i])).theConsList;

                      loop006 : for (;!(iter005 == Stella.NIL); iter005 = iter005.rest) {
                        ele = ((Symbol)(iter005.value));
                        if (vars.memberP(ele)) {
                          foundP001 = true;
                          break loop006;
                        }
                      }
                    }
                    testValue001 = foundP001;
                  }
                  testValue001 = !testValue001;
                }
                if (testValue001) {
                  gain = -9999.0;
                }
                else {
                  gain = Logic.foilGain(0 - i, current_utility, covered_pos, covered_neg);
                }
              }
              if (Logic.$TRACE_FOIL$) {
                Stella.STANDARD_OUTPUT.nativeStream.println("Foil gain on feature " + i + ": " + gain);
              }
              if (gain > max_gain) {
                feature_index = 0 - i;
                max_gain = gain;
              }
            }
          }
        }
        if (max_gain == 0.0) {
          covered_pos = List.newList();
          Stella.STANDARD_OUTPUT.nativeStream.println("   Darn, nothing we can do here, returning nil.");
          return (Stella.NIL);
        }
        if (Logic.$TRACE_FOIL$) {
          Stella.STANDARD_OUTPUT.nativeStream.println("** Choosing feature " + ((Cons)((consProps.theArray)[(Stella.integer_abs(feature_index - 1))])));
        }
        if (Logic.$ENFORCE_LINKED_VARIABLES$) {
          { Symbol var = null;
            Cons iter006 = ((List)((variableTable.theArray)[(((feature_index < 0) ? (0 - feature_index) : feature_index))])).theConsList;

            for (;!(iter006 == Stella.NIL); iter006 = iter006.rest) {
              var = ((Symbol)(iter006.value));
              if (!vars.memberP(var)) {
                vars.push(var);
              }
            }
          }
        }
        Logic.updateCoveredExamples(feature_index, covered_pos, covered_neg);
        used_features.push(IntegerWrapper.wrapInteger(((feature_index < 0) ? (0 - feature_index) : feature_index)));
        rule.push(IntegerWrapper.wrapInteger(feature_index));
      }
      Stella.STANDARD_OUTPUT.nativeStream.println("   Returning with " + covered_pos.length() + " positives and " + covered_neg.length() + " negatives covered");
      return (Logic.buildAntecedentFromRuleIndex(consProps, rule));
    }
  }

  public static void updateExampleMatches(List examples, int index, IntegerWrapper matchValue) {
    { Cons temp = Stella.NIL;

      { TrainingExample example = null;
        Cons iter000 = examples.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          example = ((TrainingExample)(iter000.value));
          if (example.input.length() <= index) {
            {
              Stella.STANDARD_WARNING.nativeStream.println("Warning: Bad training example, not enough features.  Needs `" + (index + 1) + "'");
              Stella.STANDARD_WARNING.nativeStream.println("`" + example.query + "'");
            }
;
          }
          else if (Stella_Object.eqlP((example.input.theArray)[index], matchValue)) {
            temp = Cons.cons(example, temp);
          }
        }
      }
      examples.theConsList = temp;
    }
  }

  public static void updateCoveredExamples(int feature_index, List covered_pos, List covered_neg) {
    { IntegerWrapper matchValue = ((feature_index > 0) ? Stella.ZERO_WRAPPER : Stella.ONE_WRAPPER);
      int index = (((feature_index < 0) ? (0 - feature_index) : feature_index)) - 1;

      Logic.updateExampleMatches(covered_pos, index, matchValue);
      Logic.updateExampleMatches(covered_neg, index, matchValue);
    }
  }

  public static int countExampleMatches(List examples, int index, IntegerWrapper matchValue) {
    { int n = 0;

      { TrainingExample example = null;
        Cons iter000 = examples.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          example = ((TrainingExample)(iter000.value));
          if (example.input.length() <= index) {
            {
              Stella.STANDARD_WARNING.nativeStream.println("Warning: Bad training example, not enough features.  Needs `" + (index + 1) + "'");
              Stella.STANDARD_WARNING.nativeStream.println("`" + example.query + "'");
            }
;
          }
          else if (Stella_Object.eqlP((example.input.theArray)[index], matchValue)) {
            n = n + 1;
          }
        }
      }
      return (n);
    }
  }

  public static double foilGain(int featureIndex, double utility, List coveredPos, List coveredNeg) {
    { IntegerWrapper matchValue = ((featureIndex < 0) ? Stella.ZERO_WRAPPER : Stella.ONE_WRAPPER);
      int index = (((featureIndex < 0) ? (0 - featureIndex) : featureIndex)) - 1;
      int p = Logic.countExampleMatches(coveredPos, index, matchValue);
      int n = Logic.countExampleMatches(coveredNeg, index, matchValue);

      return (p * (Logic.foilUtility(p, n) - utility));
    }
  }

  public static double foilUtility(int p, int n) {
    if (p == 0) {
      return (((double)(0)));
    }
    return (Math.log((((double)(p)) / (p + n))) / Logic.LOG_2);
  }

  public static Cons learnOneRuleTopDown(Vector propositions, List positive, List negative) {
    return (Logic.specializeRule(Stella.NIL, propositions, positive, negative));
  }

  public static Cons specializeRule(Cons rule, Vector propositions, List positive, List negative) {
    Stella.STANDARD_OUTPUT.nativeStream.println("Specializing ");
    { List candidates = List.newList();
      List coveredNegs = List.newList();
      List coveredPos = List.newList();
      double current_utility = 0.0;
      int featureIndex = 0;
      Cons newClause = Stella.NIL;
      List vars = Logic.getVariablesFromConsPropositions(rule);
      Vector variableTable = null;
      double gain = 0.0;
      double max = 0.0;

      { TrainingExample example = null;
        Cons iter000 = negative.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          example = ((TrainingExample)(iter000.value));
          if (Logic.ruleCoversExampleP(rule, example)) {
            coveredNegs.push(example);
          }
        }
      }
      { TrainingExample example = null;
        Cons iter001 = positive.theConsList;

        for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
          example = ((TrainingExample)(iter001.value));
          if (Logic.ruleCoversExampleP(rule, example)) {
            coveredPos.push(example);
          }
        }
      }
      if (coveredNegs.emptyP()) {
        Stella.STANDARD_OUTPUT.nativeStream.println(" No covered negatives");
        return (rule);
      }
      if (!vars.memberP(Logic.SYM_LOGIC_pY)) {
        vars.push(Logic.SYM_LOGIC_pY);
      }
      variableTable = Vector.newVector(propositions.length() + 1);
      { int i = Stella.NULL_INTEGER;
        int iter002 = 1;
        int upperBound000 = propositions.length();

        for (;iter002 <= upperBound000; iter002 = iter002 + 1) {
          i = iter002;
          (variableTable.theArray)[i] = (Logic.getVariablesFromConsPropositions(Cons.consList(Cons.cons(((Cons)((propositions.theArray)[(i - 1)])), Stella.NIL))));
        }
      }
      { int i = Stella.NULL_INTEGER;
        int iter003 = 1;
        int upperBound001 = propositions.length();

        for (;iter003 <= upperBound001; iter003 = iter003 + 1) {
          i = iter003;
          candidates.push(IntegerWrapper.wrapInteger(i));
          candidates.push(IntegerWrapper.wrapInteger(0 - i));
        }
      }
      { Cons clause = null;
        Cons iter004 = rule;

        for (;!(iter004 == Stella.NIL); iter004 = iter004.rest) {
          clause = ((Cons)(iter004.value));
          { Cons prop = null;
            Vector vector000 = propositions;
            int index000 = 0;
            int length000 = vector000.length();
            int i = Stella.NULL_INTEGER;
            int iter005 = 1;

            loop005 : for (;index000 < length000; index000 = index000 + 1, iter005 = iter005 + 1) {
              prop = ((Cons)((vector000.theArray)[index000]));
              i = iter005;
              if (Stella_Object.equalConsTreesP(prop, clause)) {
                candidates = ((List)(candidates.remove(IntegerWrapper.wrapInteger(i))));
                break loop005;
              }
              if (Stella_Object.equalConsTreesP(Cons.list$(Cons.cons(Logic.SYM_LOGIC_FAIL, Cons.cons(prop, Cons.cons(Stella.NIL, Stella.NIL)))), clause)) {
                candidates = ((List)(candidates.remove(IntegerWrapper.wrapInteger(0 - i))));
                break loop005;
              }
            }
          }
        }
      }
      while (!coveredNegs.emptyP()) {
        Stella.STANDARD_OUTPUT.nativeStream.println("   Covers " + coveredNegs.length() + " negs, and " + coveredPos.length() + " pos");
        current_utility = Logic.foilUtility(coveredPos.length(), coveredNegs.length());
        max = 0.0;
        { IntegerWrapper i = null;
          Cons iter006 = candidates.copy().theConsList;

          for (;!(iter006 == Stella.NIL); iter006 = iter006.rest) {
            i = ((IntegerWrapper)(iter006.value));
            { boolean foundP000 = false;

              { Symbol ele = null;
                Cons iter007 = ((List)((variableTable.theArray)[(Stella.integer_abs(i.wrapperValue))])).theConsList;

                loop008 : for (;!(iter007 == Stella.NIL); iter007 = iter007.rest) {
                  ele = ((Symbol)(iter007.value));
                  if (vars.memberP(ele)) {
                    foundP000 = true;
                    break loop008;
                  }
                }
              }
              if (foundP000) {
                if (i.wrapperValue > 0) {
                  gain = Logic.queryFoilGain(Cons.cons(((Cons)((propositions.theArray)[(i.wrapperValue - 1)])), rule), current_utility, coveredPos, coveredNegs);
                }
                else {
                  gain = Logic.queryFoilGain(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_FAIL, Cons.cons(((Cons)((propositions.theArray)[((0 - i.wrapperValue) - 1)])), Cons.cons(Stella.NIL, Stella.NIL)))), rule), current_utility, coveredPos, coveredNegs);
                }
                if (gain > max) {
                  Stella.STANDARD_OUTPUT.nativeStream.print("    Current: " + ((Cons)((propositions.theArray)[(Stella.integer_abs(i.wrapperValue) - 1)])) + ": " + gain);
                  if (i.wrapperValue < 0) {
                    Stella.STANDARD_OUTPUT.nativeStream.println(" Negated");
                  }
                  else {
                    Stella.STANDARD_OUTPUT.nativeStream.println();
                  }
                  featureIndex = i.wrapperValue;
                  max = gain;
                }
              }
            }
          }
        }
        if (max == 0.0) {
          Stella.STANDARD_OUTPUT.nativeStream.println("   No features provide any gain");
          Stella.STANDARD_OUTPUT.nativeStream.println("   Can't separate ");
          { TrainingExample pos = null;
            Cons iter008 = coveredPos.theConsList;

            for (;!(iter008 == Stella.NIL); iter008 = iter008.rest) {
              pos = ((TrainingExample)(iter008.value));
              Stella.STANDARD_OUTPUT.nativeStream.println("     " + pos.name);
            }
          }
          Stella.STANDARD_OUTPUT.nativeStream.println("   From ");
          { TrainingExample neg = null;
            Cons iter009 = coveredNegs.theConsList;

            for (;!(iter009 == Stella.NIL); iter009 = iter009.rest) {
              neg = ((TrainingExample)(iter009.value));
              Stella.STANDARD_OUTPUT.nativeStream.println("     " + neg.name);
            }
          }
          return (Stella.NIL);
        }
        { Symbol var = null;
          Cons iter010 = ((List)((variableTable.theArray)[(((featureIndex < 0) ? (0 - featureIndex) : featureIndex))])).theConsList;

          for (;!(iter010 == Stella.NIL); iter010 = iter010.rest) {
            var = ((Symbol)(iter010.value));
            if (!vars.memberP(var)) {
              vars.push(var);
            }
          }
        }
        candidates = ((List)(candidates.remove(IntegerWrapper.wrapInteger(featureIndex))));
        newClause = ((Cons)(Stella_Object.copyConsTree(((Cons)((propositions.theArray)[((((featureIndex < 0) ? (0 - featureIndex) : featureIndex)) - 1)])))));
        if (featureIndex < 0) {
          newClause = Cons.list$(Cons.cons(Logic.SYM_LOGIC_FAIL, Cons.cons(newClause, Cons.cons(Stella.NIL, Stella.NIL))));
        }
        Stella.STANDARD_OUTPUT.nativeStream.println("   Adding clause " + newClause);
        rule = Cons.cons(newClause, rule);
        Logic.removeExcludedExamples(rule, coveredPos, coveredNegs);
      }
      return (rule);
    }
  }

  public static void removeExcludedExamples(Cons rule, List coveredPos, List coveredNeg) {
    { TrainingExample example = null;
      Cons iter000 = coveredNeg.copy().theConsList;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        example = ((TrainingExample)(iter000.value));
        if (!Logic.ruleCoversExampleP(rule, example)) {
          coveredNeg = ((List)(coveredNeg.remove(example)));
        }
      }
    }
    { TrainingExample example = null;
      Cons iter001 = coveredPos.copy().theConsList;

      for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
        example = ((TrainingExample)(iter001.value));
        if (!Logic.ruleCoversExampleP(rule, example)) {
          coveredPos = ((List)(coveredPos.remove(example)));
        }
      }
    }
  }

  public static double queryFoilGain(Cons rule, double utility, List coveredPos, List coveredNeg) {
    { int p = 0;
      int n = 0;
      double result = 0.0;

      { TrainingExample example = null;
        Cons iter000 = coveredNeg.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          example = ((TrainingExample)(iter000.value));
          if (Logic.ruleCoversExampleP(rule, example)) {
            n = n + 1;
          }
        }
      }
      { TrainingExample example = null;
        Cons iter001 = coveredPos.theConsList;

        for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
          example = ((TrainingExample)(iter001.value));
          if (Logic.ruleCoversExampleP(rule, example)) {
            p = p + 1;
          }
        }
      }
      if ((p == 0) &&
          (n == 0)) {
        return (0.0);
      }
      result = p * (Logic.foilUtility(p, n) - utility);
      if (result < 1.0e-6) {
        result = 0.0;
      }
      return (result);
    }
  }

  public static void queryAndUpdateCoveredExamples(Cons rule, List uncovered, List covered) {
    { TrainingExample example = null;
      Cons iter000 = uncovered.copy().theConsList;
      Cons collect000 = null;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        example = ((TrainingExample)(iter000.value));
        if (Logic.ruleCoversExampleP(rule, example)) {
          if (collect000 == null) {
            {
              collect000 = Cons.cons(example, Stella.NIL);
              if (covered.theConsList == Stella.NIL) {
                covered.theConsList = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(covered.theConsList, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(example, Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
    }
  }

  public static void removeCoveredExamples(Cons rule, List uncovered) {
    { TrainingExample example = null;
      Cons iter000 = uncovered.copy().theConsList;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        example = ((TrainingExample)(iter000.value));
        if (Logic.ruleCoversExampleP(rule, example)) {
          uncovered = ((List)(uncovered.remove(example)));
        }
      }
    }
  }

  public static int numExamplesCovered(Cons rule, List examples) {
    { int count = 0;

      { TrainingExample example = null;
        Cons iter000 = examples.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          example = ((TrainingExample)(iter000.value));
          if (Logic.ruleCoversExampleP(rule, example)) {
            count = count + 1;
          }
        }
      }
      return (count);
    }
  }

  public static List getCoveredExamples(Cons rule, List uncovered) {
    { List covered = List.newList();

      { TrainingExample example = null;
        Cons iter000 = uncovered.theConsList;
        Cons collect000 = null;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          example = ((TrainingExample)(iter000.value));
          if (Logic.ruleCoversExampleP(rule, example)) {
            if (collect000 == null) {
              {
                collect000 = Cons.cons(example, Stella.NIL);
                if (covered.theConsList == Stella.NIL) {
                  covered.theConsList = collect000;
                }
                else {
                  Cons.addConsToEndOfConsList(covered.theConsList, collect000);
                }
              }
            }
            else {
              {
                collect000.rest = Cons.cons(example, Stella.NIL);
                collect000 = collect000.rest;
              }
            }
          }
        }
      }
      return (covered);
    }
  }

  public static boolean ruleCoversAnyExampleP(Cons rule, List examples) {
    { TrainingExample example = null;
      Cons iter000 = examples.theConsList;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        example = ((TrainingExample)(iter000.value));
        if (Logic.ruleCoversExampleP(rule, example)) {
          return (true);
        }
      }
    }
    return (false);
  }

  public static boolean ruleCoversExampleP(Cons reverseRule, TrainingExample example) {
    if (reverseRule == Stella.NIL) {
      return (true);
    }
    { QueryIterator query = null;
      Cons rule = ((Cons)(Stella_Object.copyConsTree(reverseRule))).reverse();
      List vars = ((List)(Logic.getVariablesFromConsPropositions(rule).remove(Logic.SYM_LOGIC_pY)));
      Cons consQuery = Stella.NIL;
      Cons types = Stella.NIL;

      if (example.module != null) {
        example.module.changeModule();
      }
      consQuery = Cons.cons(Logic.SYM_STELLA_AND, ((Cons)(Stella_Object.substituteConsTree(rule, example.name, Logic.SYM_LOGIC_pY))));
      if (!vars.emptyP()) {
        { Symbol var = null;
          Cons iter000 = vars.theConsList;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            var = ((Symbol)(iter000.value));
            if (Logic.$ENABLE_USER_THING$ &&
                ((var.symbolName).charAt(1) == 'X')) {
              types = Cons.cons(Cons.cons(var, Cons.cons(Logic.SYM_LOGIC_USER_THING, Stella.NIL)), types);
            }
            else {
              types = Cons.cons(var, types);
            }
          }
        }
        consQuery = Cons.list$(Cons.cons(Logic.SYM_STELLA_EXISTS, Cons.cons(types, Cons.cons(Cons.cons(consQuery, Stella.NIL), Stella.NIL))));
      }
      if (Logic.$OPTIMIZE_INDUCED_QUERIES$) {
        query = Logic.makeQuery(Stella.NIL, consQuery, Stella.NIL, Cons.list$(Cons.cons(Logic.KWD_TIMEOUT, Cons.cons(IntegerWrapper.wrapInteger(300), Cons.cons(Stella.NIL, Stella.NIL)))));
      }
      else {
        query = Logic.makeQuery(Stella.NIL, consQuery, Stella.NIL, Cons.list$(Cons.cons(Logic.KWD_TIMEOUT, Cons.cons(IntegerWrapper.wrapInteger(300), Cons.cons(Logic.KWD_DONT_OPTIMIZEp, Cons.cons(Logic.SYM_STELLA_TRUE, Cons.cons(Stella.NIL, Stella.NIL)))))));
      }
      return (TruthValue.trueTruthValueP(Logic.callAsk(query)));
    }
  }

  public static List linkVariablesInInducedRule(Cons rule, List examples, Vector consProps) {
    { List vars = null;
      Cons tempRule = Stella.NIL;
      Symbol var = null;
      List unlinked = null;
      List linked = null;
      List newRules = List.newList();

      vars = Logic.getVariablesFromConsPropositions(rule);
      { TrainingExample example = null;
        Cons iter000 = examples.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          example = ((TrainingExample)(iter000.value));
          if (example.input == null) {
            example.input = Logic.createInputSignature(example.query);
          }
          tempRule = ((Cons)(Stella_Object.copyConsTree(rule)));
          unlinked = List.newList();
          linked = List.newList();
          { Symbol var000 = null;
            Cons iter001 = vars.theConsList;
            Cons collect000 = null;

            for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
              var000 = ((Symbol)(iter001.value));
              if (collect000 == null) {
                {
                  collect000 = Cons.cons(var000, Stella.NIL);
                  if (unlinked.theConsList == Stella.NIL) {
                    unlinked.theConsList = collect000;
                  }
                  else {
                    Cons.addConsToEndOfConsList(unlinked.theConsList, collect000);
                  }
                }
              }
              else {
                {
                  collect000.rest = Cons.cons(var000, Stella.NIL);
                  collect000 = collect000.rest;
                }
              }
            }
          }
          unlinked = ((List)(unlinked.remove(Logic.SYM_LOGIC_pY)));
          linked.push(Logic.SYM_LOGIC_pY);
          while (!unlinked.emptyP()) {
            var = ((Symbol)(unlinked.pop()));
            { Cons prop = null;
              Vector vector000 = consProps;
              int index000 = 0;
              int length000 = vector000.length();
              int i = Stella.NULL_INTEGER;
              int iter002 = 0;

              loop003 : for (;index000 < length000; index000 = index000 + 1, iter002 = iter002 + 1) {
                prop = ((Cons)((vector000.theArray)[index000]));
                i = iter002;
                if (prop.memberP(var)) {
                  { boolean foundP000 = false;

                    { Stella_Object ele = null;
                      Cons iter003 = tempRule;

                      loop004 : for (;!(iter003 == Stella.NIL); iter003 = iter003.rest) {
                        ele = iter003.value;
                        if (Stella_Object.equalConsTreesP(ele, prop)) {
                          foundP000 = true;
                          break loop004;
                        }
                      }
                    }
                    if (foundP000) {
                      linked.push(var);
                      break loop003;
                    }
                  }
                  if (Stella_Object.eqlP((example.input.theArray)[i], Stella.ONE_WRAPPER)) {
                    tempRule = tempRule.concatenate(Cons.consList(Cons.cons(((Cons)(Stella_Object.copyConsTree(prop))), Stella.NIL)), Stella.NIL);
                    { Stella_Object newVar = null;
                      Cons iter004 = prop.rest;

                      for (;!(iter004 == Stella.NIL); iter004 = iter004.rest) {
                        newVar = iter004.value;
                        if ((!(newVar == var)) &&
                            (Stella_Object.symbolP(newVar) &&
                             (!linked.memberP(newVar)))) {
                          unlinked.push(((Symbol)(newVar)));
                        }
                      }
                    }
                    linked.push(var);
                    break loop003;
                  }
                }
              }
            }
          }
          { boolean testValue000 = false;

            { boolean foundP001 = false;

              { Cons ele = null;
                Cons iter005 = newRules.theConsList;

                loop006 : for (;!(iter005 == Stella.NIL); iter005 = iter005.rest) {
                  ele = ((Cons)(iter005.value));
                  if (Stella_Object.equalConsTreesP(ele, tempRule)) {
                    foundP001 = true;
                    break loop006;
                  }
                }
              }
              testValue000 = foundP001;
            }
            testValue000 = !testValue000;
            if (testValue000) {
              newRules.push(tempRule);
            }
          }
        }
      }
      { ListIterator it = ((ListIterator)(newRules.allocateIterator()));

        while (it.nextP()) {
          it.valueSetter(((Cons)(((Cons)(it.value)))).reverse());
        }
      }
      return (newRules);
    }
  }

  public static Vector evaluateRuleInduction(Symbol relationName, Symbol className, int numTrials, int curveSplits) {
    { Surrogate renamed_Class = Logic.getDescription(className).surrogateValueInverse;
      Surrogate relation = Logic.getDescription(relationName).surrogateValueInverse;
      List ilist = Logic.allClassInstances(renamed_Class).listify();
      int num = ilist.length();
      double numTrain = (1 * num) / 2.0;
      double currentSplit = numTrain;
      Vector trainingInstances = null;
      Vector instances = Vector.newVector(num);
      double result = 0.0;
      Vector results = Vector.newVector(curveSplits);

      { Stella_Object instance = null;
        Cons iter000 = ilist.theConsList;
        int i = Stella.NULL_INTEGER;
        int iter001 = 0;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
          instance = iter000.value;
          i = iter001;
          (instances.theArray)[i] = (((LogicObject)(instance)));
        }
      }
      { int i = Stella.NULL_INTEGER;
        int iter002 = 0;
        int upperBound000 = curveSplits - 1;

        for (;iter002 <= upperBound000; iter002 = iter002 + 1) {
          i = iter002;
          (results.theArray)[i] = (FloatWrapper.wrapFloat(0.0));
        }
      }
      { int split = Stella.NULL_INTEGER;
        int iter003 = 0;
        int upperBound001 = curveSplits - 1;

        for (;iter003 <= upperBound001; iter003 = iter003 + 1) {
          split = iter003;
          currentSplit = numTrain * (((double)(split + 1)) / curveSplits);
          { int i = Stella.NULL_INTEGER;
            int iter004 = 0;
            int upperBound002 = numTrials - 1;

            for (;iter004 <= upperBound002; iter004 = iter004 + 1) {
              i = iter004;
              Logic.shuffleVector(instances);
              Stella.STANDARD_OUTPUT.nativeStream.println("Starting Trial " + (i + 1) + " of split " + (split + 1) + " with " + currentSplit + " examples");
              Logic.clearTrainingExamples();
              Logic.clearCases();
              trainingInstances = Vector.newVector(((int)(currentSplit)));
              { int j = Stella.NULL_INTEGER;
                int iter005 = 0;
                int upperBound003 = ((int)(currentSplit - 1));

                for (;iter005 <= upperBound003; iter005 = iter005 + 1) {
                  j = iter005;
                  (trainingInstances.theArray)[j] = (((LogicObject)((instances.theArray)[j])));
                }
              }
              if (Logic.$RULE_INDUCTION_STRATEGY$ == Logic.KWD_TOP_DOWN) {
                Logic.$ENABLE_USER_THING$ = true;
                Stella.STANDARD_OUTPUT.nativeStream.println("  Creating Match Criteria");
                Logic.generateClassificationRule(trainingInstances, relationName, className, true);
                Logic.setCandidateClauses(className);
                Stella.STANDARD_OUTPUT.nativeStream.println("  Generating Training Examples");
                Logic.generateClassificationTrainingExamples(instances, relation, true);
                Logic.$OPTIMIZE_INDUCED_QUERIES$ = true;
              }
              else if (Logic.$RULE_INDUCTION_STRATEGY$ == Logic.KWD_BOTTOM_UP) {
                Logic.$ENABLE_USER_THING$ = false;
                Logic.generateTrainingExamples(instances, relation);
                Logic.$OPTIMIZE_INDUCED_QUERIES$ = true;
              }
              else {
                { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

                  stream000.nativeStream.print("`" + Logic.$RULE_INDUCTION_STRATEGY$ + "' is not a valid case option");
                  throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
                }
              }
              Logic.$TRAINING_EXAMPLES$ = Logic.$TRAINING_EXAMPLES$.reverse();
              { List trainSet = List.newList();
                List testSet = List.newList();

                { TrainingExample example = null;
                  Cons iter006 = Logic.$TRAINING_EXAMPLES$.theConsList;
                  int j = Stella.NULL_INTEGER;
                  int iter007 = 0;

                  for (;!(iter006 == Stella.NIL); iter006 = iter006.rest, iter007 = iter007 + 1) {
                    example = ((TrainingExample)(iter006.value));
                    j = iter007;
                    if (j < currentSplit) {
                      trainSet.push(example);
                    }
                    if (j >= numTrain) {
                      testSet.push(example);
                    }
                  }
                }
                result = Logic.trainAndTestRuleInduction(trainSet, testSet);
                (results.theArray)[split] = (FloatWrapper.wrapFloat(((FloatWrapper)((results.theArray)[split])).wrapperValue + result));
                {
                  Stella.STANDARD_OUTPUT.nativeStream.println();
                  Stella.STANDARD_OUTPUT.nativeStream.println("  Result: " + result);
                }
;
              }
            }
          }
        }
      }
      { int i = Stella.NULL_INTEGER;
        int iter008 = 0;
        int upperBound004 = curveSplits - 1;

        for (;iter008 <= upperBound004; iter008 = iter008 + 1) {
          i = iter008;
          (results.theArray)[i] = (FloatWrapper.wrapFloat(((FloatWrapper)((results.theArray)[i])).wrapperValue / numTrials));
        }
      }
      return (results);
    }
  }

  public static Vector evaluateRuleInductionEvaluatorWrapper(Cons arguments) {
    return (Logic.evaluateRuleInduction(((Symbol)(arguments.value)), ((Symbol)(arguments.rest.value)), ((IntegerWrapper)(arguments.rest.rest.value)).wrapperValue, ((IntegerWrapper)(arguments.rest.rest.rest.value)).wrapperValue));
  }

  public static double trainAndTestRuleInduction(List trainSet, List testSet) {
    { Module homeModule = ((Module)(((Context)(Stella.$CONTEXT$.get()))));
      Module testModule = Stella.findOrCreateModule(((Module)(((Context)(Stella.$CONTEXT$.get())))).moduleFullName + "INDUCED-RULES");
      double result = 0.0;

      testModule.changeModule();
      Context.clearContext(testModule);
      if (Logic.$RULE_INDUCTION_STRATEGY$ == Logic.KWD_TOP_DOWN) {
        Logic.topDownRuleInduction(trainSet);
      }
      else if (Logic.$RULE_INDUCTION_STRATEGY$ == Logic.KWD_BOTTOM_UP) {
        Logic.bottomUpRuleInduction(trainSet, Logic.$SIMPLIFY_RULE_ANTECEDENTp$);
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + Logic.$RULE_INDUCTION_STRATEGY$ + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      Logic.assertInducedRules();
      result = Logic.testTheoryOverExamples(testSet);
      homeModule.changeModule();
      return (result);
    }
  }

  public static void induceDecisionRules(Symbol relationName, Symbol className) {
    relationName = ((Symbol)(relationName.permanentify()));
    Logic.clearCases();
    Logic.clearTrainingExamples();
    Logic.$INDUCED_DECISION_RULES$ = List.newList();
    className = ((Symbol)(className.permanentify()));
    { Surrogate renamed_Class = Logic.getDescription(className).surrogateValueInverse;
      Surrogate relation = Logic.getDescription(relationName).surrogateValueInverse;
      List ilist = Logic.allClassInstances(renamed_Class).listify();
      int num = ilist.length();
      DecisionTree tree = null;
      Vector instances = Vector.newVector(num);

      { Stella_Object instance = null;
        Cons iter000 = ilist.theConsList;
        int i = Stella.NULL_INTEGER;
        int iter001 = 0;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
          instance = iter000.value;
          i = iter001;
          (instances.theArray)[i] = (((LogicObject)(instance)));
        }
      }
      if (!Logic.$ALLOW_RECURSIVE_DECISION_NODES$) {
        Logic.$TABOO_OPERATORS$.insertNew(relation);
      }
      Logic.generateClassificationRule(instances, relationName, className, true);
      Stella.STANDARD_OUTPUT.nativeStream.println("Generating Training Examples");
      Logic.generateClassificationTrainingExamples(instances, relation, true);
      Stella.STANDARD_OUTPUT.nativeStream.println("Generating Decision Rules");
      tree = Logic.induceDecisionTree(Logic.$TRAINING_EXAMPLES$);
      tree.concept = relationName;
      Logic.getRulesFromTree(((TrainingExample)(Logic.$TRAINING_EXAMPLES$.first())).query, tree);
    }
  }

  public static void modularInduceDecisionRules(Symbol relationName, Symbol className, List modules) {
    relationName = ((Symbol)(relationName.permanentify()));
    className = ((Symbol)(className.permanentify()));
    Logic.clearTrainingExamples();
    Logic.clearCases();
    { Surrogate renamed_Class = Logic.getDescription(className).surrogateValueInverse;
      Surrogate relation = Logic.getDescription(relationName).surrogateValueInverse;
      List ilist = List.newList();
      DecisionTree tree = null;
      Module home = ((Module)(Stella.$MODULE$.get()));
      int num = ilist.length();
      Vector instanceVec = Vector.newVector(modules.length());
      Vector instances = null;

      if (!Logic.$ALLOW_RECURSIVE_DECISION_NODES$) {
        Logic.$TABOO_OPERATORS$.insertNew(relation);
      }
      Stella.STANDARD_OUTPUT.nativeStream.println("Building Classification Rule");
      { Module module = null;
        Cons iter000 = modules.theConsList;
        int j = Stella.NULL_INTEGER;
        int iter001 = 0;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
          module = ((Module)(iter000.value));
          j = iter001;
          module.changeModule();
          ilist = Logic.allClassInstances(renamed_Class).listify();
          num = ilist.length();
          instances = Vector.newVector(num);
          { Stella_Object instance = null;
            Cons iter002 = ilist.theConsList;
            int i = Stella.NULL_INTEGER;
            int iter003 = 0;

            for (;!(iter002 == Stella.NIL); iter002 = iter002.rest, iter003 = iter003 + 1) {
              instance = iter002.value;
              i = iter003;
              (instances.theArray)[i] = (((LogicObject)(instance)));
            }
          }
          (instanceVec.theArray)[j] = instances;
          Logic.generateClassificationRule(instances, relationName, className, false);
        }
      }
      home.changeModule();
      Logic.buildClassificationRule(relationName, className);
      Stella.STANDARD_OUTPUT.nativeStream.println("Generating Training Examples");
      { Module module = null;
        Cons iter004 = modules.theConsList;
        Vector vec = null;
        Vector vector000 = instanceVec;
        int index000 = 0;
        int length000 = vector000.length();

        for (;(!(iter004 == Stella.NIL)) &&
                  (index000 < length000); iter004 = iter004.rest, index000 = index000 + 1) {
          module = ((Module)(iter004.value));
          vec = ((Vector)((vector000.theArray)[index000]));
          module.changeModule();
          Logic.generateClassificationTrainingExamples(vec, relation, true);
        }
      }
      Stella.STANDARD_OUTPUT.nativeStream.println("Inducing Decision Tree");
      tree = Logic.induceDecisionTree(Logic.$TRAINING_EXAMPLES$);
      tree.concept = relationName;
      if (((TrainingExample)(Logic.$TRAINING_EXAMPLES$.first())).module != null) {
        ((TrainingExample)(Logic.$TRAINING_EXAMPLES$.first())).module.changeModule();
      }
    }
  }

  public static DecisionTree induceDecisionTree(List examples) {
    { List features = List.newList();
      Symbol feature = null;
      DecisionTree tree = null;
      List props = List.newList();
      HashTable propositionTable = HashTable.newHashTable();

      Stella.STANDARD_OUTPUT.nativeStream.println("  Inducing decision tree");
      if (((TrainingExample)(examples.first())).module != null) {
        ((TrainingExample)(examples.first())).module.changeModule();
      }
      props = Logic.getClassificationRelations(((TrainingExample)(examples.first())).query);
      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = props.length() - 1;
        Cons collect000 = null;

        for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
          i = iter000;
          feature = Symbol.internSymbol("A" + Native.stringify(IntegerWrapper.wrapInteger(i)));
          propositionTable.insertAt(feature, ((Proposition)(props.nth(i))));
          if (collect000 == null) {
            {
              collect000 = Cons.cons(feature, Stella.NIL);
              if (features.theConsList == Stella.NIL) {
                features.theConsList = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(features.theConsList, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(feature, Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      tree = ((DecisionTree)(Logic.buildDecisionTree(examples, features, Stella.NIL)));
      DecisionTree.addPropositionsToDecisionTree(tree, propositionTable);
      return (tree);
    }
  }

  public static Stella_Object buildDecisionTree(List examples, List features, Cons featureStack) {
    { int p = 0;
      int n = 0;
      double currentEntropy = 0.0;
      double newEntropy = 0.0;
      DecisionTree tree = DecisionTree.newDecisionTree();
      double minNewEntropy = 1.0;
      int featureIndex = 0;
      Symbol splitFeature = null;

      { TrainingExample example = null;
        Cons iter000 = examples.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          example = ((TrainingExample)(iter000.value));
          if (BooleanWrapper.coerceWrappedBooleanToBoolean(((BooleanWrapper)(example.output)))) {
            p = p + 1;
          }
          else {
            n = n + 1;
          }
        }
      }
      if (p > n) {
        tree.truthValue = true;
      }
      else {
        tree.truthValue = false;
      }
      if ((p == 0) ||
          (n == 0)) {
        return (tree);
      }
      currentEntropy = Logic.entropy(p, n);
      { Symbol feature = null;
        Cons iter001 = features.theConsList;
        int i = Stella.NULL_INTEGER;
        int iter002 = 0;

        for (;!(iter001 == Stella.NIL); iter001 = iter001.rest, iter002 = iter002 + 1) {
          feature = ((Symbol)(iter001.value));
          i = iter002;
          if (!featureStack.memberP(feature)) {
            newEntropy = Logic.expectedEntropy(i, examples);
            if (newEntropy < minNewEntropy) {
              if (Logic.$TRACE_ID3$) {
                Stella.STANDARD_OUTPUT.nativeStream.println("Info gain for feature " + feature + ": " + (currentEntropy - newEntropy));
              }
              minNewEntropy = newEntropy;
              featureIndex = i;
              splitFeature = feature;
            }
          }
        }
      }
      if (Logic.$TRACE_ID3$) {
        Stella.STANDARD_OUTPUT.nativeStream.println("Splitting on feature " + splitFeature);
      }
      if (splitFeature == null) {
        return (tree);
      }
      { List leftExamples = List.newList();
        List rightExamples = List.newList();

        { TrainingExample example = null;
          Cons iter003 = examples.theConsList;

          for (;!(iter003 == Stella.NIL); iter003 = iter003.rest) {
            example = ((TrainingExample)(iter003.value));
            if (Stella_Object.eqlP((example.input.theArray)[featureIndex], Stella.ONE_WRAPPER)) {
              leftExamples.push(example);
            }
            else {
              rightExamples.push(example);
            }
          }
        }
        tree.feature = splitFeature;
        tree.featureIndex = featureIndex;
        tree.trueBranch = ((DecisionTree)(Logic.buildDecisionTree(leftExamples, features, Cons.cons(splitFeature, featureStack))));
        tree.falseBranch = ((DecisionTree)(Logic.buildDecisionTree(rightExamples, features, Cons.cons(splitFeature, featureStack))));
      }
      return (tree);
    }
  }

  public static double expectedEntropy(int featureIndex, List examples) {
    { double e = 0.0;
      int numExamples = examples.length();
      int p = 0;
      int n = 0;

      { TrainingExample example = null;
        Cons iter000 = examples.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          example = ((TrainingExample)(iter000.value));
          if (Stella_Object.eqlP((example.input.theArray)[featureIndex], Stella.ONE_WRAPPER)) {
            if (BooleanWrapper.coerceWrappedBooleanToBoolean(((BooleanWrapper)(example.output)))) {
              p = p + 1;
            }
            else {
              n = n + 1;
            }
          }
        }
      }
      e = (((double)(p + n)) / numExamples) * Logic.entropy(p, n);
      p = 0;
      n = 0;
      { TrainingExample example = null;
        Cons iter001 = examples.theConsList;

        for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
          example = ((TrainingExample)(iter001.value));
          if (Stella_Object.eqlP((example.input.theArray)[featureIndex], Stella.ZERO_WRAPPER)) {
            if (BooleanWrapper.coerceWrappedBooleanToBoolean(((BooleanWrapper)(example.output)))) {
              p = p + 1;
            }
            else {
              n = n + 1;
            }
          }
        }
      }
      e = e + ((((double)(p + n)) / numExamples) * Logic.entropy(p, n));
      return (e);
    }
  }

  public static double entropy(int p, int n) {
    if ((p == 0) &&
        (n == 0)) {
      return (0.0);
    }
    { int sum = p + n;
      double posImpurity = 0.0;
      double posPerc = ((double)(p)) / sum;
      double negImpurity = 0.0;
      double negPerc = ((double)(n)) / sum;

      if (p == 0) {
        posImpurity = 0.0;
      }
      else {
        posImpurity = 0 - (posPerc * (Math.log(posPerc) / Math.log((2.0))));
      }
      if (n == 0) {
        negImpurity = 0.0;
      }
      else {
        negImpurity = 0 - (negPerc * (Math.log(negPerc) / Math.log((2.0))));
      }
      return (posImpurity + negImpurity);
    }
  }

  public static List getRulesFromTree(Cons query, DecisionTree tree) {
    Stella.STANDARD_OUTPUT.nativeStream.println("  Extracting rules from decision tree");
    return (DecisionTree.buildRulesFromTree(tree, Logic.getClassificationRelations(query)));
  }

  public static void assertInducedRules() {
    { Cons command = Stella.NIL;
      Symbol name = null;
      List vars = null;
      Cons types = Stella.NIL;

      { Cons rule = null;
        Cons iter000 = Logic.$INDUCED_DECISION_RULES$.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          rule = ((Cons)(iter000.value));
          name = Symbol.internSymbol("Induced-Rule-" + Native.stringify(IntegerWrapper.wrapInteger(Logic.$INDUCED_RULE_COUNTER$)));
          vars = Logic.getVariablesFromConsPropositions(rule);
          types = Stella.NIL;
          if (Logic.$ENABLE_USER_THING$) {
            { Symbol var = null;
              Cons iter001 = vars.theConsList;
              Cons collect000 = null;

              for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                var = ((Symbol)(iter001.value));
                if (collect000 == null) {
                  {
                    collect000 = Cons.cons(Cons.cons(var, Cons.cons(Logic.SYM_LOGIC_USER_THING, Stella.NIL)), Stella.NIL);
                    if (types == Stella.NIL) {
                      types = collect000;
                    }
                    else {
                      Cons.addConsToEndOfConsList(types, collect000);
                    }
                  }
                }
                else {
                  {
                    collect000.rest = Cons.cons(Cons.cons(var, Cons.cons(Logic.SYM_LOGIC_USER_THING, Stella.NIL)), Stella.NIL);
                    collect000 = collect000.rest;
                  }
                }
              }
            }
          }
          else {
            { Symbol var = null;
              Cons iter002 = vars.theConsList;
              Cons collect001 = null;

              for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
                var = ((Symbol)(iter002.value));
                if (collect001 == null) {
                  {
                    collect001 = Cons.cons(var, Stella.NIL);
                    if (types == Stella.NIL) {
                      types = collect001;
                    }
                    else {
                      Cons.addConsToEndOfConsList(types, collect001);
                    }
                  }
                }
                else {
                  {
                    collect001.rest = Cons.cons(var, Stella.NIL);
                    collect001 = collect001.rest;
                  }
                }
              }
            }
          }
          Logic.$INDUCED_RULE_COUNTER$ = Logic.$INDUCED_RULE_COUNTER$ + 1;
          command = Cons.list$(Cons.cons(Logic.SYM_LOGIC_DEFRULE, Cons.cons(name, Cons.cons(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_FORALL, Cons.cons(types, Cons.cons(Cons.cons(((Cons)(Stella_Object.copyConsTree(rule))), Stella.NIL), Stella.NIL)))), Stella.NIL), Stella.NIL))));
          if (Logic.$LOG_INDUCED_RULES$) {
            {
              Stella.STANDARD_OUTPUT.nativeStream.println(command.toString());
              Stella.STANDARD_OUTPUT.nativeStream.println();
            }
;
          }
          else {
            Stella.STANDARD_OUTPUT.nativeStream.println("Asserting " + name);
          }
          Logic.evaluateLogicCommand(command, false);
        }
      }
    }
  }

  public static void setCandidateClauses(Symbol className) {
    { List clauses = ((List)(Logic.$CASE_ANTECEDENT_TABLE$.lookup(className.symbolName + "-match")));

      Logic.$CANDIDATE_CLAUSES$ = Vector.newVector(clauses.length());
      { Cons clause = null;
        Cons iter000 = clauses.theConsList;
        int k = Stella.NULL_INTEGER;
        int iter001 = 0;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
          clause = ((Cons)(iter000.value));
          k = iter001;
          (Logic.$CANDIDATE_CLAUSES$.theArray)[k] = clause;
        }
      }
    }
  }

  public static List getVariablesFromPropositionList(List props) {
    { List theList = List.newList();
      Symbol variable = null;

      { Proposition prop = null;
        Cons iter000 = props.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          prop = ((Proposition)(iter000.value));
          { Keyword testValue000 = prop.kind;

            if ((testValue000 == Logic.KWD_OR) ||
                ((testValue000 == Logic.KWD_NOT) ||
                 (testValue000 == Logic.KWD_AND))) {
              { Symbol var = null;
                Cons iter001 = Logic.getVariablesFromPropositionList(((List)(prop.arguments.listify()))).theConsList;

                for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                  var = ((Symbol)(iter001.value));
                  theList.insertNew(var);
                }
              }
            }
            else {
              { Stella_Object arg = null;
                Vector vector000 = prop.arguments;
                int index000 = 0;
                int length000 = vector000.length();

                for (;index000 < length000; index000 = index000 + 1) {
                  arg = (vector000.theArray)[index000];
                  { Surrogate testValue001 = Stella_Object.safePrimaryType(arg);

                    if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
                      { PatternVariable arg000 = ((PatternVariable)(arg));

                        variable = arg000.skolemName;
                      }
                    }
                    else if (Surrogate.subtypeOfSymbolP(testValue001)) {
                      { Symbol arg000 = ((Symbol)(arg));

                        variable = arg000;
                      }
                    }
                    else if (Surrogate.subtypeOfSurrogateP(testValue001)) {
                      { Surrogate arg000 = ((Surrogate)(arg));

                        variable = Symbol.internSymbol(arg000.symbolName);
                      }
                    }
                    else if (Surrogate.subtypeOfFloatP(testValue001)) {
                      { FloatWrapper arg000 = ((FloatWrapper)(arg));

                        variable = null;
                      }
                    }
                    else if (Surrogate.subtypeOfIntegerP(testValue001)) {
                      { IntegerWrapper arg000 = ((IntegerWrapper)(arg));

                        variable = null;
                      }
                    }
                    else if (Surrogate.subtypeOfStringP(testValue001)) {
                      { StringWrapper arg000 = ((StringWrapper)(arg));

                        variable = null;
                      }
                    }
                    else if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_PROPOSITION)) {
                      { Proposition arg000 = ((Proposition)(arg));

                        Stella.STANDARD_OUTPUT.nativeStream.println("Dave, you've got a proposition");
                      }
                    }
                    else if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
                      { LogicObject arg000 = ((LogicObject)(arg));

                        variable = Logic.objectName(arg000);
                      }
                    }
                    else {
                      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

                        stream000.nativeStream.print("`" + testValue001 + "' is not a valid case option");
                        throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
                      }
                    }
                  }
                  if (variable != null) {
                    theList.insertNew(variable);
                  }
                }
              }
            }
          }
        }
      }
      return (theList);
    }
  }

  public static List getVariablesFromConsPropositions(Cons props) {
    return (Logic.helpGetVariablesFromConsPropositions(props, List.newList()));
  }

  public static List helpGetVariablesFromConsPropositions(Stella_Object ele, List theList) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(ele);

      if (testValue000 == Logic.SGT_STELLA_CONS) {
        { Cons ele000 = ((Cons)(ele));

          { Stella_Object arg = null;
            Cons iter000 = ele000;

            for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
              arg = iter000.value;
              Logic.helpGetVariablesFromConsPropositions(arg, theList);
            }
          }
        }
      }
      else if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol ele000 = ((Symbol)(ele));

          if ((ele000.symbolName).charAt(0) == '?') {
            theList.insertNew(ele000);
          }
        }
      }
      else {
      }
    }
    return (theList);
  }

  public static void setTraceNeuralNetworkTraining(boolean b) {
    Logic.$TRACE_NEURAL_NETWORK_TRAINING$ = b;
  }

  public static void setTraceNeuralNetworkTrainingEvaluatorWrapper(Cons arguments) {
    Logic.setTraceNeuralNetworkTraining(((BooleanWrapper)(arguments.value)).wrapperValue);
  }

  /** Set number of cycles between which networks are saved to the
   * file established by the last call to <code>saveAllNeuralNetworks</code>.  A number &lt;= 0
   * or a NULL number turns off periodic saving.
   * @param i
   */
  public static void setSaveNetworkCycle(int i) {
    if (i == Stella.NULL_INTEGER) {
      i = 0;
    }
    Logic.$SAVE_NETWORK_CYCLE$ = i;
  }

  public static void setSaveNetworkCycleEvaluatorWrapper(Cons arguments) {
    Logic.setSaveNetworkCycle(((IntegerWrapper)(arguments.value)).wrapperValue);
  }

  public static void setErrorCutoff(double f) {
    Logic.$ERROR_CUTOFF$ = f;
  }

  public static void setErrorCutoffEvaluatorWrapper(Cons arguments) {
    Logic.setErrorCutoff(((FloatWrapper)(arguments.value)).wrapperValue);
  }

  public static void setTrainCachedNeuralNetworks(boolean b) {
    Logic.$TRAIN_CACHED_NETWORKSp$ = b;
  }

  public static void setTrainCachedNeuralNetworksEvaluatorWrapper(Cons arguments) {
    Logic.setTrainCachedNeuralNetworks(((BooleanWrapper)(arguments.value)).wrapperValue);
  }

  public static void setLearningRate(double rate) {
    Logic.$LEARNING_RATE$ = rate;
  }

  public static void setLearningRateEvaluatorWrapper(Cons arguments) {
    Logic.setLearningRate(((FloatWrapper)(arguments.value)).wrapperValue);
  }

  public static void setMomentumTerm(double m) {
    Logic.$MOMENTUM_TERM$ = m;
  }

  public static void setMomentumTermEvaluatorWrapper(Cons arguments) {
    Logic.setMomentumTerm(((FloatWrapper)(arguments.value)).wrapperValue);
  }

  public static void setWeightRange(double w) {
    Logic.$WEIGHT_RANGE$ = w;
  }

  public static void setWeightRangeEvaluatorWrapper(Cons arguments) {
    Logic.setWeightRange(((FloatWrapper)(arguments.value)).wrapperValue);
  }

  public static void setNeuralNetworkTrainingMethod(Keyword m) {
    Logic.$NEURAL_NETWORK_TRAINING_METHOD$ = m;
  }

  /** Set number of cycles between which error rates are saved to
   * the file established by the last call to <code>saveAllNeuralNetworks</code> appended
   * with extension <code>Derr</code>.  A number &lt;= 0 (or NULL) turns off periodic saving.
   * @param i
   */
  public static void setErrorPrintCycle(int i) {
    if (i == Stella.NULL_INTEGER) {
      i = 0;
    }
    Logic.$ERROR_PRINT_CYCLE$ = i;
  }

  public static void setErrorPrintCycleEvaluatorWrapper(Cons arguments) {
    Logic.setErrorPrintCycle(((IntegerWrapper)(arguments.value)).wrapperValue);
  }

  public static void deleteAllNeuralNetworks() {
    Logic.$MASTER_NEURAL_NETWORK_LIST$ = List.newList();
  }

  public static void checkMasterNetworkList() {
    { PropositionNeuralNetwork net = null;
      Cons iter000 = Logic.$MASTER_NEURAL_NETWORK_LIST$.theConsList;
      int i = Stella.NULL_INTEGER;
      int iter001 = 0;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
        net = ((PropositionNeuralNetwork)(iter000.value));
        i = iter001;
        Stella.STANDARD_OUTPUT.nativeStream.println("Net " + i + ": " + net.input.length() + " inputs, " + net.hidden.length() + " outputs.");
      }
    }
  }

  public static void clearAllNeuralNetworks() {
    { PropositionNeuralNetwork net = null;
      Cons iter000 = Logic.$MASTER_NEURAL_NETWORK_LIST$.theConsList;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        net = ((PropositionNeuralNetwork)(iter000.value));
        PropositionNeuralNetwork.randomizeNeuralNetwork(net);
      }
    }
  }

  public static void clearAllSlopes() {
    { PropositionNeuralNetwork net = null;
      Cons iter000 = Logic.$MASTER_NEURAL_NETWORK_LIST$.theConsList;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        net = ((PropositionNeuralNetwork)(iter000.value));
        PropositionNeuralNetwork.clearSlopes(net);
      }
    }
  }

  public static Proposition gnp(Symbol name) {
    return (((Proposition)(Surrogate.lookupSurrogate(name.symbolName).surrogateValue)));
  }

  public static PropositionNeuralNetwork defnetwork(Cons args) {
    return (Logic.defineNeuralNetworkFromParseTree(args));
  }

  public static PropositionNeuralNetwork defnetworkEvaluatorWrapper(Cons arguments) {
    return (Logic.defnetwork(arguments));
  }

  public static PropositionNeuralNetwork defineNeuralNetworkFromParseTree(Cons tree) {
    { Stella_Object prop = Logic.buildProposition(tree.value);
      PropositionNeuralNetwork net = Proposition.createNeuralNetwork(((Proposition)(prop)));
      Cons ih = ((Cons)(tree.rest.value));
      Cons ho = ((Cons)(tree.rest.rest.value));
      int k = 0;

      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = net.input.length() - 1;

        for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
          i = iter000;
          { int h = Stella.NULL_INTEGER;
            int iter001 = 0;
            int upperBound001 = net.hidden.length() - 1;

            for (;iter001 <= upperBound001; iter001 = iter001 + 1) {
              h = iter001;
              (net.ih.theArray)[((i * net.ih.nofColumns) + h)] = (((FloatWrapper)(ih.nth(k))));
              k = k + 1;
            }
          }
        }
      }
      { int h = Stella.NULL_INTEGER;
        int iter002 = 0;
        int upperBound002 = net.hidden.length() - 1;
        FloatWrapper num = null;
        Cons iter003 = ho;

        for (;(iter002 <= upperBound002) &&
                  (!(iter003 == Stella.NIL)); iter002 = iter002 + 1, iter003 = iter003.rest) {
          h = iter002;
          num = ((FloatWrapper)(iter003.value));
          (net.ho.theArray)[h] = num;
        }
      }
      return (net);
    }
  }

  public static PropositionNeuralNetwork allocateNeuralNetwork(int numIn, int numHidden) {
    { PropositionNeuralNetwork net = PropositionNeuralNetwork.newPropositionNeuralNetwork();

      net.input = Vector.newVector(numIn);
      net.hidden = Vector.newVector(numHidden);
      net.ih = two_D_array.new2_D_array(numIn, numHidden);
      net.ihDelta = two_D_array.new2_D_array(numIn, numHidden);
      net.inputError = Vector.newVector(numIn);
      net.hiddenError = Vector.newVector(numHidden);
      net.ho = Vector.newVector(numHidden);
      net.hoDelta = Vector.newVector(numHidden);
      if (Logic.$NEURAL_NETWORK_TRAINING_METHOD$ == Logic.KWD_QUICKPROP) {
        net.ihSlope = two_D_array.new2_D_array(numIn, numHidden);
        net.ihPrevSlope = two_D_array.new2_D_array(numIn, numHidden);
        net.hoSlope = Vector.newVector(numHidden);
        net.hoPrevSlope = Vector.newVector(numHidden);
      }
      return (net);
    }
  }

  public static String makeNetInputString(Vector input) {
    return (Native.stringify(input));
  }

  public static void trainNeuralNetwork(int cycles, int numTraining) {
    if (Logic.$TRAIN_CACHED_NETWORKSp$) {
      Logic.trainCachedNeuralNetworks(cycles, numTraining);
    }
    else {
      Logic.trainUncachedNeuralNetworks(cycles, numTraining);
    }
  }

  public static void trainNeuralNetworkEvaluatorWrapper(Cons arguments) {
    Logic.trainNeuralNetwork(((IntegerWrapper)(arguments.value)).wrapperValue, ((IntegerWrapper)(arguments.rest.value)).wrapperValue);
  }

  public static void trainUncachedNeuralNetworks(int cycles, int numTraining) {
    { double mse = 0.0;
      int numEx = Logic.$TRAINING_EXAMPLES$.length();
      OutputStream lookPtr = null;
      Vector examples = Vector.newVector(numTraining);

      if (numTraining > numEx) {
        Stella.STANDARD_ERROR.nativeStream.print("Error: There are only " + numEx + " training examples");
        return;
      }
      Logic.shuffleList(Logic.$TRAINING_EXAMPLES$);
      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = numTraining - 1;

        for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
          i = iter000;
          (examples.theArray)[i] = (((TrainingExample)(Logic.$TRAINING_EXAMPLES$.nth(i))));
        }
      }
      { int cycle = Stella.NULL_INTEGER;
        int iter001 = 0;
        int upperBound001 = cycles - 1;

        for (;iter001 <= upperBound001; iter001 = iter001 + 1) {
          cycle = iter001;
          mse = 0.0;
          if ((Logic.$NEURAL_NETWORK_TRAINING_METHOD$ == Logic.KWD_BACKPROP) ||
              (Logic.$NEURAL_NETWORK_TRAINING_METHOD$ == Logic.KWD_BACKPROPAGATION)) {
            Logic.shuffleVector(examples);
          }
          else if (Logic.$NEURAL_NETWORK_TRAINING_METHOD$ == Logic.KWD_QUICKPROP) {
            Logic.clearAllSlopes();
          }
          else {
            { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

              stream000.nativeStream.print("`" + Logic.$NEURAL_NETWORK_TRAINING_METHOD$ + "' is not a valid case option");
              throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
            }
          }
          { TrainingExample example = null;
            Vector vector000 = examples;
            int index000 = 0;
            int length000 = vector000.length();
            int k = Stella.NULL_INTEGER;
            int iter002 = 0;

            for (;index000 < length000; index000 = index000 + 1, iter002 = iter002 + 1) {
              example = ((TrainingExample)((vector000.theArray)[index000]));
              k = iter002;
              if (Logic.$TRACE_NEURAL_NETWORK_TRAINING$) {
                Stella.STANDARD_OUTPUT.nativeStream.println("Example " + k + ": " + example.query + "  " + example.score);
              }
              if (!(example.module == null)) {
                example.module.changeModule();
              }
              { Cons form = ((Cons)(Stella_Object.copyConsTree(example.query)));
                double target = example.score;
                QueryIterator query = Logic.makeQuery(Stella.NIL, Logic.coerceToTree(form), Stella.NIL, Stella.NIL);
                Proposition prop = query.baseControlFrame.proposition;
                double output = QueryIterator.returnPartialTruth(query, true);
                double error = Logic.computeError(target, output);

                if (Logic.$TRACE_NEURAL_NETWORK_TRAINING$) {
                  Stella.STANDARD_OUTPUT.nativeStream.println("   Output: " + output);
                }
                mse = mse + (error * error);
                Logic.$PARTIAL_SUPPORT_CACHE$ = List.newList();
                if ((Logic.$NEURAL_NETWORK_TRAINING_METHOD$ == Logic.KWD_BACKPROPAGATION) ||
                    (Logic.$NEURAL_NETWORK_TRAINING_METHOD$ == Logic.KWD_BACKPROP)) {
                  Proposition.backpropagateError(prop, error);
                }
                else if (Logic.$NEURAL_NETWORK_TRAINING_METHOD$ == Logic.KWD_QUICKPROP) {
                  Proposition.quickpropagateError(prop, error);
                }
                else {
                  { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

                    stream001.nativeStream.print("`" + Logic.$NEURAL_NETWORK_TRAINING_METHOD$ + "' is not a valid case option");
                    throw ((StellaException)(StellaException.newStellaException(stream001.theStringReader()).fillInStackTrace()));
                  }
                }
              }
            }
          }
          if (Logic.$NEURAL_NETWORK_TRAINING_METHOD$ == Logic.KWD_QUICKPROP) {
            Logic.modifyWeights();
          }
          if ((Logic.$SAVE_NETWORK_CYCLE$ > 0) &&
              ((cycle % Logic.$SAVE_NETWORK_CYCLE$) == 0)) {
            Logic.saveAllNeuralNetworks(Logic.$SAVE_NETWORK_FILE$);
          }
          if ((Logic.$ERROR_PRINT_CYCLE$ > 0) &&
              ((cycle % Logic.$ERROR_PRINT_CYCLE$) == 0)) {
            if (Logic.$SAVE_NETWORK_FILE$ != null) {
              if (lookPtr == null) {
                lookPtr = OutputFileStream.newOutputFileStream(Logic.$SAVE_NETWORK_FILE$ + ".err");
              }
              lookPtr.nativeStream.println("Cycle " + cycle + " Error: " + (mse / numTraining));
            }
            Stella.STANDARD_OUTPUT.nativeStream.println("Cycle " + cycle + " Error: " + (mse / numTraining));
          }
        }
      }
      if (lookPtr != null) {
        lookPtr.free();
      }
    }
  }

  public static double computeError(double training, double output) {
    if (training == 1.0) {
      if (output > 0.9) {
        return (0.0);
      }
    }
    else if (training == 0.0) {
      if (output < 0.1) {
        return (0.0);
      }
    }
    else {
    }
    return (training - output);
  }

  public static double computeDelta(double slope, double prevSlope, double prevDelta) {
    prevSlope = prevSlope;
    return ((Logic.$LEARNING_RATE$ * slope) + (Logic.$MOMENTUM_TERM$ * prevDelta));
  }

  public static double computeQpDelta(double slope, double prevSlope, double prevDelta) {
    { double delta = 0.0;

      if (prevDelta > Logic.$MODE_SWITCH$) {
        if (slope > 0.0) {
          delta = Logic.$LEARNING_RATE$ * slope;
        }
        if (slope > (Logic.$SHRINK_FACTOR$ * prevSlope)) {
          delta = delta + (Logic.$MAX_MOVEMENT$ * prevDelta);
        }
        else {
          delta = delta + ((slope / (prevSlope - slope)) * prevDelta);
        }
      }
      else if (prevDelta < (0.0 - Logic.$MODE_SWITCH$)) {
        if (slope < 0.0) {
          delta = Logic.$LEARNING_RATE$ * slope;
        }
        if (slope < (Logic.$SHRINK_FACTOR$ * prevSlope)) {
          delta = delta + (Logic.$MAX_MOVEMENT$ * prevDelta);
        }
        else {
          delta = delta + ((slope / (prevSlope - slope)) * prevDelta);
        }
      }
      else {
        delta = (Logic.$LEARNING_RATE$ * slope) + (Logic.$MOMENTUM_TERM$ * prevDelta);
      }
      return (delta);
    }
  }

  public static void modifyWeights() {
    { double delta = 0.0;
      int numIn = 0;
      int numHidden = 0;

      { PropositionNeuralNetwork net = null;
        Cons iter000 = Logic.$MASTER_NEURAL_NETWORK_LIST$.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          net = ((PropositionNeuralNetwork)(iter000.value));
          numIn = net.input.length();
          numHidden = net.hidden.length();
          { int h = Stella.NULL_INTEGER;
            int iter001 = 0;
            int upperBound000 = numHidden - 1;

            for (;iter001 <= upperBound000; iter001 = iter001 + 1) {
              h = iter001;
              delta = Logic.computeQpDelta(((FloatWrapper)((net.hoSlope.theArray)[h])).wrapperValue, ((FloatWrapper)((net.hoPrevSlope.theArray)[h])).wrapperValue, ((FloatWrapper)((net.hoDelta.theArray)[h])).wrapperValue);
              (net.ho.theArray)[h] = (FloatWrapper.wrapFloat(((FloatWrapper)((net.ho.theArray)[h])).wrapperValue + delta));
              (net.hoDelta.theArray)[h] = (FloatWrapper.wrapFloat(delta));
            }
          }
          { int i = Stella.NULL_INTEGER;
            int iter002 = 0;
            int upperBound001 = numIn - 1;

            for (;iter002 <= upperBound001; iter002 = iter002 + 1) {
              i = iter002;
              { int h = Stella.NULL_INTEGER;
                int iter003 = 0;
                int upperBound002 = numHidden - 1;

                for (;iter003 <= upperBound002; iter003 = iter003 + 1) {
                  h = iter003;
                  delta = Logic.computeQpDelta(((FloatWrapper)((net.ihSlope.theArray)[((i * net.ihSlope.nofColumns) + h)])).wrapperValue, ((FloatWrapper)((net.ihPrevSlope.theArray)[((i * net.ihPrevSlope.nofColumns) + h)])).wrapperValue, ((FloatWrapper)((net.ihDelta.theArray)[((i * net.ihDelta.nofColumns) + h)])).wrapperValue);
                  (net.ih.theArray)[((i * net.ih.nofColumns) + h)] = (FloatWrapper.wrapFloat(((FloatWrapper)((net.ih.theArray)[((i * net.ih.nofColumns) + h)])).wrapperValue + delta));
                  (net.ihDelta.theArray)[((i * net.ihDelta.nofColumns) + h)] = (FloatWrapper.wrapFloat(delta));
                }
              }
            }
          }
        }
      }
    }
  }

  public static double testOverTrainingExamples() {
    { double mse = 0.0;
      double error = 0.0;
      double output = 0.0;
      Cons form = Stella.NIL;
      QueryIterator query = null;

      { TrainingExample example = null;
        Cons iter000 = Logic.$TRAINING_EXAMPLES$.theConsList;
        int i = Stella.NULL_INTEGER;
        int iter001 = 0;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
          example = ((TrainingExample)(iter000.value));
          i = iter001;
          if (!(example.module == null)) {
            example.module.changeModule();
          }
          form = ((Cons)(Stella_Object.copyConsTree(example.query)));
          query = Logic.makeQuery(Stella.NIL, Logic.coerceToTree(form), Stella.NIL, Stella.NIL);
          output = QueryIterator.returnPartialTruth(query, true);
          Stella.STANDARD_OUTPUT.nativeStream.println("Example " + i + ": " + example.query.rest.value + ", " + output + "  Target: " + example.score);
          error = example.score - output;
          mse = mse + (error * error);
        }
      }
      return (mse);
    }
  }

  public static FloatWrapper testOverTrainingExamplesEvaluatorWrapper(Cons arguments) {
    arguments = arguments;
    { double result = Logic.testOverTrainingExamples();

      if (result != Stella.NULL_FLOAT) {
        return (FloatWrapper.wrapFloat(result));
      }
      else {
        return (null);
      }
    }
  }

  public static double trainAndTestNeuralNetwork(int cycles, int numTraining, int numTesting) {
    Logic.trainNeuralNetwork(cycles, numTraining);
    { double mse = 0.0;
      Vector testingExamples = Vector.newVector(numTesting);

      { int i = Stella.NULL_INTEGER;
        int iter000 = numTraining;
        int upperBound000 = numTraining + (numTesting - 1);

        for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
          i = iter000;
          (testingExamples.theArray)[(i - numTraining)] = (((TrainingExample)(Logic.$TRAINING_EXAMPLES$.nth(i))));
        }
      }
      { TrainingExample example = null;
        Vector vector000 = testingExamples;
        int index000 = 0;
        int length000 = vector000.length();

        for (;index000 < length000; index000 = index000 + 1) {
          example = ((TrainingExample)((vector000.theArray)[index000]));
          if (!(example.module == null)) {
            example.module.changeModule();
          }
          { Cons form = ((Cons)(Stella_Object.copyConsTree(example.query)));
            QueryIterator query = Logic.makeQuery(Stella.NIL, Logic.coerceToTree(form), Stella.NIL, Stella.NIL);
            double output = QueryIterator.returnPartialTruth(query, true);
            double error = example.score - output;

            mse = mse + (error * error);
          }
        }
      }
      mse = mse / numTesting;
      return (mse);
    }
  }

  public static FloatWrapper trainAndTestNeuralNetworkEvaluatorWrapper(Cons arguments) {
    { double result = Logic.trainAndTestNeuralNetwork(((IntegerWrapper)(arguments.value)).wrapperValue, ((IntegerWrapper)(arguments.rest.value)).wrapperValue, ((IntegerWrapper)(arguments.rest.rest.value)).wrapperValue);

      if (result != Stella.NULL_FLOAT) {
        return (FloatWrapper.wrapFloat(result));
      }
      else {
        return (null);
      }
    }
  }

  public static double testNeuralNetwork() {
    { double errorSum = 0.0;
      int numTesting = Logic.$TESTING_EXAMPLES$.length();

      { TrainingExample example = null;
        Cons iter000 = Logic.$TESTING_EXAMPLES$.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          example = ((TrainingExample)(iter000.value));
          if (!(example.module == null)) {
            example.module.changeModule();
          }
          { Cons form = ((Cons)(Stella_Object.copyConsTree(example.query)));
            QueryIterator query = Logic.makeQuery(Stella.NIL, Logic.coerceToTree(form), Stella.NIL, Stella.NIL);
            double output = QueryIterator.returnPartialTruth(query, true);
            double error = example.score - output;

            errorSum = errorSum + (((error < 0.0) ? (0.0 - error) : error));
          }
        }
      }
      errorSum = errorSum / numTesting;
      return (errorSum);
    }
  }

  public static FloatWrapper testNeuralNetworkEvaluatorWrapper(Cons arguments) {
    arguments = arguments;
    { double result = Logic.testNeuralNetwork();

      if (result != Stella.NULL_FLOAT) {
        return (FloatWrapper.wrapFloat(result));
      }
      else {
        return (null);
      }
    }
  }

  public static double multipleNetworkTrainingRuns(int runs, int cycles, int numTraining) {
    { Vector errors = Vector.newVector(runs);
      double sum = 0.0;

      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = runs - 1;

        for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
          i = iter000;
          Logic.clearAllNeuralNetworks();
          Logic.trainNeuralNetwork(cycles, numTraining);
          (errors.theArray)[i] = (FloatWrapper.wrapFloat(Logic.testNeuralNetwork()));
          sum = sum + ((FloatWrapper)((errors.theArray)[i])).wrapperValue;
          Stella.STANDARD_OUTPUT.nativeStream.println("** Run " + i + ": " + ((FloatWrapper)((errors.theArray)[i])));
        }
      }
      {
        Stella.STANDARD_OUTPUT.nativeStream.println();
        Stella.STANDARD_OUTPUT.nativeStream.println("*** Report");
      }
;
      { int i = Stella.NULL_INTEGER;
        int iter001 = 0;
        int upperBound001 = runs - 1;

        for (;iter001 <= upperBound001; iter001 = iter001 + 1) {
          i = iter001;
          Stella.STANDARD_OUTPUT.nativeStream.println("** Run " + i + ": " + ((FloatWrapper)((errors.theArray)[i])));
        }
      }
      return (sum / runs);
    }
  }

  public static FloatWrapper multipleNetworkTrainingRunsEvaluatorWrapper(Cons arguments) {
    { double result = Logic.multipleNetworkTrainingRuns(((IntegerWrapper)(arguments.value)).wrapperValue, ((IntegerWrapper)(arguments.rest.value)).wrapperValue, ((IntegerWrapper)(arguments.rest.rest.value)).wrapperValue);

      if (result != Stella.NULL_FLOAT) {
        return (FloatWrapper.wrapFloat(result));
      }
      else {
        return (null);
      }
    }
  }

  public static void trainCachedNeuralNetworks(int cycles, int numTraining) {
    { double mse = 0.0;
      double absError = 0.0;
      double error = 0.0;
      double target = 0.0;
      double output = 0.0;
      int numEx = Logic.$TRAINING_EXAMPLES$.length();
      Vector index = Vector.newVector(numTraining);
      OutputStream lookPtr = null;
      Vector examples = Vector.newVector(numTraining);
      Vector netRecords = Vector.newVector(numTraining);

      if (numTraining > numEx) {
        Stella.STANDARD_OUTPUT.nativeStream.print("Error: There are only " + numEx + " training examples");
        return;
      }
      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = numTraining - 1;
        TrainingExample example = null;
        Cons iter001 = Logic.$TRAINING_EXAMPLES$.theConsList;

        for (;(iter000 <= upperBound000) &&
                  (!(iter001 == Stella.NIL)); iter000 = iter000 + 1, iter001 = iter001.rest) {
          i = iter000;
          example = ((TrainingExample)(iter001.value));
          (examples.theArray)[i] = example;
          (index.theArray)[i] = (IntegerWrapper.wrapInteger(i));
        }
      }
      { int i = Stella.NULL_INTEGER;
        int iter002 = 0;
        int upperBound001 = numTraining - 1;

        for (;iter002 <= upperBound001; iter002 = iter002 + 1) {
          i = iter002;
          { TrainingExample example = ((TrainingExample)((examples.theArray)[i]));
            int timestamp = Logic.getNowTimestamp();

            if ((!(example.cachedSolution == null)) &&
                (timestamp == example.timestamp)) {
              (netRecords.theArray)[i] = (((Cons)(example.cachedSolution)));
            }
            else {
              { Module currentModule = ((Module)(Stella.$MODULE$.get()));

                if (!(example.module == null)) {
                  example.module.changeModule();
                }
                (netRecords.theArray)[i] = (Logic.createCachedNetwork(example.query));
                example.cachedSolution = ((Cons)((netRecords.theArray)[i]));
                example.timestamp = timestamp;
                currentModule.changeModule();
              }
            }
          }
        }
      }
      Stella.STANDARD_OUTPUT.nativeStream.println("Training Networks");
      { int cycle = Stella.NULL_INTEGER;
        int iter003 = 0;
        int upperBound002 = cycles - 1;

        loop002 : for (;iter003 <= upperBound002; iter003 = iter003 + 1) {
          cycle = iter003;
          mse = 0.0;
          absError = 0.0;
          if ((Logic.$NEURAL_NETWORK_TRAINING_METHOD$ == Logic.KWD_BACKPROP) ||
              (Logic.$NEURAL_NETWORK_TRAINING_METHOD$ == Logic.KWD_BACKPROPAGATION)) {
            Logic.shuffleVector(index);
          }
          else if (Logic.$NEURAL_NETWORK_TRAINING_METHOD$ == Logic.KWD_QUICKPROP) {
            Logic.clearAllSlopes();
          }
          else {
            { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

              stream000.nativeStream.print("`" + Logic.$NEURAL_NETWORK_TRAINING_METHOD$ + "' is not a valid case option");
              throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
            }
          }
          { int k = Stella.NULL_INTEGER;
            int iter004 = 0;
            int upperBound003 = numTraining - 1;

            for (;iter004 <= upperBound003; iter004 = iter004 + 1) {
              k = iter004;
              if (Logic.$TRACE_NEURAL_NETWORK_TRAINING$) {
                Stella.STANDARD_OUTPUT.nativeStream.println("Example " + k + ": " + ((TrainingExample)((examples.theArray)[(((IntegerWrapper)((index.theArray)[k])).wrapperValue)])).query + "  " + ((TrainingExample)((examples.theArray)[(((IntegerWrapper)((index.theArray)[k])).wrapperValue)])).score);
              }
              target = ((TrainingExample)((examples.theArray)[(((IntegerWrapper)((index.theArray)[k])).wrapperValue)])).score;
              output = Logic.activateCachedNetwork(((Cons)((netRecords.theArray)[(((IntegerWrapper)((index.theArray)[k])).wrapperValue)])));
              error = Logic.computeError(target, output);
              if (Logic.$TRACE_NEURAL_NETWORK_TRAINING$) {
                Stella.STANDARD_OUTPUT.nativeStream.println("   Output: " + output);
              }
              absError = absError + (((error < 0.0) ? (0.0 - error) : error));
              mse = mse + (error * error);
              if ((Logic.$NEURAL_NETWORK_TRAINING_METHOD$ == Logic.KWD_BACKPROPAGATION) ||
                  (Logic.$NEURAL_NETWORK_TRAINING_METHOD$ == Logic.KWD_BACKPROP)) {
                Logic.cachedBackpropagateError(((Cons)((netRecords.theArray)[(((IntegerWrapper)((index.theArray)[k])).wrapperValue)])), error);
              }
              else if (Logic.$NEURAL_NETWORK_TRAINING_METHOD$ == Logic.KWD_QUICKPROP) {
                Logic.cachedQuickpropagateError(((Cons)((netRecords.theArray)[(((IntegerWrapper)((index.theArray)[k])).wrapperValue)])), error);
              }
              else {
                { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

                  stream001.nativeStream.print("`" + Logic.$NEURAL_NETWORK_TRAINING_METHOD$ + "' is not a valid case option");
                  throw ((StellaException)(StellaException.newStellaException(stream001.theStringReader()).fillInStackTrace()));
                }
              }
            }
          }
          if (Logic.$NEURAL_NETWORK_TRAINING_METHOD$ == Logic.KWD_QUICKPROP) {
            Logic.modifyWeights();
          }
          if ((Logic.$SAVE_NETWORK_CYCLE$ > 0) &&
              ((cycle % Logic.$SAVE_NETWORK_CYCLE$) == 0)) {
            Stella.STANDARD_OUTPUT.nativeStream.println("Saving networks");
            Logic.saveAllNeuralNetworks(Logic.$SAVE_NETWORK_FILE$);
          }
          if ((Logic.$ERROR_PRINT_CYCLE$ > 0) &&
              ((cycle % Logic.$ERROR_PRINT_CYCLE$) == 0)) {
            if (Logic.$SAVE_NETWORK_FILE$ != null) {
              if (lookPtr == null) {
                lookPtr = OutputFileStream.newOutputFileStream(Logic.$SAVE_NETWORK_FILE$ + ".err");
              }
              lookPtr.nativeStream.println("Cycle " + cycle + " Error: " + (absError / numTraining));
            }
            Stella.STANDARD_OUTPUT.nativeStream.println("Cycle " + cycle + " Error: " + (absError / numTraining));
          }
          if ((mse / numTraining) < Logic.$ERROR_CUTOFF$) {
            break loop002;
          }
        }
      }
      if (lookPtr != null) {
        lookPtr.free();
      }
    }
  }

  public static void cachedBackpropagateError(Cons tree, double error) {
    { PropositionNeuralNetwork net = null;
      double temp = 0.0;
      double delta = 0.0;
      Vector input = null;
      Vector hidden = null;
      Vector hiddenError = null;
      Vector inputError = null;
      boolean recursiveConflictP = false;

      if (Stella_Object.isaP(tree.value, Logic.SGT_STELLA_CONS)) {
        if (Logic.$RULE_COMBINATION$ == Logic.KWD_MAX) {
          { double max = 0.0;
            Cons guilty = Stella.NIL;

            { Stella_Object netDef = null;
              Cons iter000 = tree;

              for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                netDef = iter000.value;
                net = ((PropositionNeuralNetwork)(((Cons)(netDef)).value));
                if (net.output > max) {
                  max = net.output;
                  guilty = ((Cons)(netDef));
                }
              }
            }
            Logic.cachedBackpropagateError(guilty, error);
          }
        }
        else if (Logic.$RULE_COMBINATION$ == Logic.KWD_NOISY_OR) {
          { Stella_Object netDef = null;
            Cons iter001 = tree;

            for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
              netDef = iter001.value;
              Logic.cachedBackpropagateError(((Cons)(netDef)), error * ((PropositionNeuralNetwork)(((Cons)(netDef)).value)).output);
            }
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + Logic.$RULE_COMBINATION$ + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
        return;
      }
      net = ((PropositionNeuralNetwork)(tree.value));
      input = net.input;
      hidden = net.hidden;
      inputError = net.inputError;
      hiddenError = net.hiddenError;
      error = error * net.output * (1.0 - net.output);
      { int i = Stella.NULL_INTEGER;
        int iter002 = 1;
        int upperBound000 = net.input.length() - 1;
        Stella_Object ele = null;
        Cons iter003 = tree.rest;

        loop002 : for (;(iter002 <= upperBound000) &&
                  (!(iter003 == Stella.NIL)); iter002 = iter002 + 1, iter003 = iter003.rest) {
          i = iter002;
          ele = iter003.value;
          { Surrogate testValue000 = Stella_Object.safePrimaryType(ele);

            if (testValue000 == Logic.SGT_STELLA_CONS) {
              { Cons ele000 = ((Cons)(ele));

                if (ele000.length() == 1) {
                  temp = ((PropositionNeuralNetwork)(((Cons)(ele000.value)).value)).output;
                }
                else {
                  if (Logic.$RULE_COMBINATION$ == Logic.KWD_MAX) {
                    temp = 0.0;
                    { Stella_Object netDef = null;
                      Cons iter004 = ele000;

                      for (;!(iter004 == Stella.NIL); iter004 = iter004.rest) {
                        netDef = iter004.value;
                        if (((PropositionNeuralNetwork)(((Cons)(netDef)).value)).output > temp) {
                          temp = net.output;
                        }
                      }
                    }
                  }
                  else if (Logic.$RULE_COMBINATION$ == Logic.KWD_NOISY_OR) {
                    { Cons scores = Stella.NIL;

                      { Stella_Object netDef = null;
                        Cons iter005 = ele000;
                        Cons collect000 = null;

                        for (;!(iter005 == Stella.NIL); iter005 = iter005.rest) {
                          netDef = iter005.value;
                          if (collect000 == null) {
                            {
                              collect000 = Cons.cons(FloatWrapper.wrapFloat(((PropositionNeuralNetwork)(((Cons)(netDef)).value)).output), Stella.NIL);
                              if (scores == Stella.NIL) {
                                scores = collect000;
                              }
                              else {
                                Cons.addConsToEndOfConsList(scores, collect000);
                              }
                            }
                          }
                          else {
                            {
                              collect000.rest = Cons.cons(FloatWrapper.wrapFloat(((PropositionNeuralNetwork)(((Cons)(netDef)).value)).output), Stella.NIL);
                              collect000 = collect000.rest;
                            }
                          }
                        }
                      }
                      temp = Logic.probabilisticSumN(scores);
                    }
                  }
                  else {
                    { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

                      stream001.nativeStream.print("`" + Logic.$RULE_COMBINATION$ + "' is not a valid case option");
                      throw ((StellaException)(StellaException.newStellaException(stream001.theStringReader()).fillInStackTrace()));
                    }
                  }
                }
              }
            }
            else if (Surrogate.subtypeOfFloatP(testValue000)) {
              { FloatWrapper ele000 = ((FloatWrapper)(ele));

                temp = ele000.wrapperValue;
              }
            }
            else {
              { OutputStringStream stream002 = OutputStringStream.newOutputStringStream();

                stream002.nativeStream.print("`" + testValue000 + "' is not a valid case option");
                throw ((StellaException)(StellaException.newStellaException(stream002.theStringReader()).fillInStackTrace()));
              }
            }
          }
          { double value = ((FloatWrapper)((net.input.theArray)[i])).wrapperValue;

            if (!(value == temp)) {
              recursiveConflictP = true;
              break loop002;
            }
          }
        }
      }
      if (recursiveConflictP) {
        Logic.activateCachedNetwork(Cons.consList(Cons.cons(tree, Stella.NIL)));
        hidden = Vector.newVector(net.hidden.length());
        hiddenError = Vector.newVector(net.hidden.length());
        input = Vector.newVector(net.input.length());
        { int i = Stella.NULL_INTEGER;
          int iter006 = 0;
          int upperBound001 = input.length() - 1;

          for (;iter006 <= upperBound001; iter006 = iter006 + 1) {
            i = iter006;
            (input.theArray)[i] = (((FloatWrapper)((net.input.theArray)[i])));
          }
        }
        { int h = Stella.NULL_INTEGER;
          int iter007 = 0;
          int upperBound002 = hidden.length() - 1;

          for (;iter007 <= upperBound002; iter007 = iter007 + 1) {
            h = iter007;
            (hidden.theArray)[h] = (((FloatWrapper)((net.hidden.theArray)[h])));
          }
        }
      }
      { int h = Stella.NULL_INTEGER;
        int iter008 = 0;
        int upperBound003 = hidden.length() - 1;

        for (;iter008 <= upperBound003; iter008 = iter008 + 1) {
          h = iter008;
          (hiddenError.theArray)[h] = (FloatWrapper.wrapFloat(error * ((FloatWrapper)((net.ho.theArray)[h])).wrapperValue));
          (hiddenError.theArray)[h] = (FloatWrapper.wrapFloat(((FloatWrapper)((hiddenError.theArray)[h])).wrapperValue * ((FloatWrapper)((hidden.theArray)[h])).wrapperValue * (1.0 - ((FloatWrapper)((hidden.theArray)[h])).wrapperValue)));
        }
      }
      { int i = Stella.NULL_INTEGER;
        int iter009 = 0;
        int upperBound004 = input.length() - 1;

        for (;iter009 <= upperBound004; iter009 = iter009 + 1) {
          i = iter009;
          (inputError.theArray)[i] = (FloatWrapper.wrapFloat(0.0));
          { int h = Stella.NULL_INTEGER;
            int iter010 = 0;
            int upperBound005 = hidden.length() - 1;

            for (;iter010 <= upperBound005; iter010 = iter010 + 1) {
              h = iter010;
              (inputError.theArray)[i] = (FloatWrapper.wrapFloat(((FloatWrapper)((inputError.theArray)[i])).wrapperValue + (((FloatWrapper)((hiddenError.theArray)[h])).wrapperValue * ((FloatWrapper)((net.ih.theArray)[((i * net.ih.nofColumns) + h)])).wrapperValue)));
            }
          }
        }
      }
      { Stella_Object input000 = null;
        Cons iter011 = tree.rest;
        int i = Stella.NULL_INTEGER;
        int iter012 = 1;

        for (;!(iter011 == Stella.NIL); iter011 = iter011.rest, iter012 = iter012 + 1) {
          input000 = iter011.value;
          i = iter012;
          if (Stella_Object.isaP(input000, Logic.SGT_STELLA_CONS)) {
            Logic.cachedBackpropagateError(((Cons)(input000)), ((FloatWrapper)((inputError.theArray)[i])).wrapperValue);
          }
        }
      }
      { int h = Stella.NULL_INTEGER;
        int iter013 = 0;
        int upperBound006 = hidden.length() - 1;

        for (;iter013 <= upperBound006; iter013 = iter013 + 1) {
          h = iter013;
          delta = (Logic.$MOMENTUM_TERM$ * ((FloatWrapper)((net.hoDelta.theArray)[h])).wrapperValue) + (Logic.$LEARNING_RATE$ * error * ((FloatWrapper)((hidden.theArray)[h])).wrapperValue);
          (net.ho.theArray)[h] = (FloatWrapper.wrapFloat(((FloatWrapper)((net.ho.theArray)[h])).wrapperValue + delta));
          (net.hoDelta.theArray)[h] = (FloatWrapper.wrapFloat(delta));
          { int i = Stella.NULL_INTEGER;
            int iter014 = 0;
            int upperBound007 = input.length() - 1;

            for (;iter014 <= upperBound007; iter014 = iter014 + 1) {
              i = iter014;
              delta = (Logic.$MOMENTUM_TERM$ * ((FloatWrapper)((net.ihDelta.theArray)[((i * net.ihDelta.nofColumns) + h)])).wrapperValue) + (Logic.$LEARNING_RATE$ * ((FloatWrapper)((hiddenError.theArray)[h])).wrapperValue * ((FloatWrapper)((input.theArray)[i])).wrapperValue);
              (net.ih.theArray)[((i * net.ih.nofColumns) + h)] = (FloatWrapper.wrapFloat(((FloatWrapper)((net.ih.theArray)[((i * net.ih.nofColumns) + h)])).wrapperValue + delta));
              (net.ihDelta.theArray)[((i * net.ihDelta.nofColumns) + h)] = (FloatWrapper.wrapFloat(delta));
            }
          }
        }
      }
    }
  }

  public static void cachedQuickpropagateError(Cons tree, double error) {
    { PropositionNeuralNetwork net = null;
      double temp = 0.0;
      Vector input = null;
      Vector hidden = null;
      Vector inputError = null;
      boolean recursiveConflictP = false;

      if (Stella_Object.isaP(tree.value, Logic.SGT_STELLA_CONS)) {
        if (Logic.$RULE_COMBINATION$ == Logic.KWD_MAX) {
          { double max = 0.0;
            Cons guilty = Stella.NIL;

            { Stella_Object netDef = null;
              Cons iter000 = tree;

              for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                netDef = iter000.value;
                net = ((PropositionNeuralNetwork)(((Cons)(netDef)).value));
                if (net.output > max) {
                  max = net.output;
                  guilty = ((Cons)(netDef));
                }
              }
            }
            Logic.cachedQuickpropagateError(guilty, error);
          }
        }
        else if (Logic.$RULE_COMBINATION$ == Logic.KWD_NOISY_OR) {
          { Stella_Object netDef = null;
            Cons iter001 = tree;

            for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
              netDef = iter001.value;
              Logic.cachedQuickpropagateError(((Cons)(netDef)), error * ((PropositionNeuralNetwork)(((Cons)(netDef)).value)).output);
            }
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + Logic.$RULE_COMBINATION$ + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
        return;
      }
      net = ((PropositionNeuralNetwork)(tree.value));
      input = net.input;
      hidden = net.hidden;
      inputError = net.inputError;
      error = error * (Logic.$SIGMOID_PRIME_OFFSET$ + (net.output * (1.0 - net.output)));
      { int i = Stella.NULL_INTEGER;
        int iter002 = 1;
        int upperBound000 = net.input.length() - 1;
        Stella_Object ele = null;
        Cons iter003 = tree.rest;

        loop002 : for (;(iter002 <= upperBound000) &&
                  (!(iter003 == Stella.NIL)); iter002 = iter002 + 1, iter003 = iter003.rest) {
          i = iter002;
          ele = iter003.value;
          { Surrogate testValue000 = Stella_Object.safePrimaryType(ele);

            if (testValue000 == Logic.SGT_STELLA_CONS) {
              { Cons ele000 = ((Cons)(ele));

                if (ele000.length() == 1) {
                  temp = ((PropositionNeuralNetwork)(((Cons)(ele000.value)).value)).output;
                }
                else {
                  if (Logic.$RULE_COMBINATION$ == Logic.KWD_MAX) {
                    temp = 0.0;
                    { Stella_Object netDef = null;
                      Cons iter004 = ele000;

                      for (;!(iter004 == Stella.NIL); iter004 = iter004.rest) {
                        netDef = iter004.value;
                        if (((PropositionNeuralNetwork)(((Cons)(netDef)).value)).output > temp) {
                          temp = net.output;
                        }
                      }
                    }
                  }
                  else if (Logic.$RULE_COMBINATION$ == Logic.KWD_NOISY_OR) {
                    { Cons scores = Stella.NIL;

                      { Stella_Object netDef = null;
                        Cons iter005 = ele000;
                        Cons collect000 = null;

                        for (;!(iter005 == Stella.NIL); iter005 = iter005.rest) {
                          netDef = iter005.value;
                          if (collect000 == null) {
                            {
                              collect000 = Cons.cons(FloatWrapper.wrapFloat(((PropositionNeuralNetwork)(((Cons)(netDef)).value)).output), Stella.NIL);
                              if (scores == Stella.NIL) {
                                scores = collect000;
                              }
                              else {
                                Cons.addConsToEndOfConsList(scores, collect000);
                              }
                            }
                          }
                          else {
                            {
                              collect000.rest = Cons.cons(FloatWrapper.wrapFloat(((PropositionNeuralNetwork)(((Cons)(netDef)).value)).output), Stella.NIL);
                              collect000 = collect000.rest;
                            }
                          }
                        }
                      }
                      temp = Logic.probabilisticSumN(scores);
                    }
                  }
                  else {
                    { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

                      stream001.nativeStream.print("`" + Logic.$RULE_COMBINATION$ + "' is not a valid case option");
                      throw ((StellaException)(StellaException.newStellaException(stream001.theStringReader()).fillInStackTrace()));
                    }
                  }
                }
              }
            }
            else if (Surrogate.subtypeOfFloatP(testValue000)) {
              { FloatWrapper ele000 = ((FloatWrapper)(ele));

                temp = ele000.wrapperValue;
              }
            }
            else {
              { OutputStringStream stream002 = OutputStringStream.newOutputStringStream();

                stream002.nativeStream.print("`" + testValue000 + "' is not a valid case option");
                throw ((StellaException)(StellaException.newStellaException(stream002.theStringReader()).fillInStackTrace()));
              }
            }
          }
          { double value = ((FloatWrapper)((net.input.theArray)[i])).wrapperValue;

            if (!(value == temp)) {
              recursiveConflictP = true;
              break loop002;
            }
          }
        }
      }
      if (recursiveConflictP) {
        Logic.activateCachedNetwork(Cons.consList(Cons.cons(tree, Stella.NIL)));
      }
      Logic.zeroVector(inputError);
      { int h = Stella.NULL_INTEGER;
        int iter006 = 0;
        int upperBound001 = hidden.length() - 1;

        for (;iter006 <= upperBound001; iter006 = iter006 + 1) {
          h = iter006;
          (net.hoSlope.theArray)[h] = (FloatWrapper.wrapFloat(((FloatWrapper)((net.hoSlope.theArray)[h])).wrapperValue + (error * ((FloatWrapper)((hidden.theArray)[h])).wrapperValue)));
          temp = error * ((FloatWrapper)((net.ho.theArray)[h])).wrapperValue * (Logic.$SIGMOID_PRIME_OFFSET$ + (((FloatWrapper)((hidden.theArray)[h])).wrapperValue * (1.0 - ((FloatWrapper)((hidden.theArray)[h])).wrapperValue)));
          { int i = Stella.NULL_INTEGER;
            int iter007 = 0;
            int upperBound002 = input.length() - 1;

            for (;iter007 <= upperBound002; iter007 = iter007 + 1) {
              i = iter007;
              (net.ihSlope.theArray)[((i * net.ihSlope.nofColumns) + h)] = (FloatWrapper.wrapFloat(((FloatWrapper)((net.ihSlope.theArray)[((i * net.ihSlope.nofColumns) + h)])).wrapperValue + (temp * ((FloatWrapper)((input.theArray)[i])).wrapperValue)));
              (inputError.theArray)[i] = (FloatWrapper.wrapFloat(((FloatWrapper)((inputError.theArray)[i])).wrapperValue + (temp * ((FloatWrapper)((net.ih.theArray)[((i * net.ih.nofColumns) + h)])).wrapperValue)));
            }
          }
        }
      }
      { Stella_Object input000 = null;
        Cons iter008 = tree.rest;
        int i = Stella.NULL_INTEGER;
        int iter009 = 1;

        for (;!(iter008 == Stella.NIL); iter008 = iter008.rest, iter009 = iter009 + 1) {
          input000 = iter008.value;
          i = iter009;
          if (Stella_Object.isaP(input000, Logic.SGT_STELLA_CONS)) {
            Logic.cachedQuickpropagateError(((Cons)(input000)), ((FloatWrapper)((inputError.theArray)[i])).wrapperValue);
          }
        }
      }
    }
  }

  public static Cons createCachedNetwork(Cons consQuery) {
    { QueryIterator query = Logic.makeQuery(Stella.NIL, Logic.coerceToTree(((Cons)(Stella_Object.copyConsTree(consQuery)))), Stella.NIL, Stella.NIL);
      double score = QueryIterator.returnPartialTruth(query, true);
      Stella_Object tree = Proposition.buildNetworkTree(query.baseControlFrame.proposition, Stella.NIL);

      score = score;
      if (Stella_Object.isaP(tree, Logic.SGT_STELLA_CONS)) {
        return (((Cons)(tree)));
      }
      return (Stella.NIL);
    }
  }

  public static double activateCachedNetwork(Cons tree) {
    { Vector scores = Vector.newVector(tree.length());
      double score = 0.0;
      double sum = 0.0;

      { Cons cachedNet = null;
        Cons iter000 = tree;
        int k = Stella.NULL_INTEGER;
        int iter001 = 0;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
          cachedNet = ((Cons)(iter000.value));
          k = iter001;
          { PropositionNeuralNetwork net = ((PropositionNeuralNetwork)(cachedNet.value));

            sum = 0.0;
            score = 0.0;
            (net.input.theArray)[0] = (FloatWrapper.wrapFloat(1.0));
            { int i = Stella.NULL_INTEGER;
              int iter002 = 1;
              int upperBound000 = net.input.length() - 1;
              Stella_Object input = null;
              Cons iter003 = cachedNet.rest;

              for (;(iter002 <= upperBound000) &&
                        (!(iter003 == Stella.NIL)); iter002 = iter002 + 1, iter003 = iter003.rest) {
                i = iter002;
                input = iter003.value;
                if (Stella_Object.isaP(input, Logic.SGT_STELLA_CONS)) {
                  (net.input.theArray)[i] = (FloatWrapper.wrapFloat(Logic.activateCachedNetwork(((Cons)(input)))));
                }
                else {
                  (net.input.theArray)[i] = (((FloatWrapper)(input)));
                }
              }
            }
            { int i = Stella.NULL_INTEGER;
              int iter004 = 0;
              int upperBound001 = net.hidden.length() - 1;

              for (;iter004 <= upperBound001; iter004 = iter004 + 1) {
                i = iter004;
                { int j = Stella.NULL_INTEGER;
                  int iter005 = 0;
                  int upperBound002 = net.input.length() - 1;

                  for (;iter005 <= upperBound002; iter005 = iter005 + 1) {
                    j = iter005;
                    sum = sum + (((FloatWrapper)((net.input.theArray)[j])).wrapperValue * ((FloatWrapper)((net.ih.theArray)[((j * net.ih.nofColumns) + i)])).wrapperValue);
                  }
                }
                (net.hidden.theArray)[i] = (FloatWrapper.wrapFloat(1.0 / (1.0 + Math.exp((0 - sum)))));
                score = score + (((FloatWrapper)((net.hidden.theArray)[i])).wrapperValue * ((FloatWrapper)((net.ho.theArray)[i])).wrapperValue);
              }
            }
            net.output = 1.0 / (1.0 + Math.exp((0 - score)));
            (scores.theArray)[k] = (FloatWrapper.wrapFloat(net.output));
          }
        }
      }
      if (Logic.$RULE_COMBINATION$ == Logic.KWD_MAX) {
        { FloatWrapper max = ((FloatWrapper)((scores.theArray)[0]));

          { int i = Stella.NULL_INTEGER;
            int iter006 = 0;
            int upperBound003 = scores.length() - 1;

            for (;iter006 <= upperBound003; iter006 = iter006 + 1) {
              i = iter006;
              if (((FloatWrapper)((scores.theArray)[i])).wrapperValue > max.wrapperValue) {
                max = ((FloatWrapper)((scores.theArray)[i]));
              }
            }
          }
          return (max.wrapperValue);
        }
      }
      else if (Logic.$RULE_COMBINATION$ == Logic.KWD_NOISY_OR) {
        switch (scores.length()) {
          case 0: 
            return (0.0);
          case 1: 
            return (((FloatWrapper)((scores.theArray)[0])).wrapperValue);
          case 2: 
            return (Logic.probabilisticSum(((FloatWrapper)((scores.theArray)[0])).wrapperValue, ((FloatWrapper)((scores.theArray)[1])).wrapperValue));
          default:
            { Cons consScores = Stella.NIL;

              { FloatWrapper ele = null;
                Vector vector000 = scores;
                int index000 = 0;
                int length000 = vector000.length();
                Cons collect000 = null;

                for (;index000 < length000; index000 = index000 + 1) {
                  ele = ((FloatWrapper)((vector000.theArray)[index000]));
                  if (collect000 == null) {
                    {
                      collect000 = Cons.cons(ele, Stella.NIL);
                      if (consScores == Stella.NIL) {
                        consScores = collect000;
                      }
                      else {
                        Cons.addConsToEndOfConsList(consScores, collect000);
                      }
                    }
                  }
                  else {
                    {
                      collect000.rest = Cons.cons(ele, Stella.NIL);
                      collect000 = collect000.rest;
                    }
                  }
                }
              }
              return (Logic.probabilisticSumN(consScores));
            }
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + Logic.$RULE_COMBINATION$ + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  public static double randomWeight(double n) {
    if (Stella.random(2) == 1) {
      return (Logic.randomFloat(n));
    }
    return (0.0 - Logic.randomFloat(n));
  }

  /** Generate a random integer in the interval [0..n-1].
   * 'n' must be &lt;= 2^15.
   * @param n
   * @return double
   */
  public static double randomFloat(double n) {
    if (n > 32768) {
      throw ((StellaException)(StellaException.newStellaException("random: Can only generate random numbers between 0 and (2^15)-1.").fillInStackTrace()));
    }
    return (n * (Stella.random(32768) / 32767.0));
  }

  public static Vector consToVector(Cons form) {
    { int size = form.length();
      Vector vect = Vector.newVector(size);

      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = size - 1;

        for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
          i = iter000;
          (vect.theArray)[i] = (form.nth(i));
        }
      }
      return (vect);
    }
  }

  /** Return a vector containing 'values', in order.
   * @param values
   * @return Vector
   */
  public static Vector createVector(Cons values) {
    { Vector vector = Vector.newVector(values.length());

      { Stella_Object v = null;
        Cons iter000 = values;
        int i = Stella.NULL_INTEGER;
        int iter001 = 0;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
          v = iter000.value;
          i = iter001;
          (vector.theArray)[i] = v;
        }
      }
      return (vector);
    }
  }

  public static void zeroVector(Vector v) {
    { int i = Stella.NULL_INTEGER;
      int iter000 = 0;
      int upperBound000 = v.length() - 1;

      for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
        i = iter000;
        (v.theArray)[i] = (FloatWrapper.wrapFloat(0.0));
      }
    }
  }

  public static void structuredNeuralNetworkRegression(Symbol className, Symbol slotName, int cycles) {
    slotName = ((Symbol)(slotName.permanentify()));
    className = ((Symbol)(className.permanentify()));
    Stella.STANDARD_OUTPUT.nativeStream.println("Generating training examples");
    { Surrogate renamed_Class = Logic.getDescription(className).surrogateValueInverse;
      Surrogate slot = Logic.getDescription(slotName).surrogateValueInverse;
      List ilist = Logic.allClassInstances(renamed_Class).listify();
      Vector instances = Vector.newVector(ilist.length());

      if (!Logic.floatFunctionP(slot)) {
        Stella.STANDARD_OUTPUT.nativeStream.println("ERROR " + slotName + " is not a function of type float or integer");
        return;
      }
      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = ilist.length() - 1;
        Stella_Object instance = null;
        Cons iter001 = ilist.theConsList;

        for (;(iter000 <= upperBound000) &&
                  (!(iter001 == Stella.NIL)); iter000 = iter000 + 1, iter001 = iter001.rest) {
          i = iter000;
          instance = iter001.value;
          (instances.theArray)[i] = (((LogicObject)(instance)));
        }
      }
      Logic.clearCases();
      Logic.generateRegressionRuleWoSlot(instances, slotName, className, true);
      { int num = Logic.generateRegressionTrainingExamples(instances, slot);

        Stella.STANDARD_OUTPUT.nativeStream.println("Training regression networks");
        Logic.trainCachedNeuralNetworks(cycles, num);
      }
    }
  }

  public static void structuredNeuralNetworkRegressionEvaluatorWrapper(Cons arguments) {
    Logic.structuredNeuralNetworkRegression(((Symbol)(arguments.value)), ((Symbol)(arguments.rest.value)), ((IntegerWrapper)(arguments.rest.rest.value)).wrapperValue);
  }

  public static void swapInNewNetworks(List oldNets, List newNets) {
    { PropositionNeuralNetwork oldNet = null;
      Cons iter000 = oldNets.theConsList;
      PropositionNeuralNetwork newNet = null;
      Cons iter001 = newNets.theConsList;

      for (;(!(iter000 == Stella.NIL)) &&
                (!(iter001 == Stella.NIL)); iter000 = iter000.rest, iter001 = iter001.rest) {
        oldNet = ((PropositionNeuralNetwork)(iter000.value));
        newNet = ((PropositionNeuralNetwork)(iter001.value));
        KeyValueList.setDynamicSlotValue(oldNet.proposition.dynamicSlots, Logic.SYM_LOGIC_NEURAL_NETWORK, newNet, null);
        newNet.proposition = oldNet.proposition;
      }
    }
    Logic.$MASTER_NEURAL_NETWORK_LIST$ = newNets;
  }

  public static void swapInNetworkFile(String file) {
    { List newNets = Logic.loadNeuralNetworkFile(file);

      { PropositionNeuralNetwork oldNet = null;
        Cons iter000 = Logic.$MASTER_NEURAL_NETWORK_LIST$.theConsList;
        PropositionNeuralNetwork newNet = null;
        Cons iter001 = newNets.theConsList;

        for (;(!(iter000 == Stella.NIL)) &&
                  (!(iter001 == Stella.NIL)); iter000 = iter000.rest, iter001 = iter001.rest) {
          oldNet = ((PropositionNeuralNetwork)(iter000.value));
          newNet = ((PropositionNeuralNetwork)(iter001.value));
          if ((!(oldNet.input.length() == newNet.input.length())) ||
              (!(oldNet.hidden.length() == newNet.hidden.length()))) {
            Stella.STANDARD_OUTPUT.nativeStream.println("Error: network file does not match master list");
            return;
          }
        }
      }
      Logic.swapInNewNetworks(Logic.$MASTER_NEURAL_NETWORK_LIST$, newNets);
    }
  }

  public static void swapInNetworkFileEvaluatorWrapper(Cons arguments) {
    Logic.swapInNetworkFile(((StringWrapper)(arguments.value)).wrapperValue);
  }

  public static List loadNeuralNetworkFile(String file) {
    { List nets = List.newList();
      InputFileStream stream = InputFileStream.newInputFileStream(file);
      int numHidden = 0;
      Cons prop = Stella.NIL;
      Stella_Object temp = null;
      int numIn = 0;
      PropositionNeuralNetwork net = null;

      for (;;) {
        if (!(InputStream.readSExpression(stream, new Object[1]) == Logic.SYM_LOGIC_DEFNETWORK)) {
          return (nets.reverse());
        }
        prop = ((Cons)(InputStream.readSExpression(stream, new Object[1])));
        numIn = ((IntegerWrapper)(InputStream.readSExpression(stream, new Object[1]))).wrapperValue;
        numHidden = ((IntegerWrapper)(InputStream.readSExpression(stream, new Object[1]))).wrapperValue;
        net = Logic.allocateNeuralNetwork(numIn, numHidden);
        { int i = Stella.NULL_INTEGER;
          int iter000 = 0;
          int upperBound000 = numIn - 1;

          for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
            i = iter000;
            { int h = Stella.NULL_INTEGER;
              int iter001 = 0;
              int upperBound001 = numHidden - 1;

              for (;iter001 <= upperBound001; iter001 = iter001 + 1) {
                h = iter001;
                temp = InputStream.readSExpression(stream, new Object[1]);
                if (Stella_Object.eqlP(temp, Stella.ZERO_WRAPPER)) {
                  temp = FloatWrapper.wrapFloat(0.0);
                }
                (net.ih.theArray)[((i * net.ih.nofColumns) + h)] = (((FloatWrapper)(temp)));
              }
            }
          }
        }
        { int h = Stella.NULL_INTEGER;
          int iter002 = 0;
          int upperBound002 = numHidden - 1;

          for (;iter002 <= upperBound002; iter002 = iter002 + 1) {
            h = iter002;
            (net.ho.theArray)[h] = (((FloatWrapper)(InputStream.readSExpression(stream, new Object[1]))));
          }
        }
        nets.push(net);
      }
    }
  }

  public static List loadNeuralNetworkFileEvaluatorWrapper(Cons arguments) {
    return (Logic.loadNeuralNetworkFile(((StringWrapper)(arguments.value)).wrapperValue));
  }

  /** Save all neural networks to <code>file</code> (if <code>file</code> is non-NULL).
   * If networks are saved periodically (see <code>setSaveNetworkCycle</code>) this file
   * name will be used to perform periodic saves.
   * @param file
   */
  public static void saveAllNeuralNetworks(String file) {
    Logic.$SAVE_NETWORK_FILE$ = file;
    if (file != null) {
      Stella.STANDARD_OUTPUT.nativeStream.println("Saving networks");
      { OutputFileStream fptr = OutputFileStream.newOutputFileStream(file);

        { PropositionNeuralNetwork net = null;
          Cons iter000 = Logic.$MASTER_NEURAL_NETWORK_LIST$.theConsList;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            net = ((PropositionNeuralNetwork)(iter000.value));
            PropositionNeuralNetwork.printNeuralNetwork(net, fptr);
            fptr.nativeStream.println();
          }
        }
        fptr.free();
      }
    }
  }

  public static void saveAllNeuralNetworksEvaluatorWrapper(Cons arguments) {
    Logic.saveAllNeuralNetworks(((StringWrapper)(arguments.value)).wrapperValue);
  }

  public static void saveNeuralNetworkEvaluatorWrapper(Cons arguments) {
    PropositionNeuralNetwork.saveNeuralNetwork(((PropositionNeuralNetwork)(arguments.value)), ((StringWrapper)(arguments.rest.value)).wrapperValue);
  }

  public static Vector createHiddenSignature(Cons consQuery) {
    { QueryIterator query = Logic.makeQuery(Stella.NIL, ((Cons)(Stella_Object.copyConsTree(consQuery))), Stella.NIL, Stella.NIL);
      NnPartialMatch pmf = null;
      PropositionNeuralNetwork net = null;
      Vector result = null;

      query.options.insertAt(Logic.KWD_MATCH_MODE, Logic.KWD_NN);
      query.options.insertAt(Logic.KWD_MAXIMIZE_SCOREp, Stella.TRUE_WRAPPER);
      Logic.callAskPartial(query);
      pmf = ((NnPartialMatch)(query.baseControlFrame.partialMatchFrame.child.child));
      net = ((PropositionNeuralNetwork)(KeyValueList.dynamicSlotValue(pmf.controlFrame.proposition.dynamicSlots, Logic.SYM_LOGIC_NEURAL_NETWORK, null)));
      result = Vector.newVector(net.hidden.length());
      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = net.hidden.length() - 1;

        for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
          i = iter000;
          (result.theArray)[i] = (((FloatWrapper)((net.hidden.theArray)[i])));
        }
      }
      return (result);
    }
  }

  /** Create a two-dimensional array with <code>nofRows</code> rows and
   * <code>nofColumns</code> columns, and initialize it in row-major-order from <code>values</code>.
   * Missing values will be padded with NULL, extraneous values will be ignored.
   * @param nofRows
   * @param nofColumns
   * @param values
   * @return two_D_array
   */
  public static two_D_array create2_D_array(int nofRows, int nofColumns, Cons values) {
    { two_D_array array = two_D_array.new2_D_array(nofRows, nofColumns);
      edu.isi.stella.Stella_Object[] nativearray = array.theArray;

      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = (nofRows * nofColumns) - 1;
        Stella_Object value = null;
        Cons iter001 = values;

        for (;(iter000 <= upperBound000) &&
                  (!(iter001 == Stella.NIL)); iter000 = iter000 + 1, iter001 = iter001.rest) {
          i = iter000;
          value = iter001.value;
          nativearray[i] = value;
        }
      }
      return (array);
    }
  }

  /** Return a vector containing 'values', in order.
   * @param values
   * @return FloatVector
   */
  public static FloatVector createFloatVector(Cons values) {
    { FloatVector vector = FloatVector.newFloatVector(values.length());

      { double v = Stella.NULL_FLOAT;
        Cons iter000 = values;
        int i = Stella.NULL_INTEGER;
        int iter001 = 0;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
          v = ((FloatWrapper)(iter000.value)).wrapperValue;
          i = iter001;
          ((FloatWrapper)(((FloatWrapper)((vector.theArray)[i])))).wrapperValue = v;
        }
      }
      return (vector);
    }
  }

  /** Create a two-dimensional array with <code>nofRows</code> rows and
   * <code>nofColumns</code> columns, and initialize it in row-major-order from <code>values</code>.
   * Missing values will be padded with NULL, extraneous values will be ignored.
   * @param nofRows
   * @param nofColumns
   * @param values
   * @return two_D_floatArray
   */
  public static two_D_floatArray create2_D_floatArray(int nofRows, int nofColumns, Cons values) {
    { two_D_floatArray array = two_D_floatArray.new2_D_floatArray(nofRows, nofColumns);
      edu.isi.stella.Stella_Object[] nativearray = array.theArray;

      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = (nofRows * nofColumns) - 1;
        double value = Stella.NULL_FLOAT;
        Cons iter001 = values;

        for (;(iter000 <= upperBound000) &&
                  (!(iter001 == Stella.NIL)); iter000 = iter000 + 1, iter001 = iter001.rest) {
          i = iter000;
          value = ((FloatWrapper)(iter001.value)).wrapperValue;
          ((FloatWrapper)(((FloatWrapper)(nativearray[i])))).wrapperValue = value;
        }
      }
      return (array);
    }
  }

  /** Sets the number of nearest neighbors to predict from.
   * @param d
   */
  public static void setNumNeighbors(int d) {
    Logic.$NUM_NEIGHBORS$ = d;
  }

  public static void setNumNeighborsEvaluatorWrapper(Cons arguments) {
    Logic.setNumNeighbors(((IntegerWrapper)(arguments.value)).wrapperValue);
  }

  public static void setCaseSolutionCombination(Keyword k) {
    Logic.$CASE_SOLUTION_COMBINATION$ = k;
  }

  /** Sets the number of training examples for each case in the training set.
   * @param d
   */
  public static void setNumTrainingPerCase(int d) {
    Logic.$NUM_TRAINING_PER_CASE$ = d;
  }

  public static void setNumTrainingPerCaseEvaluatorWrapper(Cons arguments) {
    Logic.setNumTrainingPerCase(((IntegerWrapper)(arguments.value)).wrapperValue);
  }

  public static void clearCases() {
    { Symbol name = null;
      Cons iter000 = Logic.$CASE_RULE_NAMES$.theConsList;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        name = ((Symbol)(iter000.value));
        Logic.smartUpdateProposition(name, Logic.KWD_RETRACT_TRUE);
      }
    }
    Logic.$NUM_CASES$ = 0;
    Logic.$SEEN_INSTANCES$ = List.newList();
    Logic.$VISITED_PROPOSITIONS$ = List.newList();
    Logic.$VISITED_INSTANCES$ = List.newList();
    Logic.$CASE_RULE_NAMES$ = List.newList();
    Logic.$CASE_ANTECEDENT_TABLE$ = StringHashTable.newStringHashTable();
    Logic.$CASE_TYPES_TABLE$ = StringHashTable.newStringHashTable();
    Logic.$CASE_NAME_TABLE$ = HashTable.newHashTable();
    Logic.$CASE_VARIABLE_COUNTER$ = 0;
  }

  public static void addAllClassInstancesToCaseRule(Surrogate kind) {
    { Stella_Object instance = null;
      Cons iter000 = Logic.allClassInstances(kind);

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        instance = iter000.value;
        LogicObject.buildCaseFromInstance(((LogicObject)(instance)), kind);
      }
    }
    Logic.buildCaseRule(kind);
  }

  public static void finalizeCases(Symbol kind) {
    { Surrogate renamed_Class = Logic.getDescription(kind).surrogateValueInverse;

      Logic.buildCaseRule(renamed_Class);
    }
  }

  public static void buildCaseRule(Surrogate kind) {
    { String ruleName = kind.symbolName + "-match";
      Symbol ruleNameSymbol = Symbol.internSymbol(ruleName);
      List ruleAntecedent = ((List)(Logic.$CASE_ANTECEDENT_TABLE$.lookup(ruleName)));
      List ruleTypes = ((List)(Logic.$CASE_TYPES_TABLE$.lookup(ruleName)));
      Cons rule = Stella.NIL;

      rule = Cons.list$(Cons.cons(Logic.SYM_LOGIC_DEFRULE, Cons.cons(StringWrapper.wrapString(ruleName), Cons.cons(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_FORALL, Cons.cons(ruleTypes, Cons.cons(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_eg, Cons.cons(Cons.cons(Logic.SYM_STELLA_AND, ruleAntecedent.consify().concatenate(Stella.NIL, Stella.NIL)), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_CASE_MATCH, Cons.cons(Logic.SYM_LOGIC_pX, Cons.cons(Logic.SYM_LOGIC_pY, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))), Stella.NIL), Stella.NIL)))), Stella.NIL), Stella.NIL))));
      if (!Logic.$CASE_RULE_NAMES$.memberP(ruleNameSymbol)) {
        Logic.$CASE_RULE_NAMES$.push(ruleNameSymbol);
      }
      if (Logic.$LOG_MATCH_RULES$) {
        Stella.STANDARD_OUTPUT.nativeStream.println(rule.toString());
      }
      if (!ruleAntecedent.emptyP()) {
        Logic.evaluateLogicCommand(rule, false);
      }
    }
  }

  public static void addCase(Symbol inst, Symbol kind) {
    inst = ((Symbol)(inst.permanentify()));
    kind = ((Symbol)(kind.permanentify()));
    LogicObject.buildCaseFromInstance(((LogicObject)(Logic.getInstance(inst))), Logic.getDescription(kind).surrogateValueInverse);
  }

  public static Vector createCaseInstanceVector(Surrogate renamed_Class) {
    { Cons iterator = Logic.allClassInstances(renamed_Class);
      int num = iterator.length();
      Vector instances = Vector.newVector(num);

      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = num - 1;
        Stella_Object inst = null;
        Cons iter001 = iterator;

        for (;(iter000 <= upperBound000) &&
                  (!(iter001 == Stella.NIL)); iter000 = iter000 + 1, iter001 = iter001.rest) {
          i = iter000;
          inst = iter001.value;
          (instances.theArray)[i] = inst;
        }
      }
      return (instances);
    }
  }

  public static Vector createCaseValueVector(List instances, Surrogate slot) {
    { Vector slotValues = Vector.newVector(instances.length());

      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = instances.length() - 1;
        LogicObject inst = null;
        Cons iter001 = instances.theConsList;

        for (;(iter000 <= upperBound000) &&
                  (!(iter001 == Stella.NIL)); iter000 = iter000 + 1, iter001 = iter001.rest) {
          i = iter000;
          inst = ((LogicObject)(iter001.value));
          (slotValues.theArray)[i] = (LogicObject.getSlotValue(inst, slot));
        }
      }
      return (slotValues);
    }
  }

  public static Stella_Object guess(Symbol instName, Symbol slotName) {
    instName = ((Symbol)(instName.permanentify()));
    slotName = ((Symbol)(slotName.permanentify()));
    { Stella_Object probe = Logic.getInstance(instName);
      Surrogate renamed_Class = ((LogicObject)(LogicObject.getMostSpecificClasses(((LogicObject)(probe))).last())).surrogateValueInverse;
      String ruleName = renamed_Class.symbolName + "-match";
      Symbol ruleNameSymbol = Symbol.internSymbol(ruleName);
      List instances = Logic.allClassInstances(renamed_Class).listify();
      Surrogate slot = Logic.getDescription(slotName).surrogateValueInverse;

      if (!Logic.$CASE_RULE_NAMES$.memberP(ruleNameSymbol)) {
        Stella.STANDARD_OUTPUT.nativeStream.println("Building match rule.");
        Logic.addAllClassInstancesToCaseRule(renamed_Class);
      }
      Stella.STANDARD_OUTPUT.nativeStream.println("Generating answer");
      return (LogicObject.generateCaseBasedAnswer(((LogicObject)(probe)), slot, instances));
    }
  }

  public static Stella_Object combineCaseAnswers(Vector closest, Vector scores, Vector slots) {
    scores = scores;
    if (Logic.$CASE_SOLUTION_COMBINATION$ == Logic.KWD_WEIGHTED_VOTE) {
      { PropertyList answerTable = PropertyList.newPropertyList();
        List keys = List.newList();

        { IntegerWrapper neighbor = null;
          Vector vector000 = closest;
          int index000 = 0;
          int length000 = vector000.length();

          for (;index000 < length000; index000 = index000 + 1) {
            neighbor = ((IntegerWrapper)((vector000.theArray)[index000]));
            { Stella_Object answer = (slots.theArray)[(neighbor.wrapperValue)];
              IntegerWrapper votes = ((IntegerWrapper)(answerTable.lookup(answer)));

              if (votes == null) {
                {
                  keys.push(answer);
                  answerTable.insertAt(answer, IntegerWrapper.wrapInteger(1));
                }
              }
              else {
                answerTable.insertAt(answer, IntegerWrapper.wrapInteger(votes.wrapperValue + 1));
              }
            }
          }
        }
        { int max = 0;
          Stella_Object answer = null;

          { Stella_Object key = null;
            Cons iter000 = keys.theConsList;

            for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
              key = iter000.value;
              { IntegerWrapper votes = ((IntegerWrapper)(answerTable.lookup(key)));

                if (votes.wrapperValue > max) {
                  max = votes.wrapperValue;
                  answer = key;
                }
              }
            }
          }
          return (answer);
        }
      }
    }
    else if (Logic.$CASE_SOLUTION_COMBINATION$ == Logic.KWD_WEIGHTED_AVERAGE) {
      if (Stella_Object.isaP((slots.theArray)[0], Logic.SGT_STELLA_FLOAT_WRAPPER) ||
          Stella_Object.isaP((slots.theArray)[0], Logic.SGT_STELLA_INTEGER_WRAPPER)) {
        Stella.STANDARD_OUTPUT.nativeStream.println("Weighted average not implemented yet");
      }
      else {
        Stella.STANDARD_OUTPUT.nativeStream.println("Warning:  Slot type not number.  Cannot average");
      }
    }
    else if (Logic.$CASE_SOLUTION_COMBINATION$ == Logic.KWD_AVERAGE) {
      { Surrogate testValue000 = Stella_Object.safePrimaryType((slots.theArray)[0]);

        if (Surrogate.subtypeOfFloatP(testValue000)) {
          { FloatWrapper sum = ((FloatWrapper)((slots.theArray)[(((IntegerWrapper)((closest.theArray)[0])).wrapperValue)]));

            { int i = Stella.NULL_INTEGER;
              int iter001 = 1;
              int upperBound000 = Logic.$NUM_NEIGHBORS$ - 1;

              for (;iter001 <= upperBound000; iter001 = iter001 + 1) {
                i = iter001;
                sum = FloatWrapper.wrapFloat(sum.wrapperValue + ((FloatWrapper)((slots.theArray)[(((IntegerWrapper)((closest.theArray)[i])).wrapperValue)])).wrapperValue);
              }
            }
            return (FloatWrapper.wrapFloat(sum.wrapperValue / Logic.$NUM_NEIGHBORS$));
          }
        }
        else if (Surrogate.subtypeOfIntegerP(testValue000)) {
          { IntegerWrapper sum = ((IntegerWrapper)((slots.theArray)[(((IntegerWrapper)((closest.theArray)[0])).wrapperValue)]));

            { int i = Stella.NULL_INTEGER;
              int iter002 = 1;
              int upperBound001 = Logic.$NUM_NEIGHBORS$ - 1;

              for (;iter002 <= upperBound001; iter002 = iter002 + 1) {
                i = iter002;
                sum = IntegerWrapper.wrapInteger(sum.wrapperValue + ((IntegerWrapper)((slots.theArray)[(((IntegerWrapper)((closest.theArray)[i])).wrapperValue)])).wrapperValue);
              }
            }
            return (FloatWrapper.wrapFloat(((double)(sum.wrapperValue)) / Logic.$NUM_NEIGHBORS$));
          }
        }
        else {
          Stella.STANDARD_OUTPUT.nativeStream.println("Warning:  Slot type not number.  Cannot average");
        }
      }
    }
    else {
    }
    return ((slots.theArray)[(((IntegerWrapper)((closest.theArray)[0])).wrapperValue)]);
  }

  public static void trainCaseMatcher(Symbol className, Symbol slotName, int cycles) {
    slotName = ((Symbol)(slotName.permanentify()));
    className = ((Symbol)(className.permanentify()));
    Stella.STANDARD_OUTPUT.nativeStream.println("Generating training examples");
    { Surrogate renamed_Class = Logic.getDescription(className).surrogateValueInverse;
      Surrogate slot = Logic.getDescription(slotName).surrogateValueInverse;
      List ilist = Logic.allClassInstances(renamed_Class).listify();
      Vector instances = Vector.newVector(ilist.length());

      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = ilist.length() - 1;
        Stella_Object instance = null;
        Cons iter001 = ilist.theConsList;

        for (;(iter000 <= upperBound000) &&
                  (!(iter001 == Stella.NIL)); iter000 = iter000 + 1, iter001 = iter001.rest) {
          i = iter000;
          instance = iter001.value;
          (instances.theArray)[i] = (((LogicObject)(instance)));
        }
      }
      Logic.generateCaseRuleWoSlot(instances, className, slotName);
      { int num = Logic.generateCaseTrainingExamples(instances, slot);

        Stella.STANDARD_OUTPUT.nativeStream.println("Training case match network");
        Logic.trainCachedNeuralNetworks(cycles, num * Logic.$NUM_TRAINING_PER_CASE$);
      }
    }
  }

  public static void trainCaseMatcherEvaluatorWrapper(Cons arguments) {
    Logic.trainCaseMatcher(((Symbol)(arguments.value)), ((Symbol)(arguments.rest.value)), ((IntegerWrapper)(arguments.rest.rest.value)).wrapperValue);
  }

  public static void generateCaseRuleWoSlot(Vector cases, Symbol className, Symbol slotName) {
    { int numCases = cases.length();
      Surrogate kind = Logic.getDescription(className).surrogateValueInverse;
      List caseNames = List.newList();
      Surrogate slot = Logic.getDescription(slotName).surrogateValueInverse;
      Vector slotValues = Vector.newVector(numCases);

      Logic.clearCases();
      { LogicObject renamed_Case = null;
        Vector vector000 = cases;
        int index000 = 0;
        int length000 = vector000.length();
        Cons collect000 = null;

        for (;index000 < length000; index000 = index000 + 1) {
          renamed_Case = ((LogicObject)((vector000.theArray)[index000]));
          if (collect000 == null) {
            {
              collect000 = Cons.cons(Logic.objectName(renamed_Case), Stella.NIL);
              if (caseNames.theConsList == Stella.NIL) {
                caseNames.theConsList = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(caseNames.theConsList, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(Logic.objectName(renamed_Case), Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      { LogicObject renamed_Case = null;
        Vector vector001 = cases;
        int index001 = 0;
        int length001 = vector001.length();
        Symbol caseName = null;
        Cons iter000 = caseNames.theConsList;
        int i = Stella.NULL_INTEGER;
        int iter001 = 0;

        for (;(index001 < length001) &&
                  (!(iter000 == Stella.NIL)); 
              index001 = index001 + 1,
              iter000 = iter000.rest,
              iter001 = iter001 + 1) {
          renamed_Case = ((LogicObject)((vector001.theArray)[index001]));
          caseName = ((Symbol)(iter000.value));
          i = iter001;
          { Stella_Object val = LogicObject.getSlotValue(renamed_Case, slot);

            (slotValues.theArray)[i] = val;
            Logic.smartUpdateProposition(Cons.cons(slotName, Cons.cons(caseName, Cons.cons(val, Stella.NIL))), Logic.KWD_RETRACT_TRUE);
          }
        }
      }
      { OutputFileStream fptr = OutputFileStream.newOutputFileStream("current-cases.ste");

        fptr.nativeStream.println("(in-package \"STELLA\")");
        { int i = Stella.NULL_INTEGER;
          int iter002 = 0;
          int upperBound000 = numCases - 1;
          Symbol caseName = null;
          Cons iter003 = caseNames.theConsList;

          for (;(iter002 <= upperBound000) &&
                    (!(iter003 == Stella.NIL)); iter002 = iter002 + 1, iter003 = iter003.rest) {
            i = iter002;
            caseName = ((Symbol)(iter003.value));
            LogicObject.buildCaseFromInstance(((LogicObject)((cases.theArray)[i])), kind);
            fptr.nativeStream.println("(add-case " + caseName + ")");
          }
        }
      }
      Logic.buildCaseRule(kind);
      { Stella_Object val = null;
        Vector vector002 = slotValues;
        int index002 = 0;
        int length002 = vector002.length();
        Symbol caseName = null;
        Cons iter004 = caseNames.theConsList;

        for (;(index002 < length002) &&
                  (!(iter004 == Stella.NIL)); index002 = index002 + 1, iter004 = iter004.rest) {
          val = (vector002.theArray)[index002];
          caseName = ((Symbol)(iter004.value));
          Logic.smartUpdateProposition(Cons.cons(slotName, Cons.cons(caseName, Cons.cons(val, Stella.NIL))), Logic.KWD_ASSERT_TRUE);
        }
      }
    }
  }

  public static double trainAndTestCaseMatcher(Symbol className, Symbol slotName, int numTrain, int numTest, int cycles) {
    className = ((Symbol)(className.permanentify()));
    slotName = ((Symbol)(slotName.permanentify()));
    { Surrogate renamed_Class = Logic.getDescription(className).surrogateValueInverse;
      List cases = Logic.allClassInstances(renamed_Class).listify();
      Vector instances = Vector.newVector(numTrain);
      Surrogate slot = Logic.getDescription(slotName).surrogateValueInverse;
      Vector slotValues = Vector.newVector(cases.length());
      int numCorrect = 0;

      Logic.shuffleList(cases);
      { Stella_Object renamed_Case = null;
        Cons iter000 = cases.theConsList;
        int i = Stella.NULL_INTEGER;
        int iter001 = 0;
        int upperBound000 = numTrain - 1;

        for (;(!(iter000 == Stella.NIL)) &&
                  (iter001 <= upperBound000); iter000 = iter000.rest, iter001 = iter001 + 1) {
          renamed_Case = iter000.value;
          i = iter001;
          (instances.theArray)[i] = (((LogicObject)(renamed_Case)));
        }
      }
      Logic.generateCaseRuleWoSlot(instances, className, slotName);
      QueryIterator.returnPartialTruth(Logic.makeQuery(Stella.NIL, Logic.coerceToTree(Cons.list$(Cons.cons(Logic.SYM_LOGIC_CASE_MATCH, Cons.cons(Logic.objectName(cases.first()), Cons.cons(Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_OBJECT_NAME, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_SECOND, Cons.cons(Logic.SYM_LOGIC_CASES, Cons.cons(Stella.NIL, Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL), Stella.NIL))))), Stella.NIL, Stella.NIL), true);
      Logic.saveAllNeuralNetworks(Logic.$SAVE_NETWORK_FILE$);
      Stella.STANDARD_OUTPUT.nativeStream.println("Training case matcher");
      { int numInstances = Logic.generateCaseTrainingExamples(instances, slot);

        Logic.trainNeuralNetwork(cycles, numInstances * Logic.$NUM_TRAINING_PER_CASE$);
      }
      { List trainingCases = List.newList();

        { int i = Stella.NULL_INTEGER;
          int iter002 = 0;
          int upperBound001 = numTrain - 1;
          Cons collect000 = null;

          for (;iter002 <= upperBound001; iter002 = iter002 + 1) {
            i = iter002;
            if (collect000 == null) {
              {
                collect000 = Cons.cons(((LogicObject)((instances.theArray)[i])), Stella.NIL);
                if (trainingCases.theConsList == Stella.NIL) {
                  trainingCases.theConsList = collect000;
                }
                else {
                  Cons.addConsToEndOfConsList(trainingCases.theConsList, collect000);
                }
              }
            }
            else {
              {
                collect000.rest = Cons.cons(((LogicObject)((instances.theArray)[i])), Stella.NIL);
                collect000 = collect000.rest;
              }
            }
          }
        }
        { int i = Stella.NULL_INTEGER;
          int iter003 = numTrain;
          int upperBound002 = (numTrain + numTest) - 1;

          for (;iter003 <= upperBound002; iter003 = iter003 + 1) {
            i = iter003;
            { Stella_Object probe = cases.nth(i);
              Stella_Object correctAnswer = (slotValues.theArray)[i];
              Stella_Object answer = LogicObject.generateCaseBasedAnswer(((LogicObject)(probe)), slot, trainingCases);

              Stella.STANDARD_OUTPUT.nativeStream.println(probe + "  Predicted: " + answer + ", Correct: " + correctAnswer);
              if (Stella_Object.eqlP(answer, correctAnswer)) {
                numCorrect = numCorrect + 1;
              }
            }
          }
        }
      }
      return (((double)(numCorrect)) / numTest);
    }
  }

  public static FloatWrapper trainAndTestCaseMatcherEvaluatorWrapper(Cons arguments) {
    { double result = Logic.trainAndTestCaseMatcher(((Symbol)(arguments.value)), ((Symbol)(arguments.rest.value)), ((IntegerWrapper)(arguments.rest.rest.value)).wrapperValue, ((IntegerWrapper)(arguments.rest.rest.rest.value)).wrapperValue, ((IntegerWrapper)(arguments.rest.rest.rest.rest.value)).wrapperValue);

      if (result != Stella.NULL_FLOAT) {
        return (FloatWrapper.wrapFloat(result));
      }
      else {
        return (null);
      }
    }
  }

  public static double testCaseBasedReasoner(Symbol className, Symbol slotName, int numTrain, int numTest) {
    className = ((Symbol)(className.permanentify()));
    slotName = ((Symbol)(slotName.permanentify()));
    { Surrogate renamed_Class = Logic.getDescription(className).surrogateValueInverse;
      List caseList = Logic.allClassInstances(renamed_Class).listify();
      int numCases = caseList.length();
      Surrogate slot = Logic.getDescription(slotName).surrogateValueInverse;
      OutputFileStream fptr = OutputFileStream.newOutputFileStream("cbr-test-output.txt");
      List trainingCases = List.newList();
      Vector caseVector = Vector.newVector(numCases);
      int numCorrect = 0;

      Logic.shuffleList(caseList);
      if ((numTrain + numTest) > numCases) {
        Stella.STANDARD_OUTPUT.nativeStream.println("Error:  training and test instances out number total instances");
        return (0.0);
      }
      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = numCases - 1;
        Stella_Object renamed_Case = null;
        Cons iter001 = caseList.theConsList;

        for (;(iter000 <= upperBound000) &&
                  (!(iter001 == Stella.NIL)); iter000 = iter000 + 1, iter001 = iter001.rest) {
          i = iter000;
          renamed_Case = iter001.value;
          (caseVector.theArray)[i] = (((LogicObject)(renamed_Case)));
        }
      }
      { int i = Stella.NULL_INTEGER;
        int iter002 = 1;
        int upperBound001 = numTrain;
        boolean unboundedP000 = upperBound001 == Stella.NULL_INTEGER;
        Stella_Object renamed_Case = null;
        Cons iter003 = caseList.theConsList;
        Cons collect000 = null;

        for (;(unboundedP000 ||
                  (iter002 <= upperBound001)) &&
                  (!(iter003 == Stella.NIL)); iter002 = iter002 + 1, iter003 = iter003.rest) {
          i = iter002;
          renamed_Case = iter003.value;
          if (collect000 == null) {
            {
              collect000 = Cons.cons(renamed_Case, Stella.NIL);
              if (trainingCases.theConsList == Stella.NIL) {
                trainingCases.theConsList = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(trainingCases.theConsList, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(renamed_Case, Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      { int i = Stella.NULL_INTEGER;
        int iter004 = numTrain;
        int upperBound002 = (numTrain + numTest) - 1;

        for (;iter004 <= upperBound002; iter004 = iter004 + 1) {
          i = iter004;
          { LogicObject probe = ((LogicObject)((caseVector.theArray)[i]));
            Symbol caseName = Logic.objectName(probe);
            Stella_Object correctAnswer = LogicObject.getSlotValue(probe, slot);
            Stella_Object answer = LogicObject.generateCaseBasedAnswer(probe, slot, trainingCases);

            if (Stella_Object.eqlP(answer, correctAnswer)) {
              numCorrect = numCorrect + 1;
            }
            fptr.nativeStream.print("Case " + caseName + " predicted: " + answer + " correct: " + correctAnswer);
            Stella.STANDARD_OUTPUT.nativeStream.print("Case " + caseName + " predicted: " + answer + " correct: " + correctAnswer);
            fptr.nativeStream.println("  Summary: " + numCorrect + " out of " + numTest);
            Stella.STANDARD_OUTPUT.nativeStream.println("  Summary: " + numCorrect + " out of " + numTest);
          }
        }
      }
      return (((double)(numCorrect)) / numTest);
    }
  }

  public static FloatWrapper testCaseBasedReasonerEvaluatorWrapper(Cons arguments) {
    { double result = Logic.testCaseBasedReasoner(((Symbol)(arguments.value)), ((Symbol)(arguments.rest.value)), ((IntegerWrapper)(arguments.rest.rest.value)).wrapperValue, ((IntegerWrapper)(arguments.rest.rest.rest.value)).wrapperValue);

      if (result != Stella.NULL_FLOAT) {
        return (FloatWrapper.wrapFloat(result));
      }
      else {
        return (null);
      }
    }
  }

  public static double testCaseMatcher(Symbol className, Symbol slotName) {
    className = ((Symbol)(className.permanentify()));
    slotName = ((Symbol)(slotName.permanentify()));
    { Surrogate renamed_Class = Logic.getDescription(className).surrogateValueInverse;
      List cases = Logic.allClassInstances(renamed_Class).listify();
      Surrogate slot = Logic.getDescription(slotName).surrogateValueInverse;
      OutputFileStream fptr = OutputFileStream.newOutputFileStream("test-output.txt");
      List trainingCaseNames = ((List)(Logic.$CASE_NAME_TABLE$.lookup(className)));
      List trainingCases = List.newList();
      List caseNames = List.newList();
      int total = 0;
      int numCorrect = 0;

      { Stella_Object renamed_Case = null;
        Cons iter000 = cases.theConsList;
        Cons collect000 = null;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          renamed_Case = iter000.value;
          if (collect000 == null) {
            {
              collect000 = Cons.cons(Logic.objectName(renamed_Case), Stella.NIL);
              if (caseNames.theConsList == Stella.NIL) {
                caseNames.theConsList = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(caseNames.theConsList, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(Logic.objectName(renamed_Case), Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      { Stella_Object renamed_Case = null;
        Cons iter001 = cases.theConsList;
        Symbol caseName = null;
        Cons iter002 = caseNames.theConsList;
        Cons collect001 = null;

        for (;(!(iter001 == Stella.NIL)) &&
                  (!(iter002 == Stella.NIL)); iter001 = iter001.rest, iter002 = iter002.rest) {
          renamed_Case = iter001.value;
          caseName = ((Symbol)(iter002.value));
          if (trainingCaseNames.memberP(caseName)) {
            if (collect001 == null) {
              {
                collect001 = Cons.cons(renamed_Case, Stella.NIL);
                if (trainingCases.theConsList == Stella.NIL) {
                  trainingCases.theConsList = collect001;
                }
                else {
                  Cons.addConsToEndOfConsList(trainingCases.theConsList, collect001);
                }
              }
            }
            else {
              {
                collect001.rest = Cons.cons(renamed_Case, Stella.NIL);
                collect001 = collect001.rest;
              }
            }
          }
        }
      }
      { Stella_Object renamed_Case = null;
        Cons iter003 = cases.theConsList;
        Stella_Object probe = null;
        Cons iter004 = cases.theConsList;
        Symbol caseName = null;
        Cons iter005 = caseNames.theConsList;

        for (;(!(iter003 == Stella.NIL)) &&
                  ((!(iter004 == Stella.NIL)) &&
                   (!(iter005 == Stella.NIL))); 
              iter003 = iter003.rest,
              iter004 = iter004.rest,
              iter005 = iter005.rest) {
          renamed_Case = iter003.value;
          probe = iter004.value;
          caseName = ((Symbol)(iter005.value));
          if (!trainingCaseNames.memberP(caseName)) {
            { Stella_Object correctAnswer = LogicObject.getSlotValue(((LogicObject)(renamed_Case)), slot);
              Stella_Object answer = LogicObject.generateCaseBasedAnswer(((LogicObject)(probe)), slot, cases);

              fptr.nativeStream.print("Case " + caseName + " predicted: " + answer + " correct: " + correctAnswer);
              Stella.STANDARD_OUTPUT.nativeStream.print("Case " + caseName + " predicted: " + answer + " correct: " + correctAnswer);
              total = total + 1;
              if (Stella_Object.eqlP(answer, correctAnswer)) {
                numCorrect = numCorrect + 1;
              }
              fptr.nativeStream.println("  Summary: " + numCorrect + " out of " + total);
              Stella.STANDARD_OUTPUT.nativeStream.println("  Summary: " + numCorrect + " out of " + total);
            }
          }
        }
      }
      return (((double)(numCorrect)) / total);
    }
  }

  public static FloatWrapper testCaseMatcherEvaluatorWrapper(Cons arguments) {
    { double result = Logic.testCaseMatcher(((Symbol)(arguments.value)), ((Symbol)(arguments.rest.value)));

      if (result != Stella.NULL_FLOAT) {
        return (FloatWrapper.wrapFloat(result));
      }
      else {
        return (null);
      }
    }
  }

  public static int generateCaseTrainingExamples(Vector instances, Surrogate slot) {
    { int numInstances = instances.length();
      Vector slotValues = Vector.newVector(numInstances);
      int k = 0;
      int l = 0;
      Vector index = Vector.newVector(numInstances * Logic.$NUM_TRAINING_PER_CASE$);
      Vector matchScores = Vector.newVector(numInstances * Logic.$NUM_TRAINING_PER_CASE$);

      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = numInstances - 1;
        LogicObject inst = null;
        Vector vector000 = instances;
        int index000 = 0;
        int length000 = vector000.length();

        for (;(iter000 <= upperBound000) &&
                  (index000 < length000); iter000 = iter000 + 1, index000 = index000 + 1) {
          i = iter000;
          inst = ((LogicObject)((vector000.theArray)[index000]));
          (slotValues.theArray)[i] = (LogicObject.getSlotValue(inst, slot));
        }
      }
      { int i = Stella.NULL_INTEGER;
        int iter001 = 0;
        int upperBound001 = numInstances - 1;

        for (;iter001 <= upperBound001; iter001 = iter001 + 1) {
          i = iter001;
          { int j = Stella.NULL_INTEGER;
            int iter002 = 1;
            int upperBound002 = Logic.$NUM_TRAINING_PER_CASE$;
            boolean unboundedP000 = upperBound002 == Stella.NULL_INTEGER;

            for (;unboundedP000 ||
                      (iter002 <= upperBound002); iter002 = iter002 + 1) {
              j = iter002;
              j = j;
              l = Stella.random(numInstances);
              while (i == l) {
                l = Stella.random(numInstances);
              }
              (index.theArray)[k] = (IntegerWrapper.wrapInteger(l));
              (matchScores.theArray)[k] = (FloatWrapper.wrapFloat(Logic.calculateCaseMatch((slotValues.theArray)[i], (slotValues.theArray)[l])));
              k = k + 1;
            }
          }
        }
      }
      k = 0;
      Logic.normalizeNumbers(matchScores);
      { int i = Stella.NULL_INTEGER;
        int iter003 = 0;
        int upperBound003 = matchScores.length() - 1;

        for (;iter003 <= upperBound003; iter003 = iter003 + 1) {
          i = iter003;
          (matchScores.theArray)[i] = (FloatWrapper.wrapFloat(1.0 - ((FloatWrapper)((matchScores.theArray)[i])).wrapperValue));
        }
      }
      { int i = Stella.NULL_INTEGER;
        int iter004 = 0;
        int upperBound004 = numInstances - 1;

        for (;iter004 <= upperBound004; iter004 = iter004 + 1) {
          i = iter004;
          { int j = Stella.NULL_INTEGER;
            int iter005 = 1;
            int upperBound005 = Logic.$NUM_TRAINING_PER_CASE$;
            boolean unboundedP001 = upperBound005 == Stella.NULL_INTEGER;

            for (;unboundedP001 ||
                      (iter005 <= upperBound005); iter005 = iter005 + 1) {
              j = iter005;
              j = j;
              { TrainingExample example = TrainingExample.newTrainingExample();

                example.query = Cons.list$(Cons.cons(Logic.SYM_PL_KERNEL_KB_CASE_MATCH, Cons.cons(Logic.logicSymbol(((LogicObject)((instances.theArray)[i]))), Cons.cons(Cons.cons(Logic.logicSymbol(((LogicObject)((instances.theArray)[(((IntegerWrapper)((index.theArray)[k])).wrapperValue)]))), Stella.NIL), Stella.NIL))));
                example.score = ((FloatWrapper)((matchScores.theArray)[k])).wrapperValue;
                Logic.$TRAINING_EXAMPLES$.push(example);
              }
              k = k + 1;
            }
          }
        }
      }
      return (numInstances);
    }
  }

  public static void normalizeNumbers(Vector vect) {
    { int num = vect.length();
      double max = -99999.0;
      double min = 99999.0;
      double range = 0.0;

      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = num - 1;

        for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
          i = iter000;
          (vect.theArray)[i] = (FloatWrapper.wrapFloat(1.0 * ((FloatWrapper)((vect.theArray)[i])).wrapperValue));
          if (((FloatWrapper)((vect.theArray)[i])).wrapperValue > max) {
            max = ((FloatWrapper)((vect.theArray)[i])).wrapperValue;
          }
          if (((FloatWrapper)((vect.theArray)[i])).wrapperValue < min) {
            min = ((FloatWrapper)((vect.theArray)[i])).wrapperValue;
          }
        }
      }
      range = max - min;
      { int i = Stella.NULL_INTEGER;
        int iter001 = 0;
        int upperBound001 = num - 1;

        for (;iter001 <= upperBound001; iter001 = iter001 + 1) {
          i = iter001;
          (vect.theArray)[i] = (FloatWrapper.wrapFloat((((FloatWrapper)((vect.theArray)[i])).wrapperValue - min) / range));
        }
      }
    }
  }

  public static void clearSlotFromClass(Symbol className, Symbol slotName) {
    className = ((Symbol)(className.permanentify()));
    slotName = ((Symbol)(slotName.permanentify()));
    { Surrogate renamed_Class = Logic.getDescription(className).surrogateValueInverse;
      List cases = Logic.allClassInstances(renamed_Class).listify();
      Surrogate slot = Logic.getDescription(slotName).surrogateValueInverse;

      { Stella_Object renamed_Case = null;
        Cons iter000 = cases.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          renamed_Case = iter000.value;
          Logic.smartUpdateProposition(Cons.cons(slotName, Cons.cons(renamed_Case, Cons.cons(LogicObject.getSlotValue(((LogicObject)(renamed_Case)), slot), Stella.NIL))), Logic.KWD_RETRACT_TRUE);
        }
      }
    }
  }

  public static Stella_Object logicSymbol(Stella_Object obj) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(obj);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description obj000 = ((Description)(obj));

          return (obj000);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable obj000 = ((PatternVariable)(obj));

          return (Symbol.internSymbol(Skolem.getSkolemPrintName(obj000)));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
        { Skolem obj000 = ((Skolem)(obj));

          return (Symbol.internSymbol(Skolem.getSkolemPrintName(obj000)));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject obj000 = ((LogicObject)(obj));

          return (Symbol.internSymbol(obj000.surrogateValueInverse.symbolName));
        }
      }
      else {
        return (obj);
      }
    }
  }

  public static double calculateCaseMatch(Stella_Object x, Stella_Object y) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(x);

      if (Surrogate.subtypeOfFloatP(testValue000)) {
        { FloatWrapper x000 = ((FloatWrapper)(x));

          return (Stella.float_abs(((FloatWrapper)(x000)).wrapperValue - ((FloatWrapper)(y)).wrapperValue));
        }
      }
      else if (Surrogate.subtypeOfIntegerP(testValue000)) {
        { IntegerWrapper x000 = ((IntegerWrapper)(x));

          return (((double)(Stella.integer_abs(((IntegerWrapper)(x000)).wrapperValue - ((IntegerWrapper)(y)).wrapperValue))));
        }
      }
      else if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol x000 = ((Symbol)(x));

          if (x000 == y) {
            return (1.0);
          }
          else {
            return (0.0);
          }
        }
      }
      else {
        return (((double)(0)));
      }
    }
  }

  public static List findUniqueVariableNames(Cons tree, List names) {
    { Stella_Object arg = null;
      Cons iter000 = tree.rest;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        arg = iter000.value;
        { Surrogate testValue000 = Stella_Object.safePrimaryType(arg);

          if (testValue000 == Logic.SGT_STELLA_CONS) {
            { Cons arg000 = ((Cons)(arg));

              Logic.findUniqueVariableNames(arg000, names);
            }
          }
          else if (Surrogate.subtypeOfSymbolP(testValue000)) {
            { Symbol arg000 = ((Symbol)(arg));

              if (!names.memberP(arg000)) {
                names.push(arg000);
              }
            }
          }
          else {
          }
        }
      }
    }
    return (names);
  }

  public static List variablizeConsPropositions(List antecedent) {
    { List varList = List.newList();

      { Cons prop = null;
        Cons iter000 = antecedent.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          prop = ((Cons)(iter000.value));
          Logic.findUniqueVariableNames(prop, varList);
        }
      }
      return (Logic.variablizeInstances(antecedent, varList));
    }
  }

  public static List variablizeInstances(List form, List instances) {
    { Stella_Object bind = null;
      Cons iter000 = instances.theConsList;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        bind = iter000.value;
        { Symbol var = Logic.internLogicSymbol("?X" + Native.stringify(IntegerWrapper.wrapInteger(Logic.$CASE_VARIABLE_COUNTER$)));

          Logic.$CASE_VARIABLE_COUNTER$ = Logic.$CASE_VARIABLE_COUNTER$ + 1;
          Logic.$SYMBOL_VARIABLE_HASH_TABLE$.insertAt(((Symbol)(bind)), var);
          Logic.$SEEN_INSTANCES$.push(((Symbol)(bind)));
          { Cons clause = null;
            Cons iter001 = form.theConsList;

            for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
              clause = ((Cons)(iter001.value));
              Stella_Object.substituteConsTree(clause, var, bind);
            }
          }
        }
      }
    }
    return (form);
  }

  public static boolean stringArgumentP(Cons clause) {
    { Stella_Object ele = null;
      Cons iter000 = clause;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        ele = iter000.value;
        { Surrogate testValue000 = Stella_Object.safePrimaryType(ele);

          if (testValue000 == Logic.SGT_STELLA_CONS) {
            { Cons ele000 = ((Cons)(ele));

              if (Logic.stringArgumentP(ele000)) {
                return (true);
              }
            }
          }
          else if (Surrogate.subtypeOfStringP(testValue000)) {
            { StringWrapper ele000 = ((StringWrapper)(ele));

              return (true);
            }
          }
          else {
          }
        }
      }
    }
    return (false);
  }

  public static void filterAntecedent(List antecedent, String ruleName) {
    { ListIterator clause = ((ListIterator)(antecedent.allocateIterator()));

      while (clause.nextP()) {
        if (Logic.stringArgumentP(((Cons)(clause.value)))) {
          clause.valueSetter(null);
        }
      }
    }
    antecedent.remove(null);
    { List ruleAnt = ((List)(Logic.$CASE_ANTECEDENT_TABLE$.lookup(ruleName)));
      List generatedVariables = List.list(Cons.cons(Logic.internLogicSymbol("?Y"), Stella.NIL));
      int index = 0;

      if (Logic.$LOG_ANTECEDENT_CONSTRUCTION$) {
        Stella.STANDARD_OUTPUT.nativeStream.println("New clauses: " + antecedent);
      }
      if (ruleAnt == null) {
        return;
      }
      { int i = Stella.NULL_INTEGER;
        int iter000 = 1;
        int upperBound000 = antecedent.length();

        for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
          i = iter000;
          i = i;
          { Cons clause = ((Cons)(antecedent.nth(index)));
            Cons vars = Logic.findMatchingCaseVars(clause, ruleAnt, generatedVariables);

            if (!(vars == Stella.NIL)) {
              {
                antecedent = ((List)(antecedent.remove(clause)));
                { Cons sub = null;
                  Cons iter001 = vars;

                  for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                    sub = ((Cons)(iter001.value));
                    if (Stella_Object.symbolP(sub.rest.value)) {
                      Logic.$DELETED_CASE_VARIABLES$.push(((Symbol)(sub.rest.value)));
                      if (!Stella_Object.eqlP(sub.value, sub.rest.value)) {
                        { Cons ant = null;
                          Cons iter002 = antecedent.theConsList;

                          for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
                            ant = ((Cons)(iter002.value));
                            Stella_Object.substituteConsTree(ant, sub.value, sub.rest.value);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            else {
              index = index + 1;
            }
          }
        }
      }
      if (Logic.$LOG_ANTECEDENT_CONSTRUCTION$) {
        Stella.STANDARD_OUTPUT.nativeStream.println("Clauses added to antecedent: " + antecedent);
      }
      return;
    }
  }

  public static Cons findMatchingCaseVars(Cons clause, List antecedent, List generatedVariables) {
    { Stella_Object predicate = clause.value;
      int arity = clause.length();

      { Cons ant = null;
        Cons iter000 = antecedent.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          ant = ((Cons)(iter000.value));
          { Cons realAnt = ant;

            if (Logic.$LOG_ANTECEDENT_CONSTRUCTION$) {
              Stella.STANDARD_OUTPUT.nativeStream.println("   Comparing " + clause + " to " + realAnt);
            }
            if (Stella_Object.eqlP(realAnt.value, predicate) &&
                (Logic.parametersAlignedP(clause, realAnt, generatedVariables) &&
                 (realAnt.length() == arity))) {
              { Cons subs = Stella.NIL;

                { Stella_Object var1 = null;
                  Cons iter001 = clause.rest;
                  Stella_Object var2 = null;
                  Cons iter002 = realAnt.rest;
                  Cons collect000 = null;

                  for (;(!(iter001 == Stella.NIL)) &&
                            (!(iter002 == Stella.NIL)); iter001 = iter001.rest, iter002 = iter002.rest) {
                    var1 = iter001.value;
                    var2 = iter002.value;
                    generatedVariables.push(var2);
                    if (collect000 == null) {
                      {
                        collect000 = Cons.cons(Cons.consList(Cons.cons(var2, Cons.cons(var1, Stella.NIL))), Stella.NIL);
                        if (subs == Stella.NIL) {
                          subs = collect000;
                        }
                        else {
                          Cons.addConsToEndOfConsList(subs, collect000);
                        }
                      }
                    }
                    else {
                      {
                        collect000.rest = Cons.cons(Cons.consList(Cons.cons(var2, Cons.cons(var1, Stella.NIL))), Stella.NIL);
                        collect000 = collect000.rest;
                      }
                    }
                  }
                }
                if (Logic.$LOG_ANTECEDENT_CONSTRUCTION$) {
                  Stella.STANDARD_OUTPUT.nativeStream.println("   Found match: " + subs);
                }
                return (subs);
              }
            }
          }
        }
      }
      return (Stella.NIL);
    }
  }

  public static boolean parametersAlignedP(Cons clause1, Cons clause2, List vars) {
    { Stella_Object var = null;
      Cons iter000 = vars.theConsList;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        var = iter000.value;
        if (!(clause1.position(var, 0) == clause2.position(var, 0))) {
          return (false);
        }
      }
    }
    { Stella_Object p1 = null;
      Cons iter001 = clause1.rest;
      Stella_Object p2 = null;
      Cons iter002 = clause2.rest;

      for (;(!(iter001 == Stella.NIL)) &&
                (!(iter002 == Stella.NIL)); iter001 = iter001.rest, iter002 = iter002.rest) {
        p1 = iter001.value;
        p2 = iter002.value;
        if (Stella_Object.consP(p1)) {
          if ((!Stella_Object.consP(p2)) ||
              (!Logic.parametersAlignedP(((Cons)(p1)), ((Cons)(p2)), vars))) {
            return (false);
          }
        }
        else {
          if (((!Logic.variableArgP(p1)) ||
              (!Logic.variableArgP(p2))) &&
              (!Stella_Object.eqlP(p1, p2))) {
            return (false);
          }
        }
      }
    }
    return (true);
  }

  public static boolean variableArgP(Stella_Object arg) {
    if (Surrogate.subtypeOfSymbolP(Stella_Object.safePrimaryType(arg))) {
      { Symbol arg000 = ((Symbol)(arg));

        if ((arg000.symbolName).charAt(0) == '?') {
          return (true);
        }
        else {
          return (false);
        }
      }
    }
    else {
      return (false);
    }
  }

  public static Cons buildVariableConstraints(List instances) {
    { Cons constraints = Stella.NIL;

      { Symbol var = null;
        Cons iter000 = instances.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          var = ((Symbol)(iter000.value));
          { Symbol name = ((Symbol)(Logic.$SYMBOL_VARIABLE_HASH_TABLE$.lookup(var)));

            if (!Logic.$DELETED_CASE_VARIABLES$.memberP(name)) {
              constraints = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_SOFT_EQ, Cons.cons(name, Cons.cons(Cons.cons(Logic.internLogicSymbol("X" + Native.string_subsequence(Native.stringify(name), 1, Stella.NULL_INTEGER)), Stella.NIL), Stella.NIL)))), constraints);
            }
          }
        }
      }
      return (constraints);
    }
  }

  public static List buildTypeDefs(List instances) {
    { List typeDefs = List.newList();
      Symbol name = null;

      { Symbol var = null;
        Cons iter000 = instances.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          var = ((Symbol)(iter000.value));
          name = ((Symbol)(Logic.$SYMBOL_VARIABLE_HASH_TABLE$.lookup(var)));
          if (!Logic.$DELETED_CASE_VARIABLES$.memberP(name)) {
            typeDefs.push(name);
          }
        }
      }
      return (typeDefs);
    }
  }

  public static void setPrintCaseDistances(boolean b) {
    Logic.$PRINT_CASE_DISTANCES$ = b;
  }

  public static void setPrintCaseDistancesEvaluatorWrapper(Cons arguments) {
    Logic.setPrintCaseDistances(((BooleanWrapper)(arguments.value)).wrapperValue);
  }

  public static double euclideanDistance(Vector vec1, Vector vec2) {
    { double result = 0.0;
      double diff = 0.0;

      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = vec1.length() - 1;

        for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
          i = iter000;
          diff = ((FloatWrapper)((vec1.theArray)[i])).wrapperValue - ((FloatWrapper)((vec2.theArray)[i])).wrapperValue;
          result = result + (diff * diff);
        }
      }
      return (Math.sqrt(result));
    }
  }

  public static int hammingDistance(Vector vec1, Vector vec2) {
    { int result = 0;

      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = vec1.length() - 1;

        for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
          i = iter000;
          if (!(((IntegerWrapper)((vec1.theArray)[i])) == ((IntegerWrapper)((vec2.theArray)[i])))) {
            result = result + 1;
          }
        }
      }
      return (result);
    }
  }

  public static Symbol internLogicSymbol(String name) {
    return (Symbol.internSymbolInModule(name, Logic.getModule(StringWrapper.wrapString("LOGIC")), true));
  }

  public static void traceGoalCache(String string, ControlFrame frame) {
    { Proposition goal = frame.proposition;

      if (Stella_Object.traceKeywordP(Logic.KWD_GOAL_CACHES)) {
        { Object old$Printinframe$000 = Logic.$PRINTINFRAME$.get();

          try {
            Native.setSpecial(Logic.$PRINTINFRAME$, frame);
            Stella.STANDARD_OUTPUT.nativeStream.print(string);
            if (((Boolean)(Logic.$REVERSEPOLARITYp$.get())).booleanValue()) {
              Stella.STANDARD_OUTPUT.nativeStream.print("not~");
            }
            Stella.STANDARD_OUTPUT.nativeStream.println(goal.toString());

          } finally {
            Logic.$PRINTINFRAME$.set(old$Printinframe$000);
          }
        }
      }
    }
  }

  public static void removeObsoleteGoalCaches(KeyValueList table) {
    { Context k = null;
      GoalCache v = null;
      KvCons iter000 = table.theKvList;

      loop000 : for (;iter000 != null; iter000 = iter000.rest) {
        k = ((Context)(iter000.key));
        v = ((GoalCache)(iter000.value));
        if (k.deletedP()) {
          v = v;
          table.removeAt(k);
          Logic.removeObsoleteGoalCaches(table);
          break loop000;
        }
      }
    }
  }

  public static GoalCache lookupGoalCache(KeyValueList table) {
    return (((GoalCache)(table.lookup(((Context)(Stella.$CONTEXT$.get()))))));
  }

  public static boolean topLevelQueryContextP(Context self) {
    { Context querycontext = ((QueryIterator)(Logic.$QUERYITERATOR$.get())).queryContext;

      return ((self == querycontext) ||
          (Logic.worldStateP(self) ||
           (((Context)(KeyValueList.dynamicSlotValue(((World)(self)).dynamicSlots, Logic.SYM_LOGIC_INFERENCE_CACHE_OF, null))) == querycontext)));
    }
  }

  public static boolean cacheQueryResultsP() {
    return ((Logic.$CACHE_SUCCEEDED_GOALSp$ ||
        Logic.$CACHE_FAILED_GOALSp$) &&
        ((Logic.$DUPLICATE_SUBGOAL_STRATEGY$ == Logic.KWD_DUPLICATE_GOALS) &&
         (!((((QueryIterator)(Logic.$QUERYITERATOR$.get())) != null) &&
        (((QueryIterator)(Logic.$QUERYITERATOR$.get())).partialMatchStrategy != null)))));
  }

  public static String toggleGoalCaching() {
    if (Logic.$CACHE_SUCCEEDED_GOALSp$) {
      {
        Logic.$CACHE_SUCCEEDED_GOALSp$ = false;
        Logic.$CACHE_FAILED_GOALSp$ = false;
        Logic.incrementNowTimestamp();
        return ("Disabled goal caching.");
      }
    }
    else {
      {
        Logic.$CACHE_SUCCEEDED_GOALSp$ = true;
        Logic.$CACHE_FAILED_GOALSp$ = true;
        return ("Enabled goal caching.");
      }
    }
  }

  public static StringWrapper toggleGoalCachingEvaluatorWrapper(Cons arguments) {
    arguments = arguments;
    { String result = Logic.toggleGoalCaching();

      if (result != null) {
        return (StringWrapper.wrapString(result));
      }
      else {
        return (null);
      }
    }
  }

  public static void clearQueryResultsCache() {
    { AtomicGoalCache cache = null;
      Vector vector000 = Logic.$SUCCEEDED_GOALS_CACHE$;
      int index000 = 0;
      int length000 = vector000.length();

      for (;index000 < length000; index000 = index000 + 1) {
        cache = ((AtomicGoalCache)((vector000.theArray)[index000]));
        if (cache != null) {
          Proposition.setGoalCacheList(cache.proposition, null);
        }
      }
    }
    Logic.$SUCCEEDED_GOALS_CACHE$.clear();
    Logic.$FAILED_GOALS_CACHE$.clear();
    Logic.$FAILED_GOAL_CUTOFFS$ = 0;
    Logic.$SUCCEEDED_GOAL_CUTOFFS$ = 0;
  }

  public static void printQueryResultsCache(int limit) {
    if (limit == Stella.NULL_INTEGER) {
      limit = 100;
    }
    { int count = limit;

      Stella.STANDARD_OUTPUT.nativeStream.println("Failed goal cutoffs:    " + Logic.$FAILED_GOAL_CUTOFFS$);
      {
        Stella.STANDARD_OUTPUT.nativeStream.println("Succeeded goal cutoffs: " + Logic.$SUCCEEDED_GOAL_CUTOFFS$);
        Stella.STANDARD_OUTPUT.nativeStream.println();
      }
;
      Stella.STANDARD_OUTPUT.nativeStream.println("Cached failed goals:");
      { AtomicGoalCache cache = null;
        Vector vector000 = Logic.$FAILED_GOALS_CACHE$;
        int index000 = 0;
        int length000 = vector000.length();
        int i = Stella.NULL_INTEGER;
        int iter000 = 0;

        loop000 : for (;index000 < length000; index000 = index000 + 1, iter000 = iter000 + 1) {
          cache = ((AtomicGoalCache)((vector000.theArray)[index000]));
          i = iter000;
          { boolean testValue000 = false;

            testValue000 = cache != null;
            if (testValue000) {
              testValue000 = !cache.proposition.deletedP();
              if (testValue000) {
                testValue000 = !(cache.proposition.operator.symbolId == -1);
                if (testValue000) {
                  { boolean foundP000 = false;

                    { Stella_Object arg = null;
                      Vector vector001 = cache.proposition.arguments;
                      int index001 = 0;
                      int length001 = vector001.length();
                      Stella_Object binding = null;
                      Cons iter001 = cache.bindings;

                      loop001 : for (;(index001 < length001) &&
                                (!(iter001 == Stella.NIL)); index001 = index001 + 1, iter001 = iter001.rest) {
                        arg = (vector001.theArray)[index001];
                        binding = iter001.value;
                        if (arg.deletedP() ||
                            ((binding != null) &&
                             binding.deletedP())) {
                          foundP000 = true;
                          break loop001;
                        }
                      }
                    }
                    testValue000 = foundP000;
                  }
                  testValue000 = !testValue000;
                }
              }
            }
            if (testValue000) {
              if (count <= 0) {
                break loop000;
              }
              Stella.STANDARD_OUTPUT.nativeStream.println(i + ": " + cache);
              count = count - 1;
            }
          }
        }
      }
      count = limit;
      {
        Stella.STANDARD_OUTPUT.nativeStream.println();
        Stella.STANDARD_OUTPUT.nativeStream.println("Cached succeeded goals:");
      }
;
      { AtomicGoalCache cache = null;
        Vector vector002 = Logic.$SUCCEEDED_GOALS_CACHE$;
        int index002 = 0;
        int length002 = vector002.length();
        int i = Stella.NULL_INTEGER;
        int iter002 = 0;

        loop002 : for (;index002 < length002; index002 = index002 + 1, iter002 = iter002 + 1) {
          cache = ((AtomicGoalCache)((vector002.theArray)[index002]));
          i = iter002;
          { boolean testValue001 = false;

            testValue001 = cache != null;
            if (testValue001) {
              testValue001 = !cache.proposition.deletedP();
              if (testValue001) {
                testValue001 = !(cache.proposition.operator.symbolId == -1);
                if (testValue001) {
                  { boolean foundP001 = false;

                    { Stella_Object arg = null;
                      Vector vector003 = cache.proposition.arguments;
                      int index003 = 0;
                      int length003 = vector003.length();
                      Stella_Object binding = null;
                      Cons iter003 = cache.bindings;

                      loop003 : for (;(index003 < length003) &&
                                (!(iter003 == Stella.NIL)); index003 = index003 + 1, iter003 = iter003.rest) {
                        arg = (vector003.theArray)[index003];
                        binding = iter003.value;
                        if (arg.deletedP() ||
                            ((binding != null) &&
                             binding.deletedP())) {
                          foundP001 = true;
                          break loop003;
                        }
                      }
                    }
                    testValue001 = foundP001;
                  }
                  testValue001 = !testValue001;
                }
              }
            }
            if (testValue001) {
              if (count <= 0) {
                break loop002;
              }
              Stella.STANDARD_OUTPUT.nativeStream.println(i + ": " + cache);
              count = count - 1;
            }
          }
        }
      }
    }
  }

  public static int hashGoalArgument(Stella_Object arg, int code) {
    { Stella_Object hashedarg = arg;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(arg);

        if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
          { Skolem arg000 = ((Skolem)(arg));

          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
          { LogicObject arg000 = ((LogicObject)(arg));

            if (arg000.surrogateValueInverse == null) {
              hashedarg = StringWrapper.wrapString(Native.stringify(arg000));
            }
          }
        }
        else {
        }
      }
      return ((((((code & 1) == 0) ? (code >>> 1) : (((code >> 1)) | Stella.$INTEGER_MSB_MASK$))) ^ (Stella_Object.safeEqualHashCode(hashedarg))));
    }
  }

  public static boolean filterOutStrategyP(Keyword strategy, ControlFrame frame) {
    if (strategy == Logic.KWD_LOOKUP_GOAL_CACHES) {
      return ((!((BooleanWrapper)(KeyValueList.dynamicSlotValue(Logic.surrogateToDescription(((Surrogate)(frame.proposition.operator))).dynamicSlots, Logic.SYM_LOGIC_CHECK_FOR_CACHED_GOALSp, Stella.FALSE_WRAPPER))).wrapperValue) ||
          (!((Logic.$CACHE_SUCCEEDED_GOALSp$ ||
          Logic.$CACHE_FAILED_GOALSp$) &&
          ((Logic.$DUPLICATE_SUBGOAL_STRATEGY$ == Logic.KWD_DUPLICATE_GOALS) &&
           (!((((QueryIterator)(Logic.$QUERYITERATOR$.get())) != null) &&
          (((QueryIterator)(Logic.$QUERYITERATOR$.get())).partialMatchStrategy != null)))))));
    }
    else if (strategy == Logic.KWD_SPECIALIST) {
      { Proposition proposition = frame.proposition;
        NamedDescription description = Logic.getDescription(((Surrogate)(proposition.operator)));

        return (NamedDescription.lookupSpecialist(description) == null);
      }
    }
    else if (strategy == Logic.KWD_MANUFACTURE_SKOLEM) {
      { NamedDescription description = Logic.getDescription(((Surrogate)(frame.proposition.operator)));

        return ((!Logic.testPropertyP(description, Logic.SGT_PL_KERNEL_KB_TOTAL)) ||
            frame.reversePolarityP);
      }
    }
    else {
      return (false);
    }
  }

  public static boolean parallelStrategyP(Keyword strategy) {
    return (Logic.$PARALLEL_STRATEGIES$.memberP(strategy));
  }

  public static Cons optimizeOrderOfApplicableRules(Cons rules, boolean tailP) {
    { Cons cursor = rules;
      Cons result = Stella.NIL;
      Description antecedent = null;
      int antecedentindex = (tailP ? 0 : 1);

      if (rules.rest == Stella.NIL) {
        return (rules);
      }
      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;

        loop000 : for (;true; iter000 = iter000 + 1) {
          i = iter000;
          while (!(cursor == Stella.NIL)) {
            antecedent = ((Description)((((Proposition)(cursor.value)).arguments.theArray)[antecedentindex]));
            if (antecedent.internalVariables.length() == i) {
              result = Cons.cons(((Proposition)(cursor.value)), result);
              cursor.value = null;
            }
            cursor = cursor.rest;
          }
          cursor = rules.remove(null);
          if (cursor == Stella.NIL) {
            break loop000;
          }
        }
      }
      return (result.reverse());
    }
  }

  public static boolean inferableDescriptionP(Stella_Object self) {
    if (self == null) {
      return (false);
    }
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(self), Logic.SGT_LOGIC_DESCRIPTION)) {
      { Description self000 = ((Description)(self));

        if (((Boolean)(Logic.$REVERSEPOLARITYp$.get())).booleanValue() &&
            (Description.getInferableComplementDescription(self000) != null)) {
          self000 = ((Description)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_COMPLEMENT_DESCRIPTION, null)));
        }
        return (Description.inferableP(self000));
      }
    }
    else {
      return (false);
    }
  }

  public static Keyword trySimpleContainedByProof(Stella_Object subcollection, Stella_Object supercollection, boolean reversepolarityP) {
    { Object old$ReversepolarityP$000 = Logic.$REVERSEPOLARITYp$.get();

      try {
        Native.setBooleanSpecial(Logic.$REVERSEPOLARITYp$, false);
        { List members = Logic.assertedCollectionMembers(subcollection, false);

          Native.setBooleanSpecial(Logic.$REVERSEPOLARITYp$, reversepolarityP);
          if (members != null) {
            if (reversepolarityP) {
              { boolean foundP000 = false;

                { Stella_Object m = null;
                  Cons iter000 = members.theConsList;

                  loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                    m = iter000.value;
                    if (Logic.memberOfCollectionP(Logic.valueOf(m), supercollection)) {
                      foundP000 = true;
                      break loop000;
                    }
                  }
                }
                if (foundP000) {
                  return (Logic.KWD_FINAL_SUCCESS);
                }
                else {
                  if (Logic.closedTermP(supercollection)) {
                    return (Logic.KWD_TERMINAL_FAILURE);
                  }
                }
              }
            }
            else {
              { boolean alwaysP000 = true;

                { Stella_Object m = null;
                  Cons iter001 = members.theConsList;

                  loop001 : for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                    m = iter001.value;
                    if (!Logic.memberOfCollectionP(Logic.valueOf(m), supercollection)) {
                      alwaysP000 = false;
                      break loop001;
                    }
                  }
                }
                if (alwaysP000) {
                  return (Logic.KWD_FINAL_SUCCESS);
                }
                else {
                  if (Logic.closedTermP(supercollection)) {
                    return (Logic.KWD_TERMINAL_FAILURE);
                  }
                }
              }
            }
          }
          return (Logic.KWD_FAILURE);
        }

      } finally {
        Logic.$REVERSEPOLARITYp$.set(old$ReversepolarityP$000);
      }
    }
  }

  public static Proposition createContainedByArgument(Stella_Object collection, List bridgeargs) {
    { Proposition proposition = null;
      Stella_Object thecollection = collection;
      int arity = 1;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(collection);

        if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
          { NamedDescription collection000 = ((NamedDescription)(collection));

            if (Logic.classP(collection000)) {
              proposition = Logic.createProposition(Logic.SYM_STELLA_ISA, 1);
              proposition.operator = collection000.surrogateValueInverse;
              (proposition.arguments.theArray)[0] = (bridgeargs.first());
              return (proposition);
            }
            else {
              proposition = Logic.createProposition(Logic.SYM_STELLA_PREDICATE, collection000.arity());
              proposition.operator = collection000.surrogateValueInverse;
              { Stella_Object arg = null;
                Cons iter000 = bridgeargs.theConsList;
                int i = Stella.NULL_INTEGER;
                int iter001 = 0;

                for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
                  arg = iter000.value;
                  i = iter001;
                  (proposition.arguments.theArray)[i] = arg;
                }
              }
              return (proposition);
            }
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
          { Description collection000 = ((Description)(collection));

            arity = collection000.arity();
            thecollection = Logic.instantiateExternalBindings(collection000);
          }
        }
        else {
        }
      }
      proposition = Logic.createProposition(Logic.SYM_STELLA_PREDICATE, 2);
      proposition.operator = Logic.SGT_PL_KERNEL_KB_MEMBER_OF;
      (proposition.arguments.theArray)[0] = (((arity > 1) ? bridgeargs : bridgeargs.first()));
      (proposition.arguments.theArray)[1] = thecollection;
      return (proposition);
    }
  }

  public static World pushMonotonicWorld() {
    { World world = Stella.pushWorld();

      KeyValueList.setDynamicSlotValue(world.dynamicSlots, Logic.SYM_LOGIC_MONOTONICp, Stella.TRUE_WRAPPER, Stella.FALSE_WRAPPER);
      return (world);
    }
  }

  public static LogicObject createAnonymousInstance(String prefix, boolean skolemP) {
    { Symbol instancename = Symbol.internSymbolInModule(Stella.yieldUniqueGensymName(prefix, Logic.$PL_ANONYMOUS_MODULE$), Logic.$PL_ANONYMOUS_MODULE$, true);
      LogicObject instance = (skolemP ? Logic.createSkolem(null, instancename) : ((LogicObject)(Logic.createLogicInstance(Surrogate.internSurrogateInModule(instancename.symbolName, ((Module)(instancename.homeContext)), true), null))));

      KeyValueList.setDynamicSlotValue(instance.dynamicSlots, Logic.SYM_LOGIC_HYPOTHESIZED_INSTANCEp, Stella.TRUE_WRAPPER, Stella.FALSE_WRAPPER);
      return (instance);
    }
  }

  public static LogicObject createHypothesizedInstance(String prefix) {
    { LogicObject instance = Logic.createAnonymousInstance(prefix, true);

      KeyValueList.setDynamicSlotValue(instance.dynamicSlots, Logic.SYM_LOGIC_HYPOTHESIZED_INSTANCEp, Stella.TRUE_WRAPPER, Stella.FALSE_WRAPPER);
      return (instance);
    }
  }

  public static Stella_Object justificationArgumentBoundTo(Stella_Object argument, Justification justification) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(argument), Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
      { PatternVariable argument000 = ((PatternVariable)(argument));

        if (justification == null) {
          justification = ((Justification)(Logic.$CURRENTJUSTIFICATION$.get()));
        }
        if ((justification != null) &&
            (justification.substitution != null)) {
          return (justification.substitution.lookup(argument000));
        }
      }
    }
    else {
      return (argument);
    }
    return (null);
  }

  /** Return TRUE if every query records justifications to enable
   * the explanation of concluded results.
   * @return boolean
   */
  public static boolean recordJustificationsP() {
    return (((Boolean)(Logic.$RECORD_JUSTIFICATIONSp$.get())).booleanValue());
  }

  public static ForwardJustification createForwardJustification(Cons antecedents, Proposition forwardrule, Vector arguments, Proposition consequentproposition, Justification bcJustification) {
    { ForwardJustification self000 = ForwardJustification.newForwardJustification();

      self000.inferenceRule = Logic.KWD_MODUS_PONENS;
      { ForwardJustification fj = self000;
        Vector ruleVariables = Proposition.getRuleIoVariables(forwardrule);
        KeyValueMap substitution = null;
        Cons antecedentJustifications = Stella.NIL;

        if (bcJustification != null) {
          {
            substitution = bcJustification.substitution;
            antecedentJustifications = Cons.cons(bcJustification, antecedentJustifications);
          }
        }
        else {
          {
            substitution = KeyValueMap.newKeyValueMap();
            { Stella_Object arg = null;
              Vector vector000 = arguments;
              int index000 = 0;
              int length000 = vector000.length();
              PatternVariable var = null;
              Vector vector001 = ruleVariables;
              int index001 = 0;
              int length001 = vector001.length();

              for (;(index000 < length000) &&
                        (index001 < length001); index000 = index000 + 1, index001 = index001 + 1) {
                arg = (vector000.theArray)[index000];
                var = ((PatternVariable)((vector001.theArray)[index001]));
                substitution.insertAt(var, arg);
              }
            }
          }
        }
        { Proposition aprop = null;
          Cons iter000 = antecedents;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            aprop = ((Proposition)(iter000.value));
            antecedentJustifications = Cons.cons(Proposition.getForwardAntecedentJustification(aprop), antecedentJustifications);
          }
        }
        antecedentJustifications = Cons.cons(Proposition.getForwardAntecedentJustification(forwardrule), antecedentJustifications);
        fj.substitution = ((KeyValueMap)(substitution));
        fj.proposition = consequentproposition;
        fj.truthValue = ((TruthValue)(Stella_Object.accessInContext(consequentproposition.truthValue, consequentproposition.homeContext, false)));
        fj.antecedents = antecedentJustifications;
        return (fj);
      }
    }
  }

  public static void recordForwardJustification(Cons antecedents, Proposition forwardrule, Vector arguments, Proposition consequentproposition, Justification bcJustification) {
    if (!((Boolean)(Logic.$RECORD_JUSTIFICATIONSp$.get())).booleanValue()) {
      return;
    }
    { List justifications = consequentproposition.forwardJustifications();
      ForwardJustification newFj = Logic.createForwardJustification(antecedents, forwardrule, arguments, consequentproposition, bcJustification);

      { Justification fj = null;
        Cons iter000 = justifications.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          fj = ((Justification)(iter000.value));
          if (((Justification)(fj.antecedents.value)).proposition == forwardrule) {
            fj.substitution = newFj.substitution;
            fj.antecedents = newFj.antecedents;
            return;
          }
        }
      }
      Proposition.addForwardJustifications(consequentproposition, newFj);
    }
  }

  public static void defineExplanationPhrase(Keyword phrasekey, Keyword audience, String phrase, Cons modifiers) {
    { HashTable vocabulary = ((HashTable)(Logic.$EXPLANATION_VOCABULARIES$.lookup(audience)));
      Cons mods = modifiers;
      Cons entry = Stella.NIL;

      if (vocabulary == null) {
        vocabulary = HashTable.newHashTable();
        Logic.$EXPLANATION_VOCABULARIES$.insertAt(audience, vocabulary);
      }
      entry = ((Cons)(vocabulary.lookup(phrasekey)));
      if (entry == null) {
        entry = Stella.NIL;
      }
      vocabulary.insertAt(phrasekey, Cons.cons(Cons.cons(StringWrapper.wrapString(phrase), mods), entry));
    }
  }

  public static String lookupExplanationPhrase(Keyword phrasekey, Cons modifiers, Keyword audience) {
    { HashTable vocabulary = ((HashTable)(Logic.$EXPLANATION_VOCABULARIES$.lookup(((audience != null) ? audience : ((Keyword)(Logic.$EXPLANATION_AUDIENCE$.get()))))));
      Cons entry = Stella.NIL;
      String bestphrase = null;
      int bestscore = -1;

      if (vocabulary == null) {
        vocabulary = ((HashTable)(Logic.$EXPLANATION_VOCABULARIES$.lookup(Logic.KWD_TECHNICAL)));
      }
      if (phrasekey == null) {
        phrasekey = Logic.KWD_UNKNOWN_RULE;
      }
      entry = ((Cons)(vocabulary.lookup(phrasekey)));
      if (entry == null) {
        vocabulary = ((HashTable)(Logic.$EXPLANATION_VOCABULARIES$.lookup(Logic.KWD_TECHNICAL)));
        entry = ((Cons)(vocabulary.lookup(phrasekey)));
      }
      if (entry == null) {
        return (Logic.lookupExplanationPhrase(Logic.KWD_UNKNOWN_RULE, Stella.NIL, audience));
      }
      { Cons phrase = null;
        Cons iter000 = entry;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          phrase = ((Cons)(iter000.value));
          { boolean testValue000 = false;

            { boolean alwaysP000 = true;

              { Stella_Object mod = null;
                Cons iter001 = phrase.rest;

                loop001 : for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                  mod = iter001.value;
                  if (!modifiers.membP(mod)) {
                    alwaysP000 = false;
                    break loop001;
                  }
                }
              }
              testValue000 = alwaysP000;
            }
            if (testValue000) {
              testValue000 = phrase.rest.length() > bestscore;
            }
            if (testValue000) {
              bestscore = phrase.rest.length();
              bestphrase = ((StringWrapper)(phrase.value)).wrapperValue;
            }
          }
        }
      }
      return (bestphrase);
    }
  }

  public static Justification lookupJustification(KeyValueList mapping, String label) {
    { Justification justification = null;
      ExplanationInfo info = null;
      KvCons iter000 = mapping.theKvList;

      for (;iter000 != null; iter000 = iter000.rest) {
        justification = ((Justification)(iter000.key));
        info = ((ExplanationInfo)(iter000.value));
        if (Stella.stringEqlP(info.label, label)) {
          return (justification);
        }
      }
    }
    return (null);
  }

  public static void resetMappingForSubexplanation(KeyValueList mapping) {
    { Justification justification = null;
      ExplanationInfo info = null;
      KvCons iter000 = mapping.theKvList;

      for (;iter000 != null; iter000 = iter000.rest) {
        justification = ((Justification)(iter000.key));
        info = ((ExplanationInfo)(iter000.value));
        justification = justification;
        info.explainedP = false;
      }
    }
  }

  public static boolean printingJustificationP() {
    return (((Justification)(Logic.$CURRENTJUSTIFICATION$.get())) != null);
  }

  public static void printExplanationLabel(OutputStream stream, String label, boolean headP) {
    headP = headP;
    if (((Keyword)(Logic.$EXPLANATION_FORMAT$.get())) == Logic.KWD_ASCII) {
      stream.nativeStream.print(label);
    }
    else if (((Keyword)(Logic.$EXPLANATION_FORMAT$.get())) == Logic.KWD_XML) {
      {
        stream.nativeStream.print("<label>");
        stream.nativeStream.print(label);
        stream.nativeStream.println("</label>");
      }
    }
    else if (((Keyword)(Logic.$EXPLANATION_FORMAT$.get())) == Logic.KWD_HTML) {
      {
        stream.nativeStream.print("<STRONG>");
        stream.nativeStream.print(label + "&nbsp;");
        stream.nativeStream.print("</STRONG>");
      }
    }
    else {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        stream000.nativeStream.print("`" + ((Keyword)(Logic.$EXPLANATION_FORMAT$.get())) + "' is not a valid case option");
        throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
      }
    }
  }

  public static void printOneVariableSubstitution(OutputStream stream, Stella_Object var, Stella_Object value) {
    if (((Keyword)(Logic.$EXPLANATION_FORMAT$.get())) == Logic.KWD_ASCII) {
      Logic.prettyPrintLogicalForm(var, stream);
      if (Stella_Object.eqlP(Logic.valueOf(var), var)) {
        stream.nativeStream.print("/");
        if ((value != null) &&
            Stella_Object.isaP(value, Logic.SGT_LOGIC_ALTERNATIVE_BINDINGS_SET)) {
          stream.nativeStream.print("{");
          { Stella_Object binding = null;
            ListIterator iter000 = ((ListIterator)(((AlternativeBindingsSet)(value)).bindings.allocateIterator()));

            while (iter000.nextP()) {
              binding = iter000.value;
              Logic.prettyPrintLogicalForm(binding, stream);
              stream.nativeStream.print(", ");
            }
          }
          stream.nativeStream.print("...}");
        }
        else {
          Logic.prettyPrintLogicalForm(value, stream);
        }
      }
    }
    else if (((Keyword)(Logic.$EXPLANATION_FORMAT$.get())) == Logic.KWD_HTML) {
      { OutputStringStream stringStream = OutputStringStream.newOutputStringStream();
        boolean quotehtmlP = true;

        if (Logic.$CYC_KLUDGES_ENABLEDp$) {
          if (((Keyword)(Logic.$LOGIC_DIALECT$.get())) == Logic.KWD_CYC_NL) {
            quotehtmlP = false;
          }
        }
        if ((((Keyword)(Logic.$LOGIC_DIALECT$.get())) == Logic.KWD_KIF_ONTOSAURUS) ||
            (((Keyword)(Logic.$LOGIC_DIALECT$.get())) == Logic.KWD_JAVA_GUI_HTML)) {
          quotehtmlP = false;
        }
        Logic.prettyPrintLogicalForm(var, stringStream);
        if (Stella_Object.eqlP(Logic.valueOf(var), var)) {
          stringStream.nativeStream.print("/");
          if ((value != null) &&
              Stella_Object.isaP(value, Logic.SGT_LOGIC_ALTERNATIVE_BINDINGS_SET)) {
            stringStream.nativeStream.print("{one of ");
            { Stella_Object binding = null;
              ListIterator iter001 = ((ListIterator)(((AlternativeBindingsSet)(value)).bindings.allocateIterator()));

              while (iter001.nextP()) {
                binding = iter001.value;
                Logic.prettyPrintLogicalForm(binding, stringStream);
                stringStream.nativeStream.print(", ");
              }
            }
            stringStream.nativeStream.print("etc.}");
          }
          else {
            Logic.prettyPrintLogicalForm(value, stringStream);
          }
        }
        if (quotehtmlP) {
          Stella.writeHtmlQuotingSpecialCharacters(stream.nativeStream, stringStream.theStringReader());
        }
        else {
          stream.nativeStream.print(stringStream.theStringReader());
        }
      }
    }
    else if (((Keyword)(Logic.$EXPLANATION_FORMAT$.get())) == Logic.KWD_XML) {
      { OutputStringStream stringStream = OutputStringStream.newOutputStringStream();

        {
          stream.nativeStream.print("<binding>");
          Logic.prettyPrintLogicalForm(var, stringStream);
          {
            stream.nativeStream.print("<variable>");
            Stella.writeHtmlQuotingSpecialCharacters(stream.nativeStream, stringStream.theStringReader());
            stream.nativeStream.println("</variable>");
          }
          if (Stella_Object.eqlP(Logic.valueOf(var), var)) {
            stringStream = OutputStringStream.newOutputStringStream();
            Logic.prettyPrintLogicalForm(value, stringStream);
            {
              stream.nativeStream.print("<value>");
              Stella.writeHtmlQuotingSpecialCharacters(stream.nativeStream, stringStream.theStringReader());
              stream.nativeStream.print("</value>");
            }
          }
          stream.nativeStream.println("</binding>");
        }
      }
    }
    else {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        stream000.nativeStream.print("`" + ((Keyword)(Logic.$EXPLANATION_FORMAT$.get())) + "' is not a valid case option");
        throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
      }
    }
  }

  /** Print an explanation for the result of the most recent query.
   * Without any arguments, <code>why</code> prints an explanation of the top level
   * query proposition down to a maximum depth of 3.  <code>_whyAll_</code> prints
   * an explanation to unlimited depth.  Alternatively, a particular depth
   * can be specified, for example, <code>_why5_</code> explains down to a depth of 5.
   * A proof step that was not explained explicitly (e.g., due to a depth
   * cutoff) can be explained by supplying the label of the step as the
   * first argument to <code>why</code>, for example, <code>_why1D2D35_</code> prints an explanation
   * starting at 1.2.3 down to a depth of 5 (which is counted relative to the
   * depth of the starting point).  The keywords <code>brief</code> and <code>verbose</code> can be
   * used to select a particular explanation style.  In brief mode, explicitly
   * asserted propositions are not further explained and indicated with a
   * <code>X</code> assertion marker.  Additionally, relatively uninteresting proof steps
   * such as AND-introductions are skipped.  This explanation style option is
   * sticky and will affect future calls to <code>why</code> until it gets changed again.
   * The various options can be combined in any way, for example,
   * <code>_why1D2D3Brief3_</code> explains starting from step 1.2.3 down to a depth
   * of 3 in brief explanation mode.
   * @param args
   */
  public static void why(Cons args) {
    { String label = null;
      Keyword style = null;
      int maxdepth = Stella.NULL_INTEGER;
      boolean summaryP = false;

      { Object [] caller_MV_returnarray = new Object[3];

        label = Logic.parseWhyArguments(args, caller_MV_returnarray);
        style = ((Keyword)(caller_MV_returnarray[0]));
        maxdepth = ((int)(((IntegerWrapper)(caller_MV_returnarray[1])).wrapperValue));
        summaryP = ((boolean)(((BooleanWrapper)(caller_MV_returnarray[2])).wrapperValue));
      }
      summaryP = summaryP;
      Logic.explainWhy(label, style, maxdepth, Stella.STANDARD_OUTPUT);
    }
  }

  public static void whyEvaluatorWrapper(Cons arguments) {
    Logic.why(arguments);
  }

  /** Programmer's interface to WHY function.
   * @param label
   * @param style
   * @param maxdepth
   * @param stream
   */
  public static void explainWhy(String label, Keyword style, int maxdepth, OutputStream stream) {
    try {
      { Justification justification = Logic.getWhyJustification(label);

        { Object old$ExplanationStyle$000 = Logic.$EXPLANATION_STYLE$.get();

          try {
            Native.setSpecial(Logic.$EXPLANATION_STYLE$, ((style != null) ? style : Logic.KWD_BRIEF));
            Justification.printExplanation(justification, stream, ((KeyValueList)(Logic.$MOST_RECENT_EXPLANATION_MAPPING$.get())), maxdepth, ((Keyword)(Logic.$EXPLANATION_AUDIENCE$.get())));

          } finally {
            Logic.$EXPLANATION_STYLE$.set(old$ExplanationStyle$000);
          }
        }
      }
    } catch (ExplainException ee) {
      Stella.STANDARD_OUTPUT.nativeStream.print(Stella.exceptionMessage(ee));
    }
  }

  /** Returns the current WHY justification.  May also throw one of the
   * following subtypes of EXPLAIN-EXCEPTION:
   *    EXPLAIN-NO-QUERY-EXCEPTION
   *    EXPLAIN-NO-SOLUTION-EXCEPTION
   *    EXPLAIN-NO-MORE-SOLUTIONS-EXCEPTION
   *    EXPLAIN-NOT-ENABLED-EXCEPTION
   *    EXPLAIN-NO-SUCH-LABEL-EXCEPTION
   *    EXPLAIN-QUERY-TRUE-EXCEPTION
   * @param label
   * @return Justification
   */
  public static Justification getWhyJustification(String label) {
    { QueryIterator query = Logic.$MOST_RECENT_QUERY$;
      boolean partialqueryP = false;
      Justification justification = null;

      if (query == null) {
        throw ((ExplainNoQueryException)(ExplainNoQueryException.newExplainNoQueryException("There is nothing to explain.").fillInStackTrace()));
      }
      partialqueryP = Logic.$MOST_RECENT_QUERY$.partialMatchStrategy != null;
      justification = ((Justification)(KeyValueList.dynamicSlotValue(query.baseControlFrame.dynamicSlots, Logic.SYM_LOGIC_JUSTIFICATION, null)));
      if (justification == null) {
        if (query.solutions.nonEmptyP()) {
          if (query.exhaustedP) {
            { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

              {
                stream000.nativeStream.println("There were either no more solutions, or you used the `all' keyword.");
                stream000.nativeStream.println("   The query must generate only a single answer for explanation");
                stream000.nativeStream.print("   to be possible, thus don't use the `all' keyword to `retrieve'.");
              }
;
              throw ((ExplainNoSolutionException)(ExplainNoSolutionException.newExplainNoSolutionException(stream000.theStringReader()).fillInStackTrace()));
            }
          }
          else {
            { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

              {
                stream001.nativeStream.println("No justifications available.  You have to enable justifications");
                stream001.nativeStream.println("   with `(set-feature justifications)' and rerun the query in");
                stream001.nativeStream.print("   order to enable the explanation of results.");
              }
;
              throw ((ExplainNotEnabledException)(ExplainNotEnabledException.newExplainNotEnabledException(stream001.theStringReader()).fillInStackTrace()));
            }
          }
        }
        else if (query.exhaustedP) {
          throw ((ExplainNoSolutionException)(ExplainNoSolutionException.newExplainNoSolutionException("There was no solution.").fillInStackTrace()));
        }
        else {
          throw ((ExplainNoSolutionException)(ExplainNoSolutionException.newExplainNoSolutionException("There is no solution yet.").fillInStackTrace()));
        }
      }
      else if (query.exhaustedP &&
          (!partialqueryP)) {
        throw ((ExplainNoMoreSolutionsException)(ExplainNoMoreSolutionsException.newExplainNoMoreSolutionsException("There were no more solutions.").fillInStackTrace()));
      }
      else {
        if (label != null) {
          if (((KeyValueList)(Logic.$MOST_RECENT_EXPLANATION_MAPPING$.get())) != null) {
            justification = Logic.lookupJustification(((KeyValueList)(Logic.$MOST_RECENT_EXPLANATION_MAPPING$.get())), label);
          }
          if (justification == null) {
            { OutputStringStream stream002 = OutputStringStream.newOutputStringStream();

              stream002.nativeStream.print("Label `" + label + "' does not exists in the current explanation.");
              throw ((ExplainNoSuchLabelException)(ExplainNoSuchLabelException.newExplainNoSuchLabelException(stream002.theStringReader()).fillInStackTrace()));
            }
          }
        }
        else {
          Native.setSpecial(Logic.$MOST_RECENT_EXPLANATION_MAPPING$, null);
        }
        return (justification);
      }
    }
  }

  public static boolean commandOptionEqlP(Stella_Object arg, String option) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(arg);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_GENERALIZED_SYMBOL)) {
        { GeneralizedSymbol arg000 = ((GeneralizedSymbol)(arg));

          return (Stella.stringEqlP(Native.stringUpcase(arg000.symbolName), option));
        }
      }
      else if (Surrogate.subtypeOfStringP(testValue000)) {
        { StringWrapper arg000 = ((StringWrapper)(arg));

          return (Stella.stringEqlP(Native.stringUpcase(arg000.wrapperValue), option));
        }
      }
      else {
        return (false);
      }
    }
  }

  public static String parseWhyArguments(Cons args, Object [] MV_returnarray) {
    { String label = null;
      int depth = Logic.$DEFAULT_EXPLANATION_DEPTH$;
      Keyword style = null;
      boolean summaryP = false;
      Stella_Object firstarg = args.value;

      if (firstarg != null) {
        { Surrogate testValue000 = Stella_Object.safePrimaryType(firstarg);

          if (Surrogate.subtypeOfStringP(testValue000)) {
            { StringWrapper firstarg000 = ((StringWrapper)(firstarg));

              label = firstarg000.wrapperValue;
              args = args.rest;
            }
          }
          else if (Surrogate.subtypeOfIntegerP(testValue000)) {
            { IntegerWrapper firstarg000 = ((IntegerWrapper)(firstarg));

              if (Stella_Object.eqlP(firstarg000, Stella.ONE_WRAPPER)) {
                label = "1";
                args = args.rest;
              }
            }
          }
          else if (Surrogate.subtypeOfFloatP(testValue000)) {
            { FloatWrapper firstarg000 = ((FloatWrapper)(firstarg));

              label = Native.stringify(firstarg000);
              args = args.rest;
            }
          }
          else if (Surrogate.subtypeOfSymbolP(testValue000)) {
            { Symbol firstarg000 = ((Symbol)(firstarg));

              if (Stella.$CHARACTER_TYPE_TABLE$[(int) ((firstarg000.symbolName).charAt(0))] == Logic.KWD_DIGIT) {
                label = firstarg000.symbolName;
                args = args.rest;
              }
            }
          }
          else {
          }
        }
        { Stella_Object arg = null;
          Cons iter000 = args;
          int i = Stella.NULL_INTEGER;
          int iter001 = 0;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
            arg = iter000.value;
            i = iter001;
            if (Logic.commandOptionEqlP(arg, "BRIEF")) {
              style = Logic.KWD_BRIEF;
            }
            if (Logic.commandOptionEqlP(arg, "VERBOSE")) {
              style = Logic.KWD_VERBOSE;
            }
            if (Logic.commandOptionEqlP(arg, "SUMMARY")) {
              summaryP = true;
            }
            if (Stella_Object.integerP(arg)) {
              depth = ((IntegerWrapper)(arg)).wrapperValue;
            }
            if (arg == Logic.KWD_DEPTH) {
              if (args.nth(i + 1) == null) {
                depth = Stella.NULL_INTEGER;
              }
            }
            if (Logic.commandOptionEqlP(arg, "ALL")) {
              depth = Stella.NULL_INTEGER;
            }
          }
        }
      }
      { String _return_temp = label;

        MV_returnarray[0] = style;
        MV_returnarray[1] = IntegerWrapper.wrapInteger(depth);
        MV_returnarray[2] = BooleanWrapper.wrapBoolean(summaryP);
        return (_return_temp);
      }
    }
  }

  public static boolean whynotPartialMatchModeP() {
    return (((((QueryIterator)(Logic.$QUERYITERATOR$.get())) != null) &&
        (((QueryIterator)(Logic.$QUERYITERATOR$.get())).partialMatchStrategy != null)) &&
        Stella_Object.isaP(((QueryIterator)(Logic.$QUERYITERATOR$.get())).partialMatchStrategy, Logic.SGT_LOGIC_WHYNOT_PARTIAL_MATCH));
  }

  public static int numberOfRemainingAntecedents(Iterator iterator) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(iterator), Logic.SGT_STELLA_CONS_ITERATOR)) {
      { ConsIterator iterator000 = ((ConsIterator)(iterator));

        if (iterator000.firstIterationP) {
          return (iterator000.consIteratorCursor.length());
        }
        else {
          return (iterator000.consIteratorCursor.length() - 1);
        }
      }
    }
    else {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        stream000.nativeStream.print("Don't know how to handle antecedents iterator of type `" + iterator.primaryType() + "'");
        throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
      }
    }
  }

  public static WhynotProofClass insertWhynotProof(List classes, Justification proof) {
    { WhynotProofClass renamed_Class = null;
      Cons iter000 = classes.theConsList;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        renamed_Class = ((WhynotProofClass)(iter000.value));
        if (WhynotProofClass.insertWhynotProofToClassP(renamed_Class, proof)) {
          return (renamed_Class);
        }
      }
    }
    classes.push(WhynotProofClass.newWhynotProofClass());
    WhynotProofClass.insertWhynotProofToClassP(((WhynotProofClass)(classes.first())), proof);
    return (((WhynotProofClass)(classes.first())));
  }

  public static boolean alternativeBindingsSetP(Stella_Object thing) {
    return ((thing != null) &&
        Stella_Object.isaP(thing, Logic.SGT_LOGIC_ALTERNATIVE_BINDINGS_SET));
  }

  public static void postProcessWhynotProofClasses(List classes) {
    classes.sort(Native.find_java_method("edu.isi.powerloom.logic.WhynotProofClass", "betterWhynotProofClassP", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.WhynotProofClass"), Native.find_java_class("edu.isi.powerloom.logic.WhynotProofClass")}));
    { WhynotProofClass renamed_Class = null;
      Cons iter000 = classes.theConsList;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        renamed_Class = ((WhynotProofClass)(iter000.value));
        if (renamed_Class.length() > 1) {
          { KeyValueMap substitution = renamed_Class.deviatingPattern.substitution;
            PatternVariable variable = renamed_Class.deviatingVariable;

            { AlternativeBindingsSet self000 = AlternativeBindingsSet.newAlternativeBindingsSet();

              self000.theVariable = variable;
              { AlternativeBindingsSet bindings = self000;

                { Stella_Object instance = null;
                  Cons iter001 = renamed_Class.deviatingInstances.theConsList;

                  for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                    instance = iter001.value;
                    bindings.bindings.insert(instance);
                  }
                }
                substitution.insertAt(variable, bindings);
              }
            }
          }
        }
      }
    }
  }

  public static void whynot(Cons args) {
    { String label = null;
      Keyword style = null;
      int maxdepth = Stella.NULL_INTEGER;
      boolean summaryP = false;

      { Object [] caller_MV_returnarray = new Object[3];

        label = Logic.parseWhyArguments(args, caller_MV_returnarray);
        style = ((Keyword)(caller_MV_returnarray[0]));
        maxdepth = ((int)(((IntegerWrapper)(caller_MV_returnarray[1])).wrapperValue));
        summaryP = ((boolean)(((BooleanWrapper)(caller_MV_returnarray[2])).wrapperValue));
      }
      Logic.explainWhynot(label, style, maxdepth, summaryP, Stella.STANDARD_OUTPUT);
    }
  }

  public static void whynotEvaluatorWrapper(Cons arguments) {
    Logic.whynot(arguments);
  }

  /** Programmer's interface to the WHYNOT function.
   * @param label
   * @param style
   * @param maxdepth
   * @param summaryP
   * @param stream
   */
  public static void explainWhynot(String label, Keyword style, int maxdepth, boolean summaryP, OutputStream stream) {
    if (label == null) {
      Native.setSpecial(Logic.$MOST_RECENT_EXPLANATION_MAPPING$, KeyValueList.newKeyValueList());
    }
    try {
      { Cons mappings = Stella.NIL;

        { Justification justification = null;
          Cons iter000 = QueryIterator.getWhynotJustifications(Logic.$MOST_RECENT_QUERY$, label, ((KeyValueList)(Logic.$MOST_RECENT_EXPLANATION_MAPPING$.get()))).theConsList;
          int i = Stella.NULL_INTEGER;
          int iter001 = 1;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
            justification = ((Justification)(iter000.value));
            i = iter001;
            if (label == null) {
              { ExplanationInfo info = Justification.registerJustification(Justification.visibleJustification(justification), ((KeyValueList)(Logic.$MOST_RECENT_EXPLANATION_MAPPING$.get())));

                info.label = Native.integerToString(((long)(i)));
                info.depth = 1;
              }
            }
            {
              stream.nativeStream.println();
              stream.nativeStream.println("Explanation #" + i + " score=" + justification.positiveScore + ":");
              stream.nativeStream.println();
            }
;
            Justification.printWhynotJustification(justification, stream, maxdepth, style, summaryP);
            if (label == null) {
              mappings = Cons.cons(((KeyValueList)(Logic.$MOST_RECENT_EXPLANATION_MAPPING$.get())), mappings);
              Native.setSpecial(Logic.$MOST_RECENT_EXPLANATION_MAPPING$, KeyValueList.newKeyValueList());
            }
          }
        }
        if (!(mappings == Stella.NIL)) {
          Native.setSpecial(Logic.$MOST_RECENT_EXPLANATION_MAPPING$, KeyValueList.newKeyValueList());
          { KeyValueList mapping = null;
            Cons iter002 = mappings;

            for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
              mapping = ((KeyValueList)(iter002.value));
              { Justification k = null;
                ExplanationInfo v = null;
                KvCons iter003 = mapping.theKvList;

                for (;iter003 != null; iter003 = iter003.rest) {
                  k = ((Justification)(iter003.key));
                  v = ((ExplanationInfo)(iter003.value));
                  ((KeyValueList)(Logic.$MOST_RECENT_EXPLANATION_MAPPING$.get())).insertAt(k, v);
                }
              }
            }
          }
        }
      }
    } catch (ExplainException ee) {
      Stella.STANDARD_OUTPUT.nativeStream.print(Stella.exceptionMessage(ee));
    }
  }

  /** Register <code>fn</code> as a logic-object print function for <code>dialect</code>.
   * Each function should have the signature <code>__self_OBJECT___stream_OUTPUT_STREAM__</code>.
   * Any return values will be ignored.
   * @param dialect
   * @param fn
   */
  public static void registerLogicDialectPrintFunction(Keyword dialect, FunctionCodeWrapper fn) {
    Logic.$LOGIC_DIALECT_PRINT_FUNCTIONS$.insertAt(dialect, fn);
  }

  public static void pushQuantifiedObject(Stella_Object renamed_Object) {
    if (((Cons)(Logic.$PRINTQUANTIFIEDOBJECTSSTACK$.get())) != null) {
      Native.setSpecial(Logic.$PRINTQUANTIFIEDOBJECTSSTACK$, Cons.cons(renamed_Object, ((Cons)(Logic.$PRINTQUANTIFIEDOBJECTSSTACK$.get()))));
    }
  }

  public static void popQuantifiedObject() {
    if (((Cons)(Logic.$PRINTQUANTIFIEDOBJECTSSTACK$.get())) != null) {
      Native.setSpecial(Logic.$PRINTQUANTIFIEDOBJECTSSTACK$, ((Cons)(Logic.$PRINTQUANTIFIEDOBJECTSSTACK$.get())).rest);
    }
  }

  public static String maybeDowncase(String string) {
    if (!((Module)(Stella.$MODULE$.get())).caseSensitiveP) {
      if (((Boolean)(Logic.$DOWNCASEOPERATORSp$.get())).booleanValue()) {
        return (Native.stringDowncase(string));
      }
      if (Stella.stringEqlP(string, "FORALL")) {
        return ("forall");
      }
      else if (Stella.stringEqlP(string, "EXISTS")) {
        return ("exists");
      }
      else if (Stella.stringEqlP(string, "THE")) {
        return ("the");
      }
      else if (Stella.stringEqlP(string, "AND")) {
        return ("and");
      }
      else if (Stella.stringEqlP(string, "OR")) {
        return ("or");
      }
      else if (Stella.stringEqlP(string, "NOT")) {
        return ("not");
      }
      else if (Stella.stringEqlP(string, "KAPPA")) {
        return ("kappa");
      }
      else if (Stella.stringEqlP(string, "SUBSET-OF")) {
        return ("subset-of");
      }
      else {
      }
    }
    return (string);
  }

  public static void increaseIndent(int indent) {
    if (indent == Stella.NULL_INTEGER) {
      indent = Logic.$INDENT_QUANTUM$;
    }
    Native.setIntSpecial(Logic.$INDENTCOUNTER$, ((Integer)(Logic.$INDENTCOUNTER$.get())).intValue() + indent);
  }

  public static void decreaseIndent(int indent) {
    if (indent == Stella.NULL_INTEGER) {
      indent = Logic.$INDENT_QUANTUM$;
    }
    Native.setIntSpecial(Logic.$INDENTCOUNTER$, ((Integer)(Logic.$INDENTCOUNTER$.get())).intValue() - indent);
  }

  public static void printIndent(OutputStream stream, int indent) {
    if (indent == Stella.NULL_INTEGER) {
      indent = ((Integer)(Logic.$INDENTCOUNTER$.get())).intValue();
    }
    { int i = Stella.NULL_INTEGER;
      int iter000 = 1;
      int upperBound000 = indent;
      boolean unboundedP000 = upperBound000 == Stella.NULL_INTEGER;

      for (;unboundedP000 ||
                (iter000 <= upperBound000); iter000 = iter000 + 1) {
        i = iter000;
        i = i;
        stream.nativeStream.print(" ");
      }
    }
  }

  /** Produce a stringified version of a logical representation
   * of 'self' and write it to the stream 'stream'.  Use the dialect 'dialect',
   * or use the current dialect if 'dialect' is NULL.
   * @param self
   * @param dialect
   * @param stream
   */
  public static void printLogicalFormInDialect(Stella_Object self, Keyword dialect, OutputStream stream) {
    if (self == null) {
      return;
    }
    if (dialect == null) {
      dialect = ((Keyword)(Logic.$LOGIC_DIALECT$.get()));
    }
    if (dialect == Logic.KWD_KIF) {
      Logic.printAsKif(self, stream);
    }
    else if ((dialect == Logic.KWD_STELLA) ||
        (dialect == Logic.KWD_PREFIX_STELLA)) {
      Logic.printAsKif(self, stream);
    }
    else if (dialect == Logic.KWD_SQL) {
    }
    else {
      { FunctionCodeWrapper fn = ((FunctionCodeWrapper)(Logic.$LOGIC_DIALECT_PRINT_FUNCTIONS$.lookup(dialect)));

        if (fn != null) {
          edu.isi.stella.javalib.Native.funcall(fn.wrapperValue, null, new java.lang.Object [] {self, stream});
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("Unknown dialect for printing logic forms: `" + dialect + "'");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
    }
  }

  /** Print the logical form <code>form</code> to <code>stream</code> according to
   * the current setting of <code>$LOGIC_DIALECT$</code>.  Pretty-printing is controlled
   * by the current setting of <code>$prettyPrintLogicalFormsP$</code>.
   * @param form
   * @param stream
   */
  public static void printLogicalForm(Stella_Object form, OutputStream stream) {
    { Object old$Printquantifiedobjectsstack$000 = Logic.$PRINTQUANTIFIEDOBJECTSSTACK$.get();

      try {
        Native.setSpecial(Logic.$PRINTQUANTIFIEDOBJECTSSTACK$, Stella.NIL);
        Logic.printLogicalFormInDialect(form, ((Keyword)(Logic.$LOGIC_DIALECT$.get())), stream);

      } finally {
        Logic.$PRINTQUANTIFIEDOBJECTSSTACK$.set(old$Printquantifiedobjectsstack$000);
      }
    }
  }

  /** Pretty-print the logical form <code>form</code> to <code>stream</code> according
   * to the current setting of <code>$LOGIC_DIALECT$</code>.
   * @param form
   * @param stream
   */
  public static void prettyPrintLogicalForm(Stella_Object form, OutputStream stream) {
    { Object old$PrettyprintlogicalformsP$000 = Logic.$PRETTYPRINTLOGICALFORMSp$.get();
      Object old$Printquantifiedobjectsstack$000 = Logic.$PRINTQUANTIFIEDOBJECTSSTACK$.get();

      try {
        Native.setBooleanSpecial(Logic.$PRETTYPRINTLOGICALFORMSp$, true);
        Native.setSpecial(Logic.$PRINTQUANTIFIEDOBJECTSSTACK$, Stella.NIL);
        Logic.printLogicalFormInDialect(form, ((Keyword)(Logic.$LOGIC_DIALECT$.get())), stream);

      } finally {
        Logic.$PRINTQUANTIFIEDOBJECTSSTACK$.set(old$Printquantifiedobjectsstack$000);
        Logic.$PRETTYPRINTLOGICALFORMSp$.set(old$PrettyprintlogicalformsP$000);
      }
    }
  }

  /** Print the logical form <code>form</code> to <code>stream</code> according to
   * the current setting of <code>$LOGIC_DIALECT$</code>.  Pretty-printing is explicitly
   * forced to be turned off.
   * @param form
   * @param stream
   */
  public static void printUnformattedLogicalForm(Stella_Object form, OutputStream stream) {
    { Object old$PrettyprintlogicalformsP$000 = Logic.$PRETTYPRINTLOGICALFORMSp$.get();
      Object old$Printquantifiedobjectsstack$000 = Logic.$PRINTQUANTIFIEDOBJECTSSTACK$.get();

      try {
        Native.setBooleanSpecial(Logic.$PRETTYPRINTLOGICALFORMSp$, false);
        Native.setSpecial(Logic.$PRINTQUANTIFIEDOBJECTSSTACK$, Stella.NIL);
        Logic.printLogicalFormInDialect(form, ((Keyword)(Logic.$LOGIC_DIALECT$.get())), stream);

      } finally {
        Logic.$PRINTQUANTIFIEDOBJECTSSTACK$.set(old$Printquantifiedobjectsstack$000);
        Logic.$PRETTYPRINTLOGICALFORMSp$.set(old$PrettyprintlogicalformsP$000);
      }
    }
  }

  public static void printFormula(Stella_Object formula, int indent) {
    { Object old$Indentcounter$000 = Logic.$INDENTCOUNTER$.get();

      try {
        Native.setIntSpecial(Logic.$INDENTCOUNTER$, indent);
        Logic.printUnformattedLogicalForm(formula, Stella.STANDARD_OUTPUT);

      } finally {
        Logic.$INDENTCOUNTER$.set(old$Indentcounter$000);
      }
    }
  }

  public static void printAsKif(Stella_Object self, OutputStream stream) {
    { int currentindentcounter = ((Integer)(Logic.$INDENTCOUNTER$.get())).intValue();

      { Object old$Indentcounter$000 = Logic.$INDENTCOUNTER$.get();
        Object old$Printlogicalformstream$000 = Logic.$PRINTLOGICALFORMSTREAM$.get();
        Object old$PrettyprintkifP$000 = Logic.$PRETTYPRINTKIFp$.get();
        Object old$Printquantifiedobjectsstack$000 = Logic.$PRINTQUANTIFIEDOBJECTSSTACK$.get();

        try {
          Native.setIntSpecial(Logic.$INDENTCOUNTER$, currentindentcounter);
          Native.setSpecial(Logic.$PRINTLOGICALFORMSTREAM$, stream);
          Native.setBooleanSpecial(Logic.$PRETTYPRINTKIFp$, ((Boolean)(Logic.$PRETTYPRINTLOGICALFORMSp$.get())).booleanValue());
          Native.setSpecial(Logic.$PRINTQUANTIFIEDOBJECTSSTACK$, Stella.NIL);
          Logic.printAsKifInternal(self);

        } finally {
          Logic.$PRINTQUANTIFIEDOBJECTSSTACK$.set(old$Printquantifiedobjectsstack$000);
          Logic.$PRETTYPRINTKIFp$.set(old$PrettyprintkifP$000);
          Logic.$PRINTLOGICALFORMSTREAM$.set(old$Printlogicalformstream$000);
          Logic.$INDENTCOUNTER$.set(old$Indentcounter$000);
        }
      }
    }
  }

  public static void printAsKifInternal(Stella_Object self) {
    { OutputStream stream = ((OutputStream)(Logic.$PRINTLOGICALFORMSTREAM$.get()));

      if (self == null) {
        stream.nativeStream.print("NULL");
        return;
      }
      if (self.deletedP()) {
        stream.nativeStream.print("DeLeTeD");
        return;
      }
      { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

        if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
          { Proposition self000 = ((Proposition)(self));

            Proposition.printKifProposition(self000);
          }
        }
        else if (Surrogate.subtypeOfWrapperP(testValue000)) {
          { Wrapper self000 = ((Wrapper)(self));

            Logic.printKifWrapper(((LiteralWrapper)(self000)));
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
          { Description self000 = ((Description)(self));

            Description.printKifDescription(self000);
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
          { PatternVariable self000 = ((PatternVariable)(self));

            PatternVariable.printKifVariable(self000);
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
          { Skolem self000 = ((Skolem)(self));

            Skolem.printKifSkolem(self000, false);
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
          { LogicObject self000 = ((LogicObject)(self));

            LogicObject.printKifLogicObject(self000);
          }
        }
        else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
          { Surrogate self000 = ((Surrogate)(self));

            stream.nativeStream.print(Logic.stringifiedSurrogate(self000));
          }
        }
        else if (Surrogate.subtypeOfKeywordP(testValue000)) {
          { Keyword self000 = ((Keyword)(self));

            stream.nativeStream.print(self000);
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_COLLECTION)) {
          { Collection self000 = ((Collection)(self));

            Logic.printKifStellaCollection(self000);
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_THING)) {
          { LogicThing self000 = ((LogicThing)(self));

            stream.nativeStream.print(Logic.generateTerm(self000));
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
          { Thing self000 = ((Thing)(self));

            stream.nativeStream.print(self000);
          }
        }
        else {
          stream.nativeStream.print("|Illegal Logical Form|: " + self);
        }
      }
    }
  }

  public static boolean visibleArgumentP(Stella_Object self) {
    if (self == null) {
      return (true);
    }
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(self), Logic.SGT_LOGIC_PROPOSITION)) {
      { Proposition self000 = ((Proposition)(self));

        if ((self000.kind == Logic.KWD_ISA) &&
            BooleanWrapper.coerceWrappedBooleanToBoolean(self000.variableTypeP())) {
          if (((Justification)(Logic.$CURRENTJUSTIFICATION$.get())) != null) {
            return (true);
          }
          if ((((Keyword)(Logic.$PRINTMODE$.get())) == Logic.KWD_REALISTIC) ||
              (((Keyword)(Logic.$PRINTMODE$.get())) == Logic.KWD_ORIGINAL)) {
            return (false);
          }
          else {
          }
        }
      }
    }
    else {
    }
    return (true);
  }

  public static int visibleArgumentsCount(Vector arguments) {
    { int count = 0;

      { Stella_Object arg = null;
        Vector vector000 = arguments;
        int index000 = 0;
        int length000 = vector000.length();

        for (;index000 < length000; index000 = index000 + 1) {
          arg = (vector000.theArray)[index000];
          if (Logic.visibleArgumentP(arg)) {
            count = count + 1;
          }
        }
      }
      return (count);
    }
  }

  public static void printKifArguments(Vector arguments, boolean separatelinesP, boolean omitlastargumentP) {
    if (arguments == null) {
      return;
    }
    { OutputStream stream = ((OutputStream)(Logic.$PRINTLOGICALFORMSTREAM$.get()));
      Iterator argumentsiterator = (omitlastargumentP ? arguments.butLast() : ((Iterator)(arguments.allocateIterator())));
      int visibleargcount = Logic.visibleArgumentsCount(arguments);
      int argindex = 0;

      if (omitlastargumentP &&
          Logic.visibleArgumentP(arguments.last())) {
        visibleargcount = visibleargcount - 1;
      }
      { Stella_Object arg = null;
        Iterator iter000 = argumentsiterator;

        while (iter000.nextP()) {
          arg = iter000.value;
          if (Logic.visibleArgumentP(arg) ||
              (visibleargcount == 0)) {
            argindex = argindex + 1;
            if (argindex > 1) {
              if (separatelinesP &&
                  ((Boolean)(Logic.$PRETTYPRINTKIFp$.get())).booleanValue()) {
                stream.nativeStream.println();
                Logic.printIndent(stream, Stella.NULL_INTEGER);
              }
              else {
                stream.nativeStream.print(" ");
              }
            }
            Logic.printAsKifInternal(arg);
          }
        }
      }
    }
  }

  public static void printKifOperatorWithArguments(String operator, Vector arguments, boolean separatelinesP, boolean omitlastargumentP) {
    { OutputStream stream = ((OutputStream)(Logic.$PRINTLOGICALFORMSTREAM$.get()));

      stream.nativeStream.print("(" + operator + (((arguments.length() > 0) ? " " : "")));
      Logic.increaseIndent(operator.length() + 2);
      Logic.printKifArguments(arguments, separatelinesP, omitlastargumentP);
      Logic.decreaseIndent(operator.length() + 2);
      stream.nativeStream.print(")");
    }
  }

  public static String stringifiedSurrogate(Surrogate operator) {
    { NamedDescription description = Logic.getDescription(operator);
      String string = null;
      boolean visibleP = operator == Surrogate.lookupSurrogateInModule(operator.symbolName, ((Module)(Stella.$MODULE$.get())), false);

      if (description != null) {
        string = Logic.internalStellaOperatorToKif(Surrogate.surrogateToSymbol(operator)).symbolName;
      }
      else {
        string = operator.symbolName;
      }
      if ((((Boolean)(Stella.$PRINTREADABLYp$.get())).booleanValue() ||
          (!visibleP)) &&
          ((description == null) ||
           (!(string.charAt(0) == '(')))) {
        { Keyword testValue000 = Stella.computeSymbolEscapeCode(string, ((Module)(Stella.$MODULE$.get())).caseSensitiveP);

          if (testValue000 == Logic.KWD_UNESCAPED) {
            if (visibleP) {
              string = Logic.maybeDowncase(string);
            }
          }
          else if (testValue000 == Logic.KWD_ESCAPED) {
            string = "|" + string + "|";
          }
          else if (testValue000 == Logic.KWD_COMPLEX_ESCAPED) {
            string = Stella.replaceSubstrings(string, "\\\\", "\\");
            string = Stella.replaceSubstrings(string, "\\|", "|");
            string = "|" + string + "|";
          }
          else {
            { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

              stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
              throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
            }
          }
        }
      }
      if (visibleP) {
        return (string);
      }
      else {
        return (Stella.computeFullName(string, ((Module)(operator.homeContext))));
      }
    }
  }

  public static void printKifQuantifiedVariables(Vector variables, boolean includetypesP) {
    if (variables == null) {
      return;
    }
    { OutputStream stream = ((OutputStream)(Logic.$PRINTLOGICALFORMSTREAM$.get()));

      stream.nativeStream.print("(");
      { Skolem vbl = null;
        Vector vector000 = variables;
        int index000 = 0;
        int length000 = vector000.length();
        int i = Stella.NULL_INTEGER;
        int iter000 = 1;

        for (;index000 < length000; index000 = index000 + 1, iter000 = iter000 + 1) {
          vbl = ((Skolem)((vector000.theArray)[index000]));
          i = iter000;
          { boolean printtypeP = includetypesP &&
                (!(Logic.logicalType(vbl) == Logic.SGT_STELLA_THING));

            if (printtypeP) {
              stream.nativeStream.print("(");
            }
            { Surrogate testValue000 = Stella_Object.safePrimaryType(vbl);

              if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
                { PatternVariable vbl000 = ((PatternVariable)(vbl));

                  PatternVariable.printQuantifiedVariable(vbl000, stream);
                }
              }
              else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
                { Skolem vbl000 = ((Skolem)(vbl));

                  Skolem.printValueOfChain(vbl000, stream, vbl000);
                }
              }
              else {
                { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

                  stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
                  throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
                }
              }
            }
            if (printtypeP) {
              stream.nativeStream.print(" " + Logic.logicalType(vbl).symbolName + ")");
            }
            if (i < variables.length()) {
              stream.nativeStream.print(" ");
            }
          }
        }
      }
      stream.nativeStream.print(")");
    }
  }

  public static void printKifWrapper(LiteralWrapper self) {
    { OutputStream stream = ((OutputStream)(Logic.$PRINTLOGICALFORMSTREAM$.get()));

      { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

        if (Surrogate.subtypeOfIntegerP(testValue000)) {
          { IntegerWrapper self000 = ((IntegerWrapper)(self));

            stream.nativeStream.print(self000.wrapperValue);
          }
        }
        else if (Surrogate.subtypeOfLongIntegerP(testValue000)) {
          { LongIntegerWrapper self000 = ((LongIntegerWrapper)(self));

            stream.nativeStream.print(self000.wrapperValue);
          }
        }
        else if (Surrogate.subtypeOfFloatP(testValue000)) {
          { FloatWrapper self000 = ((FloatWrapper)(self));

            stream.nativeStream.print(self000.wrapperValue);
          }
        }
        else if (Surrogate.subtypeOfBooleanP(testValue000)) {
          { BooleanWrapper self000 = ((BooleanWrapper)(self));

            stream.nativeStream.print(self000.wrapperValue);
          }
        }
        else if (Surrogate.subtypeOfStringP(testValue000)) {
          { StringWrapper self000 = ((StringWrapper)(self));

            { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

              try {
                Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                stream.nativeStream.print(self000);

              } finally {
                Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
              }
            }
          }
        }
        else if (Surrogate.subtypeOfCharacterP(testValue000)) {
          { CharacterWrapper self000 = ((CharacterWrapper)(self));

            { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

              try {
                Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                stream.nativeStream.print(self000);

              } finally {
                Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
              }
            }
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
    }
  }

  public static void printKifStellaCollection(Collection self) {
    { OutputStream stream = ((OutputStream)(Logic.$PRINTLOGICALFORMSTREAM$.get()));

      stream.nativeStream.print("(" + ((self.noDuplicatesP() ? Logic.stringifiedSurrogate(Logic.SGT_PL_KERNEL_KB_SETOF) : Logic.stringifiedSurrogate(Logic.SGT_PL_KERNEL_KB_LISTOF))));
      { Stella_Object m = null;
        Iterator iter000 = ((Iterator)(self.allocateIterator()));

        while (iter000.nextP()) {
          m = iter000.value;
          stream.nativeStream.print(" ");
          Logic.printAsKifInternal(m);
        }
      }
      stream.nativeStream.print(")");
    }
  }

  public static KeyValueMap createSkolemMappingTable(Vector oldvars, Vector newvars) {
    { KeyValueMap mapping = null;

      { PatternVariable oldvar = null;
        Vector vector000 = oldvars;
        int index000 = 0;
        int length000 = vector000.length();
        PatternVariable newvar = null;
        Vector vector001 = newvars;
        int index001 = 0;
        int length001 = vector001.length();

        for (;(index000 < length000) &&
                  (index001 < length001); index000 = index000 + 1, index001 = index001 + 1) {
          oldvar = ((PatternVariable)((vector000.theArray)[index000]));
          newvar = ((PatternVariable)((vector001.theArray)[index001]));
          if (!(oldvar.skolemName == newvar.skolemName)) {
            if (mapping == null) {
              mapping = KeyValueMap.newKeyValueMap();
            }
            mapping.insertAt(oldvar, newvar);
          }
        }
      }
      return (mapping);
    }
  }

  public static void excludeOriginatedPropositions() {
    { NamedDescription d = null;
      Iterator iter000 = Logic.allNamedDescriptions(null, false);

      while (iter000.nextP()) {
        d = ((NamedDescription)(iter000.value));
        { Proposition prop = null;
          Cons iter001 = Logic.originatedPropositions(d).theConsList;

          for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
            prop = ((Proposition)(iter001.value));
            ((HashTable)(Logic.$EXCLUDEDPROPOSITIONS$.get())).insertAt(prop, Stella.TRUE_WRAPPER);
          }
        }
      }
    }
    { Proposition p = null;
      Iterator iter002 = Logic.locallyConceivedPropositions(((Module)(Stella.$MODULE$.get()))).allocateIterator();

      while (iter002.nextP()) {
        p = ((Proposition)(iter002.value));
        if (Logic.objectSurrogate(p) != null) {
          { Proposition prop = null;
            Cons iter003 = Logic.originatedPropositions(p).theConsList;

            for (;!(iter003 == Stella.NIL); iter003 = iter003.rest) {
              prop = ((Proposition)(iter003.value));
              ((HashTable)(Logic.$EXCLUDEDPROPOSITIONS$.get())).insertAt(prop, Stella.TRUE_WRAPPER);
            }
          }
        }
      }
    }
  }

  public static boolean hiddenRelationP(Surrogate relationRef) {
    return (Logic.allTrueDependentPropositions(relationRef.surrogateValue, Logic.SGT_PL_KERNEL_KB_HIDDEN_RELATION, false).nextP());
  }

  public static String stellaRelationStringifiedSource(Relation self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfClassP(testValue000)) {
        { Stella_Class self000 = ((Stella_Class)(self));

          return (self000.classStringifiedSource);
        }
      }
      else if (Surrogate.subtypeOfMethodSlotP(testValue000)) {
        { MethodSlot self000 = ((MethodSlot)(self));

          return (self000.methodStringifiedSource);
        }
      }
      else {
        return (null);
      }
    }
  }

  public static void prettyPrintRelationDefinition(Relation self, OutputStream stream) {
    { String definitionstring = Logic.stellaRelationStringifiedSource(self);

      if (definitionstring != null) {
        Logic.prettyPrintRelationDefinitionTree(((Cons)(Stella.readSExpressionFromString(definitionstring))), stream);
      }
    }
  }

  public static void prettyPrintRelationDefinitionTree(Cons tree, OutputStream stream) {
    Logic.helpPrettyPrintRelationDefinitionTree(tree, stream, 0, 2, true);
    stream.nativeStream.println();
  }

  public static void helpPrettyPrintRelationDefinitionTree(Cons tree, OutputStream stream, int startindent, int keyindent, boolean forcefirstkeyonseparatelineP) {
    { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();
      Object old$PrintprettyP$000 = Stella.$PRINTPRETTYp$.get();

      try {
        Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
        Native.setBooleanSpecial(Stella.$PRINTPRETTYp$, true);
        { Stella_Object value000 = null;

          { Stella_Object element = null;
            Cons iter000 = tree;

            loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
              element = iter000.value;
              if (Stella_Object.keywordP(element)) {
                value000 = element;
                break loop000;
              }
            }
          }
          { int nofheaderelements = tree.position(value000, 0);

            { PropertyList self000 = PropertyList.newPropertyList();

              self000.thePlist = Cons.extractOptions(tree, null);
              { PropertyList options = self000;
                int keylength = Stella.NULL_INTEGER;

                if (nofheaderelements == Stella.NULL_INTEGER) {
                  nofheaderelements = tree.length();
                }
                forcefirstkeyonseparatelineP = forcefirstkeyonseparatelineP ||
                    (options.length() > 1);
                stream.nativeStream.print("(");
                { Stella_Object element = null;
                  Cons iter001 = tree;
                  int i = Stella.NULL_INTEGER;
                  int iter002 = 1;
                  int upperBound000 = nofheaderelements;
                  boolean unboundedP000 = upperBound000 == Stella.NULL_INTEGER;

                  for (;(!(iter001 == Stella.NIL)) &&
                            (unboundedP000 ||
                             (iter002 <= upperBound000)); iter001 = iter001.rest, iter002 = iter002 + 1) {
                    element = iter001.value;
                    i = iter002;
                    if (i > 1) {
                      stream.nativeStream.print(" ");
                    }
                    stream.nativeStream.print(element);
                  }
                }
                { Stella_Object key = null;
                  Stella_Object value = null;
                  Cons iter003 = options.thePlist;
                  int i = Stella.NULL_INTEGER;
                  int iter004 = 1;

                  for (;!(iter003 == Stella.NIL); iter003 = iter003.rest.rest, iter004 = iter004 + 1) {
                    key = iter003.value;
                    value = iter003.rest.value;
                    i = iter004;
                    if ((i == 1) &&
                        (!forcefirstkeyonseparatelineP)) {
                      if (nofheaderelements > 0) {
                        stream.nativeStream.print(" ");
                      }
                    }
                    else {
                      stream.nativeStream.println();
                      Logic.printIndent(stream, startindent + keyindent);
                    }
                    if (Surrogate.subtypeOfKeywordP(Stella_Object.safePrimaryType(key))) {
                      { Keyword key000 = ((Keyword)(key));

                        keylength = (key000.symbolName).length() + 1;
                        stream.nativeStream.print(":" + key000.symbolName);
                      }
                    }
                    else {
                      keylength = 4;
                      stream.nativeStream.print(key);
                    }
                    stream.nativeStream.print(" ");
                    if (((key == Logic.KWD_SLOTS) ||
                        ((key == Logic.KWD_PUBLIC_SLOTS) ||
                         ((key == Logic.KWD_METHODS) ||
                          (key == Logic.KWD_PUBLIC_METHODS)))) &&
                        Stella_Object.consP(value)) {
                      stream.nativeStream.print("(");
                      { Stella_Object element = null;
                        Cons iter005 = ((Cons)(value));
                        int i000 = Stella.NULL_INTEGER;
                        int iter006 = 1;

                        for (;!(iter005 == Stella.NIL); iter005 = iter005.rest, iter006 = iter006 + 1) {
                          element = iter005.value;
                          i000 = iter006;
                          if (i000 > 1) {
                            stream.nativeStream.println();
                            Logic.printIndent(stream, keyindent + keylength + 2);
                          }
                          if (Stella_Object.consP(element)) {
                            Logic.helpPrettyPrintRelationDefinitionTree(((Cons)(element)), stream, startindent + keyindent + keylength + 2, keyindent, false);
                          }
                          else {
                            stream.nativeStream.print(value);
                          }
                        }
                      }
                      stream.nativeStream.print(")");
                    }
                    else {
                      stream.nativeStream.print(value);
                    }
                  }
                }
                { Stella_Object element = null;
                  Cons iter007 = tree.nthRest(nofheaderelements);

                  for (;!(iter007 == Stella.NIL); iter007 = iter007.rest) {
                    element = iter007.value;
                    stream.nativeStream.println();
                    Logic.printIndent(stream, keyindent);
                    stream.nativeStream.print(element);
                  }
                }
                stream.nativeStream.print(")");
                options.free();
              }
            }
          }
        }

      } finally {
        Stella.$PRINTPRETTYp$.set(old$PrintprettyP$000);
        Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
      }
    }
  }

  public static void prettyPrintNamedRule(Surrogate rulename, OutputStream stream) {
    { Symbol operator = Logic.SYM_LOGIC_DEFRULE;
      Proposition proposition = ((Proposition)(rulename.surrogateValue));

      { Object old$Printmode$000 = Logic.$PRINTMODE$.get();
        Object old$Printlogicalformstream$000 = Logic.$PRINTLOGICALFORMSTREAM$.get();
        Object old$Indentcounter$000 = Logic.$INDENTCOUNTER$.get();

        try {
          Native.setSpecial(Logic.$PRINTMODE$, Logic.KWD_ORIGINAL);
          Native.setSpecial(Logic.$PRINTLOGICALFORMSTREAM$, stream);
          Native.setIntSpecial(Logic.$INDENTCOUNTER$, 2);
          stream.nativeStream.println("(" + operator + " " + Symbol.internSymbolInModule(rulename.symbolName, ((Module)(rulename.homeContext)), true));
          Logic.printIndent(stream, Stella.NULL_INTEGER);
          Logic.prettyPrintLogicalForm(proposition, stream);
          { Proposition prop = null;
            Cons iter000 = Logic.originatedPropositions(proposition).theConsList;

            loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
              prop = ((Proposition)(iter000.value));
              { Keyword testValue000 = prop.kind;

                if ((testValue000 == Logic.KWD_PREDICATE) ||
                    (testValue000 == Logic.KWD_FUNCTION)) {
                  if ((prop.arguments.length() == 2) &&
                      ((prop.arguments.theArray)[0] == proposition)) {
                    {
                      stream.nativeStream.println();
                      stream.nativeStream.print("  " + prop.operator.keywordify() + " ");
                    }
;
                    Logic.prettyPrintLogicalForm((prop.arguments.theArray)[1], stream);
                    continue loop000;
                  }
                }
                else {
                }
              }
              {
                stream.nativeStream.println();
                stream.nativeStream.print("  :AXIOMS ");
              }
;
              Logic.prettyPrintLogicalForm(prop, stream);
            }
          }
          stream.nativeStream.println(")");

        } finally {
          Logic.$INDENTCOUNTER$.set(old$Indentcounter$000);
          Logic.$PRINTLOGICALFORMSTREAM$.set(old$Printlogicalformstream$000);
          Logic.$PRINTMODE$.set(old$Printmode$000);
        }
      }
    }
  }

  public static void printModuleFileHeader(Module module, OutputStream stream) {
    OutputStream.clOutputFileHeader(stream, null, false);
    if (!(Logic.$BUILT_IN_MODULE_NAMES$.memberP(StringWrapper.wrapString(module.name())))) {
      module.printDefinition(stream);
    }
    stream.nativeStream.println();
    {
      stream.nativeStream.println("(IN-MODULE \"" + module.moduleFullName + "\")");
      stream.nativeStream.println();
      stream.nativeStream.println("(" + Logic.SYM_LOGIC_IN_DIALECT + " " + ((Keyword)(Logic.$LOGIC_DIALECT$.get())) + ")");
      stream.nativeStream.println();
    }
;
  }

  public static void printModuleFileTrailer(Module module, OutputStream stream) {
    {
      module = module;
      stream = stream;
    }
  }

  public static void saveObject(Stella_Object renamed_Object, Stella_Object store) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(renamed_Object);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_RELATION)) {
        { Relation object000 = ((Relation)(renamed_Object));

          { Surrogate testValue001 = Stella_Object.safePrimaryType(store);

            if (Surrogate.subtypeOfP(testValue001, Logic.SGT_STELLA_OUTPUT_STREAM)) {
              { OutputStream store000 = ((OutputStream)(store));

                Logic.prettyPrintRelationDefinition(object000, store000);
              }
            }
            else if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_OBJECT_STORE)) {
              { ObjectStore store000 = ((ObjectStore)(store));

                store000.storeNativeRelation(object000);
              }
            }
            else {
              { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

                stream000.nativeStream.print("`" + testValue001 + "' is not a valid case option");
                throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
              }
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        { NamedDescription object000 = ((NamedDescription)(renamed_Object));

          if (((BooleanWrapper)(KeyValueList.dynamicSlotValue(object000.dynamicSlots, Logic.SYM_LOGIC_UNDECLAREDp, Stella.FALSE_WRAPPER))).wrapperValue) {
            return;
          }
          { Surrogate testValue002 = Stella_Object.safePrimaryType(store);

            if (Surrogate.subtypeOfP(testValue002, Logic.SGT_STELLA_OUTPUT_STREAM)) {
              { OutputStream store000 = ((OutputStream)(store));

                NamedDescription.prettyPrintNamedDescription(object000, store000);
              }
            }
            else if (Surrogate.subtypeOfP(testValue002, Logic.SGT_LOGIC_OBJECT_STORE)) {
              { ObjectStore store000 = ((ObjectStore)(store));

                store000.storeRelation(object000);
              }
            }
            else {
              { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

                stream001.nativeStream.print("`" + testValue002 + "' is not a valid case option");
                throw ((StellaException)(StellaException.newStellaException(stream001.theStringReader()).fillInStackTrace()));
              }
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition object000 = ((Proposition)(renamed_Object));

          { Surrogate testValue003 = Stella_Object.safePrimaryType(store);

            if (Surrogate.subtypeOfP(testValue003, Logic.SGT_STELLA_OUTPUT_STREAM)) {
              { OutputStream store000 = ((OutputStream)(store));

                Proposition.prettyPrintAssertion(object000, store000);
              }
            }
            else if (Surrogate.subtypeOfP(testValue003, Logic.SGT_LOGIC_OBJECT_STORE)) {
              { ObjectStore store000 = ((ObjectStore)(store));

                store000.storeAssertion(object000);
              }
            }
            else {
              { OutputStringStream stream002 = OutputStringStream.newOutputStringStream();

                stream002.nativeStream.print("`" + testValue003 + "' is not a valid case option");
                throw ((StellaException)(StellaException.newStellaException(stream002.theStringReader()).fillInStackTrace()));
              }
            }
          }
        }
      }
      else {
        { OutputStringStream stream003 = OutputStringStream.newOutputStringStream();

          stream003.nativeStream.print("save-object: Don't know how to save `" + renamed_Object + "' to `" + store + "'");
          throw ((StellaException)(StellaException.newStellaException(stream003.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  /** Save <code>module</code> to the persistent store <code>store</code> which can
   * either be an output stream or a persistent OBJECT-STORE.
   * @param module
   * @param store
   */
  public static void doSaveModule(Module module, Stella_Object store) {
    { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

      try {
        Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
        { Object old$Module$000 = Stella.$MODULE$.get();
          Object old$Context$000 = Stella.$CONTEXT$.get();

          try {
            Native.setSpecial(Stella.$MODULE$, module);
            Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
            { Surrogate testValue000 = Stella_Object.safePrimaryType(store);

              if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_OUTPUT_STREAM)) {
                { OutputStream store000 = ((OutputStream)(store));

                  Logic.printModuleFileHeader(module, store000);
                }
              }
              else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_OBJECT_STORE)) {
                { ObjectStore store000 = ((ObjectStore)(store));

                  store000.storeModuleHeader(module);
                }
              }
              else {
                { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

                  stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
                  throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
                }
              }
            }
            { NamedDescription description = null;
              Iterator iter000 = Logic.allNamedDescriptions(module, true);

              while (iter000.nextP()) {
                description = ((NamedDescription)(iter000.value));
                if (NamedDescription.classDescriptionP(description) &&
                    (description.nativeRelation() != null)) {
                  { Stella_Class renamed_Class = ((Stella_Class)(description.nativeRelation()));

                    Logic.saveObject(renamed_Class, store);
                    { Slot slot = null;
                      Cons iter001 = renamed_Class.classLocalSlots.theConsList;

                      for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                        slot = ((Slot)(iter001.value));
                        if (Logic.stellaRelationStringifiedSource(slot) != null) {
                          Logic.saveObject(slot, store);
                        }
                      }
                    }
                  }
                }
                else {
                  Logic.saveObject(description, store);
                }
              }
            }
            { MethodSlot function = null;
              Iterator iter002 = Module.allFunctions(module, true);

              while (iter002.nextP()) {
                function = ((MethodSlot)(iter002.value));
                if (Logic.stellaRelationStringifiedSource(function) != null) {
                  Logic.saveObject(function, store);
                }
              }
            }
            { Object old$Excludedpropositions$000 = Logic.$EXCLUDEDPROPOSITIONS$.get();

              try {
                Native.setSpecial(Logic.$EXCLUDEDPROPOSITIONS$, HashTable.newHashTable());
                Logic.excludeOriginatedPropositions();
                { Cons reversedpropositions = Stella.NIL;

                  { Proposition p = null;
                    Iterator iter003 = Logic.allPropositions(module, false);

                    while (iter003.nextP()) {
                      p = ((Proposition)(iter003.value));
                      if (Proposition.locallyModifiedPropositionP(p, module) &&
                          (!Proposition.excludedPropositionP(p, module))) {
                        reversedpropositions = Cons.cons(p, reversedpropositions);
                      }
                    }
                  }
                  { Stella_Object p = null;
                    Cons iter004 = reversedpropositions;

                    for (;!(iter004 == Stella.NIL); iter004 = iter004.rest) {
                      p = iter004.value;
                      Logic.saveObject(p, store);
                    }
                  }
                }

              } finally {
                Logic.$EXCLUDEDPROPOSITIONS$.set(old$Excludedpropositions$000);
              }
            }
            { Surrogate testValue001 = Stella_Object.safePrimaryType(store);

              if (Surrogate.subtypeOfP(testValue001, Logic.SGT_STELLA_OUTPUT_STREAM)) {
                { OutputStream store000 = ((OutputStream)(store));

                  Logic.printModuleFileTrailer(module, store000);
                }
              }
              else if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_OBJECT_STORE)) {
                { ObjectStore store000 = ((ObjectStore)(store));

                  store000.storeModuleTrailer(module);
                }
              }
              else {
                { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

                  stream001.nativeStream.print("`" + testValue001 + "' is not a valid case option");
                  throw ((StellaException)(StellaException.newStellaException(stream001.theStringReader()).fillInStackTrace()));
                }
              }
            }

          } finally {
            Stella.$CONTEXT$.set(old$Context$000);
            Stella.$MODULE$.set(old$Module$000);
          }
        }

      } finally {
        Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
      }
    }
  }

  /** Save all definitions and assertions of the specified :module (which
   * defaults to the current module) to a file or persistent store.  If :file is specified,
   * the KB is saved to that file.  If no :file is specified but the specified :module is
   * associated with a persistent store, the KB will saved to that store, otherwise, an
   * error will be signalled.  The specifics on how a save operation will proceed for a
   * persistent store depends on the particular type of store (see respective documentation).
   * For backwards compatibility, this command also supports the old &lt;module&gt; &lt;file&gt; arguments
   * specified without keywords.
   * @param options
   */
  public static void saveModule(Cons options) {
    { Cons optionslist = options;
      PropertyList theoptions = Stella_Object.parseOptions((Stella_Object.keywordP(optionslist.value) ? optionslist : Cons.consList(Cons.cons(Logic.KWD_MODULE, Cons.cons(optionslist.value, Cons.cons(Logic.KWD_FILE, Cons.cons(optionslist.rest.value, Stella.NIL)))))), Cons.list$(Cons.cons(Logic.KWD_MODULE, Cons.cons(Logic.SGT_STELLA_MODULE, Cons.cons(Logic.KWD_FILE, Cons.cons(Logic.SGT_STELLA_STRING, Cons.cons(Stella.NIL, Stella.NIL)))))), true, false);
      Module themodule = ((Module)(theoptions.lookupWithDefault(Logic.KWD_MODULE, ((Module)(Stella.$MODULE$.get())))));
      StringWrapper file = ((StringWrapper)(theoptions.lookupWithDefault(Logic.KWD_FILE, null)));

      if ((themodule != null) &&
          (file != null)) {
        Logic.plLog(Logic.KWD_MEDIUM, Cons.cons(StringWrapper.wrapString("Saving module "), Cons.cons(StringWrapper.wrapString(themodule.moduleFullName), Cons.cons(StringWrapper.wrapString(" to "), Cons.cons(file, Cons.cons(StringWrapper.wrapString("..."), Stella.NIL))))));
        { OutputFileStream stream = null;

          try {
            stream = Stella.openOutputFile(file.wrapperValue, Stella.NIL);
            Logic.doSaveModule(themodule, stream);

          } finally {
            if (stream != null) {
              stream.free();
            }
          }
        }
      }
      else if ((themodule != null) &&
          (((ObjectStore)(KeyValueList.dynamicSlotValue(themodule.dynamicSlots, Logic.SYM_LOGIC_OBJECT_STORE, null))) != null)) {
        Logic.plLog(Logic.KWD_MEDIUM, Cons.cons(StringWrapper.wrapString("Saving module "), Cons.cons(StringWrapper.wrapString(themodule.moduleFullName), Cons.cons(StringWrapper.wrapString(" to the associated store..."), Stella.NIL))));
        Logic.doSaveModule(themodule, ((ObjectStore)(KeyValueList.dynamicSlotValue(themodule.dynamicSlots, Logic.SYM_LOGIC_OBJECT_STORE, null))));
      }
      else if (file == null) {
        throw ((StellaException)(StellaException.newStellaException("save-module: no file or persistent store specified to save to").fillInStackTrace()));
      }
    }
  }

  public static void saveModuleEvaluatorWrapper(Cons arguments) {
    Logic.saveModule(arguments);
  }

  public static OutputStream wrapNativeOutputStream(edu.isi.stella.javalib.NativeOutputStream nativestream) {
    if (nativestream == Stella.STANDARD_OUTPUT.nativeStream) {
      return (Stella.STANDARD_OUTPUT);
    }
    else {
      { OutputStream self000 = OutputStream.newOutputStream();

        self000.nativeStream = nativestream;
        { OutputStream value000 = self000;

          return (value000);
        }
      }
    }
  }

  public static void printTopLevelObject(Stella_Object self, edu.isi.stella.javalib.NativeOutputStream nativestream) {
    { OutputStream stream = Logic.wrapNativeOutputStream(nativestream);

      if (self.deletedP()) {
        stream.nativeStream.print("#DELETED#");
      }
      { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

        if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
          { Description self000 = ((Description)(self));

            Description.printDescription(self000, stream, true);
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
          { PatternVariable self000 = ((PatternVariable)(self));

            stream.nativeStream.print("|V|");
            PatternVariable.printVariable(self000, stream);
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
          { Skolem self000 = ((Skolem)(self));

            Skolem.printSkolem(self000, stream, true);
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_TRUTH_VALUE)) {
          { TruthValue self000 = ((TruthValue)(self));

            TruthValue.printTruthValue(self000, stream);
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
          { LogicObject self000 = ((LogicObject)(self));

            LogicObject.printLogicObject(self000, stream, true);
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
          { Proposition self000 = ((Proposition)(self));

            Proposition.printProposition(self000, stream, true);
          }
        }
        else {
          stream.nativeStream.print(self);
        }
      }
    }
  }

  public static void printVariableValue(Stella_Object self, OutputStream stream) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable self000 = ((PatternVariable)(self));

          PatternVariable.printVariableName(self000, stream);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
        { Skolem self000 = ((Skolem)(self));

          Skolem.printSkolemName(self000, stream);
        }
      }
      else {
        Logic.printLogicalForm(self, stream);
      }
    }
  }

  public static Cons generateVariables(Vector vector, boolean typedP) {
    { Cons result = Stella.NIL;

      { Stella_Object v = null;
        Vector vector000 = vector;
        int index000 = 0;
        int length000 = vector000.length();
        Cons collect000 = null;

        for (;index000 < length000; index000 = index000 + 1) {
          v = (vector000.theArray)[index000];
          if (collect000 == null) {
            {
              collect000 = Cons.cons(PatternVariable.generateOneVariable(((PatternVariable)(v)), typedP), Stella.NIL);
              if (result == Stella.NIL) {
                result = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(result, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(PatternVariable.generateOneVariable(((PatternVariable)(v)), typedP), Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      return (result);
    }
  }

  public static Cons generateQuantifiedVariables(Vector vector, boolean typedP) {
    { Cons result = Stella.NIL;

      { Stella_Object v = null;
        Vector vector000 = vector;
        int index000 = 0;
        int length000 = vector000.length();
        Cons collect000 = null;

        for (;index000 < length000; index000 = index000 + 1) {
          v = (vector000.theArray)[index000];
          if (collect000 == null) {
            {
              collect000 = Cons.cons(PatternVariable.generateOneQuantifiedVariable(((PatternVariable)(v)), typedP), Stella.NIL);
              if (result == Stella.NIL) {
                result = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(result, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(PatternVariable.generateOneQuantifiedVariable(((PatternVariable)(v)), typedP), Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      return (result);
    }
  }

  public static Cons generateStellaCollection(Collection self) {
    { Cons collection = Stella.NIL;

      { Stella_Object m = null;
        Iterator iter000 = ((Iterator)(self.allocateIterator()));
        Cons collect000 = null;

        while (iter000.nextP()) {
          m = iter000.value;
          if (collect000 == null) {
            {
              collect000 = Cons.cons(Logic.generateTerm(m), Stella.NIL);
              if (collection == Stella.NIL) {
                collection = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(collection, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(Logic.generateTerm(m), Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      return (Cons.cons((self.noDuplicatesP() ? Logic.SYM_STELLA_SETOF : Logic.SYM_LOGIC_LISTOF), collection.concatenate(Stella.NIL, Stella.NIL)));
    }
  }

  public static Cons generateArguments(Vector arguments) {
    { Cons result = Stella.NIL;

      { Stella_Object arg = null;
        Vector vector000 = arguments;
        int index000 = 0;
        int length000 = vector000.length();
        Cons collect000 = null;

        for (;index000 < length000; index000 = index000 + 1) {
          arg = (vector000.theArray)[index000];
          if (collect000 == null) {
            {
              collect000 = Cons.cons(Logic.generateTerm(arg), Stella.NIL);
              if (result == Stella.NIL) {
                result = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(result, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(Logic.generateTerm(arg), Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      return (result);
    }
  }

  public static Stella_Object generateTerm(Stella_Object self) {
    if (self == null) {
      return (null);
    }
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          return (Proposition.generateProposition(self000));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_LITERAL_WRAPPER)) {
        { LiteralWrapper self000 = ((LiteralWrapper)(self));

          return (self000);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description self000 = ((Description)(self));

          return (Description.generateDescription(self000));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable self000 = ((PatternVariable)(self));

          return (PatternVariable.generateOneVariable(self000, false));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
        { Skolem self000 = ((Skolem)(self));

          return (Skolem.generateSkolem(self000));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          if (self000.surrogateValueInverse != null) {
            return (Symbol.internSymbolInModule(self000.surrogateValueInverse.symbolName, ((Module)(self000.surrogateValueInverse.homeContext)), false));
          }
          else {
            return (Logic.SYM_LOGIC_UNNAMED_OBJECT);
          }
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate self000 = ((Surrogate)(self));

          return (Symbol.internSymbolInModule(self000.symbolName, ((Module)(self000.homeContext)), false));
        }
      }
      else if (Surrogate.subtypeOfKeywordP(testValue000)) {
        { Keyword self000 = ((Keyword)(self));

          return (self000);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_COLLECTION)) {
        { Collection self000 = ((Collection)(self));

          return (Logic.generateStellaCollection(self000));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_THING)) {
        { LogicThing self000 = ((LogicThing)(self));

          return (self000.generateSpecializedTerm());
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing self000 = ((Thing)(self));

          if (self000.surrogateValueInverse != null) {
            return (self000.surrogateValueInverse);
          }
          else {
            throw ((TermGenerationException)(TermGenerationException.newTermGenerationException(self000, "DON'T KNOW HOW TO GENERATE EXPRESSION FOR THE THING: " + Native.stringify(self000)).fillInStackTrace()));
          }
        }
      }
      else {
        {
          Stella.STANDARD_WARNING.nativeStream.println("Warning: Illegal logical form: `" + self + "'");
          Stella.STANDARD_WARNING.nativeStream.println();
        }
;
        return (Logic.SYM_LOGIC_ILLEGAL_TERM);
      }
    }
  }

  /** Return a copy of <code>self</code> where all logic objects are
   * replaced by their <code>generated</code> parse-tree version.  This is useful to
   * convert the result of a retrieval query into a regular parse tree.
   * @param self
   * @return Stella_Object
   */
  public static Stella_Object deobjectifyTree(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (testValue000 == Logic.SGT_STELLA_CONS) {
        { Cons self000 = ((Cons)(self));

          { Cons result = Stella.NIL;

            { Stella_Object elt = null;
              Cons iter000 = self000;
              Cons collect000 = null;

              for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                elt = iter000.value;
                if (collect000 == null) {
                  {
                    collect000 = Cons.cons(Logic.deobjectifyTree(elt), Stella.NIL);
                    if (result == Stella.NIL) {
                      result = collect000;
                    }
                    else {
                      Cons.addConsToEndOfConsList(result, collect000);
                    }
                  }
                }
                else {
                  {
                    collect000.rest = Cons.cons(Logic.deobjectifyTree(elt), Stella.NIL);
                    collect000 = collect000.rest;
                  }
                }
              }
            }
            return (result);
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          return (Logic.generateTerm(self000));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          return (Logic.generateTerm(self000));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_COLLECTION)) {
        { Collection self000 = ((Collection)(self));

          return (Logic.generateTerm(self000));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing self000 = ((Thing)(self));

          return (Logic.generateTerm(self000));
        }
      }
      else {
        return (self);
      }
    }
  }

  /** Helping function for specialists testing the validity of a
   * fully bound inference frame.  Based on the test result <code>successP</code>
   * and <code>reversePolarityP$</code>, set the truth value of <code>frame</code> and return
   * an appropriate keyword.  The keyword will be either <code>CfinalSuccess</code>
   * <code>CterminalFailure</code> if <code>terminalP</code> is true.  Otherwise it will be
   * <code>CfinalSuccess</code> or <code>Cfailure</code>.
   * @param successP
   * @param terminalP
   * @param frame
   * @return Keyword
   */
  public static Keyword selectTestResult(boolean successP, boolean terminalP, ControlFrame frame) {
    if (successP == ((Boolean)(Logic.$REVERSEPOLARITYp$.get())).booleanValue()) {
      ControlFrame.setFrameTruthValue(frame, Logic.FALSE_TRUTH_VALUE);
      if ((((QueryIterator)(Logic.$QUERYITERATOR$.get())) != null) &&
          (((QueryIterator)(Logic.$QUERYITERATOR$.get())).partialMatchStrategy != null)) {
        ((QueryIterator)(Logic.$QUERYITERATOR$.get())).partialMatchStrategy.setBasePartialMatchTruth(frame.proposition, Logic.KWD_FAIL);
      }
      return ((terminalP ? Logic.KWD_TERMINAL_FAILURE : Logic.KWD_FAILURE));
    }
    else {
      ControlFrame.setFrameTruthValue(frame, Logic.TRUE_TRUTH_VALUE);
      if ((((QueryIterator)(Logic.$QUERYITERATOR$.get())) != null) &&
          (((QueryIterator)(Logic.$QUERYITERATOR$.get())).partialMatchStrategy != null)) {
        ((QueryIterator)(Logic.$QUERYITERATOR$.get())).partialMatchStrategy.setBasePartialMatchTruth(frame.proposition, Logic.KWD_TRUE);
      }
      return (Logic.KWD_FINAL_SUCCESS);
    }
  }

  /** Helping function for specialists.   Return the appropriate
   * keyword indicating success or failure of a proof.
   * @param successP
   * @param continuingP
   * @param terminalP
   * @return Keyword
   */
  public static Keyword selectProofResult(boolean successP, boolean continuingP, boolean terminalP) {
    return ((successP ? ((continuingP ? Logic.KWD_CONTINUING_SUCCESS : Logic.KWD_FINAL_SUCCESS)) : ((terminalP ? Logic.KWD_TERMINAL_FAILURE : Logic.KWD_FAILURE))));
  }

  public static boolean nullWrapperP(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing self000 = ((Thing)(self));

          return (self000 == null);
        }
      }
      else if (Surrogate.subtypeOfIntegerP(testValue000)) {
        { IntegerWrapper self000 = ((IntegerWrapper)(self));

          return (Stella_Object.eqlP(self000, Stella.NULL_INTEGER_WRAPPER));
        }
      }
      else if (Surrogate.subtypeOfStringP(testValue000)) {
        { StringWrapper self000 = ((StringWrapper)(self));

          return (Stella_Object.eqlP(self000, Stella.NULL_STRING_WRAPPER));
        }
      }
      else if (Surrogate.subtypeOfFloatP(testValue000)) {
        { FloatWrapper self000 = ((FloatWrapper)(self));

          return (Stella_Object.eqlP(self000, Stella.NULL_FLOAT_WRAPPER));
        }
      }
      else if (Surrogate.subtypeOfCharacterP(testValue000)) {
        { CharacterWrapper self000 = ((CharacterWrapper)(self));

          return (Stella_Object.eqlP(self000, Stella.NULL_CHARACTER_WRAPPER));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_FUNCTION_CODE_WRAPPER)) {
        { FunctionCodeWrapper self000 = ((FunctionCodeWrapper)(self));

          return (Stella_Object.eqlP(self000, Stella.NULL_FUNCTION_CODE_WRAPPER));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_METHOD_CODE_WRAPPER)) {
        { MethodCodeWrapper self000 = ((MethodCodeWrapper)(self));

          return (Stella_Object.eqlP(self000, Stella.NULL_METHOD_CODE_WRAPPER));
        }
      }
      else {
        Stella.STANDARD_OUTPUT.nativeStream.println("Not prepared to handle native slots with type " + self.primaryType());
      }
    }
    return (false);
  }

  public static Surrogate argumentTargetType(List parametertypes, int ninputtypes, int argindex) {
    { StandardObject targettype = ((StandardObject)(parametertypes.nth(Stella.integer_min(argindex, ninputtypes - 1))));

      if (StandardObject.typeSpecToBaseType(targettype) == Logic.SGT_STELLA_CONS) {
        if (Surrogate.subtypeOfParametricTypeSpecifierP(Stella_Object.safePrimaryType(targettype))) {
          { ParametricTypeSpecifier targettype000 = ((ParametricTypeSpecifier)(targettype));

            return (StandardObject.typeSpecToBaseType(((StandardObject)(targettype000.specifierParameterTypes.first()))));
          }
        }
        else {
          return (Logic.SGT_STELLA_OBJECT);
        }
      }
      else {
        return (((Surrogate)(targettype)));
      }
    }
  }

  public static List enumerationsContainingMember(Stella_Object self) {
    { List list = List.newList();

      { Proposition p = null;
        Iterator iter000 = Logic.allTrueDependentPropositions(self, Logic.SGT_PL_KERNEL_KB_COLLECTIONOF, true);

        while (iter000.nextP()) {
          p = ((Proposition)(iter000.value));
          { Stella_Object skolemlist = (p.arguments.theArray)[(p.arguments.length() - 1)];

            if (!Stella_Object.eqlP(self, skolemlist)) {
              list.push(skolemlist);
            }
          }
        }
      }
      return (list);
    }
  }

  public static boolean testDisjointTermsP(Stella_Object term1, Stella_Object term2) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(term1), Logic.SGT_LOGIC_DESCRIPTION)) {
      { Description term1000 = ((Description)(term1));

        if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(term2), Logic.SGT_LOGIC_DESCRIPTION)) {
          { Description term2000 = ((Description)(term2));

            if (Logic.currentInferenceLevel() == Logic.REFUTATION_INFERENCE) {
              return (Description.expensiveDisjointTermsP(term1000, term2000));
            }
            else {
              return (Description.disjointTermsP(term1000, term2000));
            }
          }
        }
        else {
          return (false);
        }
      }
    }
    else {
      return (false);
    }
  }

  public static InferenceLevel leveledQueryRelationToInferenceLevel(Surrogate relation) {
    if (relation == Logic.SGT_PL_KERNEL_KB_ASSERTION_QUERY) {
      return (Logic.ASSERTION_INFERENCE);
    }
    else if (relation == Logic.SGT_PL_KERNEL_KB_SHALLOW_QUERY) {
      return (Logic.SHALLOW_INFERENCE);
    }
    else if (relation == Logic.SGT_PL_KERNEL_KB_SUBSUMPTION_QUERY) {
      return (Logic.SUBSUMPTION_INFERENCE);
    }
    else if (relation == Logic.SGT_PL_KERNEL_KB_BACKTRACKING_QUERY) {
      return (Logic.BACKTRACKING_INFERENCE);
    }
    else if (relation == Logic.SGT_PL_KERNEL_KB_NORMAL_QUERY) {
      return (Logic.NORMAL_INFERENCE);
    }
    else if (relation == Logic.SGT_PL_KERNEL_KB_REFUTATION_QUERY) {
      return (Logic.REFUTATION_INFERENCE);
    }
    else {
      return (Logic.getInferenceLevel(((StringWrapper)(Stella.splitString(relation.symbolName, '-').value)).keywordify()));
    }
  }

  public static boolean closedByAssertionP(Stella_Object self) {
    return (Logic.testPropertyP(self, Logic.SGT_PL_KERNEL_KB_CLOSED) &&
        (!((BooleanWrapper)(KeyValueList.dynamicSlotValue(((Context)(Stella.$CONTEXT$.get())).dynamicSlots, Logic.SYM_LOGIC_MONOTONICp, Stella.FALSE_WRAPPER))).wrapperValue));
  }

  public static boolean closedTermP(Stella_Object self) {
    { MemoizationTable memoTable000 = null;
      Cons memoizedEntry000 = null;
      Stella_Object memoizedValue000 = null;

      if (Stella.$MEMOIZATION_ENABLEDp$) {
        memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_CLOSED_TERMp_MEMO_TABLE_000.surrogateValue));
        if (memoTable000 == null) {
          Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_CLOSED_TERMp_MEMO_TABLE_000, "(:MAX-VALUES 500 :TIMESTAMPS (:KB-UPDATE))");
          memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_CLOSED_TERMp_MEMO_TABLE_000.surrogateValue));
        }
        memoizedEntry000 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable000)), self, ((Context)(Stella.$CONTEXT$.get())), Stella.MEMOIZED_NULL_VALUE, null, 2);
        memoizedValue000 = memoizedEntry000.value;
      }
      if (memoizedValue000 != null) {
        if (memoizedValue000 == Stella.MEMOIZED_NULL_VALUE) {
          memoizedValue000 = null;
        }
      }
      else {
        memoizedValue000 = (Logic.helpClosedTermP(self, Stella.NIL) ? Stella.TRUE_WRAPPER : Stella.FALSE_WRAPPER);
        if (Stella.$MEMOIZATION_ENABLEDp$) {
          memoizedEntry000.value = ((memoizedValue000 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue000);
        }
      }
      { BooleanWrapper value000 = ((BooleanWrapper)(memoizedValue000));

        return (BooleanWrapper.coerceWrappedBooleanToBoolean(value000));
      }
    }
  }

  public static boolean helpClosedTermP(Stella_Object self, Cons activeterms) {
    if (self == null) {
      return (false);
    }
    if (activeterms.membP(self)) {
      return (false);
    }
    else {
      activeterms = Cons.cons(self, activeterms);
    }
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        { NamedDescription self000 = ((NamedDescription)(self));

          return ((Logic.testPropertyP(self000, Logic.SGT_PL_KERNEL_KB_CLOSED) &&
              (!((BooleanWrapper)(KeyValueList.dynamicSlotValue(((Context)(Stella.$CONTEXT$.get())).dynamicSlots, Logic.SYM_LOGIC_MONOTONICp, Stella.FALSE_WRAPPER))).wrapperValue)) ||
              ((((Description)(Stella_Object.accessInContext(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_EQUIVALENT_VALUE, null), self000.homeContext, false))) != null) &&
               Logic.helpClosedTermP(((Description)(Stella_Object.accessInContext(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_EQUIVALENT_VALUE, null), self000.homeContext, false))), activeterms)));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description self000 = ((Description)(self));

          return ((Logic.testPropertyP(self000, Logic.SGT_PL_KERNEL_KB_CLOSED) &&
              (!((BooleanWrapper)(KeyValueList.dynamicSlotValue(((Context)(Stella.$CONTEXT$.get())).dynamicSlots, Logic.SYM_LOGIC_MONOTONICp, Stella.FALSE_WRAPPER))).wrapperValue)) ||
              Proposition.helpClosedPropositionP(self000.proposition, activeterms));
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate self000 = ((Surrogate)(self));

          return (Logic.helpClosedTermP(Logic.valueOf(self000), activeterms));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable self000 = ((PatternVariable)(self));

          return (false);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
        { Skolem self000 = ((Skolem)(self));

          { Proposition definingprop = self000.definingProposition;

            return (((definingprop != null) &&
                Proposition.collectionofPropositionP(definingprop)) ||
                (Logic.testPropertyP(self000, Logic.SGT_PL_KERNEL_KB_CLOSED) &&
                 (!((BooleanWrapper)(KeyValueList.dynamicSlotValue(((Context)(Stella.$CONTEXT$.get())).dynamicSlots, Logic.SYM_LOGIC_MONOTONICp, Stella.FALSE_WRAPPER))).wrapperValue)));
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          return (Logic.testPropertyP(self000, Logic.SGT_PL_KERNEL_KB_CLOSED) &&
              (!((BooleanWrapper)(KeyValueList.dynamicSlotValue(((Context)(Stella.$CONTEXT$.get())).dynamicSlots, Logic.SYM_LOGIC_MONOTONICp, Stella.FALSE_WRAPPER))).wrapperValue));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing self000 = ((Thing)(self));

          return (Logic.testPropertyP(self000, Logic.SGT_PL_KERNEL_KB_CLOSED) &&
              (!((BooleanWrapper)(KeyValueList.dynamicSlotValue(((Context)(Stella.$CONTEXT$.get())).dynamicSlots, Logic.SYM_LOGIC_MONOTONICp, Stella.FALSE_WRAPPER))).wrapperValue));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_COLLECTION)) {
        { Collection self000 = ((Collection)(self));

          return (true);
        }
      }
      else {
        return (false);
      }
    }
  }

  public static boolean singleValuedTermP(Stella_Object self) {
    { Object old$ReversepolarityP$000 = Logic.$REVERSEPOLARITYp$.get();

      try {
        Native.setBooleanSpecial(Logic.$REVERSEPOLARITYp$, false);
        if (Logic.$CYC_KLUDGES_ENABLEDp$) {
          return (Logic.functionP(self) ||
              Logic.testPropertyP(self, Logic.SGT_PL_KERNEL_KB_SINGLE_VALUED));
        }
        { MemoizationTable memoTable000 = null;
          Cons memoizedEntry000 = null;
          Stella_Object memoizedValue000 = null;

          if (Stella.$MEMOIZATION_ENABLEDp$) {
            memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_SINGLE_VALUED_TERMp_MEMO_TABLE_000.surrogateValue));
            if (memoTable000 == null) {
              Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_SINGLE_VALUED_TERMp_MEMO_TABLE_000, "(:MAX-VALUES 500 :TIMESTAMPS (:META-KB-UPDATE))");
              memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_SINGLE_VALUED_TERMp_MEMO_TABLE_000.surrogateValue));
            }
            memoizedEntry000 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable000)), self, ((Context)(Stella.$CONTEXT$.get())), Stella.MEMOIZED_NULL_VALUE, null, 2);
            memoizedValue000 = memoizedEntry000.value;
          }
          if (memoizedValue000 != null) {
            if (memoizedValue000 == Stella.MEMOIZED_NULL_VALUE) {
              memoizedValue000 = null;
            }
          }
          else {
            { boolean testValue001 = false;

              if (Logic.nonRecursiveSingleValuedTermP(self)) {
                testValue001 = true;
              }
              else {
                {
                  testValue001 = !Logic.classP(self);
                  if (testValue001) {
                    { boolean foundP001 = false;

                      { LogicObject d = null;
                        Iterator iter001 = LogicObject.allSupercollections(((LogicObject)(self)));

                        loop000 : while (iter001.nextP()) {
                          d = ((LogicObject)(iter001.value));
                          if (Logic.nonRecursiveSingleValuedTermP(d)) {
                            foundP001 = true;
                            break loop000;
                          }
                        }
                      }
                      testValue001 = foundP001;
                    }
                  }
                }
              }
              memoizedValue000 = (testValue001 ? Stella.TRUE_WRAPPER : Stella.FALSE_WRAPPER);
            }
            if (Stella.$MEMOIZATION_ENABLEDp$) {
              memoizedEntry000.value = ((memoizedValue000 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue000);
            }
          }
          { BooleanWrapper value000 = ((BooleanWrapper)(memoizedValue000));

            return (BooleanWrapper.coerceWrappedBooleanToBoolean(value000));
          }
        }

      } finally {
        Logic.$REVERSEPOLARITYp$.set(old$ReversepolarityP$000);
      }
    }
  }

  public static boolean nonRecursiveSingleValuedTermP(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        { NamedDescription self000 = ((NamedDescription)(self));

          return (NamedDescription.functionDescriptionP(self000) ||
              Logic.testPropertyP(self000, Logic.SGT_PL_KERNEL_KB_SINGLE_VALUED));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description self000 = ((Description)(self));

          { Proposition proposition = self000.proposition;
            Cons iovariables = Stella.NIL;

            { PatternVariable arg = null;
              Vector vector000 = self000.ioVariables;
              int index000 = 0;
              int length000 = vector000.length();

              for (;index000 < length000; index000 = index000 + 1) {
                arg = ((PatternVariable)((vector000.theArray)[index000]));
                iovariables = Cons.cons(arg, iovariables);
              }
            }
            return (Proposition.helpSingleValuedGoalP(proposition, iovariables, Cons.copyConsList(iovariables.rest), false));
          }
        }
      }
      else {
        return (false);
      }
    }
  }

  public static boolean emptyTermP(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          return (LogicObject.cheapEmptyTermP(self000) ||
              LogicObject.expensiveEmptyTermP(self000));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_COLLECTION)) {
        { Collection self000 = ((Collection)(self));

          return (self000.length() == 0);
        }
      }
      else {
        return (false);
      }
    }
  }

  public static List helpProjectNthColumn(int n, List tuplelist) {
    if (tuplelist == null) {
      return (null);
    }
    { List projectedlist = List.newList();
      Stella_Object item = null;

      { Stella_Object tuple = null;
        Cons iter000 = tuplelist.theConsList;
        Cons collect000 = null;

        loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          tuple = iter000.value;
          { Surrogate testValue000 = Stella_Object.safePrimaryType(tuple);

            if (testValue000 == Logic.SGT_STELLA_CONS) {
              { Cons tuple000 = ((Cons)(tuple));

                item = tuple000.nth(n);
              }
            }
            else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_LIST)) {
              { List tuple000 = ((List)(tuple));

                item = tuple000.nth(n);
              }
            }
            else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_COLLECTION)) {
              { Collection tuple000 = ((Collection)(tuple));

                { List members = Logic.assertedCollectionMembers(tuple000, false);

                  if (members != null) {
                    item = members.nth(n);
                  }
                  else {
                    continue loop000;
                  }
                }
              }
            }
            else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
              { Skolem tuple000 = ((Skolem)(tuple));

                { List members = Logic.assertedCollectionMembers(tuple000, false);

                  if (members != null) {
                    item = members.nth(n);
                  }
                  else {
                    continue loop000;
                  }
                }
              }
            }
            else {
              {
                Stella.STANDARD_OUTPUT.nativeStream.println("Can't handle tuple object `" + tuple + "'");
                Stella.STANDARD_OUTPUT.nativeStream.println();
              }
;
              continue loop000;
            }
          }
          if (collect000 == null) {
            {
              collect000 = Cons.cons(item, Stella.NIL);
              if (projectedlist.theConsList == Stella.NIL) {
                projectedlist.theConsList = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(projectedlist.theConsList, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(item, Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      if (projectedlist.emptyP()) {
        return (null);
      }
      else {
        return (projectedlist);
      }
    }
  }

  public static Cons getSynonyms(Stella_Object term) {
    { Stella_Object termvalue = Logic.valueOf(term);
      Stella_Object firstarg = null;
      Stella_Object secondarg = null;
      Cons synonyms = Stella.NIL;

      { Proposition prop = null;
        Iterator iter000 = Logic.allTrueDependentPropositions(term, Logic.SGT_PL_KERNEL_KB_SYNONYM, false);

        while (iter000.nextP()) {
          prop = ((Proposition)(iter000.value));
          firstarg = Logic.valueOf((prop.arguments.theArray)[0]);
          secondarg = Logic.valueOf((prop.arguments.theArray)[1]);
          if (Stella_Object.eqlP(firstarg, termvalue) &&
              ((!Stella_Object.eqlP(firstarg, secondarg)) &&
               (!synonyms.membP(secondarg)))) {
            synonyms = Cons.cons(secondarg, synonyms);
          }
        }
      }
      return (synonyms);
    }
  }

  public static boolean synonymSurrogateP(Surrogate name) {
    { Object old$Module$000 = Stella.$MODULE$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setSpecial(Stella.$MODULE$, name.homeModule());
        Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
        { Stella_Object value = name.surrogateValue;
          Surrogate valuename = Logic.objectSurrogate(value);

          { boolean testValue000 = false;

            testValue000 = valuename != null;
            if (testValue000) {
              testValue000 = !(name == valuename);
              if (testValue000) {
                { boolean foundP000 = false;

                  { LogicObject synonym = null;
                    Cons iter000 = Logic.getSynonyms(value);

                    loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                      synonym = ((LogicObject)(iter000.value));
                      if (synonym.surrogateValueInverse == name) {
                        foundP000 = true;
                        break loop000;
                      }
                    }
                  }
                  testValue000 = foundP000;
                }
              }
            }
            { boolean value000 = testValue000;

              return (value000);
            }
          }
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Stella.$MODULE$.set(old$Module$000);
      }
    }
  }

  public static void transferSynonyms(Stella_Object oldobject, Stella_Object newobject) {
    { List originatedprops = Logic.originatedPropositions(oldobject);

      { LogicObject synonym = null;
        Cons iter000 = Logic.getSynonyms(oldobject);

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          synonym = ((LogicObject)(iter000.value));
          { boolean foundP000 = false;

            { Proposition prop = null;
              Iterator iter001 = Logic.allTrueDependentPropositions(synonym, Logic.SGT_PL_KERNEL_KB_SYNONYM, false);

              loop001 : while (iter001.nextP()) {
                prop = ((Proposition)(iter001.value));
                if (Stella_Object.eqlP((prop.arguments.theArray)[0], oldobject) &&
                    (((prop.arguments.theArray)[1] == synonym) &&
                     (!originatedprops.membP(prop)))) {
                  foundP000 = true;
                  break loop001;
                }
              }
            }
            if (foundP000) {
              Logic.objectSurrogate(synonym).surrogateValue = newobject;
            }
            else {
              Logic.objectSurrogate(synonym).surrogateValue = null;
            }
          }
        }
      }
    }
  }

  /** Returns the native funtion code for <code>nativeName</code> if it exists
   * and the underlying programming languages supports such lookups.  Uses the signature
   * of a specialist function.
   * @param nativeName
   * @return java.lang.reflect.Method
   */
  public static java.lang.reflect.Method lookupNativeSpecialist(String nativeName) {
    { java.lang.reflect.Method code = null;

      int lastPeriod = nativeName.lastIndexOf('.');
    code = Native.find_java_method(nativeName.substring(0,lastPeriod),
                                   nativeName.substring(lastPeriod+1),
                                   new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.ControlFrame"), 
                                                           Native.find_java_class("edu.isi.stella.Keyword")})
;
      if (code == null) {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("Couldn't locate native function for `" + nativeName + "'");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      return (code);
    }
  }

  /** Creates a registration entry for <code>name</code> as a specialist which
   * executes <code>code</code>.  Essentially just builds the Stella meta-information
   * tructure needed to funcall <code>name</code> as a specialist.  The function definition
   * in <code>code</code> needs to accept a CONTROL-FRAME and KEYWORD as arguments and
   * return a KEYWORD.  Side effects on elements of the proposition in the
   * control frame can be used to bind and thus return values.
   * @param name
   * @param code
   */
  public static void registerSpecialistFunction(String name, java.lang.reflect.Method code) {
    Stella.defineFunctionObject(" " + name, "(DEFUN (" + name + " KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))", code, null);
  }

  /** registers a specialist function <code>stellaName</code> based on the <code>nativeName</code>
   * for the particular programming language in question.  Use of this command makes
   * the resulting code or knowledge bases non-portable to other target languages.
   * @param stellaName
   * @param nativeName
   */
  public static void registerSpecialistFunctionName(String stellaName, String nativeName) {
    Logic.registerSpecialistFunction(stellaName, Logic.lookupNativeSpecialist(nativeName));
  }

  public static void registerSpecialistFunctionNameEvaluatorWrapper(Cons arguments) {
    Logic.registerSpecialistFunctionName(((StringWrapper)(arguments.value)).wrapperValue, ((StringWrapper)(arguments.rest.value)).wrapperValue);
  }

  /** Returns the native funtion code for <code>nativeName</code> if it exists
   * and the underlying programming languages supports such lookups.  It is looked up
   * using the signature of a computation function supported by the computation specialist.
   * @param nativeName
   * @param arity
   * @return java.lang.reflect.Method
   */
  public static java.lang.reflect.Method lookupNativeComputation(String nativeName, int arity) {
    { java.lang.reflect.Method code = null;

      int lastPeriod = nativeName.lastIndexOf('.');
    java.lang.Class [] classes = new java.lang.Class[arity];
    java.lang.Class sclass = Native.find_java_class("edu.isi.stella.Stella_Object");
    for (int i = 0; i < arity; i++) {
      classes[i] = sclass;
    }
    code = Native.find_java_method(nativeName.substring(0,lastPeriod),
                                   nativeName.substring(lastPeriod+1),
                                   classes)
;
      if (code == null) {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("Couldn't locate native function for `" + nativeName + "'");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      return (code);
    }
  }

  /** Creates a registration entry for <code>name</code> as a computation which
   * executes <code>code</code>.  Essentially just builds the Stella meta-information
   * tructure needed to funcall <code>name</code> as a computation function by the
   * computation specialist.  The function definition in <code>code</code> needs to
   * accept ARITY Stella OBJECTs as arguments and return a Stella OBJECT 
   * suitable for PowerLoom use.  (These are generally LOGIC-OBJECTs and the
   * literal wrappers FLOAT-WRAPPER, INTEGER-WRAPPER and STRING-WRAPPER.)
   * @param name
   * @param code
   * @param arity
   */
  public static void registerComputationFunction(String name, java.lang.reflect.Method code, int arity) {
    { String definitionString = "(DEFUN (";

      definitionString = definitionString + name + " OBJECT) (";
      { int i = Stella.NULL_INTEGER;
        int iter000 = 1;
        int upperBound000 = arity;
        boolean unboundedP000 = upperBound000 == Stella.NULL_INTEGER;

        for (;unboundedP000 ||
                  (iter000 <= upperBound000); iter000 = iter000 + 1) {
          i = iter000;
          definitionString = definitionString + "(X" + Native.integerToString(((long)(i))) + " OBJECT) ";
        }
      }
      definitionString = definitionString + "))";
      Stella.defineFunctionObject(" " + name, definitionString, code, null);
    }
  }

  /** registers a computation function <code>stellaName</code> based on the <code>nativeName</code>
   * for the particular programming language in question.  Use of this command makes
   * the resulting code or knowledge bases non-portable to other target languages.
   * @param stellaName
   * @param nativeName
   * @param arity
   */
  public static void registerComputationFunctionName(String stellaName, String nativeName, int arity) {
    Logic.registerComputationFunction(stellaName, Logic.lookupNativeComputation(nativeName, arity), arity);
  }

  public static void registerComputationFunctionNameEvaluatorWrapper(Cons arguments) {
    Logic.registerComputationFunctionName(((StringWrapper)(arguments.value)).wrapperValue, ((StringWrapper)(arguments.rest.value)).wrapperValue, ((IntegerWrapper)(arguments.rest.rest.value)).wrapperValue);
  }

  public static TruthValue propositionsIteratorTruthValue(Iterator self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_TRUE_PROPOSITIONS_ITERATOR)) {
        { TruePropositionsIterator self000 = ((TruePropositionsIterator)(self));

          return (self000.truthValue);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION_EXTENSION_ITERATOR)) {
        { DescriptionExtensionIterator self000 = ((DescriptionExtensionIterator)(self));

          return (self000.truthValue);
        }
      }
      else {
        return (null);
      }
    }
  }

  public static Iterator allTrueDependentPropositions(Stella_Object self, Surrogate relation, boolean specializeP) {
    if (!((relation != null) ||
        (!specializeP))) {
      System.err.print("Safety violation: INTERNAL-ERROR: Expected defined relation argument");
    }
    { Cons pattern = ((relation != null) ? Cons.cons(Logic.KWD_RELATION, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(relation, Cons.cons(Logic.valueOf(self), Stella.NIL)))) : Cons.cons(Logic.KWD_DEPENDENTS, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(Logic.valueOf(self), Stella.NIL))));
      SequenceIndex index = Logic.selectPropositions(pattern);
      TruePropositionsIterator iterator = null;

      if (SequenceIndex.emptyPropositionsIndexP(index, self, specializeP)) {
        return (Logic.EMPTY_PROPOSITIONS_ITERATOR);
      }
      iterator = (specializeP ? SpecializingPropositionsIterator.newSpecializingPropositionsIterator() : TruePropositionsIterator.newTruePropositionsIterator());
      iterator.selectionPattern = pattern;
      iterator.propositionCursor = index.allocateIterator();
      return (iterator);
    }
  }

  public static Iterator allTrueDependentIsaPropositions(Stella_Object self) {
    { Cons pattern = Cons.cons(Logic.KWD_ISA, Cons.cons(((Stella.NIL == null) ? Stella.NIL : Stella.NIL), Cons.cons(Logic.valueOf(self), Stella.NIL)));
      SequenceIndex index = Logic.selectPropositions(pattern);

      if (SequenceIndex.emptyPropositionsIndexP(index, self, false)) {
        return (Logic.EMPTY_PROPOSITIONS_ITERATOR);
      }
      else {
        { TruePropositionsIterator self000 = TruePropositionsIterator.newTruePropositionsIterator();

          self000.selectionPattern = pattern;
          self000.propositionCursor = index.allocateIterator();
          { TruePropositionsIterator value000 = self000;

            return (value000);
          }
        }
      }
    }
  }

  public static Cons allPropositionsMatchingArguments(Cons arguments, Surrogate relation, boolean specializeP) {
    { Stella_Object backlinkedinstance = Logic.selectInstanceWithBacklinks(arguments, relation);

      if (backlinkedinstance == null) {
        return (Stella.NIL);
      }
      { Cons value000 = Stella.NIL;

        { Proposition prop = null;
          Iterator iter000 = Logic.allTrueDependentPropositions(backlinkedinstance, relation, specializeP);
          Cons collect000 = null;

          while (iter000.nextP()) {
            prop = ((Proposition)(iter000.value));
            { boolean alwaysP000 = true;

              { Stella_Object a1 = null;
                Cons iter001 = arguments;
                int i = Stella.NULL_INTEGER;
                int iter002 = 0;

                loop001 : for (;!(iter001 == Stella.NIL); iter001 = iter001.rest, iter002 = iter002 + 1) {
                  a1 = iter001.value;
                  i = iter002;
                  if (!Stella_Object.eqlP(Logic.valueOf(a1), Logic.valueOf((prop.arguments.theArray)[i]))) {
                    alwaysP000 = false;
                    break loop001;
                  }
                }
              }
              if (alwaysP000) {
                if (collect000 == null) {
                  {
                    collect000 = Cons.cons(prop, Stella.NIL);
                    if (value000 == Stella.NIL) {
                      value000 = collect000;
                    }
                    else {
                      Cons.addConsToEndOfConsList(value000, collect000);
                    }
                  }
                }
                else {
                  {
                    collect000.rest = Cons.cons(prop, Stella.NIL);
                    collect000 = collect000.rest;
                  }
                }
              }
            }
          }
        }
        { Cons value001 = value000;

          return (value001);
        }
      }
    }
  }

  public static Cons allDefiningPropositions(Stella_Object outputargument, Surrogate relation, boolean specializeP) {
    { Object old$ReversepolarityP$000 = Logic.$REVERSEPOLARITYp$.get();

      try {
        Native.setBooleanSpecial(Logic.$REVERSEPOLARITYp$, false);
        { Cons result = Stella.NIL;
          Stella_Object outputargumentvalue = Logic.valueOf(outputargument);

          { Proposition prop = null;
            Iterator iter000 = Logic.allTrueDependentPropositions(outputargumentvalue, relation, specializeP);
            Cons collect000 = null;

            while (iter000.nextP()) {
              prop = ((Proposition)(iter000.value));
              if ((prop.kind == Logic.KWD_FUNCTION) &&
                  Stella_Object.eqlP(Logic.valueOf((prop.arguments.theArray)[(prop.arguments.length() - 1)]), outputargumentvalue)) {
                if (collect000 == null) {
                  {
                    collect000 = Cons.cons(prop, Stella.NIL);
                    if (result == Stella.NIL) {
                      result = collect000;
                    }
                    else {
                      Cons.addConsToEndOfConsList(result, collect000);
                    }
                  }
                }
                else {
                  {
                    collect000.rest = Cons.cons(prop, Stella.NIL);
                    collect000 = collect000.rest;
                  }
                }
              }
            }
          }
          return (result);
        }

      } finally {
        Logic.$REVERSEPOLARITYp$.set(old$ReversepolarityP$000);
      }
    }
  }

  public static boolean helpMemoizeTestPropertyP(Stella_Object self, Surrogate relation) {
    { Object old$ReversepolarityP$000 = Logic.$REVERSEPOLARITYp$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setBooleanSpecial(Logic.$REVERSEPOLARITYp$, false);
        Native.setSpecial(Stella.$CONTEXT$, Logic.getPropertyTestContext());
        if (Stella_Object.isaP(self, Logic.SGT_LOGIC_LOGIC_OBJECT) &&
            (((LogicObject)(self)).variableValueInverse() == Stella.NIL)) {
          { boolean foundP000 = false;

            { Proposition p = null;
              Iterator iter000 = Logic.unfilteredDependentPropositions(self, relation).allocateIterator();

              loop000 : while (iter000.nextP()) {
                p = ((Proposition)(iter000.value));
                if ((((Surrogate)(p.operator)) == relation) &&
                    ((!p.deletedP()) &&
                     ((((Boolean)(Logic.$REVERSEPOLARITYp$.get())).booleanValue() ? Proposition.falseP(p) : (Proposition.trueP(p) ||
                    Proposition.functionWithDefinedValueP(p)))))) {
                  foundP000 = true;
                  break loop000;
                }
              }
            }
            { boolean value000 = foundP000;

              return (value000);
            }
          }
        }
        else {
          return (Logic.allTrueDependentPropositions(self, relation, false).nextP());
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Logic.$REVERSEPOLARITYp$.set(old$ReversepolarityP$000);
      }
    }
  }

  public static boolean testPropertyP(Stella_Object self, Surrogate relation) {
    { MemoizationTable memoTable000 = null;
      Cons memoizedEntry000 = null;
      Stella_Object memoizedValue000 = null;

      if (Stella.$MEMOIZATION_ENABLEDp$) {
        memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_TEST_PROPERTYp_MEMO_TABLE_000.surrogateValue));
        if (memoTable000 == null) {
          Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_TEST_PROPERTYp_MEMO_TABLE_000, "(:MAX-VALUES 500 :TIMESTAMPS (:KB-UPDATE))");
          memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_TEST_PROPERTYp_MEMO_TABLE_000.surrogateValue));
        }
        memoizedEntry000 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable000)), self, relation, ((Context)(Stella.$CONTEXT$.get())), Stella.MEMOIZED_NULL_VALUE, 6);
        memoizedValue000 = memoizedEntry000.value;
      }
      if (memoizedValue000 != null) {
        if (memoizedValue000 == Stella.MEMOIZED_NULL_VALUE) {
          memoizedValue000 = null;
        }
      }
      else {
        memoizedValue000 = (Logic.helpMemoizeTestPropertyP(self, relation) ? Stella.TRUE_WRAPPER : Stella.FALSE_WRAPPER);
        if (Stella.$MEMOIZATION_ENABLEDp$) {
          memoizedEntry000.value = ((memoizedValue000 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue000);
        }
      }
      { BooleanWrapper value000 = ((BooleanWrapper)(memoizedValue000));

        return (BooleanWrapper.coerceWrappedBooleanToBoolean(value000));
      }
    }
  }

  public static boolean helpMemoizeTestIsaP(Stella_Object member, Surrogate type) {
    { Object old$ReversepolarityP$000 = Logic.$REVERSEPOLARITYp$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setBooleanSpecial(Logic.$REVERSEPOLARITYp$, false);
        Native.setSpecial(Stella.$CONTEXT$, Logic.getPropertyTestContext());
        { boolean foundP000 = false;

          { Proposition prop = null;
            Iterator iter000 = Logic.allTrueDependentIsaPropositions(member);

            loop000 : while (iter000.nextP()) {
              prop = ((Proposition)(iter000.value));
              if (Logic.relationrefSpecializesRelationrefP(((Surrogate)(prop.operator)), type)) {
                foundP000 = true;
                break loop000;
              }
            }
          }
          { boolean value000 = foundP000;

            return (value000);
          }
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Logic.$REVERSEPOLARITYp$.set(old$ReversepolarityP$000);
      }
    }
  }

  public static boolean testIsaP(Stella_Object member, Surrogate type) {
    if (type == Logic.SGT_STELLA_THING) {
      return (true);
    }
    else if ((type == Logic.SGT_PL_KERNEL_KB_CLASS) ||
        ((type == Logic.SGT_PL_KERNEL_KB_RELATION) ||
         ((type == Logic.SGT_PL_KERNEL_KB_FUNCTION) ||
          ((type == Logic.SGT_PL_KERNEL_KB_COLLECTION) ||
           (type == Logic.SGT_PL_KERNEL_KB_SET))))) {
      { MemoizationTable memoTable000 = null;
        Cons memoizedEntry000 = null;
        Stella_Object memoizedValue000 = null;

        if (Stella.$MEMOIZATION_ENABLEDp$) {
          memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_TEST_ISAp_MEMO_TABLE_000.surrogateValue));
          if (memoTable000 == null) {
            Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_TEST_ISAp_MEMO_TABLE_000, "(:MAX-VALUES 1000 :TIMESTAMPS (:META-KB-UPDATE))");
            memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_TEST_ISAp_MEMO_TABLE_000.surrogateValue));
          }
          memoizedEntry000 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable000)), member, type, ((Context)(Stella.$CONTEXT$.get())), Stella.MEMOIZED_NULL_VALUE, 6);
          memoizedValue000 = memoizedEntry000.value;
        }
        if (memoizedValue000 != null) {
          if (memoizedValue000 == Stella.MEMOIZED_NULL_VALUE) {
            memoizedValue000 = null;
          }
        }
        else {
          memoizedValue000 = (Logic.helpMemoizeTestIsaP(member, type) ? Stella.TRUE_WRAPPER : Stella.FALSE_WRAPPER);
          if (Stella.$MEMOIZATION_ENABLEDp$) {
            memoizedEntry000.value = ((memoizedValue000 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue000);
          }
        }
        { BooleanWrapper value000 = ((BooleanWrapper)(memoizedValue000));

          return (BooleanWrapper.coerceWrappedBooleanToBoolean(value000));
        }
      }
    }
    else {
      { MemoizationTable memoTable001 = null;
        Cons memoizedEntry001 = null;
        Stella_Object memoizedValue001 = null;

        if (Stella.$MEMOIZATION_ENABLEDp$) {
          memoTable001 = ((MemoizationTable)(Logic.SGT_LOGIC_F_TEST_ISAp_MEMO_TABLE_001.surrogateValue));
          if (memoTable001 == null) {
            Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_TEST_ISAp_MEMO_TABLE_001, "(:MAX-VALUES 1000 :TIMESTAMPS (:KB-UPDATE))");
            memoTable001 = ((MemoizationTable)(Logic.SGT_LOGIC_F_TEST_ISAp_MEMO_TABLE_001.surrogateValue));
          }
          memoizedEntry001 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable001)), member, type, ((Context)(Stella.$CONTEXT$.get())), Stella.MEMOIZED_NULL_VALUE, 6);
          memoizedValue001 = memoizedEntry001.value;
        }
        if (memoizedValue001 != null) {
          if (memoizedValue001 == Stella.MEMOIZED_NULL_VALUE) {
            memoizedValue001 = null;
          }
        }
        else {
          memoizedValue001 = (Logic.helpMemoizeTestIsaP(member, type) ? Stella.TRUE_WRAPPER : Stella.FALSE_WRAPPER);
          if (Stella.$MEMOIZATION_ENABLEDp$) {
            memoizedEntry001.value = ((memoizedValue001 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue001);
          }
        }
        { BooleanWrapper value001 = ((BooleanWrapper)(memoizedValue001));

          return (BooleanWrapper.coerceWrappedBooleanToBoolean(value001));
        }
      }
    }
  }

  public static Stella_Object helpMemoizeAccessBinaryValue(Stella_Object self, Surrogate relation) {
    { Object old$ReversepolarityP$000 = Logic.$REVERSEPOLARITYp$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setBooleanSpecial(Logic.$REVERSEPOLARITYp$, false);
        Native.setSpecial(Stella.$CONTEXT$, Logic.getPropertyTestContext());
        { Stella_Object result = null;
          Iterator iterator = Logic.allTrueDependentPropositions(self, relation, false);
          Proposition proposition = null;

          while (iterator.nextP()) {
            proposition = ((Proposition)(iterator.value));
            if (Stella_Object.eqlP((proposition.arguments.theArray)[0], self)) {
              result = Logic.valueOf((proposition.arguments.theArray)[1]);
              return (result);
            }
          }
          return (null);
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Logic.$REVERSEPOLARITYp$.set(old$ReversepolarityP$000);
      }
    }
  }

  public static Stella_Object accessBinaryValue(Stella_Object self, Surrogate relation) {
    { MemoizationTable memoTable000 = null;
      Cons memoizedEntry000 = null;
      Stella_Object memoizedValue000 = null;

      if (Stella.$MEMOIZATION_ENABLEDp$) {
        memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_ACCESS_BINARY_VALUE_MEMO_TABLE_000.surrogateValue));
        if (memoTable000 == null) {
          Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_ACCESS_BINARY_VALUE_MEMO_TABLE_000, "(:MAX-VALUES 1000 :TIMESTAMPS (:KB-UPDATE))");
          memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_ACCESS_BINARY_VALUE_MEMO_TABLE_000.surrogateValue));
        }
        memoizedEntry000 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable000)), self, relation, ((Context)(Stella.$CONTEXT$.get())), Stella.MEMOIZED_NULL_VALUE, 6);
        memoizedValue000 = memoizedEntry000.value;
      }
      if (memoizedValue000 != null) {
        if (memoizedValue000 == Stella.MEMOIZED_NULL_VALUE) {
          memoizedValue000 = null;
        }
      }
      else {
        memoizedValue000 = Logic.helpMemoizeAccessBinaryValue(self, relation);
        if (Stella.$MEMOIZATION_ENABLEDp$) {
          memoizedEntry000.value = ((memoizedValue000 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue000);
        }
      }
      { Stella_Object value000 = ((Stella_Object)(memoizedValue000));

        return (value000);
      }
    }
  }

  public static boolean testCollectionofMemberOfP(Stella_Object member, Surrogate type) {
    { Object old$ReversepolarityP$000 = Logic.$REVERSEPOLARITYp$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setBooleanSpecial(Logic.$REVERSEPOLARITYp$, false);
        Native.setSpecial(Stella.$CONTEXT$, Logic.getPropertyTestContext());
        { Proposition p = null;
          Iterator iter000 = Logic.allTrueDependentPropositions(member, Logic.SGT_PL_KERNEL_KB_COLLECTIONOF, true);

          while (iter000.nextP()) {
            p = ((Proposition)(iter000.value));
            if ((!p.deletedP()) &&
                ((((Boolean)(Logic.$REVERSEPOLARITYp$.get())).booleanValue() ? Proposition.falseP(p) : (Proposition.trueP(p) ||
                Proposition.functionWithDefinedValueP(p))))) {
              { Stella_Object collection = p.arguments.last();

                if ((!Stella_Object.eqlP(member, collection)) &&
                    LogicObject.collectionImpliesCollectionP(((LogicObject)(collection)), Logic.surrogateToDescription(type))) {
                  return (true);
                }
              }
            }
          }
        }
        return (false);

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Logic.$REVERSEPOLARITYp$.set(old$ReversepolarityP$000);
      }
    }
  }

  /** Return an iterator that generates the transitive
   * closure of applying iterators generated by 'allocateAdjacencyIterator'
   * to 'startNode'.  If 'filterFunction' is non-null, that function is applied
   * as a filter to each node generated (nodes filtered out still generate
   * descendants, but they don't get returned).
   * @param startnode
   * @param allocateadjacencyiterator
   * @param filterfunction
   * @return Iterator
   */
  public static Iterator allocateTransitiveClosureIterator(Stella_Object startnode, java.lang.reflect.Method allocateadjacencyiterator, java.lang.reflect.Method filterfunction) {
    { TransitiveClosureIterator iterator = TransitiveClosureIterator.newTransitiveClosureIterator();

      iterator.value = startnode;
      iterator.beenThereList = Stella.NIL;
      iterator.allocateAdjacencyIteratorFunction = allocateadjacencyiterator;
      iterator.filterP = filterfunction;
      return (iterator);
    }
  }

  /** Similar to <code>allocateTransitiveClosureIterator</code> (which see),
   * but return a SUPPORTED-CLOSURE-ITERATOR instead.
   * @param startnode
   * @param allocateadjacencyiterator
   * @param filterfunction
   * @return SupportedClosureIterator
   */
  public static SupportedClosureIterator allocateSupportedClosureIterator(Cons startnode, java.lang.reflect.Method allocateadjacencyiterator, java.lang.reflect.Method filterfunction) {
    { SupportedClosureIterator iterator = SupportedClosureIterator.newSupportedClosureIterator();

      iterator.value = startnode;
      iterator.beenThereList = Stella.NIL;
      iterator.allocateAdjacencyIteratorFunction = allocateadjacencyiterator;
      iterator.filterP = filterfunction;
      return (iterator);
    }
  }

  public static Iterator allDirectlyLinkedObjects(Stella_Object self, Surrogate relation, boolean inverseP) {
    { Cons pattern = (inverseP ? Logic.makeRelationPattern2(relation, null, Logic.valueOf(self)) : Logic.makeRelationPattern2(relation, Logic.valueOf(self), null));
      SequenceIndex index = Logic.selectPropositions(pattern);

      if (SequenceIndex.emptyPropositionsIndexP(index, self, false)) {
        return (Logic.EMPTY_PROPOSITIONS_ITERATOR);
      }
      { DirectlyLinkedObjectsIterator self000 = DirectlyLinkedObjectsIterator.newDirectlyLinkedObjectsIterator();

        self000.selectionPattern = pattern;
        self000.propositionCursor = index.allocateIterator();
        self000.inverseP = inverseP;
        { DirectlyLinkedObjectsIterator value000 = self000;

          return (value000);
        }
      }
    }
  }

  public static Cons allIsaCollections(Stella_Object self) {
    { Cons collections = Stella.NIL;

      { Proposition p = null;
        Iterator iter000 = Logic.allTrueDependentPropositions(self, null, false);

        while (iter000.nextP()) {
          p = ((Proposition)(iter000.value));
          if (p.kind == Logic.KWD_ISA) {
            collections = Cons.cons(Logic.getDescription(((Surrogate)(p.operator))), collections);
          }
        }
      }
      { Proposition p = null;
        Iterator iter001 = Logic.allTrueDependentPropositions(self, Logic.SGT_PL_KERNEL_KB_MEMBER_OF, false);

        while (iter001.nextP()) {
          p = ((Proposition)(iter001.value));
          collections = Cons.cons((p.arguments.theArray)[1], collections);
        }
      }
      return (collections);
    }
  }

  public static TruePropositionsIterator allDirectlyLinkedSubcollections(Stella_Object self) {
    { LogicObject renamed_Object = null;
      TruthValue truthvalue = null;
      Iterator iterator = null;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

        if (testValue000 == Logic.SGT_STELLA_CONS) {
          { Cons self000 = ((Cons)(self));

            renamed_Object = ((LogicObject)(self000.value));
            truthvalue = ((TruthValue)(self000.rest.value));
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
          { LogicObject self000 = ((LogicObject)(self));

            renamed_Object = self000;
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
      if (Stella_Object.isaP(renamed_Object, Logic.SGT_LOGIC_DESCRIPTION)) {
        Description.deriveDeferredSatelliteRules(((Description)(renamed_Object)));
      }
      iterator = Logic.allDirectlyLinkedObjects(renamed_Object, Logic.SGT_PL_KERNEL_KB_SUBSET_OF, !((Boolean)(Logic.$REVERSEPOLARITYp$.get())).booleanValue());
      if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(iterator), Logic.SGT_LOGIC_DIRECTLY_LINKED_OBJECTS_ITERATOR)) {
        { DirectlyLinkedObjectsIterator iterator000 = ((DirectlyLinkedObjectsIterator)(iterator));

          if (truthvalue != null) {
            iterator000.rootTruthValue = truthvalue;
          }
          return (iterator000);
        }
      }
      else {
        return (null);
      }
    }
  }

  public static List relationsWithDescriptions() {
    { List result = List.newList();

      { Stella_Class renamed_Class = null;
        Iterator iter000 = Module.allClasses(null, false);
        Cons collect000 = null;

        while (iter000.nextP()) {
          renamed_Class = ((Stella_Class)(iter000.value));
          if (((NamedDescription)(KeyValueList.dynamicSlotValue(renamed_Class.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))) != null) {
            if (collect000 == null) {
              {
                collect000 = Cons.cons(renamed_Class, Stella.NIL);
                if (result.theConsList == Stella.NIL) {
                  result.theConsList = collect000;
                }
                else {
                  Cons.addConsToEndOfConsList(result.theConsList, collect000);
                }
              }
            }
            else {
              {
                collect000.rest = Cons.cons(renamed_Class, Stella.NIL);
                collect000 = collect000.rest;
              }
            }
          }
        }
      }
      { Slot slot = null;
        Iterator iter001 = Module.allSlots(null, false);
        Cons collect001 = null;

        while (iter001.nextP()) {
          slot = ((Slot)(iter001.value));
          if (((NamedDescription)(KeyValueList.dynamicSlotValue(slot.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))) != null) {
            if (collect001 == null) {
              {
                collect001 = Cons.cons(slot, Stella.NIL);
                if (result.theConsList == Stella.NIL) {
                  result.theConsList = collect001;
                }
                else {
                  Cons.addConsToEndOfConsList(result.theConsList, collect001);
                }
              }
            }
            else {
              {
                collect001.rest = Cons.cons(slot, Stella.NIL);
                collect001 = collect001.rest;
              }
            }
          }
        }
      }
      return (result);
    }
  }

  public static void buildSubsumptionTaxonomyGraph() {
    { List relationswithdescriptions = Logic.relationsWithDescriptions();

      { Relation r = null;
        Cons iter000 = relationswithdescriptions.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          r = ((Relation)(iter000.value));
          Description.createDescriptionImplicationSubsumptionNode(((NamedDescription)(KeyValueList.dynamicSlotValue(r.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))), null);
        }
      }
      { Relation r = null;
        Cons iter001 = relationswithdescriptions.theConsList;

        for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
          r = ((Relation)(iter001.value));
          { Relation renamed_Super = null;
            Iterator iter002 = Logic.directSuperrelations(r);

            while (iter002.nextP()) {
              renamed_Super = ((Relation)(iter002.value));
              if (relationswithdescriptions.memberP(renamed_Super)) {
                TaxonomyGraph.createTaxonomyLink(Logic.$IMPLICATION_SUBSUMPTION_GRAPH$, Description.findDescriptionImplicationSubsumptionNode(((NamedDescription)(KeyValueList.dynamicSlotValue(renamed_Super.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null)))), Description.findDescriptionImplicationSubsumptionNode(((NamedDescription)(KeyValueList.dynamicSlotValue(r.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null)))));
              }
            }
          }
        }
      }
    }
  }

  public static void clearImplicationSubsumptionGraph() {
    { Relation r = null;
      Cons iter000 = Logic.relationsWithDescriptions().theConsList;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        r = ((Relation)(iter000.value));
        KeyValueList.setDynamicSlotValue(((NamedDescription)(KeyValueList.dynamicSlotValue(r.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null))).dynamicSlots, Logic.SYM_STELLA_TAXONOMY_NODE, null, null);
      }
    }
  }

  public static void initializeImplicationSubsumptionGraph() {
    Logic.clearImplicationSubsumptionGraph();
    Logic.$IMPLICATION_SUBSUMPTION_GRAPH$ = TaxonomyGraph.newTaxonomyGraph();
    TaxonomyGraph.finalizeTaxonomyGraph(Logic.$IMPLICATION_SUBSUMPTION_GRAPH$);
  }

  public static Description createDescriptionForStellaRelationAndAncestors(Relation self) {
    if (self == null) {
      return (null);
    }
    { NamedDescription description = Logic.getDescription(self);
      TaxonomyNode taxonomynode = Description.findOrCreateDescriptionImplicationSubsumptionNode(description);

      { Relation renamed_Super = null;
        Iterator iter000 = Logic.directSuperrelations(self);

        while (iter000.nextP()) {
          renamed_Super = ((Relation)(iter000.value));
          { Description superdescription = Logic.createDescriptionForStellaRelationAndAncestors(renamed_Super);
            TaxonomyNode supertaxonomynode = Description.findDescriptionImplicationSubsumptionNode(superdescription);

            TaxonomyGraph.createTaxonomyLink(Logic.$IMPLICATION_SUBSUMPTION_GRAPH$, supertaxonomynode, taxonomynode);
          }
        }
      }
      return (description);
    }
  }

  public static boolean taxonomyImpliesOrIsSubsumedP(Relation premise, Relation conclusion) {
    { NamedDescription premisedescription = ((NamedDescription)(KeyValueList.dynamicSlotValue(premise.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null)));
      Description conclusiondescription = null;

      if ((premisedescription == null) ||
          (Description.findDescriptionImplicationSubsumptionNode(premisedescription) == null)) {
        premisedescription = ((NamedDescription)(Logic.createDescriptionForStellaRelationAndAncestors(premise)));
      }
      conclusiondescription = ((NamedDescription)(KeyValueList.dynamicSlotValue(conclusion.dynamicSlots, Logic.SYM_LOGIC_DESCRIPTION, null)));
      if (conclusiondescription == null) {
        return (false);
      }
      if (Description.findDescriptionImplicationSubsumptionNode(conclusiondescription) == null) {
        throw ((StellaException)(StellaException.newStellaException("'taxonomy-implies-or-is-subsumed?' conclusionDescription should have taxonomy-node").fillInStackTrace()));
      }
      return (TaxonomyNode.taxonomySubnodeOfP(Description.findDescriptionImplicationSubsumptionNode(premisedescription), Description.findDescriptionImplicationSubsumptionNode(conclusiondescription)));
    }
  }

  public static boolean argumentBoundP(Stella_Object argument) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(argument);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable argument000 = ((PatternVariable)(argument));

          return (PatternVariable.variableBoundP(argument000));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition argument000 = ((Proposition)(argument));

          if (((Vector)(KeyValueList.dynamicSlotValue(argument000.dynamicSlots, Logic.SYM_LOGIC_IO_VARIABLES, null))) != null) {
            return (Logic.quantifiedArgumentBoundP(argument000, null));
          }
          else {
            { boolean alwaysP000 = true;

              { Stella_Object arg = null;
                Vector vector000 = argument000.arguments;
                int index000 = 0;
                int length000 = vector000.length();

                loop000 : for (;index000 < length000; index000 = index000 + 1) {
                  arg = (vector000.theArray)[index000];
                  if (!Logic.argumentBoundP(arg)) {
                    alwaysP000 = false;
                    break loop000;
                  }
                }
              }
              { boolean value000 = alwaysP000;

                return (value000);
              }
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description argument000 = ((Description)(argument));

          { boolean testValue001 = false;

            if (((Vector)(KeyValueList.dynamicSlotValue(argument000.dynamicSlots, Logic.SYM_LOGIC_EXTERNAL_VARIABLES, null))) == null) {
              testValue001 = true;
            }
            else {
              { boolean alwaysP001 = true;

                { PatternVariable v = null;
                  Vector vector001 = ((Vector)(KeyValueList.dynamicSlotValue(argument000.dynamicSlots, Logic.SYM_LOGIC_EXTERNAL_VARIABLES, null)));
                  int index001 = 0;
                  int length001 = vector001.length();

                  loop001 : for (;index001 < length001; index001 = index001 + 1) {
                    v = ((PatternVariable)((vector001.theArray)[index001]));
                    if (!Logic.argumentBoundP(v)) {
                      alwaysP001 = false;
                      break loop001;
                    }
                  }
                }
                testValue001 = alwaysP001;
              }
            }
            { boolean value001 = testValue001;

              return (value001);
            }
          }
        }
      }
      else {
        return (true);
      }
    }
  }

  public static boolean quantifiedArgumentBoundP(Stella_Object argument, List quantifiedvars) {
    if (quantifiedvars == null) {
      quantifiedvars = List.newList();
    }
    { Surrogate testValue000 = Stella_Object.safePrimaryType(argument);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable argument000 = ((PatternVariable)(argument));

          return (PatternVariable.variableBoundP(argument000) ||
              quantifiedvars.membP(argument000));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition argument000 = ((Proposition)(argument));

          { Vector iovars = ((Vector)(KeyValueList.dynamicSlotValue(argument000.dynamicSlots, Logic.SYM_LOGIC_IO_VARIABLES, null)));

            if (iovars != null) {
              { PatternVariable var = null;
                Vector vector000 = iovars;
                int index000 = 0;
                int length000 = vector000.length();

                for (;index000 < length000; index000 = index000 + 1) {
                  var = ((PatternVariable)((vector000.theArray)[index000]));
                  quantifiedvars.insert(var);
                }
              }
            }
            { boolean alwaysP000 = true;

              { Stella_Object arg = null;
                Vector vector001 = argument000.arguments;
                int index001 = 0;
                int length001 = vector001.length();

                loop001 : for (;index001 < length001; index001 = index001 + 1) {
                  arg = (vector001.theArray)[index001];
                  if (!Logic.quantifiedArgumentBoundP(arg, quantifiedvars)) {
                    alwaysP000 = false;
                    break loop001;
                  }
                }
              }
              { boolean value000 = alwaysP000;

                return (value000);
              }
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description argument000 = ((Description)(argument));

          { boolean testValue001 = false;

            if (((Vector)(KeyValueList.dynamicSlotValue(argument000.dynamicSlots, Logic.SYM_LOGIC_EXTERNAL_VARIABLES, null))) == null) {
              testValue001 = true;
            }
            else {
              { boolean alwaysP001 = true;

                { PatternVariable v = null;
                  Vector vector002 = ((Vector)(KeyValueList.dynamicSlotValue(argument000.dynamicSlots, Logic.SYM_LOGIC_EXTERNAL_VARIABLES, null)));
                  int index002 = 0;
                  int length002 = vector002.length();

                  loop002 : for (;index002 < length002; index002 = index002 + 1) {
                    v = ((PatternVariable)((vector002.theArray)[index002]));
                    if (!Logic.quantifiedArgumentBoundP(v, quantifiedvars)) {
                      alwaysP001 = false;
                      break loop002;
                    }
                  }
                }
                testValue001 = alwaysP001;
              }
            }
            { boolean value001 = testValue001;

              return (value001);
            }
          }
        }
      }
      else {
        return (true);
      }
    }
  }

  public static boolean unboundVariableP(Stella_Object argument) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(argument), Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
      { PatternVariable argument000 = ((PatternVariable)(argument));

        return (!PatternVariable.variableBoundP(argument000));
      }
    }
    else {
      return (false);
    }
  }

  public static int simulateCreateChoicePoint() {
    return (((QueryIterator)(Logic.$QUERYITERATOR$.get())).currentPatternRecord.topUnbindingStackOffset + 1);
  }

  public static boolean generatorCollectionP(Stella_Object collection) {
    if (((Boolean)(Logic.$REVERSEPOLARITYp$.get())).booleanValue() &&
        (!Logic.closedTermP(collection))) {
      return (false);
    }
    { Surrogate testValue000 = Stella_Object.safePrimaryType(collection);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description collection000 = ((Description)(collection));

          return ((!Stella_Object.isaP(collection000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) ||
              NamedDescription.relationSupportsExtensionP(((NamedDescription)(collection000))));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable collection000 = ((PatternVariable)(collection));

          { Stella_Object boundtovalue = Logic.argumentBoundTo(collection000);

            if (boundtovalue != null) {
              return (Logic.generatorCollectionP(boundtovalue));
            }
            else if (collection000.definingProposition != null) {
              return (true);
            }
            else {
              return (false);
            }
          }
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate collection000 = ((Surrogate)(collection));

          return (NamedDescription.relationSupportsExtensionP(Logic.getDescription(collection000)));
        }
      }
      else {
        return (true);
      }
    }
  }

  public static void initializeOptimizerGoalRecords(int size) {
    { ExtensibleVector stack = ((ExtensibleVector)(KeyValueList.dynamicSlotValue(((QueryIterator)(Logic.$QUERYITERATOR$.get())).dynamicSlots, Logic.SYM_LOGIC_OPTIMIZER_GOAL_RECORDS, null)));

      if (stack == null) {
        stack = ExtensibleVector.newExtensibleVector(20);
        KeyValueList.setDynamicSlotValue(((QueryIterator)(Logic.$QUERYITERATOR$.get())).dynamicSlots, Logic.SYM_LOGIC_OPTIMIZER_GOAL_RECORDS, stack, null);
      }
      if (size > stack.length()) {
        stack.insertAt(size, null);
      }
      { int i = Stella.NULL_INTEGER;
        int iter000 = 0;
        int upperBound000 = size - 1;

        for (;iter000 <= upperBound000; iter000 = iter000 + 1) {
          i = iter000;
          { GoalRecord goalrecord = ((GoalRecord)((stack.theArray)[i]));

            if (goalrecord == null) {
              goalrecord = GoalRecord.newGoalRecord();
              (stack.theArray)[i] = goalrecord;
            }
            goalrecord.generatorGoals.clear();
            goalrecord.otherGoals.clear();
          }
        }
      }
    }
  }

  public static void helpDistributeGoal(Stella_Object argument, Proposition parentgoal, boolean generatorP) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(argument);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable argument000 = ((PatternVariable)(argument));

          if (PatternVariable.variableBoundP(argument000)) {
            return;
          }
          { GoalRecord goalrecord = PatternVariable.goalRecord(argument000);

            if (goalrecord.generatorGoals.memberP(parentgoal) ||
                goalrecord.otherGoals.memberP(parentgoal)) {
              return;
            }
            if (generatorP) {
              goalrecord.generatorGoals.insert(parentgoal);
            }
            else {
              goalrecord.otherGoals.insert(parentgoal);
            }
            Native.setBooleanSpecial(Logic.$DISTRIBUTEDOPENGOALp$, true);
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition argument000 = ((Proposition)(argument));

          { Stella_Object arg = null;
            Vector vector000 = argument000.arguments;
            int index000 = 0;
            int length000 = vector000.length();

            for (;index000 < length000; index000 = index000 + 1) {
              arg = (vector000.theArray)[index000];
              Logic.helpDistributeGoal(arg, parentgoal, generatorP);
            }
          }
        }
      }
      else {
      }
    }
  }

  public static void collectClosedGoals(List goals, List goalsequence) {
    { Proposition g = null;
      Cons iter000 = goals.theConsList;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        g = ((Proposition)(iter000.value));
        if (Proposition.allArgumentsBoundP(g) &&
            (!goalsequence.memberP(g))) {
          goalsequence.push(g);
        }
      }
    }
  }

  public static void computeOptimalOpenGoalOrdering(List optimizervariables, int numberofopengoals, List goalsequence, double priorcost, double priorfanout) {
    { Cons goalsequencecheckpoint = null;
      int choicepointunbindingoffset = Stella.NULL_INTEGER;
      double cumulativecost = Stella.NULL_FLOAT;
      double cumulativefanout = Stella.NULL_FLOAT;

      if (((Integer)(Logic.$OPTIMALGOALORDERINGRECURSIONS$.get())).intValue() >= Logic.$OPTIMAL_GOAL_ORDERING_CUTOFF$) {
        return;
      }
      else {
        Native.setIntSpecial(Logic.$OPTIMALGOALORDERINGRECURSIONS$, ((Integer)(Logic.$OPTIMALGOALORDERINGRECURSIONS$.get())).intValue() + 1);
      }
      if (optimizervariables.emptyP()) {
        KeyValueList.setDynamicSlotValue(((QueryIterator)(Logic.$QUERYITERATOR$.get())).dynamicSlots, Logic.SYM_LOGIC_BEST_GOAL_SEQUENCE, goalsequence, null);
        return;
      }
      { PatternVariable vbl = null;
        Cons iter000 = optimizervariables.theConsList;

        loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          vbl = ((PatternVariable)(iter000.value));
          if (!PatternVariable.variableBoundP(vbl)) {
            { Proposition generatorgoal = null;
              double generatorcost = Stella.NULL_FLOAT;
              double generatorfanout = Stella.NULL_FLOAT;

              { Object [] caller_MV_returnarray = new Object[2];

                generatorgoal = PatternVariable.cheapestGeneratorGoal(vbl, caller_MV_returnarray);
                generatorcost = ((double)(((FloatWrapper)(caller_MV_returnarray[0])).wrapperValue));
                generatorfanout = ((double)(((FloatWrapper)(caller_MV_returnarray[1])).wrapperValue));
              }
              if (generatorgoal == null) {
                continue loop000;
              }
              cumulativefanout = priorfanout * generatorfanout;
              cumulativecost = priorcost + (cumulativefanout * generatorcost);
              if ((cumulativecost == Stella.NULL_FLOAT) ||
                  (cumulativecost < priorcost)) {
                continue loop000;
              }
              if ((((FloatWrapper)(KeyValueList.dynamicSlotValue(((QueryIterator)(Logic.$QUERYITERATOR$.get())).dynamicSlots, Logic.SYM_LOGIC_BEST_COST, Stella.NULL_FLOAT_WRAPPER))).wrapperValue != Stella.NULL_FLOAT) &&
                  (cumulativecost >= ((FloatWrapper)(KeyValueList.dynamicSlotValue(((QueryIterator)(Logic.$QUERYITERATOR$.get())).dynamicSlots, Logic.SYM_LOGIC_BEST_COST, Stella.NULL_FLOAT_WRAPPER))).wrapperValue)) {
                continue loop000;
              }
              goalsequencecheckpoint = goalsequence.theConsList;
              choicepointunbindingoffset = Logic.simulateCreateChoicePoint();
              goalsequence.push(generatorgoal);
              Proposition.bindAllVariablesInGeneratorGoal(generatorgoal, goalsequence);
            }
            if (goalsequence.length() == numberofopengoals) {
              if ((((FloatWrapper)(KeyValueList.dynamicSlotValue(((QueryIterator)(Logic.$QUERYITERATOR$.get())).dynamicSlots, Logic.SYM_LOGIC_BEST_COST, Stella.NULL_FLOAT_WRAPPER))).wrapperValue == Stella.NULL_FLOAT) ||
                  (cumulativecost < ((FloatWrapper)(KeyValueList.dynamicSlotValue(((QueryIterator)(Logic.$QUERYITERATOR$.get())).dynamicSlots, Logic.SYM_LOGIC_BEST_COST, Stella.NULL_FLOAT_WRAPPER))).wrapperValue)) {
                KeyValueList.setDynamicSlotValue(((QueryIterator)(Logic.$QUERYITERATOR$.get())).dynamicSlots, Logic.SYM_LOGIC_BEST_COST, FloatWrapper.wrapFloat(cumulativecost), Stella.NULL_FLOAT_WRAPPER);
                KeyValueList.setDynamicSlotValue(((QueryIterator)(Logic.$QUERYITERATOR$.get())).dynamicSlots, Logic.SYM_LOGIC_BEST_GOAL_SEQUENCE, goalsequence.copy(), null);
              }
            }
            else {
              Logic.computeOptimalOpenGoalOrdering(optimizervariables, numberofopengoals, goalsequence, cumulativecost, cumulativefanout);
            }
            goalsequence.theConsList = goalsequencecheckpoint;
            PatternRecord.unbindVariablesBeginningAt(((QueryIterator)(Logic.$QUERYITERATOR$.get())).currentPatternRecord, choicepointunbindingoffset);
          }
        }
      }
    }
  }

  public static void computeGreedyOpenGoalOrdering(List optimizervariables, int numberofopengoals, List goalsequence, double priorcost, double priorfanout) {
    { Cons goalsequencecheckpoint = null;
      int choicepointunbindingoffset = Stella.NULL_INTEGER;
      Proposition bestgeneratorgoal = null;
      double bestgeneratorfanout = Stella.NULL_FLOAT;
      double bestcombinedcost = Stella.NULL_FLOAT;
      int opengoalreduction = Stella.NULL_INTEGER;

      if (optimizervariables.emptyP()) {
        KeyValueList.setDynamicSlotValue(((QueryIterator)(Logic.$QUERYITERATOR$.get())).dynamicSlots, Logic.SYM_LOGIC_BEST_GOAL_SEQUENCE, goalsequence, null);
        return;
      }
      for (;;) {
        bestgeneratorgoal = null;
        bestgeneratorfanout = Stella.NULL_FLOAT;
        bestcombinedcost = Stella.NULL_FLOAT;
        { PatternVariable vbl = null;
          Cons iter000 = optimizervariables.theConsList;

          loop001 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            vbl = ((PatternVariable)(iter000.value));
            if (!PatternVariable.variableBoundP(vbl)) {
              { Proposition generatorgoal = null;
                double generatorcost = Stella.NULL_FLOAT;
                double generatorfanout = Stella.NULL_FLOAT;

                { Object [] caller_MV_returnarray = new Object[2];

                  generatorgoal = PatternVariable.cheapestGeneratorGoal(vbl, caller_MV_returnarray);
                  generatorcost = ((double)(((FloatWrapper)(caller_MV_returnarray[0])).wrapperValue));
                  generatorfanout = ((double)(((FloatWrapper)(caller_MV_returnarray[1])).wrapperValue));
                }
                if (generatorgoal == null) {
                  continue loop001;
                }
                goalsequencecheckpoint = goalsequence.theConsList;
                choicepointunbindingoffset = Logic.simulateCreateChoicePoint();
                goalsequence.push(generatorgoal);
                Proposition.bindAllVariablesInGeneratorGoal(generatorgoal, goalsequence);
                opengoalreduction = Native.ceiling((((double)(goalsequence.length() - goalsequencecheckpoint.length())) / numberofopengoals) * 100);
                { double combinedcost = (generatorfanout + generatorcost) - opengoalreduction;

                  if ((bestcombinedcost == Stella.NULL_FLOAT) ||
                      (combinedcost < bestcombinedcost)) {
                    bestgeneratorgoal = generatorgoal;
                    bestgeneratorfanout = generatorfanout;
                    bestcombinedcost = combinedcost;
                  }
                }
                goalsequence.theConsList = goalsequencecheckpoint;
                PatternRecord.unbindVariablesBeginningAt(((QueryIterator)(Logic.$QUERYITERATOR$.get())).currentPatternRecord, choicepointunbindingoffset);
              }
            }
          }
        }
        if (bestgeneratorgoal == null) {
          if (goalsequence.length() == numberofopengoals) {
            KeyValueList.setDynamicSlotValue(((QueryIterator)(Logic.$QUERYITERATOR$.get())).dynamicSlots, Logic.SYM_LOGIC_BEST_COST, FloatWrapper.wrapFloat(priorcost), Stella.NULL_FLOAT_WRAPPER);
            KeyValueList.setDynamicSlotValue(((QueryIterator)(Logic.$QUERYITERATOR$.get())).dynamicSlots, Logic.SYM_LOGIC_BEST_GOAL_SEQUENCE, goalsequence, null);
          }
          return;
        }
        priorfanout = priorfanout * bestgeneratorfanout;
        goalsequence.push(bestgeneratorgoal);
        Proposition.bindAllVariablesInGeneratorGoal(bestgeneratorgoal, goalsequence);
      }
    }
  }

  public static void computeBackupOpenGoalOrdering(List goalsequence) {
    { Proposition g = null;
      Cons iter000 = goalsequence.theConsList;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        g = ((Proposition)(iter000.value));
        if ((Proposition.estimateGoalCost(g) == Stella.NULL_FLOAT) &&
            BooleanWrapper.coerceWrappedBooleanToBoolean(g.variableTypeP())) {
          ((QueryIterator)(Logic.$QUERYITERATOR$.get())).residueGoals().insertLast(g);
        }
        else {
          ((QueryIterator)(Logic.$QUERYITERATOR$.get())).bestGoalSequence().push(g);
        }
      }
    }
  }

  public static void extractOpenGoalClusters(List opengoals, List opengoalclusters) {
    { Cons allgoals = Cons.copyConsList(opengoals.theConsList);
      Cons remaininggoals = allgoals;
      Cons cursor = null;
      Proposition goal = null;
      List clusters = List.newList();
      List currentcluster = null;
      List currentclustervars = List.newList();
      boolean currentclustervarsgrewP = false;
      List unboundgoalvars = List.newList();

      loop000 : for (;;) {
        currentclustervars.clear();
        loop001 : for (;;) {
          if (remaininggoals == Stella.NIL) {
            break loop001;
          }
          if (((Proposition)(remaininggoals.value)) != null) {
            Proposition.collectUnboundGoalVariables(((Proposition)(remaininggoals.value)), currentclustervars);
          }
          if (currentclustervars.nonEmptyP()) {
            break loop001;
          }
          else {
            remaininggoals = remaininggoals.rest;
          }
        }
        if (currentclustervars.emptyP()) {
          break loop000;
        }
        currentcluster = List.newList();
        currentcluster.insert(((Proposition)(remaininggoals.value)));
        remaininggoals.firstSetter(null);
        remaininggoals = remaininggoals.rest;
        loop002 : for (;;) {
          currentclustervarsgrewP = false;
          cursor = remaininggoals;
          while (!(cursor == Stella.NIL)) {
            goal = ((Proposition)(cursor.value));
            if (goal != null) {
              unboundgoalvars.clear();
              Proposition.collectUnboundGoalVariables(goal, unboundgoalvars);
              { boolean foundP000 = false;

                { PatternVariable var = null;
                  Cons iter000 = unboundgoalvars.theConsList;

                  loop004 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                    var = ((PatternVariable)(iter000.value));
                    if (currentclustervars.memberP(var)) {
                      foundP000 = true;
                      break loop004;
                    }
                  }
                }
                if (foundP000) {
                  currentcluster.push(goal);
                  cursor.firstSetter(null);
                  { PatternVariable var = null;
                    Cons iter001 = unboundgoalvars.theConsList;

                    for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                      var = ((PatternVariable)(iter001.value));
                      if (!currentclustervars.memberP(var)) {
                        currentclustervars.insert(var);
                        currentclustervarsgrewP = true;
                      }
                    }
                  }
                }
              }
            }
            cursor = cursor.rest;
          }
          if (!currentclustervarsgrewP) {
            break loop002;
          }
        }
        clusters.push(currentcluster.reverse());
      }
      currentclustervars.free();
      if (clusters.length() >= 2) {
        opengoals.clear();
        opengoals.theConsList = allgoals.remove(null);
        { List cluster = null;
          Cons iter002 = clusters.reverse().theConsList;
          Cons collect000 = null;

          for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
            cluster = ((List)(iter002.value));
            if (collect000 == null) {
              {
                collect000 = Cons.cons(cluster, Stella.NIL);
                if (opengoalclusters.theConsList == Stella.NIL) {
                  opengoalclusters.theConsList = collect000;
                }
                else {
                  Cons.addConsToEndOfConsList(opengoalclusters.theConsList, collect000);
                }
              }
            }
            else {
              {
                collect000.rest = Cons.cons(cluster, Stella.NIL);
                collect000 = collect000.rest;
              }
            }
          }
        }
      }
      else {
        if (currentcluster != null) {
          currentcluster.free();
        }
      }
      clusters.free();
    }
  }

  public static void simulateBindVariableToValue(Stella_Object formula) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(formula), Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
      { PatternVariable formula000 = ((PatternVariable)(formula));

        if (!Logic.argumentBoundP(formula000)) {
          PatternVariable.setPatternVariableBinding(formula000, Logic.KWD_BOUND);
        }
      }
    }
    else {
    }
  }

  public static void simulateAndOptimizeArgument(Stella_Object formula) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(formula), Logic.SGT_LOGIC_PROPOSITION)) {
      { Proposition formula000 = ((Proposition)(formula));

        Proposition.simulateAndOptimizeQuery(formula000);
      }
    }
    else {
    }
  }

  public static void initializeOptimizerMemory(int stacksize) {
    if ((stacksize <= 0) &&
        (((ExtensibleVector)(KeyValueList.dynamicSlotValue(((QueryIterator)(Logic.$QUERYITERATOR$.get())).dynamicSlots, Logic.SYM_LOGIC_OPTIMIZER_GOAL_RECORDS, null))) != null)) {
      stacksize = ((ExtensibleVector)(KeyValueList.dynamicSlotValue(((QueryIterator)(Logic.$QUERYITERATOR$.get())).dynamicSlots, Logic.SYM_LOGIC_OPTIMIZER_GOAL_RECORDS, null))).length();
    }
    Logic.initializeOptimizerGoalRecords(stacksize);
    KeyValueList.setDynamicSlotValue(((QueryIterator)(Logic.$QUERYITERATOR$.get())).dynamicSlots, Logic.SYM_LOGIC_RESIDUE_GOALS, List.list(Stella.NIL), null);
    KeyValueList.setDynamicSlotValue(((QueryIterator)(Logic.$QUERYITERATOR$.get())).dynamicSlots, Logic.SYM_LOGIC_BEST_GOAL_SEQUENCE, List.list(Stella.NIL), null);
    KeyValueList.setDynamicSlotValue(((QueryIterator)(Logic.$QUERYITERATOR$.get())).dynamicSlots, Logic.SYM_LOGIC_BEST_COST, FloatWrapper.wrapFloat(Stella.NULL_FLOAT), Stella.NULL_FLOAT_WRAPPER);
  }

  public static boolean useDynamicQueryOptimizationP() {
    return ((Logic.$QUERY_OPTIMIZATION_STRATEGY$ == Logic.KWD_DYNAMIC) ||
        (Logic.$QUERY_OPTIMIZATION_STRATEGY$ == Logic.KWD_DYNAMIC_WITH_CLUSTERING));
  }

  public static boolean useStaticQueryOptimizationP() {
    return ((!(Logic.$QUERY_OPTIMIZATION_STRATEGY$ == Logic.KWD_NONE)) &&
        (!((Logic.$QUERY_OPTIMIZATION_STRATEGY$ == Logic.KWD_DYNAMIC) ||
        (Logic.$QUERY_OPTIMIZATION_STRATEGY$ == Logic.KWD_DYNAMIC_WITH_CLUSTERING))));
  }

  public static boolean tryToClusterConjunctionsP() {
    return (Logic.$QUERY_OPTIMIZATION_STRATEGY$ == Logic.KWD_STATIC_WITH_CLUSTERING);
  }

  public static void dynamicallyReoptimizeArguments(Vector arguments, int cursor) {
    { int lastargindex = arguments.length() - 1;
      int cheapestargindex = cursor;
      double cost = Stella.NULL_FLOAT;
      double fanout = Stella.NULL_FLOAT;
      double unbound = Stella.NULL_FLOAT;
      int nofboundargs = 0;
      double bestcost = Stella.NULL_FLOAT;
      int bestnofboundargs = 0;
      Proposition argument = null;

      if (cursor >= lastargindex) {
        return;
      }
      { int i = Stella.NULL_INTEGER;
        int iter000 = cursor;
        int upperBound000 = lastargindex;
        boolean unboundedP000 = upperBound000 == Stella.NULL_INTEGER;

        loop000 : for (;unboundedP000 ||
                  (iter000 <= upperBound000); iter000 = iter000 + 1) {
          i = iter000;
          argument = ((Proposition)((arguments.theArray)[i]));
          if (Proposition.containsOperatorP(argument, Logic.SGT_PL_KERNEL_KB_CUT) ||
              Proposition.containsOperatorP(argument, Logic.SGT_PL_KERNEL_KB_BOUND_VARIABLES)) {
            break loop000;
          }
          unbound = Proposition.dynamicallyEstimateUnboundVariablePenalty(argument);
          if (unbound == 1.0) {
            fanout = 1.0;
            nofboundargs = argument.arguments.length();
          }
          else {
            fanout = Proposition.dynamicallyEstimateGoalFanout(argument);
            nofboundargs = Proposition.countBoundArguments(argument);
          }
          if (fanout == Stella.NULL_FLOAT) {
            continue loop000;
          }
          if (fanout < 1.0) {
            fanout = 1.0;
          }
          cost = Proposition.dynamicallyEstimateGoalCost(argument);
          cost = cost * fanout * unbound;
          if ((bestcost == Stella.NULL_FLOAT) ||
              (((cost < bestcost) &&
              ((bestnofboundargs == 0) ||
               (!(nofboundargs == 0)))) ||
               ((cost >= bestcost) &&
                ((bestnofboundargs == 0) &&
                 (!(nofboundargs == 0)))))) {
            bestcost = cost;
            bestnofboundargs = nofboundargs;
            cheapestargindex = i;
            if (bestcost == 1.0) {
              break loop000;
            }
          }
        }
      }
      if (cheapestargindex > cursor) {
        argument = ((Proposition)((arguments.theArray)[cursor]));
        (arguments.theArray)[cursor] = (((Proposition)((arguments.theArray)[cheapestargindex])));
        (arguments.theArray)[cheapestargindex] = argument;
      }
    }
  }

  public static Vector copyListToArgumentsVector(List arguments) {
    { Vector vector = Vector.newVector(arguments.length());

      { Stella_Object arg = null;
        Cons iter000 = arguments.theConsList;
        int i = Stella.NULL_INTEGER;
        int iter001 = 0;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
          arg = iter000.value;
          i = iter001;
          (vector.theArray)[i] = arg;
        }
      }
      return (vector);
    }
  }

  public static Vector copyVariablesVector(Vector self, KeyValueMap mapping) {
    if (self.emptyP()) {
      return (Logic.ZERO_VARIABLES_VECTOR);
    }
    { Vector copy = Vector.newVector(self.length());

      { PatternVariable vbl = null;
        Vector vector000 = self;
        int index000 = 0;
        int length000 = vector000.length();
        int i = Stella.NULL_INTEGER;
        int iter000 = 0;

        for (;index000 < length000; index000 = index000 + 1, iter000 = iter000 + 1) {
          vbl = ((PatternVariable)((vector000.theArray)[index000]));
          i = iter000;
          { PatternVariable vblcopy = PatternVariable.copyVariable(vbl, mapping);

            if (((Integer)(Logic.$BOUNDTOOFFSETCOUNTER$.get())).intValue() != Stella.NULL_INTEGER) {
              vblcopy.boundToOffset = ((Integer)(Logic.$BOUNDTOOFFSETCOUNTER$.get())).intValue();
              Native.setIntSpecial(Logic.$BOUNDTOOFFSETCOUNTER$, ((Integer)(Logic.$BOUNDTOOFFSETCOUNTER$.get())).intValue() + 1);
            }
            (copy.theArray)[i] = vblcopy;
          }
        }
      }
      return (copy);
    }
  }

  public static Stella_Object copyPropositionArgument(Stella_Object self, KeyValueMap mapping) {
    { Stella_Object copy = mapping.lookup(self);

      if (copy != null) {
        if (Logic.descriptionModeP()) {
          { Surrogate testValue000 = Stella_Object.safePrimaryType(copy);

            if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
              { PatternVariable copy000 = ((PatternVariable)(copy));

              }
            }
            else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
              { LogicObject copy000 = ((LogicObject)(copy));

                if (copy000.surrogateValueInverse != null) {
                  return (copy000.surrogateValueInverse);
                }
              }
            }
            else {
            }
          }
        }
        return (copy);
      }
      { Surrogate testValue001 = Stella_Object.safePrimaryType(self);

        if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_PROPOSITION)) {
          { Proposition self000 = ((Proposition)(self));

            return (Proposition.copyProposition(self000, mapping));
          }
        }
        else if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_DESCRIPTION)) {
          { Description self000 = ((Description)(self));

            if (((Vector)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_EXTERNAL_VARIABLES, null))) != null) {
              { Description copy000 = Description.copyDescription(self000, mapping, true);

                mapping.insertAt(self000, copy000);
                return (copy000);
              }
            }
            else {
              return (self000);
            }
          }
        }
        else if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
          { PatternVariable self000 = ((PatternVariable)(self));

            { Stella_Object value = Logic.mappedValueOf(self000, mapping, false);

              if (value != null) {
                return (Logic.copyPropositionArgument(value, mapping));
              }
              else {
                throw ((StellaException)(StellaException.newStellaException("INTERNAL ERROR: BUG IN 'copy-description'").fillInStackTrace()));
              }
            }
          }
        }
        else {
          return (self);
        }
      }
    }
  }

  public static Stella_Object mappedValueOf(Stella_Object self, KeyValueMap mapping, boolean createskolemP) {
    { Stella_Object value = ((mapping != null) ? mapping.lookup(self) : ((Stella_Object)(null)));

      if (value != null) {
        return (value);
      }
      if ((((QueryIterator)(Logic.$QUERYITERATOR$.get())) != null) &&
          ((!Logic.variableP(self)) ||
           (((PatternVariable)(self)).boundToOffset != Stella.NULL_INTEGER))) {
        value = Logic.argumentBoundTo(self);
      }
      else {
        {
          value = Logic.valueOf(self);
          if (Logic.variableP(self)) {
            value = null;
          }
        }
      }
      if ((mapping != null) &&
          (value != null)) {
        if (!(Stella_Object.isaP(self, Logic.SGT_LOGIC_PROPOSITION))) {
          mapping.insertAt(self, value);
        }
        return (value);
      }
      if (createskolemP) {
        return (PatternVariable.createSkolemForUnmappedVariable(((PatternVariable)(self)), mapping));
      }
      else {
        return (null);
      }
    }
  }

  public static boolean equalUpToSkolemIdentityP(Stella_Object inheritedarg, Stella_Object basearg, KeyValueMap mapping) {
    { Stella_Object inheritedvalue = ((mapping != null) ? Logic.mappedValueOf(inheritedarg, mapping, false) : inheritedarg);
      Stella_Object basevalue = Logic.valueOf(basearg);

      if (Stella_Object.eqlP(inheritedvalue, basevalue)) {
        return (true);
      }
      return (false);
    }
  }

  public static Stella_Object inheritPropositionArgument(Stella_Object argument, Proposition parent, KeyValueMap mapping) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(argument);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition argument000 = ((Proposition)(argument));

          return (Proposition.inheritProposition(argument000, mapping));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description argument000 = ((Description)(argument));

          if (Description.namedDescriptionP(argument000)) {
            return (argument000);
          }
          else {
            return (Description.copyDescription(argument000, mapping, true));
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable argument000 = ((PatternVariable)(argument));

          return (Logic.mappedValueOf(argument000, mapping, true));
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate argument000 = ((Surrogate)(argument));

          if (Logic.descriptionModeP() ||
              ((parent.kind == Logic.KWD_ISA) &&
               (((Surrogate)(parent.operator)) == argument000))) {
            return (argument000);
          }
          else {
            { Stella_Object value = argument000.surrogateValue;

              if (Logic.relationP(value)) {
                return (Logic.surrogateToDescription(argument000));
              }
              else {
                return (value);
              }
            }
          }
        }
      }
      else {
        return (argument);
      }
    }
  }

  public static Cons createSkolemPropositionsQuery(Cons inheritedprops, Description description, KeyValueMap mapping) {
    { HashSet createdskolems = null;
      Cons skolemprops = Stella.NIL;
      Cons filteredpropsindices = Stella.NIL;

      { Object old$Module$000 = Stella.$MODULE$.get();
        Object old$Context$000 = Stella.$CONTEXT$.get();

        try {
          Native.setSpecial(Stella.$MODULE$, ((Module)(Stella.$MODULE$.get())));
          Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
          { Keyword testValue000 = description.proposition.kind;

            if (testValue000 == Logic.KWD_AND) {
              createdskolems = HashSet.newHashSet();
              { Stella_Object skolem = null;
                Cons iter000 = ((List)(mapping.lookup(Logic.KWD_CREATED_SKOLEMS))).theConsList;

                for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                  skolem = iter000.value;
                  createdskolems.insert(((Skolem)(skolem)));
                }
              }
              { Proposition iprop = null;
                Cons iter001 = inheritedprops;
                int ipropindex = Stella.NULL_INTEGER;
                int iter002 = 0;
                Proposition dprop = null;
                Vector vector000 = ((Vector)(description.proposition.arguments));
                int index000 = 0;
                int length000 = vector000.length();
                Cons collect000 = null;

                loop001 : for (;(!(iter001 == Stella.NIL)) &&
                          (index000 < length000); 
                      iter001 = iter001.rest,
                      iter002 = iter002 + 1,
                      index000 = index000 + 1) {
                  iprop = ((Proposition)(iter001.value));
                  ipropindex = iter002;
                  dprop = ((Proposition)((vector000.theArray)[index000]));
                  if (!Proposition.propositionReferencesTermsP(iprop, createdskolems)) {
                    filteredpropsindices = Cons.cons(IntegerWrapper.wrapInteger(ipropindex), filteredpropsindices);
                    continue loop001;
                  }
                  if (collect000 == null) {
                    {
                      collect000 = Cons.cons(dprop, Stella.NIL);
                      if (skolemprops == Stella.NIL) {
                        skolemprops = collect000;
                      }
                      else {
                        Cons.addConsToEndOfConsList(skolemprops, collect000);
                      }
                    }
                  }
                  else {
                    {
                      collect000.rest = Cons.cons(dprop, Stella.NIL);
                      collect000 = collect000.rest;
                    }
                  }
                }
              }
              filteredpropsindices = filteredpropsindices.reverse();
              if (!(filteredpropsindices == Stella.NIL)) {
                { Description self001 = Description.newDescription();

                  self001.ioVariables = description.ioVariables;
                  self001.proposition = Logic.conjoinPropositions(skolemprops);
                  description = self001;
                }
                Description.computeInternalVariables(description);
              }
            }
            else if ((testValue000 == Logic.KWD_ISA) ||
                ((testValue000 == Logic.KWD_FUNCTION) ||
                 (testValue000 == Logic.KWD_PREDICATE))) {
            }
            else {
            }
          }
          return (Cons.consList(Cons.cons(QueryIterator.initializeQueryIterator(Logic.allocateQueryIterator(), description, Vector.newVector(description.arity())), Cons.cons(filteredpropsindices, Stella.NIL))));

        } finally {
          Stella.$CONTEXT$.set(old$Context$000);
          Stella.$MODULE$.set(old$Module$000);
        }
      }
    }
  }

  public static Cons filterImpliedSkolemPropositions(Cons inheritedprops, Description description, Vector arguments, KeyValueMap mapping) {
    { List createdskolems = ((mapping != null) ? ((List)(mapping.lookup(Logic.KWD_CREATED_SKOLEMS))) : null);
      Cons filteredprops = inheritedprops;
      Cons filteredpropsindices = Stella.NIL;
      QueryIterator query = null;
      Cons cachedqueryrecord = Stella.NIL;

      if (createdskolems != null) {
        { MemoizationTable memoTable000 = null;
          Cons memoizedEntry000 = null;
          Stella_Object memoizedValue000 = null;

          if (Stella.$MEMOIZATION_ENABLEDp$) {
            memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_FILTER_IMPLIED_SKOLEM_PROPOSITIONS_MEMO_TABLE_000.surrogateValue));
            if (memoTable000 == null) {
              Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_FILTER_IMPLIED_SKOLEM_PROPOSITIONS_MEMO_TABLE_000, "(:MAX-VALUES 500 :TIMESTAMPS (:MODULE-UPDATE))");
              memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_FILTER_IMPLIED_SKOLEM_PROPOSITIONS_MEMO_TABLE_000.surrogateValue));
            }
            memoizedEntry000 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable000)), description, Stella.MEMOIZED_NULL_VALUE, null, null, -1);
            memoizedValue000 = memoizedEntry000.value;
          }
          if (memoizedValue000 != null) {
            if (memoizedValue000 == Stella.MEMOIZED_NULL_VALUE) {
              memoizedValue000 = null;
            }
          }
          else {
            memoizedValue000 = Logic.createSkolemPropositionsQuery(inheritedprops, description, mapping);
            if (Stella.$MEMOIZATION_ENABLEDp$) {
              memoizedEntry000.value = ((memoizedValue000 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue000);
            }
          }
          cachedqueryrecord = ((Cons)(memoizedValue000));
        }
        query = ((QueryIterator)(cachedqueryrecord.value));
        filteredpropsindices = ((Cons)(cachedqueryrecord.rest.value));
        { Stella_Object arg = null;
          Vector vector000 = arguments;
          int index000 = 0;
          int length000 = vector000.length();
          int i = Stella.NULL_INTEGER;
          int iter000 = 0;

          for (;index000 < length000; index000 = index000 + 1, iter000 = iter000 + 1) {
            arg = (vector000.theArray)[index000];
            i = iter000;
            (((Vector)(KeyValueList.dynamicSlotValue(query.dynamicSlots, Logic.SYM_LOGIC_INITIAL_BINDINGS, null))).theArray)[i] = arg;
          }
        }
        { Object old$TypeCheckStrategy$000 = Logic.$TYPE_CHECK_STRATEGY$.get();
          Object old$Queryiterator$000 = Logic.$QUERYITERATOR$.get();
          Object old$ReversepolarityP$000 = Logic.$REVERSEPOLARITYp$.get();
          Object old$Inferencelevel$000 = Logic.$INFERENCELEVEL$.get();
          Object old$GenerateAllProofsP$000 = Logic.$GENERATE_ALL_PROOFSp$.get();

          try {
            Native.setSpecial(Logic.$TYPE_CHECK_STRATEGY$, Logic.KWD_NONE);
            Native.setSpecial(Logic.$QUERYITERATOR$, query);
            Native.setBooleanSpecial(Logic.$REVERSEPOLARITYp$, false);
            Native.setSpecial(Logic.$INFERENCELEVEL$, Logic.SUBSUMPTION_INFERENCE);
            Native.setBooleanSpecial(Logic.$GENERATE_ALL_PROOFSp$, false);
            query.reset();
            if (query.nextP()) {
              filteredprops = Stella.NIL;
              { IntegerWrapper i = null;
                Cons iter001 = filteredpropsindices;
                Cons collect000 = null;

                for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                  i = ((IntegerWrapper)(iter001.value));
                  if (collect000 == null) {
                    {
                      collect000 = Cons.cons(((Proposition)(inheritedprops.nth(i.wrapperValue))), Stella.NIL);
                      if (filteredprops == Stella.NIL) {
                        filteredprops = collect000;
                      }
                      else {
                        Cons.addConsToEndOfConsList(filteredprops, collect000);
                      }
                    }
                  }
                  else {
                    {
                      collect000.rest = Cons.cons(((Proposition)(inheritedprops.nth(i.wrapperValue))), Stella.NIL);
                      collect000 = collect000.rest;
                    }
                  }
                }
              }
            }

          } finally {
            Logic.$GENERATE_ALL_PROOFSp$.set(old$GenerateAllProofsP$000);
            Logic.$INFERENCELEVEL$.set(old$Inferencelevel$000);
            Logic.$REVERSEPOLARITYp$.set(old$ReversepolarityP$000);
            Logic.$QUERYITERATOR$.set(old$Queryiterator$000);
            Logic.$TYPE_CHECK_STRATEGY$.set(old$TypeCheckStrategy$000);
          }
        }
      }
      return (filteredprops);
    }
  }

  public static boolean mapAndEnqueueVariableP(Stella_Object variable, Stella_Object localvalue, KeyValueMap mapping) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(variable), Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
      { PatternVariable variable000 = ((PatternVariable)(variable));

        { Stella_Object mapstovalue = mapping.lookup(variable000);

          if (mapstovalue == null) {
            mapstovalue = Logic.nativeValueOf(variable000);
            if (mapstovalue != null) {
              mapping.insertAt(variable000, mapstovalue);
            }
          }
          if (mapstovalue != null) {
            return ((localvalue == null) ||
                (Stella_Object.eqlP(mapstovalue, localvalue) ||
                 (Logic.skolemP(localvalue) ||
                  Logic.skolemP(mapstovalue))));
          }
          else if (localvalue != null) {
            mapping.insertAt(variable000, localvalue);
          }
          else {
            { Skolem skolem = Logic.createVariableOrSkolem(variable000.skolemType, null);

              mapping.insertAt(variable000, skolem);
            }
          }
        }
      }
    }
    else {
    }
    return (true);
  }

  public static Cons inheritDescriptionPropositions(Vector arguments, Description description, Object [] MV_returnarray) {
    { KeyValueMap mapping = KeyValueMap.newKeyValueMap();

      { PatternVariable v = null;
        Vector vector000 = description.ioVariables;
        int index000 = 0;
        int length000 = vector000.length();
        Stella_Object arg = null;
        Vector vector001 = arguments;
        int index001 = 0;
        int length001 = vector001.length();

        for (;(index000 < length000) &&
                  (index001 < length001); index000 = index000 + 1, index001 = index001 + 1) {
          v = ((PatternVariable)((vector000.theArray)[index000]));
          arg = (vector001.theArray)[index001];
          if (!(Logic.mapAndEnqueueVariableP(v, arg, mapping))) {
            { Cons _return_temp = Stella.NIL;

              MV_returnarray[0] = null;
              return (_return_temp);
            }
          }
        }
      }
      { Proposition p = null;
        Cons iter000 = Description.getStructuralFunctionEvaluationOrder(description).theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          p = ((Proposition)(iter000.value));
          if (!(Proposition.mapFunctionalValueP(p, mapping))) {
            { Cons _return_temp = Stella.NIL;

              MV_returnarray[0] = null;
              return (_return_temp);
            }
          }
        }
      }
      { Cons propositions = Proposition.inheritAsTopLevelProposition(description.proposition, mapping);

        { ConsIterator it = propositions.allocateIterator();

          while (it.nextP()) {
            it.valueSetter(Proposition.recursivelyFastenDownPropositions(((Proposition)(it.value)), false));
          }
        }
        { Cons _return_temp = propositions;

          MV_returnarray[0] = mapping;
          return (_return_temp);
        }
      }
    }
  }

  public static void inheritUnnamedDescription(Stella_Object self, Description description, boolean defaulttrueP) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_VECTOR)) {
        { Vector self000 = ((Vector)(self));

          Logic.vectorDinheritUnnamedDescription(self000, description, defaulttrueP);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          LogicObject.logicObjectDinheritUnnamedDescription(self000, description, defaulttrueP);
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  public static void vectorDinheritUnnamedDescription(Vector arguments, Description description, boolean defaulttrueP) {
    { Cons propositions = null;
      KeyValueMap mapping = null;

      { Object [] caller_MV_returnarray = new Object[1];

        propositions = Logic.inheritDescriptionPropositions(arguments, description, caller_MV_returnarray);
        mapping = ((KeyValueMap)(caller_MV_returnarray[0]));
      }
      { Proposition prop = null;
        Cons iter000 = Logic.filterImpliedSkolemPropositions(propositions, description, arguments, mapping);
        Cons collect000 = null;

        loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          prop = ((Proposition)(iter000.value));
          if (!Proposition.trueP(prop)) {
            Proposition.assignTruthValue(prop, (defaulttrueP ? Logic.DEFAULT_TRUE_TRUTH_VALUE : Logic.TRUE_TRUTH_VALUE));
            if (!(((Cons)(Logic.$COLLECTFORWARDPROPOSITIONS$.get())) != null)) {
              continue loop000;
            }
            if (collect000 == null) {
              {
                collect000 = Cons.cons(prop, Stella.NIL);
                if (((Cons)(Logic.$COLLECTFORWARDPROPOSITIONS$.get())) == Stella.NIL) {
                  Native.setSpecial(Logic.$COLLECTFORWARDPROPOSITIONS$, collect000);
                }
                else {
                  Cons.addConsToEndOfConsList(((Cons)(Logic.$COLLECTFORWARDPROPOSITIONS$.get())), collect000);
                }
              }
            }
            else {
              {
                collect000.rest = Cons.cons(prop, Stella.NIL);
                collect000 = collect000.rest;
              }
            }
          }
        }
      }
    }
  }

  public static void inheritDescription(Vector arguments, Description description, boolean defaulttrueP) {
    if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(description), Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
      { NamedDescription description000 = ((NamedDescription)(description));

        { Proposition prop = Logic.updateTuple(description000.surrogateValueInverse, arguments.consify(), Logic.KWD_CONCEIVE);

          if (!(Proposition.trueP(prop))) {
            if (((Cons)(Logic.$COLLECTFORWARDPROPOSITIONS$.get())) != null) {
              Native.setSpecial(Logic.$COLLECTFORWARDPROPOSITIONS$, Cons.cons(prop, ((Cons)(Logic.$COLLECTFORWARDPROPOSITIONS$.get()))));
            }
            Proposition.assignTruthValue(prop, (defaulttrueP ? Logic.DEFAULT_TRUE_TRUTH_VALUE : Logic.TRUE_TRUTH_VALUE));
          }
        }
      }
    }
    else {
      Logic.inheritUnnamedDescription(arguments, description, defaulttrueP);
    }
  }

  public static void bumpInferableTimestamp() {
    Keyword.bumpMemoizationTimestamp(Logic.KWD_IMPLIES_PROPOSITION_UPDATE);
  }

  /** Return a new marker storage object, used to
   * remember with objects have been 'marked'.  If 'supportRecall?'
   * is set, then the iterator 'recall-marked-objects' can be invoked
   * on the new marker storage object.
   * @param supportrecallP
   * @return MarkerTable
   */
  public static MarkerTable createMarkerStorage(boolean supportrecallP) {
    { MarkerTable table = MarkerTable.newMarkerTable();

      table.testTable = HashTable.newHashTable();
      if (supportrecallP) {
        table.supportsRecallP = true;
        table.recallTable = List.newList();
      }
      return (table);
    }
  }

  /** Return TRUE if the object 'self' is stored (marked)
   * in the table pointed at by the special variable *specialMarkerTable*.
   * Designed for use by 'remove-if'.
   * @param self
   * @return boolean
   */
  public static boolean testSpecialMarkerTableP(Stella_Object self) {
    return (((MarkerTable)(Logic.$SPECIALMARKERTABLE$.get())).testMarkerP(self));
  }

  public static Cons mostSpecificCollections(Cons descriptions) {
    if (descriptions.rest == null) {
      return (descriptions);
    }
    { Cons cursor1 = descriptions;
      Cons cursor2 = null;
      Stella_Object value1 = null;
      Stella_Object value2 = null;

      while (!(cursor1 == Stella.NIL)) {
        value1 = ((LogicObject)(cursor1.value));
        if (value1 != null) {
          cursor2 = cursor1.rest;
          loop001 : while (!(cursor2 == Stella.NIL)) {
            value2 = cursor2.value;
            if (value2 != null) {
              if (LogicObject.collectionImpliesCollectionP(((LogicObject)(value1)), ((LogicObject)(value2)))) {
                cursor2.value = null;
              }
              else {
                if (LogicObject.collectionImpliesCollectionP(((LogicObject)(value2)), ((LogicObject)(value1)))) {
                  cursor1.value = null;
                  break loop001;
                }
              }
            }
            cursor2 = cursor2.rest;
          }
        }
        cursor1 = cursor1.rest;
      }
    }
    descriptions = descriptions.remove(null);
    return (descriptions);
  }

  public static Cons mostGeneralCollections(Cons descriptions) {
    if (descriptions.rest == null) {
      return (descriptions);
    }
    { Cons cursor1 = descriptions;
      Cons cursor2 = null;
      Stella_Object value1 = null;
      Stella_Object value2 = null;

      while (!(cursor1 == Stella.NIL)) {
        value1 = ((LogicObject)(cursor1.value));
        if (value1 != null) {
          cursor2 = cursor1.rest;
          loop001 : while (!(cursor2 == Stella.NIL)) {
            value2 = cursor2.value;
            if (value2 != null) {
              if (LogicObject.collectionImpliesCollectionP(((LogicObject)(value2)), ((LogicObject)(value1)))) {
                cursor2.value = null;
              }
              else {
                if (LogicObject.collectionImpliesCollectionP(((LogicObject)(value1)), ((LogicObject)(value2)))) {
                  cursor1.value = null;
                  break loop001;
                }
              }
            }
            cursor2 = cursor2.rest;
          }
        }
        cursor1 = cursor1.rest;
      }
    }
    descriptions = descriptions.remove(null);
    return (descriptions);
  }

  public static Cons mostSpecificNamedCollections(Cons descriptions) {
    descriptions = Logic.mostSpecificCollections(descriptions);
    { boolean recomputeP = false;

      { LogicObject d = null;
        Cons iter000 = Cons.copyConsList(descriptions);

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          d = ((LogicObject)(iter000.value));
          if (!LogicObject.namedCollectionP(d)) {
            descriptions = descriptions.remove(d);
            { LogicObject renamed_Super = null;
              Iterator iter001 = LogicObject.allDirectSupercollections(d, false);

              while (iter001.nextP()) {
                renamed_Super = ((LogicObject)(iter001.value));
                descriptions = Cons.cons(renamed_Super, descriptions);
              }
            }
            recomputeP = true;
          }
        }
      }
      if (recomputeP) {
        Logic.mostSpecificNamedCollections(descriptions);
      }
      return (descriptions);
    }
  }

  public static Cons mostSpecificNamedDescriptions(Cons descriptions) {
    descriptions = Logic.mostSpecificCollections(descriptions);
    { boolean recomputeP = false;

      { LogicObject d = null;
        Cons iter000 = Cons.copyConsList(descriptions);

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          d = ((LogicObject)(iter000.value));
          if (!Description.namedDescriptionP(((Description)(d)))) {
            descriptions = descriptions.remove(d);
            { LogicObject renamed_Super = null;
              Iterator iter001 = LogicObject.allDirectSupercollections(d, false);

              while (iter001.nextP()) {
                renamed_Super = ((LogicObject)(iter001.value));
                descriptions = Cons.cons(renamed_Super, descriptions);
              }
            }
            recomputeP = true;
          }
        }
      }
      if (recomputeP) {
        Logic.mostSpecificNamedCollections(descriptions);
      }
      return (((Cons)(descriptions)));
    }
  }

  public static World getClassificationWorld() {
    return (((ClassificationSession)(Logic.$CLASSIFICATIONSESSION$.get())).classificationWorld);
  }

  public static ClassificationSession getClassificationSession(Keyword instanceordescription) {
    if (((ClassificationSession)(Logic.$CLASSIFICATIONSESSION$.get())) != null) {
      return (((ClassificationSession)(Logic.$CLASSIFICATIONSESSION$.get())));
    }
    { World world = null;
      ClassificationSession session = null;

      if (instanceordescription == Logic.KWD_DESCRIPTION) {
        world = Logic.getInferenceCache(((Module)(Stella.$MODULE$.get())), Logic.KWD_META);
      }
      else if (instanceordescription == Logic.KWD_INSTANCE) {
        world = Logic.getInferenceCache(((Module)(Stella.$MODULE$.get())), Logic.KWD_TMS);
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + instanceordescription + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      session = ((ClassificationSession)(KeyValueList.dynamicSlotValue(world.dynamicSlots, Logic.SYM_LOGIC_CLASSIFICATION_SESSION, null)));
      if (session == null) {
        session = ClassificationSession.newClassificationSession();
        KeyValueList.setDynamicSlotValue(world.dynamicSlots, Logic.SYM_LOGIC_CLASSIFICATION_SESSION, session, null);
        session.classificationWorld = world;
      }
      return (session);
    }
  }

  public static ClassificationCache getClassificationCache(Stella_Object self) {
    { ClassificationSession session = ((ClassificationSession)(Logic.$CLASSIFICATIONSESSION$.get()));
      ClassificationCache cache = null;

      if (session.lastCacheTableKey == self) {
        return (session.lastCacheTableValue);
      }
      cache = ((ClassificationCache)(session.classificationCacheTable.lookup(self)));
      if (cache == null) {
        cache = ClassificationCache.newClassificationCache();
        session.classificationCacheTable.insertAt(self, cache);
      }
      session.lastCacheTableKey = ((LogicObject)(self));
      session.lastCacheTableValue = cache;
      return (cache);
    }
  }

  public static String toggleInferableDirectSubcollectionsCaching() {
    Logic.$CACHE_INFERABLE_SUBCOLLECTIONSp$ = !Logic.$CACHE_INFERABLE_SUBCOLLECTIONSp$;
    return ((Logic.$CACHE_INFERABLE_SUBCOLLECTIONSp$ ? "Inferable subcollections caching enabled" : "Inferable subcollections caching disabled"));
  }

  public static int currentClassificationTime() {
    return (((ClassificationSession)(Logic.$CLASSIFICATIONSESSION$.get())).classificationTimeclock);
  }

  public static int bumpClassificationTimeclock() {
    return (((ClassificationSession)(Logic.$CLASSIFICATIONSESSION$.get())).classificationTimeclock = ((ClassificationSession)(Logic.$CLASSIFICATIONSESSION$.get())).classificationTimeclock + 1);
  }

  public static int youngestIntroductionTimestamp() {
    return (((IntegerWrapper)(((ClassificationSession)(Logic.$CLASSIFICATIONSESSION$.get())).introductionTimestampStack.first())).wrapperValue);
  }

  public static int upclassificationTimestamp(Stella_Object self) {
    return (Logic.getClassificationCache(self).cacheUpclassificationTimestamp);
  }

  public static void refreshUpclassificationTimestamp(Stella_Object self) {
    Logic.getClassificationCache(self).cacheUpclassificationTimestamp = Logic.bumpClassificationTimeclock();
  }

  public static void flushClassificationSessions() {
    { World jitworld = Logic.lookupInferenceCache(((Module)(Stella.$MODULE$.get())), Logic.KWD_JUST_IN_TIME);
      World metaworld = Logic.lookupInferenceCache(((Module)(Stella.$MODULE$.get())), Logic.KWD_META);
      World tmsworld = Logic.lookupInferenceCache(((Module)(Stella.$MODULE$.get())), Logic.KWD_TMS);

      if (jitworld != null) {
        KeyValueList.setDynamicSlotValue(jitworld.dynamicSlots, Logic.SYM_LOGIC_CLASSIFICATION_SESSION, null, null);
      }
      if (metaworld != null) {
        KeyValueList.setDynamicSlotValue(metaworld.dynamicSlots, Logic.SYM_LOGIC_CLASSIFICATION_SESSION, null, null);
      }
      if (tmsworld != null) {
        KeyValueList.setDynamicSlotValue(tmsworld.dynamicSlots, Logic.SYM_LOGIC_CLASSIFICATION_SESSION, null, null);
      }
    }
  }

  public static boolean upclassifiedP(Stella_Object self) {
    return (Logic.upclassificationTimestamp(self) > Logic.youngestIntroductionTimestamp());
  }

  public static boolean applySubsumptionTestP(java.lang.reflect.Method subsumptiontest, LogicObject self, LogicObject renamed_Super) {
    { TruthValue result = ((TruthValue)(edu.isi.stella.javalib.Native.funcall(subsumptiontest, null, new java.lang.Object [] {self, renamed_Super})));

      if ((Stella.$TRACED_KEYWORDS$ != null) &&
          (Stella.$TRACED_KEYWORDS$.membP(Logic.KWD_CLASSIFIER) ||
           Stella.$TRACED_KEYWORDS$.membP(Logic.KWD_CLASSIFIER_PROFILE))) {
        Stella.STANDARD_OUTPUT.nativeStream.println("   SPECIALIZES?:  " + result + "  self=" + self + " super=" + renamed_Super);
      }
      return ((result == Logic.TRUE_TRUTH_VALUE) ||
          (result == Logic.DEFAULT_TRUE_TRUTH_VALUE));
    }
  }

  public static Iterator allAncestorsOfParents(Cons supers) {
    { Cons collection = Cons.copyConsList(supers);

      { LogicObject s = null;
        Cons iter000 = supers;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          s = ((LogicObject)(iter000.value));
          { LogicObject a = null;
            Iterator iter001 = LogicObject.allSupercollections(s);

            while (iter001.nextP()) {
              a = ((LogicObject)(iter001.value));
              if (!supers.memberP(a)) {
                collection = Cons.cons(a, collection);
              }
            }
          }
        }
      }
      return (collection.allocateIterator());
    }
  }

  public static Iterator allAncestorCollections(Stella_Object self, Keyword instanceordescription) {
    if (instanceordescription == Logic.KWD_INSTANCE) {
      return (Logic.allAncestorsOfParents(Logic.allIsaCollections(self)));
    }
    else if (instanceordescription == Logic.KWD_DESCRIPTION) {
      return (LogicObject.allSupercollections(((LogicObject)(self))));
    }
    else {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        stream000.nativeStream.print("`" + instanceordescription + "' is not a valid case option");
        throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
      }
    }
  }

  public static LogicObject collectionWithFewestChildren(Cons collections) {
    if (collections.rest == null) {
      return (((LogicObject)(collections.value)));
    }
    { LogicObject bestcollection = ((LogicObject)(collections.value));
      int lowestchildcount = 100;

      { LogicObject c = null;
        Cons iter000 = collections;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          c = ((LogicObject)(iter000.value));
          { int childcount = 0;

            { ConsIterator p = LogicObject.applicableRulesOfDescription(c, Logic.KWD_BACKWARD, true).allocateIterator();

              while (p.nextP()) {
                childcount = childcount + 1;
              }
            }
            if (childcount < lowestchildcount) {
              bestcollection = c;
              lowestchildcount = childcount;
            }
          }
        }
      }
      return (bestcollection);
    }
  }

  public static LogicObject chooseBestDownclassifiedParent(Cons parents) {
    if (parents == Stella.NIL) {
      return (null);
    }
    { Cons downclassifiedparents = Stella.NIL;
      LogicObject bestparent = null;

      { LogicObject p = null;
        Cons iter000 = parents;
        Cons collect000 = null;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          p = ((LogicObject)(iter000.value));
          if (LogicObject.downclassifiedP(p)) {
            {
            }
            if (collect000 == null) {
              {
                collect000 = Cons.cons(p, Stella.NIL);
                if (downclassifiedparents == Stella.NIL) {
                  downclassifiedparents = collect000;
                }
                else {
                  Cons.addConsToEndOfConsList(downclassifiedparents, collect000);
                }
              }
            }
            else {
              {
                collect000.rest = Cons.cons(p, Stella.NIL);
                collect000 = collect000.rest;
              }
            }
          }
        }
      }
      switch (downclassifiedparents.length()) {
        case 0: 
          { Cons namedparents = Stella.NIL;

            { LogicObject p = null;
              Cons iter001 = parents;
              Cons collect001 = null;

              for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                p = ((LogicObject)(iter001.value));
                if (Description.namedDescriptionP(((Description)(p)))) {
                  if (collect001 == null) {
                    {
                      collect001 = Cons.cons(p, Stella.NIL);
                      if (namedparents == Stella.NIL) {
                        namedparents = collect001;
                      }
                      else {
                        Cons.addConsToEndOfConsList(namedparents, collect001);
                      }
                    }
                  }
                  else {
                    {
                      collect001.rest = Cons.cons(p, Stella.NIL);
                      collect001 = collect001.rest;
                    }
                  }
                }
              }
            }
            if (!(namedparents == Stella.NIL)) {
              bestparent = Logic.collectionWithFewestChildren(namedparents);
            }
            if (bestparent == null) {
              bestparent = Logic.collectionWithFewestChildren(parents);
            }
            LogicObject.downclassifyOneDescription(bestparent);
          }
        break;
        case 1: 
          bestparent = ((LogicObject)(downclassifiedparents.value));
        break;
        default:
          bestparent = Logic.collectionWithFewestChildren(downclassifiedparents);
        break;
      }
      if ((Stella.$TRACED_KEYWORDS$ != null) &&
          Stella.$TRACED_KEYWORDS$.membP(Logic.KWD_CLASSIFIER)) {
        Stella.STANDARD_OUTPUT.nativeStream.println("   BEST PARENT:   " + bestparent + "   ALL-PARENTS: " + parents);
      }
      return (bestparent);
    }
  }

  /** Classify 'self' and return a list of most specific 
   * named descriptions among all descriptions that it satisfies.
   * @param self
   * @return Cons
   */
  public static Cons findDirectSupersOfInstance(Stella_Object self) {
    Logic.finalizeObjects();
    if (self == null) {
      return (Stella.NIL);
    }
    { Object old$Classificationsession$000 = Logic.$CLASSIFICATIONSESSION$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setSpecial(Logic.$CLASSIFICATIONSESSION$, Logic.getClassificationSession(Logic.KWD_INSTANCE));
        Native.setSpecial(Stella.$CONTEXT$, ((ClassificationSession)(Logic.$CLASSIFICATIONSESSION$.get())).classificationWorld);
        LogicObject.upclassifyOneInstance(((LogicObject)(self)));
        return (Logic.mostSpecificNamedCollections(Logic.allIsaCollections(self)));

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Logic.$CLASSIFICATIONSESSION$.set(old$Classificationsession$000);
      }
    }
  }

  /** Classify named descriptions local to 'module' and inherited
   * by 'module'.  If 'local?', don't classify inherited descriptions.  If
   * 'module' is NULL, classify descriptions in all modules.
   * @param module
   * @param localP
   */
  public static void upclassifyNamedDescriptions(Module module, boolean localP) {
    { Object old$Classificationsession$000 = Logic.$CLASSIFICATIONSESSION$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setSpecial(Logic.$CLASSIFICATIONSESSION$, Logic.getClassificationSession(Logic.KWD_DESCRIPTION));
        Native.setSpecial(Stella.$CONTEXT$, ((ClassificationSession)(Logic.$CLASSIFICATIONSESSION$.get())).classificationWorld);
        { Object old$Module$000 = Stella.$MODULE$.get();
          Object old$Context$001 = Stella.$CONTEXT$.get();

          try {
            Native.setSpecial(Stella.$MODULE$, ((module == null) ? ((Module)(Stella.$MODULE$.get())) : module));
            Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
            if (module == null) {
              Logic.upclassifyAllDescriptions();
            }
            else if (localP) {
              { NamedDescription d = null;
                Iterator iter000 = Logic.allNamedDescriptions(module, true);

                while (iter000.nextP()) {
                  d = ((NamedDescription)(iter000.value));
                  LogicObject.upclassifyOneDescription(d);
                }
              }
            }
            else {
              { ClassificationSession session = ((ClassificationSession)(Logic.$CLASSIFICATIONSESSION$.get()));

                if (!session.everythingClassifiedP) {
                  { Module m = null;
                    Iterator iter001 = Module.allIncludedModules(module);

                    while (iter001.nextP()) {
                      m = ((Module)(iter001.value));
                      { NamedDescription d = null;
                        Iterator iter002 = Logic.allNamedDescriptions(m, true);

                        while (iter002.nextP()) {
                          d = ((NamedDescription)(iter002.value));
                          LogicObject.upclassifyOneDescription(d);
                        }
                      }
                    }
                  }
                  session.everythingClassifiedP = true;
                }
              }
            }

          } finally {
            Stella.$CONTEXT$.set(old$Context$001);
            Stella.$MODULE$.set(old$Module$000);
          }
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Logic.$CLASSIFICATIONSESSION$.set(old$Classificationsession$000);
      }
    }
  }

  /** Classify relations visible in the module defined by the :module option (which
   * defaults to the current module).  If :module was explicitly specified as NULL,
   * classify relations in all modules.  If <code>ClocalP</code> is specified as TRUE only classify
   * relations that belong to the specified module but not any modules it inherits.  For
   * backwards compatibility, this command also supports the old &lt;module&gt; &lt;local?&gt;
   * arguments specified without keywords.
   * <p>
   * Conceptually, the classifier operates by comparing each concept or relation
   * with all other concepts/relations, searching for a proof that a
   * subsumption relation exists between each pair. Whenever a new subsumption
   * relation is discovered, the classifier adds an <code>implication</code> link between
   * members of the pair, thereby augmenting the structure of the
   * concept or relation hierarchy. The implemented classification algorithm is
   * relatively efficient -- it works hard at limiting the number of concepts
   * or relations that need to be checked for possible subsumption
   * relationships.
   * 
   * @param options
   */
  public static void classifyRelations(Cons options) {
    Logic.finalizeObjects();
    { Cons optionslist = options;
      PropertyList theoptions = Stella_Object.parseOptions((Stella_Object.keywordP(optionslist.value) ? optionslist : Cons.consList(Cons.cons(Logic.KWD_MODULE, Cons.cons(optionslist.value, Cons.cons(Logic.KWD_LOCALp, Cons.cons(optionslist.rest.value, Stella.NIL)))))), Cons.list$(Cons.cons(Logic.KWD_MODULE, Cons.cons(Logic.SGT_STELLA_MODULE, Cons.cons(Logic.KWD_LOCALp, Cons.cons(Logic.SGT_STELLA_BOOLEAN, Cons.cons(Stella.NIL, Stella.NIL)))))), true, false);
      Module themodule = ((Module)(theoptions.lookupWithDefault(Logic.KWD_MODULE, null)));
      boolean localP = BooleanWrapper.coerceWrappedBooleanToBoolean(((BooleanWrapper)(theoptions.lookupWithDefault(Logic.KWD_LOCALp, Stella.FALSE_WRAPPER))));

      if ((themodule == null) &&
          (!optionslist.memberP(Logic.KWD_MODULE))) {
        themodule = ((Module)(Stella.$MODULE$.get()));
      }
      Logic.upclassifyNamedDescriptions(themodule, localP);
    }
  }

  public static void classifyRelationsEvaluatorWrapper(Cons arguments) {
    Logic.classifyRelations(arguments);
  }

  /** Collect all named description in the module defined by the :module option (which defaults
   * to the current module) that were not (or will not be) classified due to their lack of
   * non-inferable/primitive ancestor relations.  If :module was explicitly specified as NULL,
   * look in all currently defined modules.  If <code>ClocalP</code> is specified as TRUE only look
   * in the specified module but not any modules it inherits.  For backwards compatibility,
   * this command also supports the old &lt;module&gt; &lt;local?&gt; arguments specified without keywords.
   * @param options
   * @return Cons
   */
  public static Cons listUnclassifiedRelations(Cons options) {
    if (!((Boolean)(Logic.$CLASSIFY_FROM_NON_INFERABLE_PARENTS_ONLYp$.get())).booleanValue()) {
      return (Stella.NIL);
    }
    Logic.finalizeObjects();
    { Cons optionslist = options;
      PropertyList theoptions = Stella_Object.parseOptions((Stella_Object.keywordP(optionslist.value) ? optionslist : Cons.consList(Cons.cons(Logic.KWD_MODULE, Cons.cons(optionslist.value, Cons.cons(Logic.KWD_LOCALp, Cons.cons(optionslist.rest.value, Stella.NIL)))))), Cons.list$(Cons.cons(Logic.KWD_MODULE, Cons.cons(Logic.SGT_STELLA_MODULE, Cons.cons(Logic.KWD_LOCALp, Cons.cons(Logic.SGT_STELLA_BOOLEAN, Cons.cons(Stella.NIL, Stella.NIL)))))), true, false);
      Module themodule = ((Module)(theoptions.lookupWithDefault(Logic.KWD_MODULE, null)));
      boolean localP = BooleanWrapper.coerceWrappedBooleanToBoolean(((BooleanWrapper)(theoptions.lookupWithDefault(Logic.KWD_LOCALp, Stella.FALSE_WRAPPER))));
      Cons unclassified = Stella.NIL;

      if ((themodule == null) &&
          (!optionslist.memberP(Logic.KWD_MODULE))) {
        themodule = ((Module)(Stella.$MODULE$.get()));
      }
      { Object old$Classificationsession$000 = Logic.$CLASSIFICATIONSESSION$.get();
        Object old$Context$000 = Stella.$CONTEXT$.get();

        try {
          Native.setSpecial(Logic.$CLASSIFICATIONSESSION$, Logic.getClassificationSession(Logic.KWD_DESCRIPTION));
          Native.setSpecial(Stella.$CONTEXT$, ((ClassificationSession)(Logic.$CLASSIFICATIONSESSION$.get())).classificationWorld);
          { Object old$Module$000 = Stella.$MODULE$.get();
            Object old$Context$001 = Stella.$CONTEXT$.get();

            try {
              Native.setSpecial(Stella.$MODULE$, ((themodule == null) ? ((Module)(Stella.$MODULE$.get())) : themodule));
              Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
              { NamedDescription d = null;
                Iterator iter000 = Logic.allNamedDescriptions(themodule, localP);
                Cons collect000 = null;

                while (iter000.nextP()) {
                  d = ((NamedDescription)(iter000.value));
                  { boolean testValue000 = false;

                    testValue000 = Description.inferableP(d);
                    if (testValue000) {
                      { boolean foundP000 = false;

                        { LogicObject renamed_Super = null;
                          Iterator iter001 = Logic.allAncestorCollections(d, Logic.KWD_DESCRIPTION);

                          loop001 : while (iter001.nextP()) {
                            renamed_Super = ((LogicObject)(iter001.value));
                            if (Description.nonInferableP(((Description)(renamed_Super)))) {
                              foundP000 = true;
                              break loop001;
                            }
                          }
                        }
                        testValue000 = foundP000;
                      }
                      testValue000 = !testValue000;
                    }
                    if (testValue000) {
                      if (collect000 == null) {
                        {
                          collect000 = Cons.cons(d, Stella.NIL);
                          if (unclassified == Stella.NIL) {
                            unclassified = collect000;
                          }
                          else {
                            Cons.addConsToEndOfConsList(unclassified, collect000);
                          }
                        }
                      }
                      else {
                        {
                          collect000.rest = Cons.cons(d, Stella.NIL);
                          collect000 = collect000.rest;
                        }
                      }
                    }
                  }
                }
              }

            } finally {
              Stella.$CONTEXT$.set(old$Context$001);
              Stella.$MODULE$.set(old$Module$000);
            }
          }

        } finally {
          Stella.$CONTEXT$.set(old$Context$000);
          Logic.$CLASSIFICATIONSESSION$.set(old$Classificationsession$000);
        }
      }
      return (unclassified);
    }
  }

  public static Cons listUnclassifiedRelationsEvaluatorWrapper(Cons arguments) {
    return (Logic.listUnclassifiedRelations(arguments));
  }

  /** Classify instances local to 'module' and inherited
   * by 'module'.  If 'local?', don't classify inherited descriptions.  If
   * 'module' is NULL, classify descriptions in all modules.
   * @param module
   * @param localP
   */
  public static void upclassifyInstances(Module module, boolean localP) {
    { Object old$Classificationsession$000 = Logic.$CLASSIFICATIONSESSION$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setSpecial(Logic.$CLASSIFICATIONSESSION$, Logic.getClassificationSession(Logic.KWD_INSTANCE));
        Native.setSpecial(Stella.$CONTEXT$, ((ClassificationSession)(Logic.$CLASSIFICATIONSESSION$.get())).classificationWorld);
        { Object old$Module$000 = Stella.$MODULE$.get();
          Object old$Context$001 = Stella.$CONTEXT$.get();

          try {
            Native.setSpecial(Stella.$MODULE$, ((module == null) ? ((Module)(Stella.$MODULE$.get())) : module));
            Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
            if (module == null) {
              Logic.upclassifyAllInstances();
            }
            else if (localP) {
              { LogicObject i = null;
                Iterator iter000 = Logic.allInstances(module, true);

                while (iter000.nextP()) {
                  i = ((LogicObject)(iter000.value));
                  LogicObject.upclassifyOneInstance(i);
                }
              }
            }
            else {
              { Module m = null;
                Iterator iter001 = Module.allIncludedModules(module);

                while (iter001.nextP()) {
                  m = ((Module)(iter001.value));
                  { LogicObject i = null;
                    Iterator iter002 = Logic.allInstances(m, true);

                    while (iter002.nextP()) {
                      i = ((LogicObject)(iter002.value));
                      LogicObject.upclassifyOneInstance(i);
                    }
                  }
                }
              }
            }

          } finally {
            Stella.$CONTEXT$.set(old$Context$001);
            Stella.$MODULE$.set(old$Module$000);
          }
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Logic.$CLASSIFICATIONSESSION$.set(old$Classificationsession$000);
      }
    }
  }

  /** Classify instances visible in the module defined by the :module option (which
   * defaults to the current module).  If :module was explicitly specified as NULL,
   * classify instances in all modules.  If <code>ClocalP</code> is specified as TRUE only classify
   * instances that belong to the specified module but not any modules it inherits.  For
   * backwards compatibility, this command also supports the old &lt;module&gt; &lt;local?&gt;
   * arguments specified without keywords.
   * <p>
   * Conceptually, the classifier operates by comparing each instance with all
   * concepts in the hierarchy, searching for a proof for each pairing indicating
   * that the instance belongs to the concept.  Whenever a new <code>isA</code> relation is
   * discovered, the classifier adds an <code>isA</code> link between the instance and the
   * concept, thereby recording an additional fact about the instance.  The
   * implemented classification algorithm is relatively efficient -- it works hard at
   * limiting the number of concepts or relations that need to be checked for
   * possible is-a relationships.
   * 
   * @param options
   */
  public static void classifyInstances(Cons options) {
    Logic.finalizeObjects();
    { Cons optionslist = options;
      PropertyList theoptions = Stella_Object.parseOptions((Stella_Object.keywordP(optionslist.value) ? optionslist : Cons.consList(Cons.cons(Logic.KWD_MODULE, Cons.cons(optionslist.value, Cons.cons(Logic.KWD_LOCALp, Cons.cons(optionslist.rest.value, Stella.NIL)))))), Cons.list$(Cons.cons(Logic.KWD_MODULE, Cons.cons(Logic.SGT_STELLA_MODULE, Cons.cons(Logic.KWD_LOCALp, Cons.cons(Logic.SGT_STELLA_BOOLEAN, Cons.cons(Stella.NIL, Stella.NIL)))))), true, false);
      Module themodule = ((Module)(theoptions.lookupWithDefault(Logic.KWD_MODULE, null)));
      boolean localP = BooleanWrapper.coerceWrappedBooleanToBoolean(((BooleanWrapper)(theoptions.lookupWithDefault(Logic.KWD_LOCALp, Stella.FALSE_WRAPPER))));

      if ((themodule == null) &&
          (!optionslist.memberP(Logic.KWD_MODULE))) {
        themodule = ((Module)(Stella.$MODULE$.get()));
      }
      Logic.upclassifyInstances(themodule, localP);
    }
  }

  public static void classifyInstancesEvaluatorWrapper(Cons arguments) {
    Logic.classifyInstances(arguments);
  }

  /** Collect all instances in the module defined by the :module option (which defaults
   * to the current module) that were not (or will not be) classified due to their lack of
   * non-inferable/primitive type assertions.  If :module was explicitly specified as NULL,
   * look in all currently defined modules.  If <code>ClocalP</code> is specified as TRUE only look
   * in the specified module but not any modules it inherits.  For backwards compatibility,
   * this command also supports the old &lt;module&gt; &lt;local?&gt; arguments specified without keywords.
   * @param options
   * @return Cons
   */
  public static Cons listUnclassifiedInstances(Cons options) {
    if (!((Boolean)(Logic.$CLASSIFY_FROM_NON_INFERABLE_PARENTS_ONLYp$.get())).booleanValue()) {
      return (Stella.NIL);
    }
    Logic.finalizeObjects();
    { Cons optionslist = options;
      PropertyList theoptions = Stella_Object.parseOptions((Stella_Object.keywordP(optionslist.value) ? optionslist : Cons.consList(Cons.cons(Logic.KWD_MODULE, Cons.cons(optionslist.value, Cons.cons(Logic.KWD_LOCALp, Cons.cons(optionslist.rest.value, Stella.NIL)))))), Cons.list$(Cons.cons(Logic.KWD_MODULE, Cons.cons(Logic.SGT_STELLA_MODULE, Cons.cons(Logic.KWD_LOCALp, Cons.cons(Logic.SGT_STELLA_BOOLEAN, Cons.cons(Stella.NIL, Stella.NIL)))))), true, false);
      Module themodule = ((Module)(theoptions.lookupWithDefault(Logic.KWD_MODULE, null)));
      boolean localP = BooleanWrapper.coerceWrappedBooleanToBoolean(((BooleanWrapper)(theoptions.lookupWithDefault(Logic.KWD_LOCALp, Stella.FALSE_WRAPPER))));
      Cons unclassified = Stella.NIL;

      if ((themodule == null) &&
          (!optionslist.memberP(Logic.KWD_MODULE))) {
        themodule = ((Module)(Stella.$MODULE$.get()));
      }
      { Object old$Classificationsession$000 = Logic.$CLASSIFICATIONSESSION$.get();
        Object old$Context$000 = Stella.$CONTEXT$.get();

        try {
          Native.setSpecial(Logic.$CLASSIFICATIONSESSION$, Logic.getClassificationSession(Logic.KWD_INSTANCE));
          Native.setSpecial(Stella.$CONTEXT$, ((ClassificationSession)(Logic.$CLASSIFICATIONSESSION$.get())).classificationWorld);
          { Object old$Module$000 = Stella.$MODULE$.get();
            Object old$Context$001 = Stella.$CONTEXT$.get();

            try {
              Native.setSpecial(Stella.$MODULE$, ((themodule == null) ? ((Module)(Stella.$MODULE$.get())) : themodule));
              Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
              { LogicObject i = null;
                Iterator iter000 = Logic.allInstances(themodule, localP);
                Cons collect000 = null;

                while (iter000.nextP()) {
                  i = ((LogicObject)(iter000.value));
                  { boolean testValue000 = false;

                    testValue000 = !Logic.functionOutputSkolemP(i);
                    if (testValue000) {
                      { boolean foundP000 = false;

                        { LogicObject type = null;
                          Iterator iter001 = Logic.allAncestorCollections(i, Logic.KWD_INSTANCE);

                          loop001 : while (iter001.nextP()) {
                            type = ((LogicObject)(iter001.value));
                            if (Description.nonInferableP(((Description)(type)))) {
                              foundP000 = true;
                              break loop001;
                            }
                          }
                        }
                        testValue000 = foundP000;
                      }
                      testValue000 = !testValue000;
                    }
                    if (testValue000) {
                      if (collect000 == null) {
                        {
                          collect000 = Cons.cons(i, Stella.NIL);
                          if (unclassified == Stella.NIL) {
                            unclassified = collect000;
                          }
                          else {
                            Cons.addConsToEndOfConsList(unclassified, collect000);
                          }
                        }
                      }
                      else {
                        {
                          collect000.rest = Cons.cons(i, Stella.NIL);
                          collect000 = collect000.rest;
                        }
                      }
                    }
                  }
                }
              }

            } finally {
              Stella.$CONTEXT$.set(old$Context$001);
              Stella.$MODULE$.set(old$Module$000);
            }
          }

        } finally {
          Stella.$CONTEXT$.set(old$Context$000);
          Logic.$CLASSIFICATIONSESSION$.set(old$Classificationsession$000);
        }
      }
      return (unclassified);
    }
  }

  public static Cons listUnclassifiedInstancesEvaluatorWrapper(Cons arguments) {
    return (Logic.listUnclassifiedInstances(arguments));
  }

  /** Classify all named descriptions.
   */
  public static void upclassifyAllDescriptions() {
    Logic.finalizeObjects();
    { Object old$Classificationsession$000 = Logic.$CLASSIFICATIONSESSION$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setSpecial(Logic.$CLASSIFICATIONSESSION$, Logic.getClassificationSession(Logic.KWD_DESCRIPTION));
        Native.setSpecial(Stella.$CONTEXT$, ((ClassificationSession)(Logic.$CLASSIFICATIONSESSION$.get())).classificationWorld);
        { NamedDescription d = null;
          Iterator iter000 = Logic.allNamedDescriptions(null, false);

          while (iter000.nextP()) {
            d = ((NamedDescription)(iter000.value));
            LogicObject.upclassifyOneDescription(d);
          }
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Logic.$CLASSIFICATIONSESSION$.set(old$Classificationsession$000);
      }
    }
  }

  /** Classify all named instances.
   */
  public static void upclassifyAllInstances() {
    Logic.finalizeObjects();
    { Object old$Classificationsession$000 = Logic.$CLASSIFICATIONSESSION$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setSpecial(Logic.$CLASSIFICATIONSESSION$, Logic.getClassificationSession(Logic.KWD_INSTANCE));
        Native.setSpecial(Stella.$CONTEXT$, ((ClassificationSession)(Logic.$CLASSIFICATIONSESSION$.get())).classificationWorld);
        { LogicObject i = null;
          Iterator iter000 = Logic.allInstances(null, false);

          while (iter000.nextP()) {
            i = ((LogicObject)(iter000.value));
            LogicObject.upclassifyOneInstance(i);
          }
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Logic.$CLASSIFICATIONSESSION$.set(old$Classificationsession$000);
      }
    }
  }

  /** Return a list of lists of descriptions that are
   * provably co-extensional.
   * @param module
   * @param localP
   * @return Cons
   */
  public static Cons allCycles(Module module, boolean localP) {
    return (null);
  }

  /** Print the currently enabled and available PowerLoom environment features.
   */
  public static void printFeatures() {
    {
      Stella.STANDARD_OUTPUT.nativeStream.println("Currently enabled PowerLoom features:");
      Stella.STANDARD_OUTPUT.nativeStream.println("   " + Logic.$CURRENT_POWERLOOM_FEATURES$);
      Stella.STANDARD_OUTPUT.nativeStream.println();
      Stella.STANDARD_OUTPUT.nativeStream.println("Available PowerLoom features:");
      Stella.STANDARD_OUTPUT.nativeStream.println("   " + Logic.$AVAILABLE_POWERLOOM_FEATURES$);
    }
;
  }

  /** Return a list containing two lists, a list of currently enabled PowerLoom
   * features, and a list of all available PowerLoom features.
   * @return List
   */
  public static List listFeatures() {
    return (List.list(Cons.cons(Logic.$CURRENT_POWERLOOM_FEATURES$, Cons.cons(Logic.$AVAILABLE_POWERLOOM_FEATURES$, Stella.NIL))));
  }

  /** Enable the PowerLoom environment feature <code>feature</code>.
   * @param feature
   */
  public static void setPowerloomFeature(Keyword feature) {
    if (!(Logic.$CURRENT_POWERLOOM_FEATURES$.memberP(feature))) {
      if (feature == Logic.KWD_TRACE_SUBGOALS) {
        Logic.clearCaches();
        Stella.addTrace(Cons.cons(Logic.KWD_GOAL_TREE, Stella.NIL));
      }
      else if (feature == Logic.KWD_TRACE_SOLUTIONS) {
        Logic.clearCaches();
        Stella.addTrace(Cons.cons(Logic.KWD_TRACE_SOLUTIONS, Stella.NIL));
      }
      else if (feature == Logic.KWD_TRACE_CLASSIFIER) {
        Logic.clearCaches();
        Stella.addTrace(Cons.cons(Logic.KWD_CLASSIFIER_INFERENCES, Stella.NIL));
      }
      else if (feature == Logic.KWD_CLOSED_WORLD) {
      }
      else if (feature == Logic.KWD_ITERATIVE_DEEPENING) {
        Logic.$ITERATIVE_DEEPENING_MODEp$ = true;
      }
      else if (feature == Logic.KWD_JUSTIFICATIONS) {
        Native.setBooleanSpecial(Logic.$RECORD_JUSTIFICATIONSp$, true);
      }
      else if (feature == Logic.KWD_JUST_IN_TIME_INFERENCE) {
        Logic.$JUST_IN_TIME_FORWARD_INFERENCEp$ = true;
      }
      else if (feature == Logic.KWD_EMIT_THINKING_DOTS) {
        Logic.$EMIT_THINKING_DOTSp$ = true;
      }
      else {
        Stella.STANDARD_WARNING.nativeStream.println("Warning: No such PowerLoom environment feature: `" + feature + "'");
        Logic.printFeatures();
        return;
      }
      Logic.$CURRENT_POWERLOOM_FEATURES$.insert(feature);
    }
  }

  /** Enable the PowerLoom environment feature(s) named by <code>features</code>.
   * Return the list of enabled features.  Calling <code>setFeature</code> without any
   * arguments can be used to display the currently enabled features.
   * The following features are supported:
   * <p>
   * <code>justInTimeInference</code>: Enables interleaving of forward chaining inference
   * within backward chaining queries.
   * <p>
   * <code>iterativeDeepening</code>: Tells the query processor to use iterative deepening
   * instead of a depth-first search to find answers.  This is less efficient
   * but necessary for some kinds of highly recursive queries.
   * <p>
   * <code>traceSubgoals</code>: Enables the generation of subgoaling trace information during
   * backchaining inference.
   * <p>
   * <code>traceSolutions</code>: Prints newly found solutions during retrieval right when they
   * are generated as opposed to when the query terminates.
   * <p>
   * <code>traceClassifier</code>: Tells the classifier to describe the inferences it draws.
   * <p>
   * <code>justifications</code>: Enables the generation of justifications during inference,
   * which is a prerequiste for the generation of explanations with <code>_why_</code>.
   * <p>
   * <code>emitThinkingDots</code>: Tells PowerLoom to annotate its inference progress by
   * outputting characters indicating the completion of individual reasoning steps.
   * <p>
   * By default, the features <code>emitThinkingDots</code> and <code>justInTimeInference</code>
   * are enabled, and the others are disabled.
   * 
   * @param features
   * @return List
   */
  public static List setFeature(Cons features) {
    try {
      { Stella_Object featurename = null;
        Cons iter000 = features;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          featurename = iter000.value;
          Logic.setPowerloomFeature(Stella.string_keywordify(Stella_Object.coerceToString(featurename)));
        }
      }
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
    }
    return (Logic.$CURRENT_POWERLOOM_FEATURES$);
  }

  public static List setFeatureEvaluatorWrapper(Cons arguments) {
    return (Logic.setFeature(arguments));
  }

  /** Disable the PowerLoom environment feature <code>feature</code>.
   * @param feature
   */
  public static void unsetPowerloomFeature(Keyword feature) {
    if (Logic.$CURRENT_POWERLOOM_FEATURES$.memberP(feature)) {
      if (feature == Logic.KWD_TRACE_SUBGOALS) {
        Stella.dropTrace(Cons.cons(Logic.KWD_GOAL_TREE, Stella.NIL));
      }
      else if (feature == Logic.KWD_TRACE_SOLUTIONS) {
        Stella.dropTrace(Cons.cons(Logic.KWD_TRACE_SOLUTIONS, Stella.NIL));
      }
      else if (feature == Logic.KWD_TRACE_CLASSIFIER) {
        Stella.dropTrace(Cons.cons(Logic.KWD_CLASSIFIER_INFERENCES, Stella.NIL));
      }
      else if (feature == Logic.KWD_CLOSED_WORLD) {
      }
      else if (feature == Logic.KWD_ITERATIVE_DEEPENING) {
        Logic.$ITERATIVE_DEEPENING_MODEp$ = false;
      }
      else if (feature == Logic.KWD_JUSTIFICATIONS) {
        Native.setBooleanSpecial(Logic.$RECORD_JUSTIFICATIONSp$, false);
      }
      else if (feature == Logic.KWD_JUST_IN_TIME_INFERENCE) {
        Logic.$JUST_IN_TIME_FORWARD_INFERENCEp$ = false;
      }
      else if (feature == Logic.KWD_EMIT_THINKING_DOTS) {
        Logic.$EMIT_THINKING_DOTSp$ = false;
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + feature + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
    else {
      if (!Logic.$AVAILABLE_POWERLOOM_FEATURES$.memberP(feature)) {
        Stella.STANDARD_WARNING.nativeStream.println("Warning: No such PowerLoom environment feature: `" + feature + "'");
        Logic.printFeatures();
      }
    }
    Logic.$CURRENT_POWERLOOM_FEATURES$.remove(feature);
  }

  /** Disable the PowerLoom environment feature(s) named by <code>features</code>.
   * Return the list of enabled features.  Calling <code>unsetFeature</code> without any
   * arguments can be used to display the currently enabled features.
   * See <code>setFeature</code> for a description of supported features.
   * @param features
   * @return List
   */
  public static List unsetFeature(Cons features) {
    try {
      { Stella_Object featurename = null;
        Cons iter000 = features;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          featurename = iter000.value;
          Logic.unsetPowerloomFeature(Stella.string_keywordify(Stella_Object.coerceToString(featurename)));
        }
      }
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
    }
    return (Logic.$CURRENT_POWERLOOM_FEATURES$);
  }

  public static List unsetFeatureEvaluatorWrapper(Cons arguments) {
    return (Logic.unsetFeature(arguments));
  }

  /** Reset the PowerLoom environment features to their default settings.
   * @return List
   */
  public static List resetFeatures() {
    { Keyword f = null;
      Cons iter000 = Logic.$CURRENT_POWERLOOM_FEATURES$.copy().theConsList;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        f = ((Keyword)(iter000.value));
        if (!Logic.$DEFAULT_POWERLOOM_FEATURES$.memberP(f)) {
          Logic.unsetPowerloomFeature(f);
        }
      }
    }
    { Keyword f = null;
      Cons iter001 = Logic.$DEFAULT_POWERLOOM_FEATURES$.theConsList;

      for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
        f = ((Keyword)(iter001.value));
        if (!Logic.$CURRENT_POWERLOOM_FEATURES$.memberP(f)) {
          Logic.setPowerloomFeature(f);
        }
      }
    }
    return (Logic.$CURRENT_POWERLOOM_FEATURES$);
  }

  /** Return true if the STELLA <code>feature</code> is currently enabled.
   * @param feature
   * @return boolean
   */
  public static boolean enabledPowerloomFeatureP(Keyword feature) {
    return (Logic.$CURRENT_POWERLOOM_FEATURES$.membP(feature));
  }

  /** Return true if the STELLA <code>feature</code> is currently disabled.
   * @param feature
   * @return boolean
   */
  public static boolean disabledPowerloomFeatureP(Keyword feature) {
    return (!Logic.$CURRENT_POWERLOOM_FEATURES$.membP(feature));
  }

  public static PropertyList parseLogicCommandOptions(Stella_Object options, Cons legaloptionsAtypes, boolean coercionerrorP, boolean allowotherkeysP) {
    return (Stella_Object.parseOptions(options, legaloptionsAtypes, coercionerrorP, allowotherkeysP));
  }

  public static void printLogicPrompt() {
    if (((Boolean)(Logic.$PROMPT_SHOW_MODULEp$.get())).booleanValue()) {
      Stella.STANDARD_OUTPUT.nativeStream.print(((Module)(Stella.$MODULE$.get())).moduleName + " ");
    }
    Stella.STANDARD_OUTPUT.nativeStream.print(Logic.$LOGIC_PROMPT$);
  }

  public static void printLogicCommandResult(Stella_Object result) {
    { World temp000 = Logic.lookupConstraintPropagationWorld(((Context)(Stella.$CONTEXT$.get())));

      { Context printcontext = ((temp000 != null) ? temp000 : ((Context)(Stella.$CONTEXT$.get())));

        { Object old$Printmode$000 = Logic.$PRINTMODE$.get();
          Object old$PrettyprintlogicalformsP$000 = Logic.$PRETTYPRINTLOGICALFORMSp$.get();
          Object old$Context$000 = Stella.$CONTEXT$.get();

          try {
            Native.setSpecial(Logic.$PRINTMODE$, Logic.KWD_REALISTIC);
            Native.setBooleanSpecial(Logic.$PRETTYPRINTLOGICALFORMSp$, true);
            Native.setSpecial(Stella.$CONTEXT$, printcontext);
            if (result != null) {
              Stella.STANDARD_OUTPUT.nativeStream.println(Logic.$LOGIC_COMMAND_RESULT_INDENT$ + result);
            }

          } finally {
            Stella.$CONTEXT$.set(old$Context$000);
            Logic.$PRETTYPRINTLOGICALFORMSp$.set(old$PrettyprintlogicalformsP$000);
            Logic.$PRINTMODE$.set(old$Printmode$000);
          }
        }
      }
    }
  }

  public static boolean logicCommandLoopExitP(Stella_Object command, Object [] MV_returnarray) {
    { boolean exitP = false;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(command);

        if (Surrogate.subtypeOfKeywordP(testValue000)) {
          { Keyword command000 = ((Keyword)(command));

            if ((command000 == Logic.KWD_BYE) ||
                ((command000 == Logic.KWD_EXIT) ||
                 ((command000 == Logic.KWD_HALT) ||
                  ((command000 == Logic.KWD_QUIT) ||
                   (command000 == Logic.KWD_STOP))))) {
              exitP = true;
            }
            else {
            }
          }
        }
        else if (Surrogate.subtypeOfSymbolP(testValue000)) {
          { Symbol command000 = ((Symbol)(command));

            { String testValue001 = command000.symbolName;

              if (Stella.stringEqlP(testValue001, "BYE") ||
                  (Stella.stringEqlP(testValue001, "EXIT") ||
                   (Stella.stringEqlP(testValue001, "HALT") ||
                    (Stella.stringEqlP(testValue001, "QUIT") ||
                     (Stella.stringEqlP(testValue001, "STOP") ||
                      (Stella.stringEqlP(testValue001, "bye") ||
                       (Stella.stringEqlP(testValue001, "exit") ||
                        (Stella.stringEqlP(testValue001, "halt") ||
                         (Stella.stringEqlP(testValue001, "quit") ||
                          Stella.stringEqlP(testValue001, "stop")))))))))) {
                exitP = true;
              }
              else {
              }
            }
          }
        }
        else {
        }
      }
      if (exitP &&
          ((Boolean)(Logic.$CAREFUL_LOGIC_COMMAND_LOOP_EXIT$p.get())).booleanValue()) {
        exitP = Stella.yesOrNoP("Really exit? (yes or no) ");
        if (exitP) {
          Stella.STANDARD_OUTPUT.nativeStream.println();
        }
        { boolean _return_temp = exitP;

          MV_returnarray[0] = BooleanWrapper.wrapBoolean(true);
          return (_return_temp);
        }
      }
      { boolean _return_temp = exitP;

        MV_returnarray[0] = BooleanWrapper.wrapBoolean(exitP);
        return (_return_temp);
      }
    }
  }

  public static void logicCommandLoop(Module module) {
    { Stella_Object command = null;
      Stella_Object result = null;
      boolean eofP = false;
      boolean exitP = false;
      boolean exitcommandP = false;

      { Object old$Module$000 = Stella.$MODULE$.get();
        Object old$Context$000 = Stella.$CONTEXT$.get();

        try {
          Native.setSpecial(Stella.$MODULE$, ((module != null) ? module : ((Module)(Stella.$MODULE$.get()))));
          Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
          loop000 : for (;;) {
            try {
              Stella.STANDARD_OUTPUT.nativeStream.println();
              Logic.printLogicPrompt();
              { Object [] caller_MV_returnarray = new Object[1];

                command = InputStream.readSExpression(Stella.STANDARD_INPUT, caller_MV_returnarray);
                eofP = ((boolean)(((BooleanWrapper)(caller_MV_returnarray[0])).wrapperValue));
              }
              if (eofP) {
                Stella.STANDARD_OUTPUT.nativeStream.println("End of File encountered.  Exiting.");
                break loop000;
              }
              Stella.STANDARD_OUTPUT.nativeStream.println();
              { Object [] caller_MV_returnarray = new Object[1];

                exitP = Logic.logicCommandLoopExitP(command, caller_MV_returnarray);
                exitcommandP = ((boolean)(((BooleanWrapper)(caller_MV_returnarray[0])).wrapperValue));
              }
              if (exitP) {
                break loop000;
              }
              if (exitcommandP) {
                continue loop000;
              }
              result = Logic.evaluateLogicCommand(command, false);
              Logic.printLogicCommandResult(result);
            } catch (LogicException le) {
              Stella.STANDARD_ERROR.nativeStream.print(">> Error: " + Stella.exceptionMessage(le));
            } catch (StellaException e) {
              Stella.STANDARD_ERROR.nativeStream.print(">> Internal Error: " + Stella.exceptionMessage(e));
              Stella.printExceptionContext(e, Stella.STANDARD_ERROR);
            }
          }

        } finally {
          Stella.$CONTEXT$.set(old$Context$000);
          Stella.$MODULE$.set(old$Module$000);
        }
      }
    }
  }

  public static Stella_Object evaluateLogicCommand(Stella_Object command, boolean finalizeP) {
    { Object old$Translationerrors$000 = Stella.$TRANSLATIONERRORS$.get();
      Object old$Translationwarnings$000 = Stella.$TRANSLATIONWARNINGS$.get();
      Object old$IgnoretranslationerrorsP$000 = Stella.$IGNORETRANSLATIONERRORSp$.get();
      Object old$Translationunits$000 = Stella.$TRANSLATIONUNITS$.get();
      Object old$Translationphase$000 = Stella.$TRANSLATIONPHASE$.get();
      Object old$Evaluationtree$000 = Stella.$EVALUATIONTREE$.get();

      try {
        Native.setIntSpecial(Stella.$TRANSLATIONERRORS$, 0);
        Native.setIntSpecial(Stella.$TRANSLATIONWARNINGS$, 0);
        Native.setBooleanSpecial(Stella.$IGNORETRANSLATIONERRORSp$, false);
        Native.setSpecial(Stella.$TRANSLATIONUNITS$, null);
        Native.setSpecial(Stella.$TRANSLATIONPHASE$, Logic.KWD_DEFINE);
        Native.setSpecial(Stella.$EVALUATIONTREE$, null);
        { Stella_Object operator = null;
          String operatorname = null;
          Stella_Object result = null;

          { Surrogate testValue000 = Stella_Object.safePrimaryType(command);

            if (testValue000 == Logic.SGT_STELLA_CONS) {
              { Cons command000 = ((Cons)(command));

                operator = command000.value;
                if (Surrogate.subtypeOfSymbolP(Stella_Object.safePrimaryType(operator))) {
                  { Symbol operator000 = ((Symbol)(operator));

                    operatorname = operator000.symbolName;
                    if (Stella.stringEqualP(operatorname, "DEFMODULE")) {
                      operator000 = Logic.SYM_STELLA_DEFMODULE;
                      command000.value = operator000;
                    }
                    if (Stella.stringEqualP(operatorname, "IN-MODULE")) {
                      Cons.handleInModuleTree(command000, false, false, new Object[1]);
                    }
                    else if (Stella.stringEqualP(operatorname, "IN-PACKAGE")) {
                    }
                    else if (Cons.declarationTreeP(command000)) {
                      Native.setSpecial(Stella.$TRANSLATIONUNITS$, List.list(Stella.NIL));
                      Cons.walkTopLevelTree(command000, false);
                      switch (((List)(Stella.$TRANSLATIONUNITS$.get())).reverse().length()) {
                        case 0: 
                          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

                            stream000.nativeStream.print("Translation failed: `" + command000 + "'");
                            throw ((EvaluationException)(EvaluationException.newEvaluationException(stream000.theStringReader()).fillInStackTrace()));
                          }
                        case 1: 
                          result = ((TranslationUnit)(((List)(Stella.$TRANSLATIONUNITS$.get())).first())).theObject;
                        break;
                        default:
                          { Cons results = Stella.NIL;

                            { TranslationUnit unit = null;
                              Cons iter000 = ((List)(Stella.$TRANSLATIONUNITS$.get())).theConsList;
                              Cons collect000 = null;

                              for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                                unit = ((TranslationUnit)(iter000.value));
                                if (collect000 == null) {
                                  {
                                    collect000 = Cons.cons(unit.theObject, Stella.NIL);
                                    if (results == Stella.NIL) {
                                      results = collect000;
                                    }
                                    else {
                                      Cons.addConsToEndOfConsList(results, collect000);
                                    }
                                  }
                                }
                                else {
                                  {
                                    collect000.rest = Cons.cons(unit.theObject, Stella.NIL);
                                    collect000 = collect000.rest;
                                  }
                                }
                              }
                            }
                            result = results;
                          }
                        break;
                      }
                    }
                    else {
                      synchronized (Logic.$POWERLOOM_LOCK$) {
                        result = Stella_Object.evaluate(command000);
                      }
                    }
                  }
                }
                else {
                  synchronized (Logic.$POWERLOOM_LOCK$) {
                    result = Stella_Object.evaluate(command000);
                  }
                }
              }
            }
            else if (Surrogate.subtypeOfKeywordP(testValue000)) {
              { Keyword command000 = ((Keyword)(command));

                result = command000;
              }
            }
            else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
              { Surrogate command000 = ((Surrogate)(command));

                result = command000;
              }
            }
            else {
              synchronized (Logic.$POWERLOOM_LOCK$) {
                result = Stella_Object.evaluate(command);
              }
            }
          }
          if ((!Stella.translationErrorsP()) &&
              finalizeP) {
            Native.setSpecial(Stella.$TRANSLATIONPHASE$, Logic.KWD_FINALIZE);
            Logic.finalizeObjects();
          }
          return (result);
        }

      } finally {
        Stella.$EVALUATIONTREE$.set(old$Evaluationtree$000);
        Stella.$TRANSLATIONPHASE$.set(old$Translationphase$000);
        Stella.$TRANSLATIONUNITS$.set(old$Translationunits$000);
        Stella.$IGNORETRANSLATIONERRORSp$.set(old$IgnoretranslationerrorsP$000);
        Stella.$TRANSLATIONWARNINGS$.set(old$Translationwarnings$000);
        Stella.$TRANSLATIONERRORS$.set(old$Translationerrors$000);
      }
    }
  }

  /** Read logic commands from <code>file</code> and evaluate them.
   * By default, this will check for each asserted proposition whether an
   * equivalent proposition already exists and, if so, not assert the
   * duplicate.  These duplicate checks are somewhat expensive though and
   * can be skipped by setting the option :check-duplicates? to false.
   * This can save time when loading large KBs where it is known that no
   * duplicate assertions exist in a file.
   * <p>
   * Also, by setting the option :module, the module in which the file
   * contents will be loaded will be set.  This will only affect files
   * that do NOT have an <code>inModule</code> declaration as part of the file.
   * If this is not set, and no <code>inModule</code> declaration is in the file,
   * then an error will be signaled.
   * @param file
   * @param options
   */
  public static void load(String file, Cons options) {
    { String temp000 = Stella.findFileInLoadPath(file, Logic.$POWERLOOM_KB_FILE_EXTENSIONS$);

      file = ((temp000 != null) ? temp000 : file);
    }
    Stella.ensureFileExists(file, "load");
    { PropertyList theoptions = Logic.parseLogicCommandOptions(options, Cons.list$(Cons.cons(Logic.KWD_CHECK_DUPLICATESp, Cons.cons(Logic.SGT_STELLA_BOOLEAN, Cons.cons(Logic.KWD_MODULE, Cons.cons(Logic.SGT_STELLA_MODULE, Cons.cons(Stella.NIL, Stella.NIL)))))), true, false);
      boolean toplevelinvocationP = ((String)(Stella.$CURRENTFILE$.get())) == null;
      InputFileStream inputstream = null;

      try {
        { Object old$Currentfile$000 = Stella.$CURRENTFILE$.get();
          Object old$DontCheckForDuplicatePropositionsP$000 = Logic.$DONT_CHECK_FOR_DUPLICATE_PROPOSITIONSp$.get();

          try {
            Native.setSpecial(Stella.$CURRENTFILE$, Stella.fileBaseName(file));
            Native.setBooleanSpecial(Logic.$DONT_CHECK_FOR_DUPLICATE_PROPOSITIONSp$, !BooleanWrapper.coerceWrappedBooleanToBoolean(((BooleanWrapper)(theoptions.lookupWithDefault(Logic.KWD_CHECK_DUPLICATESp, Stella.TRUE_WRAPPER)))));
            inputstream = InputFileStream.newInputFileStream(file);
            Logic.loadStreamInModule(inputstream, ((Module)(theoptions.lookup(Logic.KWD_MODULE))));

          } finally {
            Logic.$DONT_CHECK_FOR_DUPLICATE_PROPOSITIONSp$.set(old$DontCheckForDuplicatePropositionsP$000);
            Stella.$CURRENTFILE$.set(old$Currentfile$000);
          }
        }

      } finally {
        if (toplevelinvocationP) {
          Stella.sweepTransients();
        }
        if (inputstream != null) {
          inputstream.free();
        }
      }
    }
  }

  public static void loadEvaluatorWrapper(Cons arguments) {
    Logic.load(((StringWrapper)(arguments.value)).wrapperValue, arguments.rest);
  }

  static boolean definitionNameP(Symbol name) {
    { String nameString = name.symbolName;

      return ((nameString.length() > 2) &&
          ((nameString.charAt(0) == 'D') &&
           ((nameString.charAt(1) == 'E') &&
            (nameString.charAt(2) == 'F'))));
    }
  }

  /** Read logic commands from <code>stream</code> and evaluate them.
   * @param stream
   */
  public static void loadStream(InputStream stream) {
    Logic.loadStreamInModule(stream, null);
  }

  /** Read logic commands from <code>stream</code> and evaluate them.  If <code>defaultModule</code>
   * is not <code>null</code>, then any commands will be read into that module unless
   * an <code>inModule</code> declaration is encountered which will over-ride the default
   * value.  If noe <code>defaultModule</code> is specified, and the input stream does
   * not have an <code>inModule</code> form, an error is signaled.
   * @param stream
   * @param defaultModule
   */
  public static void loadStreamInModule(InputStream stream, Module defaultModule) {
    { Keyword currentdialect = ((Keyword)(Logic.$LOGIC_DIALECT$.get()));
      boolean skipcommandP = false;
      boolean seeninmoduleP = defaultModule != null;
      Cons commands = Stella.NIL;
      Module loadModule = (seeninmoduleP ? defaultModule : ((Module)(Stella.$MODULE$.get())));

      { Object old$LogicDialect$000 = Logic.$LOGIC_DIALECT$.get();
        Object old$Translationerrors$000 = Stella.$TRANSLATIONERRORS$.get();
        Object old$Translationwarnings$000 = Stella.$TRANSLATIONWARNINGS$.get();
        Object old$Translationnotes$000 = Stella.$TRANSLATIONNOTES$.get();

        try {
          Native.setSpecial(Logic.$LOGIC_DIALECT$, currentdialect);
          Native.setIntSpecial(Stella.$TRANSLATIONERRORS$, 0);
          Native.setIntSpecial(Stella.$TRANSLATIONWARNINGS$, 0);
          Native.setIntSpecial(Stella.$TRANSLATIONNOTES$, 0);
          { Object old$Module$000 = Stella.$MODULE$.get();
            Object old$Context$000 = Stella.$CONTEXT$.get();

            try {
              Native.setSpecial(Stella.$MODULE$, loadModule);
              Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
              { Stella_Object tree = null;
                SExpressionIterator iter000 = InputStream.sExpressions(stream);

                loop000 : while (iter000.nextP()) {
                  tree = iter000.value;
                  if (Stella_Object.safePrimaryType(tree) == Logic.SGT_STELLA_CONS) {
                    { Cons tree000 = ((Cons)(tree));

                      { Object [] caller_MV_returnarray = new Object[1];

                        skipcommandP = Cons.handleInModuleTree(tree000, seeninmoduleP, false, caller_MV_returnarray);
                        seeninmoduleP = ((boolean)(((BooleanWrapper)(caller_MV_returnarray[0])).wrapperValue));
                      }
                      if (skipcommandP) {
                        continue loop000;
                      }
                      { Stella_Object operator = tree000.value;

                        if (Surrogate.subtypeOfSymbolP(Stella_Object.safePrimaryType(operator))) {
                          { Symbol operator000 = ((Symbol)(operator));

                            if ((operator000 == Logic.SYM_STELLA_DEFMODULE) ||
                                ((operator000 == Logic.SYM_STELLA_CLEAR_MODULE) ||
                                 ((operator000 == Logic.SYM_STELLA_DEFCLASS) ||
                                  ((operator000 == Logic.SYM_STELLA_DEFSLOT) ||
                                   ((operator000 == Logic.SYM_STELLA_DEFUN) ||
                                    ((operator000 == Logic.SYM_STELLA_DEFMETHOD) ||
                                     ((operator000 == Logic.SYM_LOGIC_DEFCONCEPT) ||
                                      ((operator000 == Logic.SYM_LOGIC_DEFFUNCTION) ||
                                       ((operator000 == Logic.SYM_LOGIC_DEFRELATION) ||
                                        ((operator000 == Logic.SYM_LOGIC_DEFOBJECT) ||
                                         (operator000 == Logic.SYM_LOGIC_DEFINSTANCE))))))))))) {
                              Logic.evaluateLogicCommand(tree000, false);
                            }
                            else if (operator000 == Logic.SYM_LOGIC_IN_DIALECT) {
                              Logic.evaluateLogicCommand(tree000, false);
                              commands = Cons.cons(tree000, commands);
                            }
                            else {
                              if ((!Logic.definitionNameP(operator000)) &&
                                  (Symbol.lookupCommand(operator000) != null)) {
                                commands = Cons.cons(tree000, commands);
                              }
                              else {
                                Logic.evaluateLogicCommand(tree000, false);
                              }
                            }
                          }
                        }
                        else {
                          Logic.evaluateLogicCommand(tree000, false);
                        }
                      }
                    }
                  }
                  else {
                    Logic.evaluateLogicCommand(tree, false);
                  }
                }
              }
              { Object old$Translationphase$000 = Stella.$TRANSLATIONPHASE$.get();

                try {
                  Native.setSpecial(Stella.$TRANSLATIONPHASE$, Logic.KWD_FINALIZE);
                  Logic.finalizeObjects();

                } finally {
                  Stella.$TRANSLATIONPHASE$.set(old$Translationphase$000);
                }
              }
              { Stella_Object tree = null;
                Cons iter001 = commands.reverse();

                for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                  tree = iter001.value;
                  Logic.evaluateLogicCommand(tree, true);
                }
              }

            } finally {
              Stella.$CONTEXT$.set(old$Context$000);
              Stella.$MODULE$.set(old$Module$000);
            }
          }
          if (!(Stella.ignoreTranslationErrorsP())) {
            Stella.summarizeTranslationErrors();
          }

        } finally {
          Stella.$TRANSLATIONNOTES$.set(old$Translationnotes$000);
          Stella.$TRANSLATIONWARNINGS$.set(old$Translationwarnings$000);
          Stella.$TRANSLATIONERRORS$.set(old$Translationerrors$000);
          Logic.$LOGIC_DIALECT$.set(old$LogicDialect$000);
        }
      }
    }
  }

  /** Load all PowerLoom files (*.plm) in <code>directory</code> in alphabetic sort order.
   * @param directory
   */
  public static void loadDirectory(String directory) {
    Logic.plLog(Logic.KWD_LOW, Cons.cons(StringWrapper.wrapString("Loading PowerLoom files from directory "), Cons.cons(StringWrapper.wrapString(directory), Cons.cons(StringWrapper.wrapString("..."), Stella.NIL))));
    Stella.bumpLogIndent();
    directory = Stella.fileNameAsDirectory(directory);
    { StringWrapper file = null;
      Cons iter000 = Stella.listDirectoryFiles(directory);

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        file = ((StringWrapper)(iter000.value));
        { boolean foundP000 = false;

          { Stella_Object ext = null;
            Cons iter001 = Logic.$POWERLOOM_KB_FILE_EXTENSIONS$;

            loop001 : for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
              ext = iter001.value;
              if (Stella.endsWithP(file.wrapperValue, ((StringWrapper)(ext)).wrapperValue, Stella.NULL_INTEGER)) {
                foundP000 = true;
                break loop001;
              }
            }
          }
          if (foundP000) {
            Logic.plLog(Logic.KWD_MEDIUM, Cons.cons(StringWrapper.wrapString("Loading file "), Cons.cons(file, Stella.NIL)));
            Logic.load(directory + file.wrapperValue, Stella.NIL);
          }
        }
      }
    }
    Stella.unbumpLogIndent();
    Logic.processDefinitions();
  }

  public static void loadDirectoryEvaluatorWrapper(Cons arguments) {
    Logic.loadDirectory(((StringWrapper)(arguments.value)).wrapperValue);
  }

  /** Loads all PowerLoom files specified on the command line.
   * If directories are listed, all PowerLoom files in those directories are loaded.
   * Since when this is called we might still have unprocessed command line args,
   * this only looks at files which are to the right of the last argument that
   * starts with a <code>_</code> character.
   */
  public static void loadCmdLineFiles() {
    { Cons unprocessedargs = Stella.unprocessedCommandLineArguments();
      String file = null;

      if (unprocessedargs != null) {
        unprocessedargs = Cons.copyConsList(Stella.unprocessedCommandLineArguments()).reverse();
        { StringWrapper arg = null;
          Cons iter000 = unprocessedargs;
          int i = Stella.NULL_INTEGER;
          int iter001 = 0;

          loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
            arg = ((StringWrapper)(iter000.value));
            i = iter001;
            if (Stella.startsWithP(arg.wrapperValue, "-", Stella.NULL_INTEGER)) {
              if (i == 0) {
                unprocessedargs = Stella.NIL;
              }
              else {
                unprocessedargs.nthRestSetter(Stella.NIL, i);
              }
              break loop000;
            }
          }
        }
        Logic.plLog(Logic.KWD_LOW, Cons.cons(StringWrapper.wrapString("Loading command line PowerLoom files..."), Stella.NIL));
        Stella.bumpLogIndent();
        { StringWrapper arg = null;
          Cons iter002 = unprocessedargs.reverse();

          for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
            arg = ((StringWrapper)(iter002.value));
            { boolean foundP000 = false;

              { Stella_Object ext = null;
                Cons iter003 = Logic.$POWERLOOM_KB_FILE_EXTENSIONS$;

                loop002 : for (;!(iter003 == Stella.NIL); iter003 = iter003.rest) {
                  ext = iter003.value;
                  if (Stella.endsWithP(arg.wrapperValue, ((StringWrapper)(ext)).wrapperValue, Stella.NULL_INTEGER)) {
                    foundP000 = true;
                    break loop002;
                  }
                }
              }
              if (foundP000) {
                {
                  { String temp000 = Stella.findFileInLoadPath(arg.wrapperValue, null);

                    file = ((temp000 != null) ? temp000 : arg.wrapperValue);
                  }
                  Logic.plLog(Logic.KWD_MEDIUM, Cons.cons(StringWrapper.wrapString("Loading file "), Cons.cons(StringWrapper.wrapString(file), Stella.NIL)));
                  Logic.load(file, Stella.NIL);
                }
              }
              else {
                if (Stella.probeFileP(Stella.fileNameAsDirectory(arg.wrapperValue))) {
                  Logic.loadDirectory(arg.wrapperValue);
                }
              }
            }
          }
        }
        Stella.unbumpLogIndent();
      }
    }
  }

  public static void printDemoPrompt() {
    Stella.STANDARD_OUTPUT.nativeStream.print(Logic.$LOGIC_PROMPT$);
  }

  public static boolean demoSkipToCommand(InputStream stream) {
    { char ch = Stella.NULL_CHARACTER;
      boolean eofP = false;
      boolean echoP = false;
      OutputStream echostream = stream.echoStream;

      loop000 : for (;;) {
        stream.echoStream = null;
        { Object [] caller_MV_returnarray = new Object[1];

          ch = InputStream.readCharacter(stream, caller_MV_returnarray);
          eofP = ((boolean)(((BooleanWrapper)(caller_MV_returnarray[0])).wrapperValue));
        }
        if (eofP) {
          return (true);
        }
        if (echoP) {
          stream.echoStream = echostream;
        }
        if (Stella.$CHARACTER_TYPE_TABLE$[(int) ch] == Logic.KWD_WHITE_SPACE) {
          if (echoP) {
            echostream.nativeStream.print(ch);
          }
        }
        else if (ch == ';') {
          echoP = true;
          stream.echoStream = echostream;
          echostream.nativeStream.print(ch);
          eofP = InputStream.nativeReadLine(stream) == null;
          if (eofP) {
            return (true);
          }
        }
        else {
          stream.echoStream = echostream;
          Stella.unreadCharacter(ch, stream);
          break loop000;
        }
      }
      return (false);
    }
  }

  public static boolean demoPauseP(boolean pauseP, Object [] MV_returnarray) {
    { boolean exitP = false;
      String input = null;

      if (pauseP) {
        Stella.STANDARD_OUTPUT.nativeStream.print("------ pause ------");
        input = InputStream.readLine(Stella.STANDARD_INPUT);
        Stella.STANDARD_OUTPUT.nativeStream.println();
        if (input.length() > 0) {
          switch (Stella.$CHARACTER_UPCASE_TABLE$.charAt(((int) (input.charAt(0))))) {
            case 'C': 
              pauseP = false;
            break;
            case 'Q': 
              if (Stella.yOrNP("Really exit demo? (y or n) ")) {
                pauseP = false;
                exitP = true;
              }
            break;
            case 'H': 
            case '?': 
              {
                Stella.STANDARD_OUTPUT.nativeStream.println("Type `c' to continue without pausing,");
                Stella.STANDARD_OUTPUT.nativeStream.println("     `q' to quit from this demo,");
                Stella.STANDARD_OUTPUT.nativeStream.println("     `?' or `h' to get this message,");
                Stella.STANDARD_OUTPUT.nativeStream.println("     or any other key to continue.");
              }
;
              return (Logic.demoPauseP(pauseP, MV_returnarray));
            default:
            break;
          }
        }
      }
      else {
        Stella.STANDARD_OUTPUT.nativeStream.println();
      }
      { boolean _return_temp = pauseP;

        MV_returnarray[0] = BooleanWrapper.wrapBoolean(exitP);
        return (_return_temp);
      }
    }
  }

  public static void demoFile(String file, boolean pauseP) {
    { String temp000 = Stella.findFileInLoadPath(file, Logic.$POWERLOOM_KB_FILE_EXTENSIONS$);

      file = ((temp000 != null) ? temp000 : file);
    }
    Stella.ensureFileExists(file, "demo-file");
    { int currentlevel = ((Integer)(Logic.$DEMO_LEVEL$.get())).intValue();
      Stella_Object command = null;
      Stella_Object result = null;
      boolean exitP = false;

      { InputFileStream inputstream = null;

        try {
          inputstream = Stella.openInputFile(file, Stella.NIL);
          { Object old$CarefulLogicCommandLoopExit$P000 = Logic.$CAREFUL_LOGIC_COMMAND_LOOP_EXIT$p.get();
            Object old$DemoLevel$000 = Logic.$DEMO_LEVEL$.get();

            try {
              Native.setBooleanSpecial(Logic.$CAREFUL_LOGIC_COMMAND_LOOP_EXIT$p, false);
              Native.setIntSpecial(Logic.$DEMO_LEVEL$, currentlevel + 1);
              inputstream.echoStream = Stella.STANDARD_OUTPUT;
              { Object old$Module$000 = Stella.$MODULE$.get();
                Object old$Context$000 = Stella.$CONTEXT$.get();

                try {
                  Native.setSpecial(Stella.$MODULE$, ((Module)(Stella.$MODULE$.get())));
                  Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
                  if (pauseP) {
                    {
                      Stella.STANDARD_OUTPUT.nativeStream.println("Now reading from `" + file + "'.");
                      Stella.STANDARD_OUTPUT.nativeStream.println("Type `?' at the pause prompt for a list of available commands.");
                    }
;
                  }
                  loop000 : for (;;) {
                    try {
                      Stella.STANDARD_OUTPUT.nativeStream.println();
                      exitP = Logic.demoSkipToCommand(inputstream);
                      Logic.printDemoPrompt();
                      if (!(exitP)) {
                        { Object [] caller_MV_returnarray = new Object[1];

                          command = InputStream.readSExpression(inputstream, caller_MV_returnarray);
                          exitP = ((boolean)(((BooleanWrapper)(caller_MV_returnarray[0])).wrapperValue));
                        }
                      }
                      if (exitP ||
                          Logic.logicCommandLoopExitP(command, new Object[1])) {
                        break loop000;
                      }
                      { Object [] caller_MV_returnarray = new Object[1];

                        pauseP = Logic.demoPauseP(pauseP, caller_MV_returnarray);
                        exitP = ((boolean)(((BooleanWrapper)(caller_MV_returnarray[0])).wrapperValue));
                      }
                      if (exitP) {
                        break loop000;
                      }
                      result = Logic.evaluateLogicCommand(command, false);
                      Logic.printLogicCommandResult(result);
                    } catch (EvaluationException e) {
                      Stella.STANDARD_ERROR.nativeStream.print(">> Error: " + Stella.exceptionMessage(e));
                    }
                  }
                  {
                    Stella.STANDARD_OUTPUT.nativeStream.println("");
                    Stella.STANDARD_OUTPUT.nativeStream.println();
                    Stella.STANDARD_OUTPUT.nativeStream.println(Logic.$LOGIC_COMMAND_RESULT_INDENT$ + "Finished demo `" + file + "'.");
                  }
;

                } finally {
                  Stella.$CONTEXT$.set(old$Context$000);
                  Stella.$MODULE$.set(old$Module$000);
                }
              }

            } finally {
              Logic.$DEMO_LEVEL$.set(old$DemoLevel$000);
              Logic.$CAREFUL_LOGIC_COMMAND_LOOP_EXIT$p.set(old$CarefulLogicCommandLoopExit$P000);
            }
          }

        } finally {
          if (inputstream != null) {
            inputstream.free();
          }
        }
      }
    }
  }

  public static String demoEntryFile(Cons demoentry) {
    { String demobasefile = ((StringWrapper)(demoentry.value)).wrapperValue;

      { String temp000 = Stella.findFileInLoadPath(demobasefile, Logic.$POWERLOOM_KB_FILE_EXTENSIONS$);

        { String value000 = ((temp000 != null) ? temp000 : demobasefile);

          return (value000);
        }
      }
    }
  }

  public static String demoEntryDescription(Cons demoentry) {
    return (((((StringWrapper)(demoentry.rest.value)) != null) ? ((StringWrapper)(demoentry.rest.value)).wrapperValue : ((StringWrapper)(demoentry.value)).wrapperValue));
  }

  public static boolean demoEntryTestSuiteP(Cons demoentry) {
    return (Stella_Object.stringP(((StringWrapper)(demoentry.rest.rest.value))) &&
        Stella.stringEqlP(((StringWrapper)(demoentry.rest.rest.value)).wrapperValue, "test-suite"));
  }

  public static String selectExampleDemo(int index) {
    { Cons entry = ((Cons)(Logic.$DEMO_FILES$.nth(index - 1)));

      if (entry != null) {
        return (Logic.demoEntryFile(entry));
      }
      else {
        return (null);
      }
    }
  }

  public static String selectExampleDemoFromMenu() {
    Stella.STANDARD_OUTPUT.nativeStream.println("Choose a demo:");
    { Cons entry = null;
      Cons iter000 = Logic.$DEMO_FILES$;
      int i = Stella.NULL_INTEGER;
      int iter001 = 1;

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest, iter001 = iter001 + 1) {
        entry = ((Cons)(iter000.value));
        i = iter001;
        Stella.STANDARD_OUTPUT.nativeStream.print("       " + i + ".  ");
        if (i < 10) {
          Stella.STANDARD_OUTPUT.nativeStream.print(" ");
        }
        Stella.STANDARD_OUTPUT.nativeStream.println(Logic.demoEntryDescription(entry));
      }
    }
    Stella.STANDARD_OUTPUT.nativeStream.println("       Q.   Quit demoing");
    Stella.STANDARD_OUTPUT.nativeStream.print("Your choice: ");
    { Stella_Object selection = InputStream.readSExpression(Stella.STANDARD_INPUT, new Object[1]);
      String file = null;

      if (Surrogate.subtypeOfIntegerP(Stella_Object.safePrimaryType(selection))) {
        { IntegerWrapper selection000 = ((IntegerWrapper)(selection));

          file = Logic.selectExampleDemo(selection000.wrapperValue);
          if (file != null) {
            return (file);
          }
        }
      }
      else {
        if (Stella.stringEqualP(Native.stringify(selection), "Q")) {
          return (null);
        }
      }
      {
        Stella.STANDARD_OUTPUT.nativeStream.println(">> ERROR: Illegal choice `" + selection + "'; enter a number between 1 and " + Logic.$DEMO_FILES$.length() + "!");
        Stella.STANDARD_OUTPUT.nativeStream.println();
      }
;
      return (Logic.selectExampleDemoFromMenu());
    }
  }

  public static void demoExampleDemos() {
    { String file = null;

      for (;;) {
        Stella.STANDARD_OUTPUT.nativeStream.println();
        file = Logic.selectExampleDemoFromMenu();
        if (file == null) {
          return;
        }
        Stella.STANDARD_OUTPUT.nativeStream.println();
        Logic.demoFile(file, true);
      }
    }
  }

  /** Read logic commands from a file, echo them verbatimly to standard output,
   * and evaluate them just as if they had been typed in interactively.
   * When called with no arguments, present a menu of example demos, otherwise,
   * use the first argument as the name of the file to demo.
   * Pause for user confirmation after each expression has been read but
   * before it is evaluated.  Pausing can be turned off by suppling FALSE
   * as the optional second argument, or by typing <code>c</code> at the pause prompt.
   * Typing <code>P</code> at the pause prompt prints a list of available commands.
   * @param fileandpause
   */
  public static void demo(Cons fileandpause) {
    { Cons thefileandpause = fileandpause;
      Stella_Object filespec = thefileandpause.value;
      boolean pauseP = !Stella_Object.eqlP(thefileandpause.rest.value, Stella.FALSE_WRAPPER);
      String file = null;

      if (Stella_Object.integerP(filespec)) {
        file = Logic.selectExampleDemo(((IntegerWrapper)(filespec)).wrapperValue);
        if (file != null) {
          filespec = StringWrapper.wrapString(file);
        }
        else {
          filespec = null;
        }
      }
      if (filespec == null) {
        Logic.demoExampleDemos();
      }
      else {
        if (Surrogate.subtypeOfStringP(Stella_Object.safePrimaryType(filespec))) {
          { StringWrapper filespec000 = ((StringWrapper)(filespec));

            Logic.demoFile(filespec000.wrapperValue, pauseP);
          }
        }
        else {
          Stella.STANDARD_OUTPUT.nativeStream.print(">> ERROR: Illegal file specification: " + filespec);
        }
      }
    }
  }

  public static void demoEvaluatorWrapper(Cons arguments) {
    Logic.demo(arguments);
  }

  public static void testLogicFile(String file) {
    Stella.ensureFileExists(file, "test-logic-file");
    { int currentlevel = ((Integer)(Logic.$DEMO_LEVEL$.get())).intValue();
      Stella_Object command = null;
      Stella_Object result = null;
      boolean exitP = false;
      InputStream inputstream = InputFileStream.newInputFileStream(file);
      String filebasename = Stella.fileNameWithoutDirectory(file);

      { Object old$CarefulLogicCommandLoopExit$P000 = Logic.$CAREFUL_LOGIC_COMMAND_LOOP_EXIT$p.get();
        Object old$DemoLevel$000 = Logic.$DEMO_LEVEL$.get();
        Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();
        Object old$PrintprettyP$000 = Stella.$PRINTPRETTYp$.get();

        try {
          Native.setBooleanSpecial(Logic.$CAREFUL_LOGIC_COMMAND_LOOP_EXIT$p, false);
          Native.setIntSpecial(Logic.$DEMO_LEVEL$, currentlevel + 1);
          Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
          Native.setBooleanSpecial(Stella.$PRINTPRETTYp$, false);
          { Object old$Module$000 = Stella.$MODULE$.get();
            Object old$Context$000 = Stella.$CONTEXT$.get();

            try {
              Native.setSpecial(Stella.$MODULE$, ((Module)(Stella.$MODULE$.get())));
              Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
              {
                Stella.STANDARD_OUTPUT.nativeStream.println();
                Stella.STANDARD_OUTPUT.nativeStream.println("Now testing file `" + filebasename + "':");
              }
;
              loop000 : for (;;) {
                try {
                  Stella.STANDARD_OUTPUT.nativeStream.println();
                  Logic.printDemoPrompt();
                  if (!(exitP)) {
                    { Object [] caller_MV_returnarray = new Object[1];

                      command = InputStream.readSExpression(inputstream, caller_MV_returnarray);
                      exitP = ((boolean)(((BooleanWrapper)(caller_MV_returnarray[0])).wrapperValue));
                    }
                  }
                  if (exitP ||
                      Logic.logicCommandLoopExitP(command, new Object[1])) {
                    break loop000;
                  }
                  {
                    Stella.STANDARD_OUTPUT.nativeStream.println(command.toString());
                    Stella.STANDARD_OUTPUT.nativeStream.println();
                  }
;
                  result = Logic.evaluateLogicCommand(command, false);
                  Logic.printLogicCommandResult(result);
                } catch (EvaluationException e) {
                  Stella.STANDARD_ERROR.nativeStream.print(">> Error: " + Stella.exceptionMessage(e));
                }
              }
              inputstream.free();
              {
                Stella.STANDARD_OUTPUT.nativeStream.println("");
                Stella.STANDARD_OUTPUT.nativeStream.println();
                Stella.STANDARD_OUTPUT.nativeStream.println(Logic.$LOGIC_COMMAND_RESULT_INDENT$ + "Finished testing file `" + filebasename + "'.");
              }
;

            } finally {
              Stella.$CONTEXT$.set(old$Context$000);
              Stella.$MODULE$.set(old$Module$000);
            }
          }

        } finally {
          Stella.$PRINTPRETTYp$.set(old$PrintprettyP$000);
          Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
          Logic.$DEMO_LEVEL$.set(old$DemoLevel$000);
          Logic.$CAREFUL_LOGIC_COMMAND_LOOP_EXIT$p.set(old$CarefulLogicCommandLoopExit$P000);
        }
      }
    }
  }

  public static String getFormattedDateAndTime() {
    return (CalendarDate.makeCurrentDateTime().calendarDateToString(Stella.getLocalTimeZone(), false, true));
  }

  /** Run the PowerLoom test suite.  Currently this simply runs all demos and
   * echos commands and their results to standard output.  The output can then
   * be diffed with previously validated runs to find deviations.
   */
  public static void runPowerloomTests() {
    { Module pluser = Stella.getStellaModule("PL-USER", true);
      CalendarDate startTime = CalendarDate.makeCurrentDateTime();
      CalendarDate finishTime = null;
      Stella_Object loglevel = Stella.lookupLoggingParameter("PowerLoom", Logic.KWD_LEVEL, Logic.KWD_LOW);

      Stella.setLoggingParameters("PowerLoom", Cons.cons(Logic.KWD_LEVEL, Cons.cons(Logic.KWD_NONE, Stella.NIL)));
      {
        Stella.STANDARD_OUTPUT.nativeStream.println("RUNNING POWERLOOM TEST SUITE");
        Stella.STANDARD_OUTPUT.nativeStream.println("============================");
        Stella.STANDARD_OUTPUT.nativeStream.println();
      }
;
      {
        Stella.STANDARD_OUTPUT.nativeStream.println("STELLA version:    " + Stella.$STELLA_VERSION_STRING$);
        Stella.STANDARD_OUTPUT.nativeStream.println("PowerLoom version: " + Logic.$POWERLOOM_VERSION_STRING$);
        Stella.STANDARD_OUTPUT.nativeStream.println("Start time:        " + startTime.calendarDateToString(Stella.getLocalTimeZone(), false, true));
        Stella.STANDARD_OUTPUT.nativeStream.println();
      }
;
      Context.clearContext(pluser);
      { Context child = null;
        Cons iter000 = pluser.childContexts.copy().theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          child = ((Context)(iter000.value));
          child.destroyContext();
        }
      }
      Logic.$SKOLEM_ID_COUNTER$ = 0;
      { Cons entry = null;
        Cons iter001 = Logic.$DEMO_FILES$;

        for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
          entry = ((Cons)(iter001.value));
          if (Logic.demoEntryTestSuiteP(entry)) {
            Logic.testLogicFile(Logic.demoEntryFile(entry));
          }
        }
      }
      finishTime = CalendarDate.makeCurrentDateTime();
      {
        Stella.STANDARD_OUTPUT.nativeStream.println();
        Stella.STANDARD_OUTPUT.nativeStream.println("FINISHED RUNNING POWERLOOM TEST SUITE");
        Stella.STANDARD_OUTPUT.nativeStream.println("=====================================");
        Stella.STANDARD_OUTPUT.nativeStream.println("Finish time:   " + finishTime.calendarDateToString(Stella.getLocalTimeZone(), false, true));
        Stella.STANDARD_OUTPUT.nativeStream.println("Elapsed time:  " + ((TimeDuration)(DateTimeObject.timeSubtract(finishTime, startTime))).timeDurationToString());
        Stella.STANDARD_OUTPUT.nativeStream.println();
      }
;
      Stella.setLoggingParameters("PowerLoom", Cons.cons(Logic.KWD_LEVEL, Cons.cons(loglevel, Stella.NIL)));
    }
  }

  /** Execute <code>command</code>, measure and report its CPU and elapsed time
   * needed for its execution, and then return its result.
   * @param command
   * @return Stella_Object
   */
  public static Stella_Object timeCommand(Cons command) {
    { CalendarDate starttime = CalendarDate.makeCurrentDateTime();
      long startcpu = Native.getTicktock();
      Stella_Object result = Stella_Object.evaluate(command);
      long endcpu = Native.getTicktock();
      TimeDuration elapsedtime = ((TimeDuration)(DateTimeObject.timeSubtract(CalendarDate.makeCurrentDateTime(), starttime)));

      Stella.STANDARD_OUTPUT.nativeStream.println("CPU Time:     " + Native.ticktockDifference(startcpu, endcpu) + " secs");
      Stella.STANDARD_OUTPUT.nativeStream.print("Elapsed Time: ");
      if (elapsedtime.days > 0) {
        Stella.STANDARD_OUTPUT.nativeStream.print(elapsedtime.days + " days, ");
      }
      Stella.STANDARD_OUTPUT.nativeStream.println(Native.round(elapsedtime.millis / 1000.0) + " secs");
      return (result);
    }
  }

  public static String getHttpServerSystem() {
    return ("webtools");
  }

  /** Start the PowerLoom HTTP server at :port (defaults to 9090).  Loads
   * the required support systems in Lisp and Java if necessary (C++ is not yet supported).
   * @param options
   */
  public static void startOntosaurus(Cons options) {
    { PropertyList theoptions = Logic.parseLogicCommandOptions(options, Cons.list$(Cons.cons(Logic.KWD_PORT, Cons.cons(Logic.SGT_STELLA_INTEGER, Cons.cons(Stella.NIL, Stella.NIL)))), true, false);
      int port = ((IntegerWrapper)(theoptions.lookupWithDefault(Logic.KWD_PORT, IntegerWrapper.wrapInteger(0)))).wrapperValue;
      String address = null;

      Stella.autoload("ONTOSAURUS/CONTROL-PANEL-HANDLER", "ontosaurus", null, true);
      address = ((String)(edu.isi.stella.javalib.Native.funcall(Stella.autoload("HTTP/START-HTTP-SERVER", Logic.getHttpServerSystem(), null, true), null, new java.lang.Object [] {new Integer(port)})));
      Logic.plLog(Logic.KWD_LOW, Cons.cons(StringWrapper.wrapString("Started Ontosaurus, point your browser to `"), Cons.cons(StringWrapper.wrapString(address), Cons.cons(StringWrapper.wrapString("ploom/ontosaurus/'"), Stella.NIL))));
    }
  }

  public static void startOntosaurusEvaluatorWrapper(Cons arguments) {
    Logic.startOntosaurus(arguments);
  }

  /** Stop the PowerLoom HTTP server and free up any bound ports.
   * This is a no-op if no server is running or the server is not supported.
   */
  public static void stopOntosaurus() {
    edu.isi.stella.javalib.Native.funcall(Stella.autoload("HTTP/STOP-HTTP-SERVER", Logic.getHttpServerSystem(), null, true), null, new java.lang.Object [] {});
  }

  /** Start the PowerLoom HTTP server at :port (defaults to 9090).  Loads
   * the required support systems in Lisp and Java if necessary (C++ is not yet supported).
   * @param options
   */
  public static void startPowerloomServer(Cons options) {
    { PropertyList theoptions = Logic.parseLogicCommandOptions(options, Cons.list$(Cons.cons(Logic.KWD_PORT, Cons.cons(Logic.SGT_STELLA_INTEGER, Cons.cons(Stella.NIL, Stella.NIL)))), true, false);
      int port = ((IntegerWrapper)(theoptions.lookupWithDefault(Logic.KWD_PORT, IntegerWrapper.wrapInteger(0)))).wrapperValue;
      String address = null;

      Stella.autoload("GUI-SERVER/GUI-REQUEST-HANDLER", "powerloom-server", null, true);
      address = ((String)(edu.isi.stella.javalib.Native.funcall(Stella.autoload("HTTP/START-HTTP-SERVER", Logic.getHttpServerSystem(), null, true), null, new java.lang.Object [] {new Integer(port)})));
      Logic.plLog(Logic.KWD_LOW, Cons.cons(StringWrapper.wrapString("Started PowerLoom server at `"), Cons.cons(StringWrapper.wrapString(address), Cons.cons(StringWrapper.wrapString("ploom/soap-rpc/...'"), Stella.NIL))));
    }
  }

  public static void startPowerloomServerEvaluatorWrapper(Cons arguments) {
    Logic.startPowerloomServer(arguments);
  }

  /** Stop the PowerLoom HTTP server and free up any bound ports.
   * This is a no-op if no server is running or the server is not supported.
   */
  public static void stopPowerloomServer() {
    edu.isi.stella.javalib.Native.funcall(Stella.autoload("HTTP/STOP-HTTP-SERVER", Logic.getHttpServerSystem(), null, true), null, new java.lang.Object [] {});
  }

  /** Start the PowerLoom server at :port (defaults to 9090) and launches
   * the GUI which will communicate with the server at that port.  If :host is specified,
   * the GUI will try to communicate with a server at <code>hostCport</code> instead of the local
   * embedded server (note, you can always point the GUI manually to a different server
   * from its <code>Connect_to_Server</code> menu item).  Loads the required support systems if necessary.
   * Embedded calls to the GUI are currently only supported in Java; however, when the GUI is
   * run in standalone mode, it can communicate with any PowerLoom installation that supports
   * an HTTP server (currently Lisp and Java).
   * @param options
   */
  public static void startPowerloomGui(Cons options) {
    { PropertyList theoptions = Logic.parseLogicCommandOptions(options, Cons.list$(Cons.cons(Logic.KWD_HOST, Cons.cons(Logic.SGT_STELLA_STRING, Cons.cons(Logic.KWD_PORT, Cons.cons(Logic.SGT_STELLA_INTEGER, Cons.cons(Logic.KWD_DEBUG_LEVEL, Cons.cons(Logic.SGT_STELLA_INTEGER, Cons.cons(Stella.NIL, Stella.NIL)))))))), true, false);
      String host = ((StringWrapper)(theoptions.lookupWithDefault(Logic.KWD_HOST, StringWrapper.wrapString("localhost")))).wrapperValue;
      int port = ((IntegerWrapper)(theoptions.lookupWithDefault(Logic.KWD_PORT, IntegerWrapper.wrapInteger(9090)))).wrapperValue;
      int debuglevel = ((IntegerWrapper)(theoptions.lookupWithDefault(Logic.KWD_DEBUG_LEVEL, IntegerWrapper.wrapInteger(1)))).wrapperValue;
      String guiclass = "edu.isi.powerloom.gui.components.PowerloomApp";
      java.lang.reflect.Method guifn = null;
      String[] guifnargs = new String[6];

      try {
        guifn = Native.find_java_method(guiclass, "main", new java.lang.Class[]{java.lang.Class.forName("[Ljava.lang.String;")});
        Logic.startPowerloomServer(Cons.cons(Logic.KWD_PORT, Cons.cons(IntegerWrapper.wrapInteger(port), Stella.NIL)));
        HookList.addHook(Stella.$STELLA_EXIT_HOOKS$, Logic.SYM_LOGIC_POWERLOOM_GUI_EXIT_HOOK);
        guifnargs[0] = "--debug";
        guifnargs[1] = Native.integerToString(((long)(debuglevel)));
        guifnargs[2] = "--host";
        guifnargs[3] = host;
        guifnargs[4] = "--port";
        guifnargs[5] = Native.integerToString(((long)(port)));
        edu.isi.stella.javalib.Native.funcall(guifn, null, new java.lang.Object [] {guifnargs});
      } catch (java.lang.Exception e) {
        throw ((LogicException)(LogicException.newLogicException("PowerLoom GUI error: " + Stella.exceptionMessage(e)).fillInStackTrace()));
      }
    }
  }

  public static void startPowerloomGuiEvaluatorWrapper(Cons arguments) {
    Logic.startPowerloomGui(arguments);
  }

  /** Closes the PowerLoom GUI application if it is currently visible.
   * This is a no-op if the GUI is not running or if it is not supported.
   */
  public static void stopPowerloomGui() {
    { String guiclass = "edu.isi.powerloom.gui.components.PowerloomApp";
      java.lang.reflect.Method exitfn = null;

      try {
        exitfn = Native.find_java_method(guiclass, "exit", new java.lang.Class[]{});
      } catch (java.lang.Exception e) {
        throw ((LogicException)(LogicException.newLogicException("PowerLoom GUI error: " + Stella.exceptionMessage(e)).fillInStackTrace()));
      }
      if (exitfn != null) {
        edu.isi.stella.javalib.Native.funcall(exitfn, null, new java.lang.Object [] {});
      }
    }
  }

  /** Exit hook to stop the PowerLoom GUI if it is running.
   * @param ignore
   */
  public static void powerloomGuiExitHook(Stella_Object ignore) {
    ignore = ignore;
    try {
      Logic.stopPowerloomGui();
    } catch (java.lang.Exception e000) {
    }
  }

  public static void printFormulaContainingError(Stella_Object self, OutputStream stream) {
    { OutputStringStream temp = OutputStringStream.newOutputStringStream();
      String expressionstring = null;

      temp.nativeStream.print(self);
      expressionstring = temp.theStringReader();
      if (expressionstring.length() > Logic.$EXPRESSION_SIZE_CUTOFF$) {
        expressionstring = Native.string_subsequence(expressionstring, 0, Logic.$EXPRESSION_SIZE_CUTOFF$) + " ......)";
      }
      stream.nativeStream.print(expressionstring);
    }
  }

  public static void helpSignalPropositionError(OutputStream stream, Keyword warningorerror) {
    { Stella_Object bestoutputobject = ((Stella_Object)(Logic.$TERMUNDERCONSTRUCTION$.get()));
      String typename = ((bestoutputobject != null) ? "proposition" : "relation");

      if (bestoutputobject == null) {
        bestoutputobject = ((Stella_Object)(Logic.$DESCRIPTIONUNDERCONSTRUCTION$.get()));
      }
      if ((bestoutputobject == null) &&
          (((String)(Logic.$TERMSOURCEBEINGPARSED$.get())) != null)) {
        bestoutputobject = StringWrapper.wrapString(((String)(Logic.$TERMSOURCEBEINGPARSED$.get())));
      }
      if (bestoutputobject != null) {
        stream.nativeStream.print("   ");
        if (warningorerror == Logic.KWD_ERROR) {
          stream.nativeStream.print("Error");
        }
        else if (warningorerror == Logic.KWD_WARNING) {
          stream.nativeStream.print("Warning");
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + warningorerror + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
        stream.nativeStream.print(" occurred while parsing the " + typename + ": ");
        { Surrogate testValue000 = Stella_Object.safePrimaryType(bestoutputobject);

          if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
            { NamedDescription bestoutputobject000 = ((NamedDescription)(bestoutputobject));

              stream.nativeStream.println(NamedDescription.relationName(bestoutputobject000));
              return;
            }
          }
          else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
            { Proposition bestoutputobject000 = ((Proposition)(bestoutputobject));

              {
                stream.nativeStream.println();
                stream.nativeStream.print("   ");
              }
;
              Logic.printFormulaContainingError(((Stella_Object)(Logic.$TERMUNDERCONSTRUCTION$.get())), stream);
            }
          }
          else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
            { Description bestoutputobject000 = ((Description)(bestoutputobject));

              {
                stream.nativeStream.println();
                stream.nativeStream.print("   ");
              }
;
              Logic.printFormulaContainingError(((Stella_Object)(Logic.$TERMUNDERCONSTRUCTION$.get())), stream);
            }
          }
          else if (testValue000 == Logic.SGT_STELLA_CONS) {
            { Cons bestoutputobject000 = ((Cons)(bestoutputobject));

              {
                stream.nativeStream.println();
                stream.nativeStream.print("   ");
              }
;
              Logic.printFormulaContainingError(((Stella_Object)(Logic.$TERMUNDERCONSTRUCTION$.get())), stream);
            }
          }
          else if (Surrogate.subtypeOfStringP(testValue000)) {
            { StringWrapper bestoutputobject000 = ((StringWrapper)(bestoutputobject));

              stream.nativeStream.println();
              { Stella_Object sexpression = Stella.readSExpressionFromString(bestoutputobject000.wrapperValue);

                Logic.printFormulaContainingError(sexpression, stream);
              }
            }
          }
          else {
          }
        }
        stream.nativeStream.println();
      }
    }
  }

  public static Keyword logicDialect(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_RELATION)) {
        { Relation self000 = ((Relation)(self));

          return (Logic.logicDialect(self000.homeModule()));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_MODULE)) {
        { Module self000 = ((Module)(self));

          { Keyword dialect = ((Keyword)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_MODULE_LOGIC_DIALECT, null)));

            if (dialect != null) {
              return (dialect);
            }
            else {
              return (Logic.KWD_KIF);
            }
          }
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  public static Surrogate lookupLogicObjectSurrogate(Symbol name, Module definitionmodule) {
    definitionmodule = ((definitionmodule != null) ? definitionmodule : ((Module)(Stella.$MODULE$.get())));
    if (Logic.explicitlyQualifiedLogicObjectNameP(name, definitionmodule)) {
      return (Surrogate.lookupSurrogateInModule(name.symbolName, ((Module)(name.homeContext)), true));
    }
    else {
      return (Surrogate.lookupSurrogate(name.symbolName));
    }
  }

  public static Surrogate internLogicObjectSurrogate(Symbol name) {
    if (!((Module)(Stella.$MODULE$.get())).clearableP()) {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

          try {
            Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
            stream000.nativeStream.println("ERROR: Can't define the term `" + name + "' in the unclearable module `" + ((Module)(Stella.$MODULE$.get())).moduleFullName + "'.");
            Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

          } finally {
            Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
          }
        }
        throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
      }
    }
    { Surrogate oldsurrogate = Logic.lookupLogicObjectSurrogate(name, ((Module)(Stella.$MODULE$.get())));
      Stella_Object oldvalue = ((oldsurrogate != null) ? oldsurrogate.surrogateValue : ((Stella_Object)(null)));
      Module oldmodule = ((oldvalue != null) ? oldvalue.homeModule() : ((Module)(null)));

      if ((oldvalue != null) &&
          (!(oldmodule == ((Module)(Stella.$MODULE$.get()))))) {
        if (((Boolean)(Stella.$WARNIFREDEFINEp$.get())).booleanValue()) {
          {
            Stella.STANDARD_OUTPUT.nativeStream.println("Defining `" + name + "' would cause a term with the same name");
            Stella.STANDARD_OUTPUT.nativeStream.println("   of type `" + Logic.nameObjectMetaclass(oldvalue) + "' in module `" + oldmodule.moduleFullName + "' to be shadowed.");
          }
;
          {
            Stella.STANDARD_OUTPUT.nativeStream.println("CAUTION: Automatic shadowing can be dangerous, because forward ");
            Stella.STANDARD_OUTPUT.nativeStream.println("   references to a shadowed object may be bound to the now shadowed ");
            Stella.STANDARD_OUTPUT.nativeStream.println("   object.  Suggestion: Explicitly shadow the name using");
            Stella.STANDARD_OUTPUT.nativeStream.println("   DEFMODULE's `:shadow' option.");
          }
;
          if (!(Stella.yesOrNoP("Do it anyway? "))) {
            { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

              { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

                try {
                  Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                  stream001.nativeStream.println("ERROR: Couldn't shadow name `" + name + "' in `" + ((Module)(Stella.$MODULE$.get())).moduleFullName + "'.");
                  Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

                } finally {
                  Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
                }
              }
              throw ((PropositionError)(PropositionError.newPropositionError(stream001.theStringReader()).fillInStackTrace()));
            }
          }
        }
      }
      if (Logic.explicitlyQualifiedLogicObjectNameP(name, ((Module)(Stella.$MODULE$.get())))) {
        { Object old$Module$000 = Stella.$MODULE$.get();
          Object old$Context$000 = Stella.$CONTEXT$.get();

          try {
            Native.setSpecial(Stella.$MODULE$, ((Module)(name.homeContext)));
            Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
            return (Stella.shadowSurrogate(name.symbolName));

          } finally {
            Stella.$CONTEXT$.set(old$Context$000);
            Stella.$MODULE$.set(old$Module$000);
          }
        }
      }
      else {
        return (Stella.shadowSurrogate(name.symbolName));
      }
    }
  }

  public static String nameObjectMetaclass(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description self000 = ((Description)(self));

          if (Logic.classP(self000)) {
            return ("concept");
          }
          else if (Logic.functionP(self000)) {
            return ("function");
          }
          else {
            return ("relation");
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          return ("logic object");
        }
      }
      else {
        return (Native.stringDowncase(self.primaryType().symbolName));
      }
    }
  }

  public static Keyword logicObjectDefinitionType(Symbol name, Stella_Object oldobject, Stella_Object newobject) {
    if (oldobject == null) {
      return (Logic.KWD_DEFINITION);
    }
    { String oldkind = Logic.nameObjectMetaclass(oldobject);
      String newkind = Logic.nameObjectMetaclass(newobject);

      { Surrogate testValue000 = Stella_Object.safePrimaryType(oldobject);

        if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
          { NamedDescription oldobject000 = ((NamedDescription)(oldobject));

            if (!(Stella.stringEqlP(oldkind, newkind))) {
              { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

                { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

                  try {
                    Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                    {
                      stream000.nativeStream.println("ERROR: Can't redefine `" + oldkind + "' `" + name + "' with a `" + newkind + "'.");
                      stream000.nativeStream.println("   Explicitly destroy the old object first before you redefine it.");
                    }
;
                    Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

                  } finally {
                    Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
                  }
                }
                throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
              }
            }
            if (!((oldobject000.arity() == ((NamedDescription)(newobject)).arity()) ||
                ((Logic.stringifiedSource(newobject) != null) &&
                 (Native.stringSearch(Logic.stringifiedSource(newobject), "VARIABLE-ARITY", 0) != Stella.NULL_INTEGER)))) {
              { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

                { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

                  try {
                    Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                    {
                      stream001.nativeStream.println("ERROR: Can't redefine `" + oldkind + "' `" + name + "' with a different arity.");
                      stream001.nativeStream.println("   Explicitly destroy the old object first before you redefine it.");
                    }
;
                    Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

                  } finally {
                    Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
                  }
                }
                throw ((PropositionError)(PropositionError.newPropositionError(stream001.theStringReader()).fillInStackTrace()));
              }
            }
            return (Logic.KWD_REDEFINITION);
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
          { LogicObject oldobject000 = ((LogicObject)(oldobject));

            { Surrogate testValue001 = Stella_Object.safePrimaryType(newobject);

              if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
                { NamedDescription newobject000 = ((NamedDescription)(newobject));

                  return (Logic.KWD_PROPER_DEFINITION);
                }
              }
              else if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
                { LogicObject newobject000 = ((LogicObject)(newobject));

                  return (Logic.KWD_REDEFINITION);
                }
              }
              else {
              }
            }
          }
        }
        else {
          if (oldobject.primaryType() == newobject.primaryType()) {
            return (Logic.KWD_REDEFINITION);
          }
        }
      }
      { OutputStringStream stream002 = OutputStringStream.newOutputStringStream();

        { Object old$PrintreadablyP$002 = Stella.$PRINTREADABLYp$.get();

          try {
            Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
            {
              stream002.nativeStream.println("ERROR: Can't redefine `" + oldkind + "' `" + name + "' with a `" + newkind + "'.");
              stream002.nativeStream.println("   Explicitly destroy the old object first before you redefine it.");
            }
;
            Logic.helpSignalPropositionError(stream002, Logic.KWD_ERROR);

          } finally {
            Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$002);
          }
        }
        throw ((PropositionError)(PropositionError.newPropositionError(stream002.theStringReader()).fillInStackTrace()));
      }
    }
  }

  public static void bindLogicObjectToSurrogate(Symbol name, Stella_Object renamed_Object) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(renamed_Object);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject object000 = ((LogicObject)(renamed_Object));

        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition object000 = ((Proposition)(renamed_Object));

        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("INTERNAL ERROR: Can't yet define logic objects of type `" + renamed_Object.primaryType() + "'");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
    { Surrogate namesurrogate = Logic.internLogicObjectSurrogate(name);
      Surrogate objectsurrogate = Logic.objectSurrogate(renamed_Object);
      Stella_Object oldobject = namesurrogate.surrogateValue;
      Keyword definitiontype = null;

      if ((oldobject != null) &&
          oldobject.deletedP()) {
        oldobject = null;
        namesurrogate.surrogateValue = null;
      }
      if (((Boolean)(Stella.$WARNIFREDEFINEp$.get())).booleanValue() &&
          ((objectsurrogate != null) &&
           (!(objectsurrogate == namesurrogate)))) {
        {
          Stella.STANDARD_OUTPUT.nativeStream.println("The `" + Logic.nameObjectMetaclass(renamed_Object) + "' now named `" + name + "' used to be named `" + Symbol.internSymbolInModule(objectsurrogate.symbolName, ((Module)(objectsurrogate.homeContext)), false) + "'.");
          Stella.STANDARD_OUTPUT.nativeStream.println("    Unlinking it from its old name.");
        }
;
        objectsurrogate.surrogateValue = null;
      }
      Logic.objectSurrogateSetter(renamed_Object, namesurrogate);
      definitiontype = Logic.logicObjectDefinitionType(name, oldobject, renamed_Object);
      namesurrogate.surrogateValue = renamed_Object;
      if ((oldobject != null) &&
          (!Stella_Object.eqlP(oldobject, renamed_Object))) {
        Logic.objectSurrogateSetter(oldobject, null);
      }
      if (definitiontype == Logic.KWD_DEFINITION) {
      }
      else if (definitiontype == Logic.KWD_PROPER_DEFINITION) {
        Logic.transferPropositionsAndBacklinks(oldobject, renamed_Object);
        { Surrogate testValue001 = Stella_Object.safePrimaryType(oldobject);

          if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
            { LogicObject oldobject000 = ((LogicObject)(oldobject));

              oldobject000.deletedPSetter(true);
            }
          }
          else if (Surrogate.subtypeOfP(testValue001, Logic.SGT_LOGIC_PROPOSITION)) {
            { Proposition oldobject000 = ((Proposition)(oldobject));

              oldobject000.deletedPSetter(true);
            }
          }
          else {
            { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

              stream001.nativeStream.print("`" + testValue001 + "' is not a valid case option");
              throw ((StellaException)(StellaException.newStellaException(stream001.theStringReader()).fillInStackTrace()));
            }
          }
        }
      }
      else if (definitiontype == Logic.KWD_REDEFINITION) {
        Logic.redefineLogicObject(name, oldobject, renamed_Object);
      }
      else {
        { OutputStringStream stream002 = OutputStringStream.newOutputStringStream();

          stream002.nativeStream.print("`" + definitiontype + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream002.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  public static void redefineLogicObject(Symbol name, Stella_Object oldobject, Stella_Object newobject) {
    { List originatedprops = Logic.originatedPropositions(oldobject).removeDeletedMembers();
      List exceptprops = originatedprops.copy();

      { Proposition prop = null;
        Cons iter000 = originatedprops.theConsList;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          prop = ((Proposition)(iter000.value));
          { Proposition satellite = null;
            Cons iter001 = prop.satellitePropositions().theConsList;

            for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
              satellite = ((Proposition)(iter001.value));
              exceptprops.insertNew(satellite);
            }
          }
        }
      }
      if (((Boolean)(Stella.$WARNIFREDEFINEp$.get())).booleanValue() &&
          (!Stella.stringEqlP(Logic.stringifiedSource(oldobject), Logic.stringifiedSource(newobject)))) {
        Logic.plLog(Logic.KWD_LOW, Cons.cons(StringWrapper.wrapString("Redefining the "), Cons.cons(StringWrapper.wrapString(Logic.nameObjectMetaclass(oldobject)), Cons.cons(StringWrapper.wrapString(" named "), Cons.cons(name, Stella.NIL)))));
      }
      Logic.transferSynonyms(oldobject, newobject);
      Logic.transferPropositionsExceptFor(oldobject, newobject, exceptprops);
      if (Stella_Object.isaP(oldobject, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        NamedDescription.transferDescriptionExtension(((NamedDescription)(oldobject)), ((NamedDescription)(newobject)));
      }
      { Proposition prop = null;
        Cons iter002 = originatedprops.theConsList;

        for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
          prop = ((Proposition)(iter002.value));
          Proposition.destroyProposition(prop);
        }
      }
      if (!(Stella_Object.eqlP(oldobject, newobject))) {
        Logic.destroyObject(oldobject);
      }
    }
  }

  public static boolean explicitlyQualifiedLogicObjectNameP(GeneralizedSymbol objectname, Module definitionmodule) {
    if (Logic.$HANDLE_EXPLICITLY_QUALIFIED_LOGIC_OBJECTSp$) {
      definitionmodule = ((definitionmodule != null) ? definitionmodule : ((Module)(Stella.$MODULE$.get())));
      return (!Context.visibleFromP(((Module)(objectname.homeContext)), definitionmodule));
    }
    return (false);
  }

  public static Surrogate coerceToBoundOrLocalSurrogate(GeneralizedSymbol self) {
    { Surrogate surrogate = null;

      if (Logic.explicitlyQualifiedLogicObjectNameP(self, ((Module)(Stella.$MODULE$.get())))) {
        { Object old$Module$000 = Stella.$MODULE$.get();
          Object old$Context$000 = Stella.$CONTEXT$.get();

          try {
            Native.setSpecial(Stella.$MODULE$, ((Module)(self.homeContext)));
            Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
            return (Logic.coerceToBoundOrLocalSurrogate(self));

          } finally {
            Stella.$CONTEXT$.set(old$Context$000);
            Stella.$MODULE$.set(old$Module$000);
          }
        }
      }
      { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

        if (Surrogate.subtypeOfSurrogateP(testValue000)) {
          { Surrogate self000 = ((Surrogate)(self));

            surrogate = self000;
          }
        }
        else if (Surrogate.subtypeOfSymbolP(testValue000)) {
          { Symbol self000 = ((Symbol)(self));

            surrogate = Surrogate.lookupSurrogateInModule(self000.symbolName, ((Module)(self000.homeContext)), false);
            if ((surrogate == null) &&
                (!(((Module)(self000.homeContext)) == ((Module)(Stella.$MODULE$.get()))))) {
              surrogate = Surrogate.lookupSurrogateInModule(self000.symbolName, ((Module)(Stella.$MODULE$.get())), false);
            }
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
      if ((surrogate != null) &&
          (surrogate.surrogateValue != null)) {
        return (surrogate);
      }
      return (Stella.shadowSurrogate(self.symbolName));
    }
  }

  public static Cons axioms(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          return (((Cons)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_OBJECT_AXIOMS, null))));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          return (((Cons)(KeyValueList.dynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_PROPOSITION_AXIOMS, null))));
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  public static Stella_Object axiomsSetter(Stella_Object self, Cons axioms) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          KeyValueList.setDynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_OBJECT_AXIOMS, axioms, null);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          KeyValueList.setDynamicSlotValue(self000.dynamicSlots, Logic.SYM_LOGIC_PROPOSITION_AXIOMS, axioms, null);
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
    return (axioms);
  }

  public static void definitionAxiomsHandler(Stella_Object self, StorageSlot slot, Stella_Object theaxioms) {
    slot = slot;
    if (Stella_Object.stringP(theaxioms)) {
      theaxioms = Stella.unstringifyInModule(((StringWrapper)(theaxioms)).wrapperValue, self.homeModule());
    }
    Logic.axiomsSetter(self, Logic.combineAxiomLists(Logic.axioms(self), theaxioms));
  }

  public static Cons combineAxiomLists(Cons oldaxioms, Stella_Object newaxioms) {
    if (oldaxioms == null) {
      oldaxioms = Stella.NIL;
    }
    if (newaxioms == null) {
      newaxioms = Stella.NIL;
    }
    { Cons normalizednewaxioms = Stella.NIL;

      if (Stella_Object.safePrimaryType(newaxioms) == Logic.SGT_STELLA_CONS) {
        { Cons newaxioms000 = ((Cons)(newaxioms));

          { boolean alwaysP000 = true;

            { Stella_Object elt = null;
              Cons iter000 = newaxioms000;

              loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                elt = iter000.value;
                if (!Stella_Object.consP(elt)) {
                  alwaysP000 = false;
                  break loop000;
                }
              }
            }
            if (alwaysP000) {
              {
                normalizednewaxioms = newaxioms000;
              }
            }
            else {
              if (newaxioms000.value == Logic.SYM_STELLA_AND) {
                {
                  normalizednewaxioms = newaxioms000.rest;
                }
              }
              else {
                {
                  normalizednewaxioms = Cons.cons(newaxioms000, Stella.NIL);
                }
              }
            }
          }
        }
      }
      else {
        normalizednewaxioms = Cons.cons(newaxioms, Stella.NIL);
      }
      return (oldaxioms.concatenate(normalizednewaxioms, Stella.NIL));
    }
  }

  public static void definitionKeywordAxiomsHandler(Stella_Object self, Symbol selfname, Keyword key, Stella_Object value) {
    Logic.axiomsSetter(self, Logic.combineAxiomLists(Logic.axioms(self), Logic.helpDefineKeywordAxioms(selfname, key, value)));
  }

  public static Cons helpDefineKeywordAxioms(Symbol selfname, Keyword key, Stella_Object value) {
    { Cons axioms = Stella.NIL;
      Symbol relationname = Symbol.internSymbol(key.symbolName);

      if (Stella_Object.symbolP(value) &&
          Stella.stringEqualP(((Symbol)(value)).symbolName, "TRUE")) {
        axioms = Cons.cons(relationname, Cons.cons(selfname, Stella.NIL));
      }
      else if (Stella_Object.symbolP(value) &&
          Stella.stringEqualP(((Symbol)(value)).symbolName, "FALSE")) {
        axioms = Cons.list$(Cons.cons(Logic.SYM_STELLA_NOT, Cons.cons(Cons.cons(relationname, Cons.cons(selfname, Stella.NIL)), Cons.cons(Stella.NIL, Stella.NIL))));
      }
      else if (Stella_Object.consP(value) &&
          (!Stella.getQuotedTree("((SETOFALL KAPPA) \"/LOGIC\")", "/LOGIC").membP(((Cons)(value)).value))) {
        { Stella_Object val = null;
          Cons iter000 = ((Cons)(value));
          Cons collect000 = null;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            val = iter000.value;
            if (collect000 == null) {
              {
                collect000 = Cons.cons(Cons.cons(relationname, Cons.cons(selfname, Cons.cons(val, Stella.NIL))), Stella.NIL);
                if (axioms == Stella.NIL) {
                  axioms = collect000;
                }
                else {
                  Cons.addConsToEndOfConsList(axioms, collect000);
                }
              }
            }
            else {
              {
                collect000.rest = Cons.cons(Cons.cons(relationname, Cons.cons(selfname, Cons.cons(val, Stella.NIL))), Stella.NIL);
                collect000 = collect000.rest;
              }
            }
          }
        }
      }
      else {
        axioms = Cons.cons(relationname, Cons.cons(selfname, Cons.cons(value, Stella.NIL)));
      }
      return (axioms);
    }
  }

  public static void assertKeywordAxiom(Stella_Object self, Symbol selfname, Keyword key, Stella_Object value) {
    { Stella_Object axiom = null;
      Cons iter000 = Logic.combineAxiomLists(Stella.NIL, Logic.helpDefineKeywordAxioms(selfname, key, value));

      for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
        axiom = iter000.value;
        { Cons props = Logic.updateProposition(axiom, Logic.KWD_ASSERT_TRUE);

          if (props != null) {
            { Proposition p = null;
              Cons iter001 = props;

              for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                p = ((Proposition)(iter001.value));
                { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

                  if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
                    { LogicObject self000 = ((LogicObject)(self));

                      Logic.linkOriginatedProposition(self000, p);
                    }
                  }
                  else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
                    { Proposition self000 = ((Proposition)(self));

                      Logic.linkOriginatedProposition(self000, p);
                    }
                  }
                  else {
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  public static void registerUnfinalizedObject(Stella_Object renamed_Object) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(renamed_Object);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject object000 = ((LogicObject)(renamed_Object));

          Logic.$UNFINALIZED_OBJECTS$.push(object000);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition object000 = ((Proposition)(renamed_Object));

          Logic.$UNFINALIZED_OBJECTS$.push(object000);
        }
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("INTERNAL ERROR: can't register objects of type `" + renamed_Object.primaryType() + "' for finalization");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
    if (((Boolean)(Logic.$FINALIZEOBJECTSIMMEDIATELYp$.get())).booleanValue()) {
      Logic.finalizeObjects();
    }
  }

  public static void cleanupUnfinalizedObjects() {
    Logic.$UNFINALIZED_OBJECTS$.removeDeletedMembers();
  }

  public static void linkOriginatedProposition(Stella_Object renamed_Object, Proposition proposition) {
    { List propositions = Logic.originatedPropositions(renamed_Object);

      if (List.nullListP(propositions)) {
        propositions = List.newList();
        Logic.originatedPropositionsSetter(renamed_Object, propositions);
      }
      propositions.push(proposition);
    }
  }

  public static Cons helpFinalizeObjectAxioms(Cons theaxioms) {
    if (theaxioms == null) {
      return (Stella.NIL);
    }
    else {
      { Cons propositions = Stella.NIL;
        Stella_Object result = null;

        { Stella_Object axiom = null;
          Cons iter000 = theaxioms;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            axiom = iter000.value;
            result = Logic.updateProposition(axiom, Logic.KWD_ASSERT_TRUE);
            { Surrogate testValue000 = Stella_Object.safePrimaryType(result);

              if (testValue000 == Logic.SGT_STELLA_CONS) {
                { Cons result000 = ((Cons)(result));

                  { Stella_Object r = null;
                    Cons iter001 = result000;

                    for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                      r = iter001.value;
                      propositions = Cons.cons(r, propositions);
                    }
                  }
                }
              }
              else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
                { Proposition result000 = ((Proposition)(result));

                  propositions = Cons.cons(result000, propositions);
                }
              }
              else {
                return (Stella.NIL);
              }
            }
          }
        }
        return (propositions.reverse());
      }
    }
  }

  public static void finalizeObjectAxioms(Stella_Object self) {
    { Object old$Termsourcebeingparsed$000 = Logic.$TERMSOURCEBEINGPARSED$.get();
      Object old$LogicDialect$000 = Logic.$LOGIC_DIALECT$.get();

      try {
        Native.setSpecial(Logic.$TERMSOURCEBEINGPARSED$, null);
        Native.setSpecial(Logic.$LOGIC_DIALECT$, Logic.KWD_KIF);
        { Object old$Module$000 = Stella.$MODULE$.get();
          Object old$Context$000 = Stella.$CONTEXT$.get();

          try {
            Native.setSpecial(Stella.$MODULE$, self.homeModule());
            Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
            { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

              if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
                { LogicObject self000 = ((LogicObject)(self));

                  Native.setSpecial(Logic.$TERMSOURCEBEINGPARSED$, Logic.stringifiedSource(self000));
                  if (Logic.axioms(self000) == null) {
                    return;
                  }
                  KeyValueList.setDynamicSlotValue(self000.dynamicSlots, Logic.SYM_STELLA_BADp, Stella.TRUE_WRAPPER, null);
                  { Cons theaxioms = Logic.helpFinalizeObjectAxioms(Logic.axioms(self000));

                    if (theaxioms == Stella.NIL) {
                      return;
                    }
                    else {
                      { Proposition p = null;
                        Cons iter000 = theaxioms;

                        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                          p = ((Proposition)(iter000.value));
                          Logic.linkOriginatedProposition(self000, p);
                        }
                      }
                    }
                  }
                  Logic.axiomsSetter(self000, null);
                  KeyValueList.setDynamicSlotValue(self000.dynamicSlots, Logic.SYM_STELLA_BADp, null, null);
                }
              }
              else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
                { Proposition self000 = ((Proposition)(self));

                  Native.setSpecial(Logic.$TERMSOURCEBEINGPARSED$, Logic.stringifiedSource(self000));
                  if (Logic.axioms(self000) == null) {
                    return;
                  }
                  KeyValueList.setDynamicSlotValue(self000.dynamicSlots, Logic.SYM_STELLA_BADp, Stella.TRUE_WRAPPER, null);
                  { Cons theaxioms = Logic.helpFinalizeObjectAxioms(Logic.axioms(self000));

                    if (theaxioms == Stella.NIL) {
                      return;
                    }
                    else {
                      { Proposition p = null;
                        Cons iter001 = theaxioms;

                        for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                          p = ((Proposition)(iter001.value));
                          Logic.linkOriginatedProposition(self000, p);
                        }
                      }
                    }
                  }
                  Logic.axiomsSetter(self000, null);
                  KeyValueList.setDynamicSlotValue(self000.dynamicSlots, Logic.SYM_STELLA_BADp, null, null);
                }
              }
              else {
                { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

                  stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
                  throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
                }
              }
            }

          } finally {
            Stella.$CONTEXT$.set(old$Context$000);
            Stella.$MODULE$.set(old$Module$000);
          }
        }

      } finally {
        Logic.$LOGIC_DIALECT$.set(old$LogicDialect$000);
        Logic.$TERMSOURCEBEINGPARSED$.set(old$Termsourcebeingparsed$000);
      }
    }
  }

  public static void finalizeObject(Stella_Object self) {
    if (self.deletedP() ||
        Logic.finalizedObjectP(self)) {
      return;
    }
    try {
      { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

        if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
          { NamedDescription self000 = ((NamedDescription)(self));

            { boolean testValue001 = false;

              if (BooleanWrapper.coerceWrappedBooleanToBoolean(self000.badP())) {
                testValue001 = true;
              }
              else {
                { boolean foundP000 = false;

                  { Surrogate type = null;
                    Cons iter000 = self000.ioVariableTypes.theConsList;

                    loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                      type = ((Surrogate)(iter000.value));
                      if (type.symbolId == -1) {
                        foundP000 = true;
                        break loop000;
                      }
                    }
                  }
                  testValue001 = foundP000;
                }
              }
              if (testValue001) {
                return;
              }
            }
            Logic.finalizeObjectAxioms(self000);
            NamedDescription.checkDescriptionArgumentTypes(self000);
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
          { LogicObject self000 = ((LogicObject)(self));

            if (BooleanWrapper.coerceWrappedBooleanToBoolean(self000.badP())) {
              return;
            }
            Logic.finalizeObjectAxioms(self000);
          }
        }
        else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
          { Proposition self000 = ((Proposition)(self));

            if (BooleanWrapper.coerceWrappedBooleanToBoolean(self000.badP())) {
              return;
            }
            Logic.finalizeObjectAxioms(self000);
          }
        }
        else {
        }
      }
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
    }
  }

  public static boolean finalizedObjectP(Stella_Object self) {
    return (Logic.axioms(self) == null);
  }

  public static boolean objectsAreFinalizedP() {
    return (Logic.$UNFINALIZED_OBJECTS$.theConsList == Stella.NIL);
  }

  /** Finalize all currently unfinalized objects.
   * The user-level entry point for this is <code>_processDefinitions_</code>.
   */
  public static void finalizeObjects() {
    if (((Boolean)(Logic.$INHIBITOBJECTFINALIZATIONp$.get())).booleanValue() ||
        ((Logic.$UNFINALIZED_OBJECTS$.theConsList == Stella.NIL) ||
         (!Logic.worldStateP(((Context)(Stella.$CONTEXT$.get())))))) {
      return;
    }
    { Object old$InhibitobjectfinalizationP$000 = Logic.$INHIBITOBJECTFINALIZATIONp$.get();
      Object old$Termsourcebeingparsed$000 = Logic.$TERMSOURCEBEINGPARSED$.get();
      Object old$Descriptionunderconstruction$000 = Logic.$DESCRIPTIONUNDERCONSTRUCTION$.get();
      Object old$Termunderconstruction$000 = Logic.$TERMUNDERCONSTRUCTION$.get();

      try {
        Native.setBooleanSpecial(Logic.$INHIBITOBJECTFINALIZATIONp$, true);
        Native.setSpecial(Logic.$TERMSOURCEBEINGPARSED$, null);
        Native.setSpecial(Logic.$DESCRIPTIONUNDERCONSTRUCTION$, null);
        Native.setSpecial(Logic.$TERMUNDERCONSTRUCTION$, null);
        Stella.finalizeClassesAndSlots();
        { Stella_Object renamed_Object = null;
          Cons iter000 = Logic.$UNFINALIZED_OBJECTS$.reverse().theConsList;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            renamed_Object = iter000.value;
            Logic.finalizeObject(renamed_Object);
          }
        }
        Logic.$UNFINALIZED_OBJECTS$.clear();

      } finally {
        Logic.$TERMUNDERCONSTRUCTION$.set(old$Termunderconstruction$000);
        Logic.$DESCRIPTIONUNDERCONSTRUCTION$.set(old$Descriptionunderconstruction$000);
        Logic.$TERMSOURCEBEINGPARSED$.set(old$Termsourcebeingparsed$000);
        Logic.$INHIBITOBJECTFINALIZATIONp$.set(old$InhibitobjectfinalizationP$000);
      }
    }
  }

  public static NamedDescription helpDefineRelationFromParseTree(Cons tree, String stringifiedsource) {
    { Symbol operator = ((Symbol)(tree.value));
      Symbol name = ((Symbol)(tree.rest.value));
      Cons parameters = ((Cons)(tree.rest.rest.value));
      Cons options = tree.nthRest(3);
      boolean classP = operator == Logic.SYM_LOGIC_DEFCONCEPT;
      boolean functionP = operator == Logic.SYM_LOGIC_DEFFUNCTION;
      NamedDescription description = null;

      description = Logic.getIdenticalRelation(name, stringifiedsource);
      if (description != null) {
        return (description);
      }
      { List parameternames = null;
        List parametertypes = null;
        boolean variablearityP = false;

        { Object [] caller_MV_returnarray = new Object[2];

          parameternames = Logic.parseRelationParametersTree(parameters, caller_MV_returnarray);
          parametertypes = ((List)(caller_MV_returnarray[0]));
          variablearityP = ((boolean)(((BooleanWrapper)(caller_MV_returnarray[1])).wrapperValue));
        }
        description = Logic.createPrimitiveDescription(parameternames, parametertypes, variablearityP, classP, functionP, ((Module)(Stella.$MODULE$.get())));
        Native.setSpecial(Logic.$DESCRIPTIONUNDERCONSTRUCTION$, description);
        Logic.stringifiedSourceSetter(description, stringifiedsource);
        KeyValueList.setDynamicSlotValue(description.dynamicSlots, Logic.SYM_STELLA_BADp, Stella.TRUE_WRAPPER, null);
        Logic.bindLogicObjectToSurrogate(name, description);
        Description.ensureDescriptionBody(description);
        description.processDefinitionOptions(options);
        KeyValueList.setDynamicSlotValue(description.dynamicSlots, Logic.SYM_STELLA_BADp, null, null);
        Logic.registerUnfinalizedObject(description);
        return (description);
      }
    }
  }

  public static List parseRelationParametersTree(Cons parameters, Object [] MV_returnarray) {
    if (parameters == null) {
      { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

        { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

          try {
            Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
            stream000.nativeStream.println("ERROR: Missing concept or relation parameters.");
            Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

          } finally {
            Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
          }
        }
        throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
      }
    }
    { Symbol name = null;
      Stella_Object type = null;
      List parameternames = List.newList();
      List parametertypes = List.newList();
      boolean variablearityP = false;

      { Stella_Object p = null;
        Cons iter000 = parameters;

        loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          p = iter000.value;
          { Surrogate testValue000 = Stella_Object.safePrimaryType(p);

            if (testValue000 == Logic.SGT_STELLA_CONS) {
              { Cons p000 = ((Cons)(p));

                if (!((p000.length() == 2) &&
                    (Stella_Object.symbolP(p000.value) &&
                     Stella_Object.symbolP(p000.rest.value)))) {
                  { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

                    { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

                      try {
                        Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                        stream001.nativeStream.println("ERROR: Illegal parameter: `" + p000 + "'.");
                        Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

                      } finally {
                        Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
                      }
                    }
                    throw ((PropositionError)(PropositionError.newPropositionError(stream001.theStringReader()).fillInStackTrace()));
                  }
                }
                name = ((Symbol)(p000.value));
                if (!Logic.questionMarkSymbolP(name)) {
                  { OutputStringStream stream002 = OutputStringStream.newOutputStringStream();

                    { Object old$PrintreadablyP$002 = Stella.$PRINTREADABLYp$.get();

                      try {
                        Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                        stream002.nativeStream.println("ERROR: Expected a question mark variable: `" + name + "'.");
                        Logic.helpSignalPropositionError(stream002, Logic.KWD_ERROR);

                      } finally {
                        Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$002);
                      }
                    }
                    throw ((PropositionError)(PropositionError.newPropositionError(stream002.theStringReader()).fillInStackTrace()));
                  }
                }
                type = p000.rest.value;
              }
            }
            else if (Surrogate.subtypeOfSymbolP(testValue000)) {
              { Symbol p000 = ((Symbol)(p));

                name = p000;
                if (!Logic.questionMarkSymbolP(name)) {
                  { OutputStringStream stream003 = OutputStringStream.newOutputStringStream();

                    { Object old$PrintreadablyP$003 = Stella.$PRINTREADABLYp$.get();

                      try {
                        Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                        stream003.nativeStream.println("ERROR: Expected a question mark variable: `" + name + "'.");
                        Logic.helpSignalPropositionError(stream003, Logic.KWD_ERROR);

                      } finally {
                        Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$003);
                      }
                    }
                    throw ((PropositionError)(PropositionError.newPropositionError(stream003.theStringReader()).fillInStackTrace()));
                  }
                }
                type = Logic.SGT_STELLA_THING;
              }
            }
            else {
              { OutputStringStream stream004 = OutputStringStream.newOutputStringStream();

                { Object old$PrintreadablyP$004 = Stella.$PRINTREADABLYp$.get();

                  try {
                    Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                    stream004.nativeStream.println("ERROR: Illegal parameter: `" + p + "'.");
                    Logic.helpSignalPropositionError(stream004, Logic.KWD_ERROR);

                  } finally {
                    Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$004);
                  }
                }
                throw ((PropositionError)(PropositionError.newPropositionError(stream004.theStringReader()).fillInStackTrace()));
              }
            }
          }
          if (Logic.sequenceVariableSymbolP(name)) {
            variablearityP = true;
          }
          if (parameternames.memberP(name)) {
            { OutputStringStream stream005 = OutputStringStream.newOutputStringStream();

              { Object old$PrintreadablyP$005 = Stella.$PRINTREADABLYp$.get();

                try {
                  Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                  stream005.nativeStream.println("ERROR: Duplicate relation parameter name: `" + name + "'.");
                  Logic.helpSignalPropositionError(stream005, Logic.KWD_ERROR);

                } finally {
                  Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$005);
                }
              }
              throw ((PropositionError)(PropositionError.newPropositionError(stream005.theStringReader()).fillInStackTrace()));
            }
          }
          parameternames.push(name);
          parametertypes.push(Logic.coerceToBoundOrLocalSurrogate(((GeneralizedSymbol)(type))));
          if (variablearityP) {
            break loop000;
          }
        }
      }
      if (parametertypes == null) {
        { OutputStringStream stream006 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$006 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream006.nativeStream.println("ERROR: Missing relation parameter list.");
              Logic.helpSignalPropositionError(stream006, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$006);
            }
          }
          throw ((PropositionError)(PropositionError.newPropositionError(stream006.theStringReader()).fillInStackTrace()));
        }
      }
      if (parametertypes.emptyP()) {
        { OutputStringStream stream007 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$007 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream007.nativeStream.println("ERROR: Empty relation parameter list.");
              Logic.helpSignalPropositionError(stream007, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$007);
            }
          }
          throw ((PropositionError)(PropositionError.newPropositionError(stream007.theStringReader()).fillInStackTrace()));
        }
      }
      { List _return_temp = parameternames.reverse();

        MV_returnarray[0] = parametertypes.reverse();
        MV_returnarray[1] = BooleanWrapper.wrapBoolean(variablearityP);
        return (_return_temp);
      }
    }
  }

  public static NamedDescription getIdenticalRelation(Symbol name, String stringifiedsource) {
    { Surrogate surrogate = Logic.lookupLogicObjectSurrogate(name, ((Module)(Stella.$MODULE$.get())));
      Stella_Object surrogatevalue = ((surrogate != null) ? surrogate.surrogateValue : ((Stella_Object)(null)));
      NamedDescription description = null;

      if ((surrogatevalue != null) &&
          Stella_Object.isaP(surrogatevalue, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        description = ((NamedDescription)(surrogatevalue));
      }
      if (description != null) {
        if ((!BooleanWrapper.coerceWrappedBooleanToBoolean(description.badP())) &&
            Stella.stringEqlP(Logic.stringifiedSource(description), stringifiedsource)) {
          return (description);
        }
      }
      return (null);
    }
  }

  /** Define (or redefine) a logic function.  The accepted syntax is:
   * 	 
   *  (deffunction &lt;funconst&gt; (&lt;vardecl&gt;+) [:-&gt; &lt;vardecl&gt;]
   *     [:documentation &lt;string&gt;]
   *     [:&lt;= &lt;sentence&gt;] | [:=&gt; &lt;sentence&gt;] |
   *     [:&lt;&lt;= &lt;sentence&gt;] | [:=&gt;&gt; &lt;sentence&gt;] | 
   *     [:&lt;=&gt; &lt;sentence&gt;] | [:&lt;=&gt;&gt; &lt;sentence&gt;] |
   *     [:&lt;&lt;=&gt; &lt;sentence&gt;] | [:&lt;&lt;=&gt;&gt; &lt;sentence&gt;] |
   *     [:axioms {&lt;sentence&gt; | (&lt;sentence&gt;+)}]
   *     [&lt;keyword-option&gt;*])
   * 	
   * Function parameters can be typed or untyped.  If the <code>CG</code> option is
   * supplied, it specifies the output variable of the function.  Otherwise,
   * the last variable in the parameter list is used as the output variable.
   * See <code>defrelation</code> for a description of <code>LkeywordOptionG</code>s.
   * 
   * @param args
   * @return NamedDescription
   */
  public static NamedDescription deffunction(Cons args) {
    try {
      return (Logic.callDeffunction(args));
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
      return (null);
    }
  }

  public static NamedDescription deffunctionEvaluatorWrapper(Cons arguments) {
    return (Logic.deffunction(arguments));
  }

  /** Callable version of the <code>deffunction</code> command (which see).
   * Expects the same arguments as <code>deffunction</code> but supplied as a list.
   * @param arguments
   * @return NamedDescription
   */
  public static NamedDescription callDeffunction(Cons arguments) {
    { Cons definition = Cons.cons(Logic.SYM_LOGIC_DEFFUNCTION, arguments.concatenate(Stella.NIL, Stella.NIL));

      { Object old$Termsourcebeingparsed$000 = Logic.$TERMSOURCEBEINGPARSED$.get();
        Object old$Descriptionunderconstruction$000 = Logic.$DESCRIPTIONUNDERCONSTRUCTION$.get();

        try {
          Native.setSpecial(Logic.$TERMSOURCEBEINGPARSED$, Native.stringify(definition));
          Native.setSpecial(Logic.$DESCRIPTIONUNDERCONSTRUCTION$, null);
          definition.rest = Logic.normalizeDeffunctionArguments(arguments);
          Logic.internLogicObjectSurrogate(((Symbol)(definition.rest.value)));
          return (Logic.helpDefineRelationFromParseTree(definition, ((String)(Logic.$TERMSOURCEBEINGPARSED$.get()))));

        } finally {
          Logic.$DESCRIPTIONUNDERCONSTRUCTION$.set(old$Descriptionunderconstruction$000);
          Logic.$TERMSOURCEBEINGPARSED$.set(old$Termsourcebeingparsed$000);
        }
      }
    }
  }

  public static Cons normalizeDeffunctionArguments(Cons arguments) {
    { Stella_Object name = arguments.value;
      Stella_Object parameters = arguments.rest.value;
      Cons options = arguments.rest.rest;

      if (!(Stella_Object.symbolP(name))) {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream000.nativeStream.println("ERROR: Illegal function name where symbol expected: `" + name + "'.");
              Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
            }
          }
          throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      if (Stella_Object.safePrimaryType(parameters) == Logic.SGT_STELLA_CONS) {
        { Cons parameters000 = ((Cons)(parameters));

          loop000 : while (!(options == Stella.NIL)) {
            if ((options.value == Logic.KWD__g) &&
                (options.rest.value != null)) {
              parameters000 = parameters000.concatenate(Cons.cons(options.rest.value, Stella.NIL), Stella.NIL);
              arguments.secondSetter(parameters000);
              options.firstSetter(null);
              options.secondSetter(null);
              options = arguments.rest.rest.remove(null);
              arguments.rest.rest = options;
              break loop000;
            }
            options = options.rest.rest;
          }
          if (parameters000 == Stella.NIL) {
            { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

              { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

                try {
                  Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                  stream001.nativeStream.println("ERROR: Cannot have 0-arity functions.");
                  Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

                } finally {
                  Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
                }
              }
              throw ((PropositionError)(PropositionError.newPropositionError(stream001.theStringReader()).fillInStackTrace()));
            }
          }
        }
      }
      else {
        { OutputStringStream stream002 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$002 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream002.nativeStream.println("ERROR: Illegal parameter list: `" + parameters + "'.");
              Logic.helpSignalPropositionError(stream002, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$002);
            }
          }
          throw ((PropositionError)(PropositionError.newPropositionError(stream002.theStringReader()).fillInStackTrace()));
        }
      }
      return (arguments);
    }
  }

  /** Define (or redefine) a logic relation.  The accepted syntax is:
   * 	 
   *  (defrelation &lt;relconst&gt; (&lt;vardecl&gt;+)
   *     [:documentation &lt;string&gt;]
   *     [:&lt;= &lt;sentence&gt;] | [:=&gt; &lt;sentence&gt;] |
   *     [:&lt;&lt;= &lt;sentence&gt;] | [:=&gt;&gt; &lt;sentence&gt;] | 
   *     [:&lt;=&gt; &lt;sentence&gt;] | [:&lt;=&gt;&gt; &lt;sentence&gt;] |
   *     [:&lt;&lt;=&gt; &lt;sentence&gt;] | [:&lt;&lt;=&gt;&gt; &lt;sentence&gt;] |
   *     [:axioms {&lt;sentence&gt; | (&lt;sentence&gt;+)}]
   *     [&lt;keyword-option&gt;*])
   * 	
   * Relation parameters can be typed or untyped.
   * <code>LkeywordOptionG</code> represents a keyword followed by a value that states an
   * assertion about <code>LrelconstG</code>.  For example, including the option <code>CfooBar</code>
   * states that the proposition <code>_fooLrelconstGBar_</code> is true.  <code>Cfoo_barFum_</code>
   * states that both <code>_fooLrelconstGBar_</code> and <code>_fooLrelconstGFum_</code> are true.
   * <code>CfooTrue</code> states that <code>_fooLrelconstG_</code> is true, <code>CfooFalse</code> states that
   * <code>_not_fooLrelconstG__</code> is true.
   * 
   * @param args
   * @return NamedDescription
   */
  public static NamedDescription defrelation(Cons args) {
    try {
      return (Logic.callDefrelation(args));
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
      return (null);
    }
  }

  public static NamedDescription defrelationEvaluatorWrapper(Cons arguments) {
    return (Logic.defrelation(arguments));
  }

  /** Callable version of the <code>defrelation</code> command (which see).
   * Expects the same arguments as <code>defrelation</code> but supplied as a list.
   * @param arguments
   * @return NamedDescription
   */
  public static NamedDescription callDefrelation(Cons arguments) {
    { Cons definition = Cons.cons(Logic.SYM_LOGIC_DEFRELATION, arguments.concatenate(Stella.NIL, Stella.NIL));

      { Object old$Termsourcebeingparsed$000 = Logic.$TERMSOURCEBEINGPARSED$.get();
        Object old$Descriptionunderconstruction$000 = Logic.$DESCRIPTIONUNDERCONSTRUCTION$.get();

        try {
          Native.setSpecial(Logic.$TERMSOURCEBEINGPARSED$, Native.stringify(definition));
          Native.setSpecial(Logic.$DESCRIPTIONUNDERCONSTRUCTION$, null);
          definition.rest = Logic.normalizeDefrelationArguments(arguments);
          Logic.internLogicObjectSurrogate(((Symbol)(definition.rest.value)));
          return (Logic.helpDefineRelationFromParseTree(definition, ((String)(Logic.$TERMSOURCEBEINGPARSED$.get()))));

        } finally {
          Logic.$DESCRIPTIONUNDERCONSTRUCTION$.set(old$Descriptionunderconstruction$000);
          Logic.$TERMSOURCEBEINGPARSED$.set(old$Termsourcebeingparsed$000);
        }
      }
    }
  }

  public static Cons normalizeDefrelationArguments(Cons arguments) {
    { Stella_Object name = arguments.value;
      Stella_Object parameters = arguments.rest.value;
      Cons options = arguments.rest.rest;

      if (!(Stella_Object.symbolP(name))) {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream000.nativeStream.println("ERROR: Illegal relation name where symbol expected: `" + name + "'.");
              Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
            }
          }
          throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      if (!(Stella_Object.consP(parameters))) {
        { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream001.nativeStream.println("ERROR: Illegal parameter list: `" + parameters + "'.");
              Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
            }
          }
          throw ((PropositionError)(PropositionError.newPropositionError(stream001.theStringReader()).fillInStackTrace()));
        }
      }
      if (((Cons)(parameters)) == Stella.NIL) {
        { OutputStringStream stream002 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$002 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream002.nativeStream.println("ERROR: Cannot have 0-arity relations.");
              Logic.helpSignalPropositionError(stream002, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$002);
            }
          }
          throw ((PropositionError)(PropositionError.newPropositionError(stream002.theStringReader()).fillInStackTrace()));
        }
      }
      if (options.memberP(Logic.KWD__g)) {
        { OutputStringStream stream003 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$003 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream003.nativeStream.println("ERROR: 'defrelation' does not allow a return value (':->') clause.");
              Logic.helpSignalPropositionError(stream003, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$003);
            }
          }
          throw ((PropositionError)(PropositionError.newPropositionError(stream003.theStringReader()).fillInStackTrace()));
        }
      }
      return (arguments);
    }
  }

  /** Define (or redefine) a concept.  The accepted syntax is:
   * 	 
   *  (defconcept &lt;conceptconst&gt; [(&lt;var&gt; &lt;parent&gt;*)]
   *     [:documentation &lt;string&gt;]
   *     [:&lt;= &lt;sentence&gt;] | [:=&gt; &lt;sentence&gt;] |
   *     [:&lt;&lt;= &lt;sentence&gt;] | [:=&gt;&gt; &lt;sentence&gt;] | 
   *     [:&lt;=&gt; &lt;sentence&gt;] | [:&lt;=&gt;&gt; &lt;sentence&gt;] | [:&lt;&lt;=&gt; &lt;sentence&gt;] |
   *     [:&lt;&lt;=&gt;&gt; &lt;sentence&gt;] |
   *     [:axioms {&lt;sentence&gt; | (&lt;sentence&gt;+)}] |
   *     &lt;keyword-option&gt;*)
   * 	
   * Declaration of a concept variable <code>LvarG</code> is optional, unless any
   * implication (arrow) options are supplied that need to reference it.  A
   * possibly empty list of concept names following <code>LvarG</code> is taken as the list
   * of parents of <code>LconceptconstG</code>.  Alternatively, parents can be specified
   * via the <code>CEG</code> option.  If no parents are specified, the parent of
   * <code>LconceptconstG</code> is taken to be THING.  <code>LkeywordOptionG</code> represents a
   * keyword followed by a value that states an assertion about <code>LconceptconstG</code>.
   * See <code>defrelation</code> for a description of <code>LkeywordOptionG</code>s.
   * 
   * @param args
   * @return NamedDescription
   */
  public static NamedDescription defconcept(Cons args) {
    try {
      return (Logic.callDefconcept(args));
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
      return (null);
    }
  }

  public static NamedDescription defconceptEvaluatorWrapper(Cons arguments) {
    return (Logic.defconcept(arguments));
  }

  /** Callable version of the <code>defconcept</code> command (which see).
   * Expects the same arguments as <code>defconcept</code> but supplied as a list.
   * @param arguments
   * @return NamedDescription
   */
  public static NamedDescription callDefconcept(Cons arguments) {
    { Cons definition = Cons.cons(Logic.SYM_LOGIC_DEFCONCEPT, arguments.concatenate(Stella.NIL, Stella.NIL));

      { Object old$Termsourcebeingparsed$000 = Logic.$TERMSOURCEBEINGPARSED$.get();
        Object old$Descriptionunderconstruction$000 = Logic.$DESCRIPTIONUNDERCONSTRUCTION$.get();

        try {
          Native.setSpecial(Logic.$TERMSOURCEBEINGPARSED$, Native.stringify(definition));
          Native.setSpecial(Logic.$DESCRIPTIONUNDERCONSTRUCTION$, null);
          definition.rest = Logic.normalizeDefconceptArguments(arguments);
          Logic.internLogicObjectSurrogate(((Symbol)(definition.rest.value)));
          return (Logic.helpDefineRelationFromParseTree(definition, ((String)(Logic.$TERMSOURCEBEINGPARSED$.get()))));

        } finally {
          Logic.$DESCRIPTIONUNDERCONSTRUCTION$.set(old$Descriptionunderconstruction$000);
          Logic.$TERMSOURCEBEINGPARSED$.set(old$Termsourcebeingparsed$000);
        }
      }
    }
  }

  public static Cons normalizeDefconceptArguments(Cons arguments) {
    { Stella_Object name = arguments.value;
      Cons parameters = null;
      Symbol selfvariable = Logic.SYM_LOGIC_pSELF;
      Cons supers = Stella.NIL;
      Cons impliesrules = Stella.NIL;

      if (!(Stella_Object.symbolP(name))) {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream000.nativeStream.println("ERROR: Illegal concept name where symbol expected: `" + name + "'.");
              Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
            }
          }
          throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      if (Stella_Object.consP(arguments.rest.value)) {
        parameters = ((Cons)(arguments.rest.value));
      }
      if (parameters != null) {
        if (Stella_Object.consP(parameters.value)) {
          parameters = ((Cons)(parameters.value));
        }
        if (parameters == Stella.NIL) {
          supers = Stella.NIL;
        }
        else if (Logic.questionMarkSymbolP(parameters.value)) {
          selfvariable = ((Symbol)(parameters.value));
          supers = parameters.rest;
        }
        else if (Stella_Object.symbolP(parameters.value)) {
          supers = parameters;
        }
        else {
          { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

            { Object old$PrintreadablyP$001 = Stella.$PRINTREADABLYp$.get();

              try {
                Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                stream001.nativeStream.println("ERROR: Illegal parameter list: `" + arguments.rest.value + "'.");
                Logic.helpSignalPropositionError(stream001, Logic.KWD_ERROR);

              } finally {
                Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$001);
              }
            }
            throw ((PropositionError)(PropositionError.newPropositionError(stream001.theStringReader()).fillInStackTrace()));
          }
        }
        { Stella_Object renamed_Super = null;
          Cons iter000 = supers;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            renamed_Super = iter000.value;
            impliesrules = Cons.cons(Logic.KWD_eg, impliesrules);
            impliesrules = Cons.cons(Cons.cons(renamed_Super, Cons.cons(selfvariable, Stella.NIL)), impliesrules);
          }
        }
        impliesrules = impliesrules.reverse();
        arguments.rest = Cons.cons(Cons.cons(Cons.cons(selfvariable, Cons.cons(name, Stella.NIL)), Stella.NIL), impliesrules.concatenate(arguments.rest.rest.concatenate(Stella.NIL, Stella.NIL), Stella.NIL));
      }
      else if (arguments.rest == Stella.NIL) {
        arguments.rest = Cons.cons(Cons.cons(Cons.cons(selfvariable, Cons.cons(name, Stella.NIL)), Stella.NIL), Stella.NIL);
      }
      else if (Stella_Object.keywordP(arguments.rest.value)) {
        arguments.rest.rest = Cons.cons(arguments.rest.value, arguments.rest.rest.concatenate(Stella.NIL, Stella.NIL));
        arguments.secondSetter(Cons.cons(Cons.cons(selfvariable, Cons.cons(name, Stella.NIL)), Stella.NIL));
      }
      return (arguments);
    }
  }

  public static NamedDescription defineRelationFromParseTree(Cons tree) {
    { GeneralizedSymbol testValue000 = ((GeneralizedSymbol)(tree.value));

      if (testValue000 == Logic.SYM_LOGIC_DEFCONCEPT) {
        return (Logic.callDefconcept(tree.rest));
      }
      else if (testValue000 == Logic.SYM_LOGIC_DEFRELATION) {
        return (Logic.callDefrelation(tree.rest));
      }
      else if (testValue000 == Logic.SYM_LOGIC_DEFFUNCTION) {
        return (Logic.callDeffunction(tree.rest));
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  /** Define (or redefine) a logic instance.  The accepted syntax is:
   * 	 
   *  (defobject &lt;constant&gt;
   *     [:documentation &lt;string&gt;]
   *     [&lt;keyword-option&gt;*])
   * 	
   * <code>LkeywordOptionG</code> represents a keyword followed by a value
   * that states an assertion about &lt;constant&gt;.  See <code>defrelation</code> for a
   * description of <code>LkeywordOptionG</code>s.
   * <p>
   * <code>defobject</code> provides a sugar-coated way to assert a collection of facts
   * about a logic constant, but otherwise adds nothing in terms of functionality.
   * 
   * @param args
   * @return LogicObject
   */
  public static LogicObject defobject(Cons args) {
    try {
      return (Logic.callDefobject(args));
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
      return (null);
    }
  }

  public static LogicObject defobjectEvaluatorWrapper(Cons arguments) {
    return (Logic.defobject(arguments));
  }

  /** Define (or redefine) a logic instance (<code>definstance</code> is an alias
   * for <code>defobject</code> which see).
   * @param args
   * @return LogicObject
   */
  public static LogicObject definstance(Cons args) {
    try {
      return (Logic.callDefobject(args));
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
      return (null);
    }
  }

  public static LogicObject definstanceEvaluatorWrapper(Cons arguments) {
    return (Logic.definstance(arguments));
  }

  /** Callable version of the <code>defobject</code> command (which see).
   * Expects the same arguments as <code>defobject</code> but supplied as a list.
   * @param arguments
   * @return LogicObject
   */
  public static LogicObject callDefobject(Cons arguments) {
    { Cons definition = Cons.cons(Logic.SYM_LOGIC_DEFOBJECT, arguments.concatenate(Stella.NIL, Stella.NIL));
      Symbol name = null;
      Cons options = Stella.NIL;
      Stella_Object term = null;

      { Object old$Termsourcebeingparsed$000 = Logic.$TERMSOURCEBEINGPARSED$.get();

        try {
          Native.setSpecial(Logic.$TERMSOURCEBEINGPARSED$, Native.stringify(definition));
          arguments = Logic.normalizeDefobjectArguments(arguments);
          options = arguments.rest;
          if (Stella_Object.consP(arguments.value)) {
            name = Symbol.internSymbol(Native.stringify(arguments.value));
            term = Logic.conceiveTerm(arguments.value);
            if (term == null) {
              { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

                { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

                  try {
                    Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                    stream000.nativeStream.println("ERROR: Illegal object name or term: `" + name + "'.");
                    Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

                  } finally {
                    Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
                  }
                }
                throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
              }
            }
          }
          else {
            name = ((Symbol)(arguments.value));
            Logic.internLogicObjectSurrogate(name);
            term = Logic.createLogicInstance(null, null);
          }
          if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(term), Logic.SGT_LOGIC_LOGIC_OBJECT)) {
            { LogicObject term000 = ((LogicObject)(term));

              Logic.stringifiedSourceSetter(term000, ((String)(Logic.$TERMSOURCEBEINGPARSED$.get())));
              Logic.bindLogicObjectToSurrogate(name, term000);
              term000.processDefinitionOptions(options);
              Logic.registerUnfinalizedObject(term000);
            }
          }
          else {
            Logic.bindLogicObjectToSurrogate(name, term);
            { Stella_Object key = null;
              Stella_Object value = null;
              Cons iter000 = Stella_Object.vetOptions(options, null).thePlist;

              for (;!(iter000 == Stella.NIL); iter000 = iter000.rest.rest) {
                key = iter000.value;
                value = iter000.rest.value;
                Logic.assertKeywordAxiom(term, name, ((Keyword)(key)), value);
              }
            }
          }
          return (((LogicObject)(term)));

        } finally {
          Logic.$TERMSOURCEBEINGPARSED$.set(old$Termsourcebeingparsed$000);
        }
      }
    }
  }

  public static Cons normalizeDefobjectArguments(Cons arguments) {
    { Stella_Object name = arguments.value;
      Cons options = arguments.rest;

      if (!(Stella_Object.symbolP(name) ||
          Stella_Object.consP(name))) {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

            try {
              Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
              stream000.nativeStream.println("ERROR: Illegal object name where symbol or function term expected: `" + name + "'.");
              Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

            } finally {
              Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
            }
          }
          throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
        }
      }
      options = options;
      return (arguments);
    }
  }

  /** Define (or redefine) a named proposition.  The accepted syntax is:
   * 	 
   *  (defproposition &lt;name&gt; &lt;sentence&gt;
   *     [:documentation &lt;string&gt;]
   *     [:forward-only? {true | false}]
   *     [:backward-only? {true | false}]
   *     [:dont-optimize? {true | false}]
   *     [:confidence-level {:strict | :default}]
   *     [&lt;keyword-option&gt;*])
   * 	
   * &lt;sentence&gt; can be any sentence that is legal as a top-level assertion.
   * &lt;name&gt; can be a string or symbol and will be bound to the asserted
   * proposition represented by &lt;sentence&gt;.  After this definition every
   * occurrence of &lt;name&gt; will be replaced by the associated proposition.
   * <p>
   * The options :forward-only? and :backward-only? can be used to tell the
   * inference engine to only use the rule in forward or backward direction
   * (this can also be achieved by using the <code>LLE</code> or <code>EGG</code> implication
   * arrows).  :dont-optimize?  tells the inference engine to not rearrange
   * the order of clauses in the antecedent of a rule and instead evaluate
   * them in their original order.  :confidence-level can be used to mark a
   * proposition as default only.
   * <p>
   * <code>LkeywordOptionG</code> represents a keyword followed by a value
   * that states an assertion about the proposition &lt;name&gt;.  See <code>defrelation</code>
   * for a description of <code>LkeywordOptionG</code>s.
   * 
   * @param args
   * @return Proposition
   */
  public static Proposition defproposition(Cons args) {
    try {
      return (Logic.callDefproposition(args));
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
      return (null);
    }
  }

  public static Proposition defpropositionEvaluatorWrapper(Cons arguments) {
    return (Logic.defproposition(arguments));
  }

  /** Define (or redefine) a named rule (<code>defrule</code> is an alias
   * for <code>defproposition</code> which see).
   * @param args
   * @return Proposition
   */
  public static Proposition defrule(Cons args) {
    try {
      return (Logic.callDefproposition(args));
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
      return (null);
    }
  }

  public static Proposition defruleEvaluatorWrapper(Cons arguments) {
    return (Logic.defrule(arguments));
  }

  /** Callable version of the <code>defproposition</code> command (which see).
   * Expects the same arguments as <code>defproposition</code> but supplied as a list.
   * @param arguments
   * @return Proposition
   */
  public static Proposition callDefproposition(Cons arguments) {
    { Cons definition = Cons.cons(Logic.SYM_LOGIC_DEFPROPOSITION, arguments.concatenate(Stella.NIL, Stella.NIL));
      Symbol name = null;
      Cons options = Stella.NIL;
      Stella_Object conception = null;
      Proposition proposition = null;
      TruthValue oldtruthvalue = null;

      { Object old$Termsourcebeingparsed$000 = Logic.$TERMSOURCEBEINGPARSED$.get();

        try {
          Native.setSpecial(Logic.$TERMSOURCEBEINGPARSED$, Native.stringify(definition));
          arguments = Logic.normalizeDefpropositionArguments(arguments);
          name = ((Symbol)(arguments.value));
          Logic.internLogicObjectSurrogate(name);
          conception = Logic.smartUpdateProposition(arguments.rest.value, Logic.KWD_CONCEIVE);
          if (conception == null) {
            return (null);
          }
          else if (Stella_Object.consP(conception)) {
            proposition = Logic.conjoinPropositions(((Cons)(conception)));
            proposition = Proposition.fastenDownOneProposition(proposition, false);
          }
          else {
            proposition = ((Proposition)(conception));
          }
          options = arguments.rest.rest;
          Logic.stringifiedSourceSetter(proposition, ((String)(Logic.$TERMSOURCEBEINGPARSED$.get())));
          KeyValueList.setDynamicSlotValue(proposition.dynamicSlots, Logic.SYM_STELLA_BADp, Stella.TRUE_WRAPPER, null);
          Logic.bindLogicObjectToSurrogate(name, proposition);
          proposition.processDefinitionOptions(options);
          if (proposition.kind == Logic.KWD_FORALL) {
            { Proposition satellite = null;
              Cons iter000 = proposition.satellitePropositions().theConsList;

              for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                satellite = ((Proposition)(iter000.value));
                Proposition.destroyProposition(satellite);
              }
            }
            KeyValueList.setDynamicSlotValue(proposition.dynamicSlots, Logic.SYM_LOGIC_SATELLITE_PROPOSITIONS, null, null);
          }
          oldtruthvalue = ((TruthValue)(Stella_Object.accessInContext(proposition.truthValue, proposition.homeContext, false)));
          if (Proposition.lookupAnnotation(proposition, Logic.KWD_CONFIDENCE_LEVEL) == Logic.KWD_DEFAULT) {
            Proposition.removeAnnotation(proposition, Logic.KWD_CONFIDENCE_LEVEL);
            Proposition.updatePropositionTruthValue(proposition, Logic.KWD_PRESUME_TRUE);
          }
          else {
            Proposition.updatePropositionTruthValue(proposition, Logic.KWD_ASSERT_TRUE);
          }
          if (oldtruthvalue == ((TruthValue)(Stella_Object.accessInContext(proposition.truthValue, proposition.homeContext, false)))) {
            Proposition.runGoesTrueDemons(proposition);
          }
          KeyValueList.setDynamicSlotValue(proposition.dynamicSlots, Logic.SYM_STELLA_BADp, null, null);
          Logic.registerUnfinalizedObject(proposition);
          return (proposition);

        } finally {
          Logic.$TERMSOURCEBEINGPARSED$.set(old$Termsourcebeingparsed$000);
        }
      }
    }
  }

  public static Cons normalizeDefpropositionArguments(Cons arguments) {
    { Stella_Object name = arguments.value;
      Stella_Object proposition = arguments.rest.value;
      PropertyList options = null;
      Stella_Object value = null;
      Cons annotations = Stella.NIL;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(arguments.value);

        if (Surrogate.subtypeOfSymbolP(testValue000)) {
        }
        else if (Surrogate.subtypeOfStringP(testValue000)) {
          name = Symbol.internSymbol(((StringWrapper)(arguments.value)).wrapperValue);
          arguments.firstSetter(name);
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

              try {
                Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                stream000.nativeStream.println("ERROR: Illegal proposition name where symbol or string expected: `" + name + "'.");
                Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

              } finally {
                Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
              }
            }
            throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
      options = Stella_Object.vetOptions(arguments.rest.rest, null);
      value = options.lookup(Logic.KWD_FORWARDp);
      if (value != null) {
        options.removeAt(Logic.KWD_FORWARDp);
        options.insertAt(Logic.KWD_FORWARD_ONLYp, value);
      }
      value = options.lookup(Logic.KWD_BACKWARDp);
      if (value != null) {
        options.removeAt(Logic.KWD_BACKWARDp);
        options.insertAt(Logic.KWD_BACKWARD_ONLYp, value);
      }
      value = options.lookup(Logic.KWD_CONFIDENCE_LEVEL);
      if (value != null) {
        annotations = annotations.concatenate(Cons.list$(Cons.cons(Logic.KWD_CONFIDENCE_LEVEL, Cons.cons(value, Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL);
        options.removeAt(Logic.KWD_CONFIDENCE_LEVEL);
      }
      value = options.lookup(Logic.KWD_WEIGHT);
      if (value != null) {
        annotations = annotations.concatenate(Cons.list$(Cons.cons(Logic.KWD_WEIGHT, Cons.cons(value, Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL);
        options.removeAt(Logic.KWD_WEIGHT);
      }
      if (!(annotations == Stella.NIL)) {
        arguments.secondSetter(Cons.list$(Cons.cons(Logic.SYM_LOGIC_ABOUT, Cons.cons(proposition, Cons.cons(annotations.concatenate(Stella.NIL, Stella.NIL), Stella.NIL)))));
      }
      arguments.rest.rest = options.thePlist;
      return (arguments);
    }
  }

  public static boolean commandL(MethodSlot command1, MethodSlot command2) {
    return (Stella.stringLessP(command1.slotName.visibleName(false), command2.slotName.visibleName(false)));
  }

  public static List listLogicCommands() {
    { List commands = List.newList();

      { MethodSlot function = null;
        Iterator iter000 = Module.allFunctions(Stella.getStellaModule("/LOGIC", true), true);
        Cons collect000 = null;

        while (iter000.nextP()) {
          function = ((MethodSlot)(iter000.value));
          if (((BooleanWrapper)(KeyValueList.dynamicSlotValue(function.dynamicSlots, Logic.SYM_STELLA_METHOD_COMMANDp, Stella.FALSE_WRAPPER))).wrapperValue &&
              function.publicP()) {
            if (collect000 == null) {
              {
                collect000 = Cons.cons(function, Stella.NIL);
                if (commands.theConsList == Stella.NIL) {
                  commands.theConsList = collect000;
                }
                else {
                  Cons.addConsToEndOfConsList(commands.theConsList, collect000);
                }
              }
            }
            else {
              {
                collect000.rest = Cons.cons(function, Stella.NIL);
                collect000 = collect000.rest;
              }
            }
          }
        }
      }
      { Symbol stellacommand = null;
        Cons iter001 = Logic.$LOGIC_RELEVANT_STELLA_COMMANDS$;
        Cons collect001 = null;

        for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
          stellacommand = ((Symbol)(iter001.value));
          if (collect001 == null) {
            {
              collect001 = Cons.cons(Symbol.lookupCommand(stellacommand), Stella.NIL);
              if (commands.theConsList == Stella.NIL) {
                commands.theConsList = collect001;
              }
              else {
                Cons.addConsToEndOfConsList(commands.theConsList, collect001);
              }
            }
          }
          else {
            {
              collect001.rest = Cons.cons(Symbol.lookupCommand(stellacommand), Stella.NIL);
              collect001 = collect001.rest;
            }
          }
        }
      }
      return (commands.sort(Native.find_java_method("edu.isi.powerloom.logic.Logic", "commandL", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.MethodSlot"), Native.find_java_class("edu.isi.stella.MethodSlot")})));
    }
  }

  /** Describe specific commands, or print a list of available commands.
   * @param commands
   */
  public static void help(Cons commands) {
    { Cons thecommands = commands;

      if (thecommands == Stella.NIL) {
        {
          Stella.STANDARD_OUTPUT.nativeStream.println("The following commands are available (type `(help <command>+)'");
          Stella.STANDARD_OUTPUT.nativeStream.println("to get command-specific documentation):");
          Stella.STANDARD_OUTPUT.nativeStream.println();
        }
;
        { List allcommands = Logic.listLogicCommands();

          { MethodSlot command = null;
            Cons iter000 = allcommands.theConsList;

            for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
              command = ((MethodSlot)(iter000.value));
              if (((StringWrapper)(KeyValueList.dynamicSlotValue(command.dynamicSlots, Logic.SYM_STELLA_DOCUMENTATION, Stella.NULL_STRING_WRAPPER))).wrapperValue != null) {
                command.printDocumentation(Stella.STANDARD_OUTPUT, true);
              }
            }
          }
          {
            Stella.STANDARD_OUTPUT.nativeStream.println();
            Stella.STANDARD_OUTPUT.nativeStream.println("Undocumented Commands:");
            Stella.STANDARD_OUTPUT.nativeStream.println();
          }
;
          { MethodSlot command = null;
            Cons iter001 = allcommands.theConsList;

            for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
              command = ((MethodSlot)(iter001.value));
              if (!(((StringWrapper)(KeyValueList.dynamicSlotValue(command.dynamicSlots, Logic.SYM_STELLA_DOCUMENTATION, Stella.NULL_STRING_WRAPPER))).wrapperValue != null)) {
                Stella.STANDARD_OUTPUT.nativeStream.println(command.slotName + ":");
              }
            }
          }
        }
      }
      else {
        { Symbol commandname = null;
          Cons iter002 = thecommands;

          for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
            commandname = ((Symbol)(iter002.value));
            { MethodSlot command = Symbol.lookupCommand(commandname);

              if (command != null) {
                command.printDocumentation(Stella.STANDARD_OUTPUT, false);
              }
              else {
                Stella.STANDARD_OUTPUT.nativeStream.println("Undefined command: `" + commandname + "'");
              }
            }
          }
        }
      }
    }
  }

  public static void helpEvaluatorWrapper(Cons arguments) {
    Logic.help(arguments);
  }

  public static Stella_Object coerceToInstanceInModule(Stella_Object self, Module module, boolean localP, Stella_Object original) {
    if (self == null) {
      if (original != null) {
        Stella.STANDARD_OUTPUT.nativeStream.println("Can't find the entity referenced as: `" + original + "'.");
      }
      return (null);
    }
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          return (self000);
        }
      }
      else if (Surrogate.subtypeOfStringP(testValue000)) {
        { StringWrapper self000 = ((StringWrapper)(self));

          { String name = self000.wrapperValue;
            Module modulefromstring = null;

            if (Stella.qualifiedStellaNameP(name)) {
              { Object [] caller_MV_returnarray = new Object[1];

                modulefromstring = Stella.computeModuleAndBareName(name, caller_MV_returnarray);
                name = ((String)(((StringWrapper)(caller_MV_returnarray[0])).wrapperValue));
              }
            }
            if (module == null) {
              if (modulefromstring != null) {
                module = modulefromstring;
              }
              else {
                module = ((Module)(Stella.$MODULE$.get()));
              }
            }
            { Surrogate surrogate = Surrogate.lookupSurrogateInModule(name, module, localP);

              if ((surrogate == null) ||
                  (surrogate.surrogateValue == null)) {
                if ((surrogate != null) &&
                    (Logic.homeObjectStore(surrogate) != null)) {
                  Logic.homeObjectStore(surrogate).fetchInstance(surrogate);
                }
                else if ((surrogate == null) &&
                    (((ObjectStore)(KeyValueList.dynamicSlotValue(module.dynamicSlots, Logic.SYM_LOGIC_OBJECT_STORE, null))) != null)) {
                  ((ObjectStore)(KeyValueList.dynamicSlotValue(module.dynamicSlots, Logic.SYM_LOGIC_OBJECT_STORE, null))).fetchInstance(Surrogate.internSurrogateInModule(name, module, localP));
                }
              }
              if ((surrogate != null) &&
                  (surrogate.surrogateValue != null)) {
                return (Logic.coerceToInstanceInModule(surrogate, module, true, original));
              }
              else {
                return (null);
              }
            }
          }
        }
      }
      else if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol self000 = ((Symbol)(self));

          { Module startingmodule = ((module != null) ? module : ((Module)(self000.homeContext)));
            Stella_Object value = Logic.coerceToInstanceInModule(Surrogate.lookupSurrogateInModule(self000.symbolName, startingmodule, localP), null, localP, null);

            if (value != null) {
              return (value);
            }
            else if (!(module == ((Module)(Stella.$MODULE$.get())))) {
              return (Logic.coerceToInstanceInModule(Surrogate.lookupSurrogateInModule(self000.symbolName, ((Module)(Stella.$MODULE$.get())), localP), ((Module)(Stella.$MODULE$.get())), localP, original));
            }
            else if (original != null) {
              return (Logic.coerceToInstanceInModule(null, null, false, original));
            }
            else {
              return (null);
            }
          }
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate self000 = ((Surrogate)(self));

          { Stella_Object value = self000.surrogateValue;

            if (value != null) {
              return (Logic.coerceToInstanceInModule(value, null, true, original));
            }
            else {
              return (Logic.coerceToInstanceInModule(StringWrapper.wrapString(self000.symbolName), ((Module)(self000.homeContext)), localP, original));
            }
          }
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_RELATION)) {
        { Relation self000 = ((Relation)(self));

          return (Logic.getDescription(self000));
        }
      }
      else if (Surrogate.subtypeOfKeywordP(testValue000)) {
        { Keyword self000 = ((Keyword)(self));

          return (Logic.coerceToInstanceInModule(StringWrapper.wrapString(self000.symbolName), module, localP, original));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing self000 = ((Thing)(self));

          return (self000);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PROPOSITION)) {
        { Proposition self000 = ((Proposition)(self));

          return (self000);
        }
      }
      else {
        return (Logic.coerceToInstanceInModule(null, null, false, original));
      }
    }
  }

  /** Return the nearest instance with name 'instanceRef'
   * visible from the current module.  'instanceRef' can be a string, symbol,
   * or surrogate.  If 'instanceRef' is a surrogate, the search originates
   * in the module the surrogate was interned in.
   * @param instanceref
   * @return Stella_Object
   */
  public static Stella_Object getInstance(Stella_Object instanceref) {
    if (instanceref == null) {
      return (null);
    }
    else if (Stella_Object.isaP(instanceref, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
      return (instanceref);
    }
    else {
      return (Logic.coerceToInstanceInModule(instanceref, null, false, null));
    }
  }

  /** Return the nearest instance with name 'instanceRef'
   * visible from the current module.  'instanceRef' can be a string, symbol,
   * or surrogate.  If 'instanceRef' is a surrogate, the search originates
   * in the module the surrogate was interned in.
   * @param instanceref
   * @return Stella_Object
   */
  public static Stella_Object findInstance(Stella_Object instanceref) {
    return (Logic.getInstance(instanceref));
  }

  /** Used to convert a computation to reference so-called
   * 'template' slots rather than 'own' slots:  If 'instanceRef' denotes a class,
   * return a prototype of that class.  Otherwise, return 'instanceRef'.
   * @param instanceref
   * @return LogicObject
   */
  public static LogicObject getSelfOrPrototype(Stella_Object instanceref) {
    return ((Logic.classP(instanceref) ? Description.getPrototype(((Description)(instanceref))) : ((LogicObject)(instanceref))));
  }

  /** Return the nearest class with name 'instanceRef'
   * visible from the current module.  'instanceRef' can be a string, symbol,
   * or surrogate.  If 'instanceRef' is a surrogate, the search originates
   * in the module the surrogate was interned in.
   * @param instanceref
   * @return LogicObject
   */
  public static LogicObject getClass(Stella_Object instanceref) {
    { Stella_Object instance = Logic.coerceToInstanceInModule(instanceref, null, false, null);

      if (Logic.classP(instance)) {
        return (((LogicObject)(instance)));
      }
      else {
        return (null);
      }
    }
  }

  /** Return the nearest relation with name 'instanceRef'
   * visible from the current module.  'instanceRef' can be a string, symbol,
   * or surrogate.  If 'instanceRef' is a surrogate, the search originates
   * in the module the surrogate was interned in.
   * @param instanceref
   * @return LogicObject
   */
  public static LogicObject getRelation(Stella_Object instanceref) {
    { Stella_Object instance = Logic.coerceToInstanceInModule(instanceref, null, false, null);

      if (Logic.relationP(instance)) {
        return (((LogicObject)(instance)));
      }
      else {
        return (null);
      }
    }
  }

  /** Return a module named 'moduleRef'.
   * @param moduleref
   * @return Module
   */
  public static Module getModule(Stella_Object moduleref) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(moduleref);

      if (Surrogate.subtypeOfStringP(testValue000)) {
        { StringWrapper moduleref000 = ((StringWrapper)(moduleref));

          return (Stella.getStellaModule(moduleref000.wrapperValue, false));
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate moduleref000 = ((Surrogate)(moduleref));

          return (Stella.getStellaModule(moduleref000.symbolName, false));
        }
      }
      else if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol moduleref000 = ((Symbol)(moduleref));

          return (Stella.getStellaModule(moduleref000.symbolName, false));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_MODULE)) {
        { Module moduleref000 = ((Module)(moduleref));

          return (moduleref000);
        }
      }
      else {
        return (null);
      }
    }
  }

  /** Return TRUE if 'objectRef' denotes a relation or a class.
   * @param objectref
   * @return boolean
   */
  public static boolean collectionP(Stella_Object objectref) {
    { Stella_Object instance = Logic.getInstance(objectref);

      if (instance == null) {
        return (false);
      }
      if (Surrogate.subtypeOfP(Stella_Object.safePrimaryType(instance), Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject instance000 = ((LogicObject)(instance));

          return (Logic.testIsaP(instance000, Logic.SGT_PL_KERNEL_KB_COLLECTION));
        }
      }
      else {
        return (false);
      }
    }
  }

  /** Return TRUE if 'objectRef' denotes a class.
   * @param objectref
   * @return boolean
   */
  public static boolean classP(Stella_Object objectref) {
    { Stella_Object instance = Logic.getInstance(objectref);

      if (instance == null) {
        return (false);
      }
      else {
        return (Logic.testIsaP(instance, Logic.SGT_PL_KERNEL_KB_CLASS));
      }
    }
  }

  /** Return TRUE if 'objectRef' denotes a relation or a class.
   * @param objectref
   * @return boolean
   */
  public static boolean relationP(Stella_Object objectref) {
    { Stella_Object instance = Logic.getInstance(objectref);

      if (instance == null) {
        return (false);
      }
      else {
        return (Logic.testIsaP(instance, Logic.SGT_PL_KERNEL_KB_RELATION));
      }
    }
  }

  /** Return TRUE if 'relationRef' references a function.
   * @param relationref
   * @return boolean
   */
  public static boolean functionP(Stella_Object relationref) {
    { Stella_Object instance = Logic.getInstance(relationref);

      if ((instance == null) ||
          (Logic.SGT_PL_KERNEL_KB_FUNCTION.surrogateValue == null)) {
        return (false);
      }
      else {
        return (Logic.testIsaP(instance, Logic.SGT_PL_KERNEL_KB_FUNCTION));
      }
    }
  }

  /** Return TRUE if <code>objectref</code> denotes a literal or scalar.
   * @param objectref
   * @return boolean
   */
  public static boolean constantP(Stella_Object objectref) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(objectref);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_LITERAL_WRAPPER)) {
        { LiteralWrapper objectref000 = ((LiteralWrapper)(objectref));

          return (true);
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate objectref000 = ((Surrogate)(objectref));

          return (Logic.constantP(objectref000.surrogateValue));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing objectref000 = ((Thing)(objectref));

          return (Logic.testIsaP(objectref000, Logic.SGT_STELLA_LITERAL) ||
              Logic.testIsaP(objectref000, Logic.SGT_PL_KERNEL_KB_SCALAR));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject objectref000 = ((LogicObject)(objectref));

          return (Logic.testIsaP(objectref000, Logic.SGT_STELLA_LITERAL) ||
              Logic.testIsaP(objectref000, Logic.SGT_PL_KERNEL_KB_SCALAR));
        }
      }
      else {
        return (false);
      }
    }
  }

  /** Convert 'self' into an equivalent PowerLoom object
   * that can be passed as an argument wherever an instance is expected.
   * @param self
   * @return Stella_Object
   */
  public static Stella_Object termify(Stella_Object self) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(self);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_LITERAL_WRAPPER)) {
        { LiteralWrapper self000 = ((LiteralWrapper)(self));

          return (((LiteralWrapper)(self000.permanentify())));
        }
      }
      else if (Surrogate.subtypeOfSurrogateP(testValue000)) {
        { Surrogate self000 = ((Surrogate)(self));

          if (self000.surrogateValue != null) {
            return (Logic.valueOf(self000.surrogateValue));
          }
          Stella.STANDARD_OUTPUT.nativeStream.print("Can't termify the surrogate 'self' because it is undefined.");
          return (null);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject self000 = ((LogicObject)(self));

          return (Logic.valueOf(self000));
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing self000 = ((Thing)(self));

          return (self000);
        }
      }
      else {
        Stella.STANDARD_OUTPUT.nativeStream.print("Can't 'termify': " + self);
        return (null);
      }
    }
  }

  public static boolean relationArityOkP(Surrogate relationref, int arity) {
    { NamedDescription relation = Logic.getDescription(relationref);

      if (relation == null) {
        Stella.STANDARD_OUTPUT.nativeStream.println("Reference to undefined relation " + relationref.symbolName);
        return (false);
      }
      if (!(relation.arity() == arity)) {
        {
          Stella.STANDARD_OUTPUT.nativeStream.println("Error:  Relation " + relationref.symbolName + " has arity " + relation.arity());
          Stella.STANDARD_OUTPUT.nativeStream.println("   when arity " + arity + " expected.");
        }
;
        return (false);
      }
      return (true);
    }
  }

  public static Cons filterOutUnnamedDescriptions(Cons descriptions) {
    { Cons namedones = Stella.NIL;

      { LogicObject d = null;
        Cons iter000 = descriptions;
        Cons collect000 = null;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          d = ((LogicObject)(iter000.value));
          if (Stella_Object.isaP(d, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
            if (collect000 == null) {
              {
                collect000 = Cons.cons(d, Stella.NIL);
                if (namedones == Stella.NIL) {
                  namedones = collect000;
                }
                else {
                  Cons.addConsToEndOfConsList(namedones, collect000);
                }
              }
            }
            else {
              {
                collect000.rest = Cons.cons(d, Stella.NIL);
                collect000 = collect000.rest;
              }
            }
          }
        }
      }
      return (namedones);
    }
  }

  /** Return a set of all of the types that are
   * asserted to be satisfied by 'self'.
   * @param self
   * @return Cons
   */
  public static Cons allAssertedTypes(Stella_Object self) {
    { Cons types = Stella.NIL;

      { Proposition p = null;
        Iterator iter000 = Logic.allTrueDependentIsaPropositions(self);

        while (iter000.nextP()) {
          p = ((Proposition)(iter000.value));
          { NamedDescription description = Logic.getDescription(((Surrogate)(p.operator)));

            if (!types.memberP(description)) {
              types = Cons.cons(description, types);
            }
          }
        }
      }
      return (types);
    }
  }

  /** Return a set of all of the types that are
   * satisfied by 'self', using only assertions and upward
   * taxonomic reasoning.
   * @param self
   * @return Cons
   */
  public static Cons allTaxonomicTypes(Stella_Object self) {
    { MemoizationTable memoTable000 = null;
      Cons memoizedEntry000 = null;
      Stella_Object memoizedValue000 = null;

      if (Stella.$MEMOIZATION_ENABLEDp$) {
        memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_ALL_TAXONOMIC_TYPES_MEMO_TABLE_000.surrogateValue));
        if (memoTable000 == null) {
          Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_ALL_TAXONOMIC_TYPES_MEMO_TABLE_000, "(:MAX-VALUES 500 :TIMESTAMPS (:KB-UPDATE))");
          memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_ALL_TAXONOMIC_TYPES_MEMO_TABLE_000.surrogateValue));
        }
        memoizedEntry000 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable000)), self, ((Context)(Stella.$CONTEXT$.get())), Stella.MEMOIZED_NULL_VALUE, null, 2);
        memoizedValue000 = memoizedEntry000.value;
      }
      if (memoizedValue000 != null) {
        if (memoizedValue000 == Stella.MEMOIZED_NULL_VALUE) {
          memoizedValue000 = null;
        }
      }
      else {
        memoizedValue000 = Logic.helpAllTypes(self, false);
        if (Stella.$MEMOIZATION_ENABLEDp$) {
          memoizedEntry000.value = ((memoizedValue000 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue000);
        }
      }
      { Cons value000 = ((Cons)(memoizedValue000));

        return (value000);
      }
    }
  }

  /** Return a set of all of the types that are
   * satisfied by 'self'.
   * @param self
   * @return Cons
   */
  public static Cons allTypes(Stella_Object self) {
    { MemoizationTable memoTable000 = null;
      Cons memoizedEntry000 = null;
      Stella_Object memoizedValue000 = null;

      if (Stella.$MEMOIZATION_ENABLEDp$) {
        memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_ALL_TYPES_MEMO_TABLE_000.surrogateValue));
        if (memoTable000 == null) {
          Surrogate.initializeMemoizationTable(Logic.SGT_LOGIC_F_ALL_TYPES_MEMO_TABLE_000, "(:MAX-VALUES 500 :TIMESTAMPS (:KB-UPDATE))");
          memoTable000 = ((MemoizationTable)(Logic.SGT_LOGIC_F_ALL_TYPES_MEMO_TABLE_000.surrogateValue));
        }
        memoizedEntry000 = MruMemoizationTable.lookupMruMemoizedValue(((MruMemoizationTable)(memoTable000)), self, ((Context)(Stella.$CONTEXT$.get())), Stella.MEMOIZED_NULL_VALUE, null, 2);
        memoizedValue000 = memoizedEntry000.value;
      }
      if (memoizedValue000 != null) {
        if (memoizedValue000 == Stella.MEMOIZED_NULL_VALUE) {
          memoizedValue000 = null;
        }
      }
      else {
        memoizedValue000 = Logic.helpAllTypes(self, true);
        if (Stella.$MEMOIZATION_ENABLEDp$) {
          memoizedEntry000.value = ((memoizedValue000 == null) ? Stella.MEMOIZED_NULL_VALUE : memoizedValue000);
        }
      }
      { Cons value000 = ((Cons)(memoizedValue000));

        return (value000);
      }
    }
  }

  public static Cons helpAllTypes(Stella_Object self, boolean doSubtypesP) {
    { Cons assertedtypes = Logic.allAssertedTypes(self);

      { List self000 = List.newList();

        self000.theConsList = Cons.copyConsList(assertedtypes);
        { List types = self000;

          { NamedDescription d = null;
            Cons iter000 = assertedtypes;

            for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
              d = ((NamedDescription)(iter000.value));
              { LogicObject c = null;
                Iterator iter001 = LogicObject.allSupercollections(d);

                while (iter001.nextP()) {
                  c = ((LogicObject)(iter001.value));
                  if (Stella_Object.isaP(c, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
                    if (!types.memberP(c)) {
                      types.push(c);
                    }
                  }
                }
              }
              if (doSubtypesP) {
                Description.helpAllSubtypes(d, self, types);
              }
            }
          }
          return (((Cons)(types.theConsList)));
        }
      }
    }
  }

  /** Return a set of most specific types that are
   * satisfied by 'self'.
   * @param self
   * @return Cons
   */
  public static Cons allDirectTypes(Stella_Object self) {
    return (Logic.mostSpecificNamedDescriptions(Logic.allTypes(self)));
  }

  /** Return TRUE if 'self' satisfies 'type'.
   * @param self
   * @param type
   * @return boolean
   */
  public static boolean testTypeOnInstanceP(Stella_Object self, Surrogate type) {
    return (Logic.currentInferenceLevel().levellizedTestTypeOnInstanceP(self, type));
  }

  public static Cons removeEquivalentRelations(Cons relationslist, NamedDescription relation) {
    if (relationslist.memberP(relation)) {
      { NamedDescription m = null;
        Cons iter000 = NamedDescription.allEquivalentRelations(relation, true);

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          m = ((NamedDescription)(iter000.value));
          relationslist = relationslist.remove(m);
        }
      }
    }
    return (relationslist);
  }

  /** Return TRUE if 'subrelation' specializes 'superrelation'.
   * @param subrelation
   * @param superrelation
   * @return boolean
   */
  public static boolean testSubrelationP(Surrogate subrelation, Surrogate superrelation) {
    if (subrelation == superrelation) {
      return (true);
    }
    { NamedDescription description = Logic.getDescription(subrelation);

      { boolean foundP000 = false;

        { LogicObject renamed_Super = null;
          Iterator iter000 = LogicObject.allSupercollections(description);

          loop000 : while (iter000.nextP()) {
            renamed_Super = ((LogicObject)(iter000.value));
            if (renamed_Super.surrogateValueInverse == superrelation) {
              foundP000 = true;
              break loop000;
            }
          }
        }
        { boolean value000 = foundP000;

          return (value000);
        }
      }
    }
  }

  /** Return a set of instances that belong to the class 'type'.
   * @param type
   * @return Cons
   */
  public static Cons allClassInstances(Surrogate type) {
    return (Logic.currentInferenceLevel().levellizedAllClassInstances(type).removeDuplicates());
  }

  /** Return a set of values that satisfy the relation
   * 'relation' (a surrogate) applied to 'nMinusOneArguments' plus that last value.
   * @param relation
   * @param nminusonearguments
   * @return Cons
   */
  public static Cons allRelationValues(Surrogate relation, Cons nminusonearguments) {
    if (!Logic.relationArityOkP(relation, nminusonearguments.length() + 1)) {
      return (Stella.NIL);
    }
    return (Logic.currentInferenceLevel().levellizedAllRelationValues(relation, nminusonearguments));
  }

  /** Return TRUE if 'relation' (a surrogate) is TRUE when
   * applied to 'arguments'.
   * @param relation
   * @param arguments
   * @return boolean
   */
  public static boolean testRelationOnArgumentsP(Surrogate relation, Cons arguments) {
    if (!Logic.relationArityOkP(relation, arguments.length())) {
      return (false);
    }
    return (Logic.currentInferenceLevel().levellizedTestRelationOnArgumentsP(relation, arguments));
  }

  /** Return TRUE if 'relation' (a surrogate) is asserted to 
   * be closed or if the current module closes all relations.
   * @param relation
   * @return boolean
   */
  public static boolean testClosedSlotP(Surrogate relation) {
    return (Logic.closedTermP(Logic.getDescription(relation)));
  }

  /** Return TRUE if 'relation' (a surrogate) is a function.
   * @param relation
   * @return boolean
   */
  public static boolean testFunctionSlotP(Surrogate relation) {
    return (NamedDescription.functionDescriptionP(Logic.getDescription(relation)));
  }

  public static Stella_Object loomArgumentDescriptionToKif(Stella_Object tree, Keyword arity) {
    if (Stella_Object.safePrimaryType(tree) == Logic.SGT_STELLA_CONS) {
      { Cons tree000 = ((Cons)(tree));

        if ((tree000.value == Logic.SYM_STELLA_INVERSE) ||
            (tree000.value == Logic.SYM_PL_KERNEL_KB_INVERSE)) {
          return (Cons.list$(Cons.cons(Logic.SYM_PL_KERNEL_KB_INVERSE, Cons.cons(Logic.loomArgumentDescriptionToKif(tree000.rest.value, Logic.KWD_BINARY), Cons.cons(Stella.NIL, Stella.NIL)))));
        }
        { Symbol x = ((Symbol)(Logic.SYSTEM_DEFINED_ARGUMENT_NAMES.nth(0)));
          Symbol y = ((Symbol)(Logic.SYSTEM_DEFINED_ARGUMENT_NAMES.nth(1)));
          Cons kappaargs = ((arity == Logic.KWD_UNARY) ? Cons.consList(Cons.cons(x, Stella.NIL)) : Cons.consList(Cons.cons(x, Cons.cons(y, Stella.NIL))));
          Cons implicitargs = Cons.copyConsList(kappaargs);

          return (Cons.list$(Cons.cons(Logic.SYM_LOGIC_KAPPA, Cons.cons(kappaargs, Cons.cons(Cons.cons(Logic.loomDescriptionToKif(tree000, implicitargs), Stella.NIL), Stella.NIL)))));
        }
      }
    }
    else {
      return (tree);
    }
  }

  public static Cons loomRestrictionToKif(Cons tree, Symbol implicitvariable) {
    { Symbol operator = ((Symbol)(tree.value));
      Stella_Object role = null;
      Stella_Object argument = null;
      Symbol existsvariable = null;
      Stella_Object qualification = tree.fourth();

      if (Stella.getQuotedTree("((AT-LEAST AT-MOST EXACTLY) \"/LOGIC\")", "/LOGIC").memberP(operator)) {
        {
          argument = tree.rest.value;
          role = tree.rest.rest.value;
        }
      }
      else {
        {
          role = tree.rest.value;
          argument = tree.rest.rest.value;
        }
      }
      if ((operator == Logic.SYM_LOGIC_AT_LEAST) ||
          ((operator == Logic.SYM_LOGIC_AT_MOST) ||
           (operator == Logic.SYM_LOGIC_EXACTLY))) {
        if (qualification != null) {
          if (operator == Logic.SYM_LOGIC_AT_LEAST) {
            operator = Logic.SYM_PL_KERNEL_KB_QUALIFIED_RANGE_CARDINALITY_LOWER_BOUND;
          }
          else if (operator == Logic.SYM_LOGIC_AT_MOST) {
            operator = Logic.SYM_PL_KERNEL_KB_QUALIFIED_RANGE_CARDINALITY_UPPER_BOUND;
          }
          else if (operator == Logic.SYM_LOGIC_EXACTLY) {
            operator = Logic.SYM_PL_KERNEL_KB_QUALIFIED_RANGE_CARDINALITY;
          }
          else {
            { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

              stream000.nativeStream.print("`" + operator + "' is not a valid case option");
              throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
            }
          }
        }
        else {
          if (operator == Logic.SYM_LOGIC_AT_LEAST) {
            operator = Logic.SYM_PL_KERNEL_KB_RANGE_CARDINALITY_LOWER_BOUND;
          }
          else if (operator == Logic.SYM_LOGIC_AT_MOST) {
            operator = Logic.SYM_PL_KERNEL_KB_RANGE_CARDINALITY_UPPER_BOUND;
          }
          else if (operator == Logic.SYM_LOGIC_EXACTLY) {
            operator = Logic.SYM_PL_KERNEL_KB_RANGE_CARDINALITY;
          }
          else {
            { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

              stream001.nativeStream.print("`" + operator + "' is not a valid case option");
              throw ((StellaException)(StellaException.newStellaException(stream001.theStringReader()).fillInStackTrace()));
            }
          }
        }
        return (Cons.cons(operator, Cons.cons(Logic.loomArgumentDescriptionToKif(role, Logic.KWD_BINARY), Cons.cons(implicitvariable, Cons.cons(argument, (((qualification != null) ? Cons.consList(Cons.cons(Logic.loomArgumentDescriptionToKif(qualification, Logic.KWD_UNARY), Stella.NIL)) : Stella.NIL)).concatenate(Stella.NIL, Stella.NIL))))));
      }
      else if (operator == Logic.SYM_LOGIC_ALL) {
        if (qualification != null) {
          {
            { Symbol v = null;
              Cons iter000 = Logic.SYSTEM_DEFINED_ARGUMENT_NAMES;

              loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                v = ((Symbol)(iter000.value));
                if (!(implicitvariable == v)) {
                  existsvariable = v;
                  break loop000;
                }
              }
            }
            return (Cons.list$(Cons.cons(Logic.SYM_STELLA_EXISTS, Cons.cons(Cons.cons(existsvariable, Stella.NIL), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_eg, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_AND, Cons.cons(Cons.cons(Logic.loomArgumentDescriptionToKif(role, Logic.KWD_BINARY), Cons.cons(implicitvariable, Cons.cons(existsvariable, Stella.NIL))), Cons.cons(Cons.cons(Logic.loomArgumentDescriptionToKif(qualification, Logic.KWD_UNARY), Cons.cons(existsvariable, Stella.NIL)), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.cons(Logic.loomArgumentDescriptionToKif(argument, Logic.KWD_UNARY), Cons.cons(((Symbol)(Logic.SYSTEM_DEFINED_ARGUMENT_NAMES.nth(0))), Stella.NIL)), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL))))));
          }
        }
        else {
          return (Cons.list$(Cons.cons(Logic.SYM_PL_KERNEL_KB_RANGE_TYPE, Cons.cons(Logic.loomArgumentDescriptionToKif(role, Logic.KWD_BINARY), Cons.cons(Cons.cons(implicitvariable, Cons.cons(Logic.loomArgumentDescriptionToKif(argument, Logic.KWD_UNARY), Stella.NIL)), Stella.NIL)))));
        }
      }
      else if (operator == Logic.SYM_STELLA_SOME) {
        return (Logic.loomRestrictionToKif(Cons.list$(Cons.cons(Logic.SYM_LOGIC_AT_LEAST, Cons.cons(IntegerWrapper.wrapInteger(1), Cons.cons(role, Cons.cons(Cons.cons(argument, Stella.NIL), Stella.NIL))))), implicitvariable));
      }
      else if (operator == Logic.SYM_LOGIC_THE) {
        return (Logic.loomDescriptionToKif(Cons.list$(Cons.cons(Logic.SYM_STELLA_AND, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_EXACTLY, Cons.cons(IntegerWrapper.wrapInteger(1), Cons.cons(role, Cons.cons(Stella.NIL, Stella.NIL))))), Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_ALL, Cons.cons(role, Cons.cons(Cons.cons(argument, Stella.NIL), Stella.NIL)))), Cons.cons(Stella.NIL, Stella.NIL))))), Cons.consList(Cons.cons(implicitvariable, Stella.NIL))));
      }
      else if ((operator == Logic.SYM_LOGIC_FILLED_BY) ||
          (operator == Logic.SYM_LOGIC_FILLERS)) {
        { Cons clauses = Stella.NIL;
          Stella_Object translatedrole = Logic.loomArgumentDescriptionToKif(role, Logic.KWD_BINARY);

          { Stella_Object filler = null;
            Cons iter001 = tree.rest.rest;
            Cons collect000 = null;

            for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
              filler = iter001.value;
              if (collect000 == null) {
                {
                  collect000 = Cons.cons(Cons.cons(translatedrole, Cons.cons(implicitvariable, Cons.cons(filler, Stella.NIL))), Stella.NIL);
                  if (clauses == Stella.NIL) {
                    clauses = collect000;
                  }
                  else {
                    Cons.addConsToEndOfConsList(clauses, collect000);
                  }
                }
              }
              else {
                {
                  collect000.rest = Cons.cons(Cons.cons(translatedrole, Cons.cons(implicitvariable, Cons.cons(filler, Stella.NIL))), Stella.NIL);
                  collect000 = collect000.rest;
                }
              }
            }
          }
          return (((Cons)(Logic.conjoinSentences(clauses))));
        }
      }
      else if (operator == Logic.SYM_LOGIC_NOT_FILLED_BY) {
        { Cons clauses = Stella.NIL;
          Stella_Object translatedrole = Logic.loomArgumentDescriptionToKif(role, Logic.KWD_BINARY);

          { Stella_Object filler = null;
            Cons iter002 = tree.rest.rest;
            Cons collect001 = null;

            for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
              filler = iter002.value;
              if (collect001 == null) {
                {
                  collect001 = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_NOT, Cons.cons(Cons.cons(translatedrole, Cons.cons(implicitvariable, Cons.cons(filler, Stella.NIL))), Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL);
                  if (clauses == Stella.NIL) {
                    clauses = collect001;
                  }
                  else {
                    Cons.addConsToEndOfConsList(clauses, collect001);
                  }
                }
              }
              else {
                {
                  collect001.rest = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_NOT, Cons.cons(Cons.cons(translatedrole, Cons.cons(implicitvariable, Cons.cons(filler, Stella.NIL))), Cons.cons(Stella.NIL, Stella.NIL)))), Stella.NIL);
                  collect001 = collect001.rest;
                }
              }
            }
          }
          return (((Cons)(Logic.conjoinSentences(clauses))));
        }
      }
      else {
        { OutputStringStream stream002 = OutputStringStream.newOutputStringStream();

          stream002.nativeStream.print("`" + operator + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream002.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  public static Cons loomRelatesToKif(Cons tree, Cons implicitvariables) {
    if (tree.value == Logic.SYM_LOGIC_RELATES) {
      tree = tree.rest;
    }
    { Cons clauses = Stella.NIL;
      Cons existsvariables = Stella.NIL;
      Cons arguments = Stella.NIL;
      Cons skolemvariables = Stella.NIL;

      { Symbol v = null;
        Cons iter000 = Logic.SYSTEM_DEFINED_ARGUMENT_NAMES;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          v = ((Symbol)(iter000.value));
          if ((!implicitvariables.memberP(v)) &&
              (skolemvariables.length() < (tree.length() - 1))) {
            skolemvariables = Cons.cons(v, skolemvariables);
          }
        }
      }
      { Stella_Object arg = null;
        Cons iter001 = tree.rest;
        Stella_Object v = null;
        Cons iter002 = skolemvariables;
        Cons collect000 = null;

        loop001 : for (;(!(iter001 == Stella.NIL)) &&
                  (!(iter002 == Stella.NIL)); iter001 = iter001.rest, iter002 = iter002.rest) {
          arg = iter001.value;
          v = iter002.value;
          {
            if (Stella_Object.isaP(arg, Logic.SGT_STELLA_NUMBER_WRAPPER)) {
              arguments = Cons.cons(arg, arguments);
              continue loop001;
            }
            arguments = Cons.cons(v, arguments);
            existsvariables = Cons.cons(v, existsvariables);
          }
          if (collect000 == null) {
            {
              collect000 = Cons.cons(Logic.loomDescriptionToKif(arg, Cons.consList(Cons.cons(((Symbol)(implicitvariables.value)), Cons.cons(v, Stella.NIL)))), Stella.NIL);
              if (clauses == Stella.NIL) {
                clauses = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(clauses, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(Logic.loomDescriptionToKif(arg, Cons.consList(Cons.cons(((Symbol)(implicitvariables.value)), Cons.cons(v, Stella.NIL)))), Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      return (Cons.list$(Cons.cons(Logic.SYM_STELLA_EXISTS, Cons.cons(existsvariables.reverse(), Cons.cons(Cons.cons(Cons.cons(Logic.SYM_STELLA_AND, clauses.concatenate(Cons.cons(Logic.loomDescriptionToKif(tree.value, arguments.reverse()), Stella.NIL), Stella.NIL)), Stella.NIL), Stella.NIL)))));
    }
  }

  public static void substituteVariablesInTree(Cons tree, Cons substitution) {
    { Stella_Object operator = tree.value;

      { GeneralizedSymbol testValue000 = ((GeneralizedSymbol)(operator));

        if ((testValue000 == Logic.SYM_STELLA_EXISTS) ||
            ((testValue000 == Logic.SYM_LOGIC_FOR_SOME) ||
             (testValue000 == Logic.SYM_STELLA_FORALL))) {
          if (operator == Logic.SYM_LOGIC_FOR_SOME) {
            tree.firstSetter(Logic.SYM_STELLA_EXISTS);
          }
          { Stella_Object variables = tree.rest.value;

            if (!Stella_Object.consP(variables)) {
              variables = Cons.consList(Cons.cons(variables, Stella.NIL));
            }
            { Stella_Object v1 = null;
              Cons iter000 = ((Cons)(variables));

              for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                v1 = iter000.value;
                if (substitution.memberP(v1)) {
                  { Symbol v2 = null;
                    Cons iter001 = Logic.SYSTEM_DEFINED_ARGUMENT_NAMES;

                    loop001 : for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                      v2 = ((Symbol)(iter001.value));
                      if (!substitution.memberP(v2)) {
                        substitution = Cons.cons(v2, substitution);
                        substitution = Cons.cons(v1, substitution);
                        break loop001;
                      }
                    }
                  }
                }
              }
            }
          }
          Logic.substituteVariablesInTree(tree.rest, substitution);
        }
        else {
          { ConsIterator it1 = tree.allocateIterator();

            while (it1.nextP()) {
              { Stella_Object arg = it1.value;

                { Surrogate testValue001 = Stella_Object.safePrimaryType(arg);

                  if (Surrogate.subtypeOfSymbolP(testValue001)) {
                    { Symbol arg000 = ((Symbol)(arg));

                      if (Logic.questionMarkSymbolP(arg000)) {
                        { ConsIterator it2 = substitution.allocateIterator();

                          loop003 : while (it2.nextP()) {
                            if (it2.value == arg000) {
                              it2.nextP();
                              it1.valueSetter(it2.value);
                              break loop003;
                            }
                          }
                        }
                      }
                    }
                  }
                  else if (testValue001 == Logic.SGT_STELLA_CONS) {
                    { Cons arg000 = ((Cons)(arg));

                      Logic.substituteVariablesInTree(arg000, substitution);
                    }
                  }
                  else {
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  public static Cons loomThroughToKif(Cons tree, Cons implicitvariables) {
    { Stella_Object lowerbound = tree.rest.value;
      Stella_Object upperbound = tree.rest.rest.value;
      Cons clauses = Stella.NIL;

      if (Stella_Object.isaP(upperbound, Logic.SGT_STELLA_NUMBER_WRAPPER)) {
        { GeneralizedSymbol testValue000 = ((GeneralizedSymbol)(tree.value));

          if ((testValue000 == Logic.SYM_LOGIC_THROUGH) ||
              ((testValue000 == Logic.SYM_LOGIC_INTERVALii) ||
               (testValue000 == Logic.SYM_LOGIC_INTERVALi_))) {
            clauses = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_el, Cons.cons(((Symbol)(implicitvariables.value)), Cons.cons(Cons.cons(upperbound, Stella.NIL), Stella.NIL)))), clauses);
          }
          else if ((testValue000 == Logic.SYM_LOGIC_INTERVAL_i) ||
              (testValue000 == Logic.SYM_LOGIC_INTERVAL__)) {
            clauses = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_l, Cons.cons(((Symbol)(implicitvariables.value)), Cons.cons(Cons.cons(upperbound, Stella.NIL), Stella.NIL)))), clauses);
          }
          else {
            { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

              stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
              throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
            }
          }
        }
      }
      if (Stella_Object.isaP(lowerbound, Logic.SGT_STELLA_NUMBER_WRAPPER)) {
        { GeneralizedSymbol testValue001 = ((GeneralizedSymbol)(tree.value));

          if ((testValue001 == Logic.SYM_LOGIC_THROUGH) ||
              ((testValue001 == Logic.SYM_LOGIC_INTERVALii) ||
               (testValue001 == Logic.SYM_LOGIC_INTERVAL_i))) {
            clauses = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_ge, Cons.cons(((Symbol)(implicitvariables.value)), Cons.cons(Cons.cons(lowerbound, Stella.NIL), Stella.NIL)))), clauses);
          }
          else if ((testValue001 == Logic.SYM_LOGIC_INTERVALi_) ||
              (testValue001 == Logic.SYM_LOGIC_INTERVAL__)) {
            clauses = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_g, Cons.cons(((Symbol)(implicitvariables.value)), Cons.cons(Cons.cons(lowerbound, Stella.NIL), Stella.NIL)))), clauses);
          }
          else {
            { OutputStringStream stream001 = OutputStringStream.newOutputStringStream();

              stream001.nativeStream.print("`" + testValue001 + "' is not a valid case option");
              throw ((StellaException)(StellaException.newStellaException(stream001.theStringReader()).fillInStackTrace()));
            }
          }
        }
      }
      return (((Cons)(Logic.conjoinSentences(clauses))));
    }
  }

  public static Cons loomSatisfiesToKif(Cons tree, Cons implicitvariables) {
    { Stella_Object iovariables = tree.rest.value;
      Stella_Object body = tree.rest.rest.value;
      Cons substitution = Stella.NIL;

      if (!Stella_Object.consP(iovariables)) {
        iovariables = Cons.consList(Cons.cons(iovariables, Stella.NIL));
      }
      { Stella_Object v1 = null;
        Cons iter000 = ((Cons)(iovariables));
        Symbol v2 = null;
        Cons iter001 = implicitvariables;

        for (;(!(iter000 == Stella.NIL)) &&
                  (!(iter001 == Stella.NIL)); iter000 = iter000.rest, iter001 = iter001.rest) {
          v1 = iter000.value;
          v2 = ((Symbol)(iter001.value));
          substitution = Cons.cons(v2, substitution);
          substitution = Cons.cons(v1, substitution);
        }
      }
      Logic.substituteVariablesInTree(((Cons)(body)), substitution);
      return (((Cons)(body)));
    }
  }

  public static Cons loomDescriptionToKif(Stella_Object tree, Cons implicitvariables) {
    if (Stella_Object.safePrimaryType(tree) == Logic.SGT_STELLA_CONS) {
      { Cons tree000 = ((Cons)(tree));

        { Stella_Object operator = tree000.value;

          { GeneralizedSymbol testValue000 = ((GeneralizedSymbol)(operator));

            if ((testValue000 == Logic.SYM_STELLA_AND) ||
                ((testValue000 == Logic.SYM_STELLA_OR) ||
                 (testValue000 == Logic.SYM_STELLA_NOT))) {
              { Cons clauses = Stella.NIL;

                { Stella_Object arg = null;
                  Cons iter000 = tree000.rest;
                  Cons collect000 = null;

                  for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                    arg = iter000.value;
                    if (collect000 == null) {
                      {
                        collect000 = Cons.cons(Logic.loomDescriptionToKif(arg, implicitvariables), Stella.NIL);
                        if (clauses == Stella.NIL) {
                          clauses = collect000;
                        }
                        else {
                          Cons.addConsToEndOfConsList(clauses, collect000);
                        }
                      }
                    }
                    else {
                      {
                        collect000.rest = Cons.cons(Logic.loomDescriptionToKif(arg, implicitvariables), Stella.NIL);
                        collect000 = collect000.rest;
                      }
                    }
                  }
                }
                return (Cons.cons(operator, clauses.concatenate(Stella.NIL, Stella.NIL)));
              }
            }
            else if ((testValue000 == Logic.SYM_LOGIC_AT_LEAST) ||
                ((testValue000 == Logic.SYM_LOGIC_AT_MOST) ||
                 ((testValue000 == Logic.SYM_LOGIC_EXACTLY) ||
                  ((testValue000 == Logic.SYM_LOGIC_ALL) ||
                   ((testValue000 == Logic.SYM_STELLA_SOME) ||
                    ((testValue000 == Logic.SYM_LOGIC_THE) ||
                     ((testValue000 == Logic.SYM_LOGIC_FILLED_BY) ||
                      (testValue000 == Logic.SYM_LOGIC_FILLERS)))))))) {
              return (Logic.loomRestrictionToKif(tree000, ((Symbol)(implicitvariables.value))));
            }
            else if (testValue000 == Logic.SYM_LOGIC_SAME_AS) {
              { Symbol selfvariable = ((Symbol)(implicitvariables.value));
                Symbol y = null;

                { Symbol v = null;
                  Cons iter001 = Logic.SYSTEM_DEFINED_ARGUMENT_NAMES;

                  loop001 : for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                    v = ((Symbol)(iter001.value));
                    if (!(v == selfvariable)) {
                      y = v;
                      break loop001;
                    }
                  }
                }
                { Cons localimplicitvariables = Cons.consList(Cons.cons(selfvariable, Cons.cons(y, Stella.NIL)));
                  Cons clauses = Stella.NIL;

                  { Stella_Object arg = null;
                    Cons iter002 = tree000.rest;
                    Cons collect001 = null;

                    for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
                      arg = iter002.value;
                      if (collect001 == null) {
                        {
                          collect001 = Cons.cons(Logic.loomDescriptionToKif(arg, localimplicitvariables), Stella.NIL);
                          if (clauses == Stella.NIL) {
                            clauses = collect001;
                          }
                          else {
                            Cons.addConsToEndOfConsList(clauses, collect001);
                          }
                        }
                      }
                      else {
                        {
                          collect001.rest = Cons.cons(Logic.loomDescriptionToKif(arg, localimplicitvariables), Stella.NIL);
                          collect001 = collect001.rest;
                        }
                      }
                    }
                  }
                  return (Cons.list$(Cons.cons(Logic.SYM_STELLA_EXISTS, Cons.cons(y, Cons.cons(Cons.cons(Cons.cons(Logic.SYM_STELLA_AND, clauses.concatenate(Stella.NIL, Stella.NIL)), Stella.NIL), Stella.NIL)))));
                }
              }
            }
            else if ((testValue000 == Logic.SYM_LOGIC_RELATES) ||
                ((testValue000 == Logic.SYM_STELLA_g) ||
                 ((testValue000 == Logic.SYM_STELLA_l) ||
                  ((testValue000 == Logic.SYM_STELLA_ge) ||
                   ((testValue000 == Logic.SYM_STELLA_le) ||
                    ((testValue000 == Logic.SYM_LOGIC_lg) ||
                     (testValue000 == Logic.SYM_STELLA_e))))))) {
              return (Logic.loomRelatesToKif(tree000, implicitvariables));
            }
            else if (testValue000 == Logic.SYM_LOGIC_ONE_OF) {
              return (Cons.cons(Logic.SYM_PL_KERNEL_KB_MEMBER_OF, Cons.copyConsList(implicitvariables).concatenate(Cons.cons(Cons.cons(Logic.SYM_STELLA_SETOF, tree000.rest.concatenate(Stella.NIL, Stella.NIL)), Stella.NIL), Stella.NIL)));
            }
            else if (testValue000 == Logic.SYM_LOGIC_THE_ORDERED_SET) {
              return (Cons.cons(Logic.SYM_PL_KERNEL_KB_MEMBER_OF, Cons.copyConsList(implicitvariables).concatenate(Cons.cons(Cons.cons(Logic.SYM_LOGIC_LISTOF, tree000.rest.concatenate(Stella.NIL, Stella.NIL)), Stella.NIL), Stella.NIL)));
            }
            else if ((testValue000 == Logic.SYM_LOGIC_THROUGH) ||
                ((testValue000 == Logic.SYM_LOGIC_INTERVALii) ||
                 ((testValue000 == Logic.SYM_LOGIC_INTERVALi_) ||
                  ((testValue000 == Logic.SYM_LOGIC_INTERVAL_i) ||
                   (testValue000 == Logic.SYM_LOGIC_INTERVAL__))))) {
              return (Logic.loomThroughToKif(tree000, implicitvariables));
            }
            else if (testValue000 == Logic.SYM_LOGIC_SATISFIES) {
              return (Logic.loomSatisfiesToKif(tree000, implicitvariables));
            }
            else if (testValue000 == Logic.SYM_LOGIC_DOMAIN) {
              return (Logic.loomDescriptionToKif(tree000.rest.value, Cons.consList(Cons.cons(((Symbol)(implicitvariables.value)), Stella.NIL))));
            }
            else if (testValue000 == Logic.SYM_STELLA_DOMAINS) {
              { Cons clauses = Stella.NIL;

                { Stella_Object domain = null;
                  Cons iter003 = tree000.rest;
                  Symbol var = null;
                  Cons iter004 = implicitvariables;
                  Cons collect002 = null;

                  for (;(!(iter003 == Stella.NIL)) &&
                            (!(iter004 == Stella.NIL)); iter003 = iter003.rest, iter004 = iter004.rest) {
                    domain = iter003.value;
                    var = ((Symbol)(iter004.value));
                    if (collect002 == null) {
                      {
                        collect002 = Cons.cons(Logic.loomDescriptionToKif(domain, Cons.consList(Cons.cons(var, Stella.NIL))), Stella.NIL);
                        if (clauses == Stella.NIL) {
                          clauses = collect002;
                        }
                        else {
                          Cons.addConsToEndOfConsList(clauses, collect002);
                        }
                      }
                    }
                    else {
                      {
                        collect002.rest = Cons.cons(Logic.loomDescriptionToKif(domain, Cons.consList(Cons.cons(var, Stella.NIL))), Stella.NIL);
                        collect002 = collect002.rest;
                      }
                    }
                  }
                }
                return (((Cons)(Logic.conjoinSentences(clauses))));
              }
            }
            else if (testValue000 == Logic.SYM_LOGIC_RANGE) {
              return (Logic.loomDescriptionToKif(tree000.rest.value, Cons.consList(Cons.cons(((Symbol)(implicitvariables.last())), Stella.NIL))));
            }
            else if ((testValue000 == Logic.SYM_STELLA_INVERSE) ||
                (testValue000 == Logic.SYM_PL_KERNEL_KB_INVERSE)) {
              { Cons inverseimplicitvariables = Cons.consList(Cons.cons(((Symbol)(implicitvariables.rest.value)), Cons.cons(((Symbol)(implicitvariables.value)), Stella.NIL)));

                return (Logic.loomDescriptionToKif(tree000.rest.value, inverseimplicitvariables));
              }
            }
            else if (testValue000 == Logic.SYM_LOGIC_COMPOSE) {
              { Cons chain = Cons.cons(tree000.rest.value, Cons.cons(((Symbol)(implicitvariables.value)), Stella.NIL));

                { Stella_Object function = null;
                  Cons iter005 = tree000.rest.rest;

                  for (;!(iter005 == Stella.NIL); iter005 = iter005.rest) {
                    function = iter005.value;
                    chain = Cons.cons(function, Cons.cons(chain, Stella.NIL));
                  }
                }
                return (chain.concatenate(Cons.cons(((Symbol)(implicitvariables.rest.value)), Stella.NIL), Stella.NIL));
              }
            }
            else {
              {
                Stella.STANDARD_OUTPUT.nativeStream.println("Illegal or unimplemented Loom operator cannot be translated to KIF.");
                Stella.STANDARD_OUTPUT.nativeStream.println("   Problem expression:  `" + tree000 + "'");
                Stella.STANDARD_OUTPUT.nativeStream.println();
              }
;
              return (Stella.NIL);
            }
          }
        }
      }
    }
    else {
      if (((GeneralizedSymbol)(tree)) == Logic.SYM_LOGIC_lg) {
        return (Cons.list$(Cons.cons(Logic.SYM_STELLA_NOT, Cons.cons(Cons.cons(Logic.SYM_STELLA_e, Cons.copyConsList(implicitvariables).concatenate(Stella.NIL, Stella.NIL)), Cons.cons(Stella.NIL, Stella.NIL)))));
      }
      else {
        return (Cons.cons(tree, Cons.copyConsList(implicitvariables).concatenate(Stella.NIL, Stella.NIL)));
      }
    }
  }

  public static boolean loomDescriptionOperatorP(Stella_Object self) {
    return (Stella.getQuotedTree("((AND OR NOT AT-LEAST AT-MOST EXACTLY ALL SOME THE FILLED-BY FILLERS SAME-AS RELATES ONE-OF THROUGH) \"/LOGIC\")", "/LOGIC").memberP(self));
  }

  public static Stella_Object loomSentenceToKif(Stella_Object tree) {
    if (Stella_Object.safePrimaryType(tree) == Logic.SGT_STELLA_CONS) {
      { Cons tree000 = ((Cons)(tree));

        if (!Stella_Object.symbolP(tree000.value)) {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();

              try {
                Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
                stream000.nativeStream.println("ERROR: Illegal clause `" + tree000 + "' in Loom formula..");
                Logic.helpSignalPropositionError(stream000, Logic.KWD_ERROR);

              } finally {
                Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
              }
            }
            throw ((PropositionError)(PropositionError.newPropositionError(stream000.theStringReader()).fillInStackTrace()));
          }
        }
        { GeneralizedSymbol testValue000 = ((GeneralizedSymbol)(tree000.value));

          if ((testValue000 == Logic.SYM_STELLA_AND) ||
              ((testValue000 == Logic.SYM_STELLA_OR) ||
               (testValue000 == Logic.SYM_STELLA_NOT))) {
            { Cons clauses = Stella.NIL;

              { Stella_Object arg = null;
                Cons iter000 = tree000.rest;
                Cons collect000 = null;

                for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                  arg = iter000.value;
                  if (collect000 == null) {
                    {
                      collect000 = Cons.cons(Logic.loomSentenceToKif(arg), Stella.NIL);
                      if (clauses == Stella.NIL) {
                        clauses = collect000;
                      }
                      else {
                        Cons.addConsToEndOfConsList(clauses, collect000);
                      }
                    }
                  }
                  else {
                    {
                      collect000.rest = Cons.cons(Logic.loomSentenceToKif(arg), Stella.NIL);
                      collect000 = collect000.rest;
                    }
                  }
                }
              }
              clauses = clauses.reverse();
              clauses = Cons.cons(tree000.value, clauses);
              return (clauses);
            }
          }
          else if (testValue000 == Logic.SYM_LOGIC_ABOUT) {
            { Cons aboutclauses = Stella.NIL;
              Cons implicitvariables = null;

              { Stella_Object clause = null;
                Cons iter001 = tree000.rest.rest;

                for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                  clause = iter001.value;
                  implicitvariables = Cons.consList(Cons.cons(tree000.rest.value, Stella.NIL));
                  if (!Stella_Object.consP(clause)) {
                    aboutclauses = Cons.cons(Cons.cons(clause, implicitvariables.concatenate(Stella.NIL, Stella.NIL)), aboutclauses);
                  }
                  else if (Logic.loomDescriptionOperatorP(((Cons)(clause)).value)) {
                    aboutclauses = Cons.cons(Logic.loomDescriptionToKif(clause, implicitvariables), aboutclauses);
                  }
                  else {
                    { Cons expression = ((Cons)(clause));

                      aboutclauses = Cons.cons(Cons.cons(expression.value, implicitvariables.concatenate(Cons.copyConsList(expression.rest).concatenate(Stella.NIL, Stella.NIL), Stella.NIL)), aboutclauses);
                    }
                  }
                }
              }
              return (Logic.conjoinSentences(aboutclauses.reverse()));
            }
          }
          else if (testValue000 == Logic.SYM_LOGIC_CREATE) {
            return (Logic.translateLoomCreateClause(tree000.rest));
          }
          else {
            return (tree000);
          }
        }
      }
    }
    else {
      return (tree);
    }
  }

  public static int computeLoomDescriptionArity(Stella_Object tree) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(tree);

      if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol tree000 = ((Symbol)(tree));

          { NamedDescription description = Logic.getDescription(tree000);

            if (description != null) {
              return (description.arity());
            }
          }
        }
      }
      else if (testValue000 == Logic.SGT_STELLA_CONS) {
        { Cons tree000 = ((Cons)(tree));

          { GeneralizedSymbol testValue001 = ((GeneralizedSymbol)(tree000.value));

            if ((testValue001 == Logic.SYM_STELLA_AND) ||
                (testValue001 == Logic.SYM_STELLA_OR)) {
              { Stella_Object arg = null;
                Cons iter000 = tree000.rest;

                for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                  arg = iter000.value;
                  { int guess = Logic.computeLoomDescriptionArity(arg);

                    if (guess > 0) {
                      return (guess);
                    }
                  }
                }
              }
            }
            else if ((testValue001 == Logic.SYM_LOGIC_AT_LEAST) ||
                ((testValue001 == Logic.SYM_LOGIC_AT_MOST) ||
                 ((testValue001 == Logic.SYM_LOGIC_ALL) ||
                  (testValue001 == Logic.SYM_LOGIC_SAME_AS)))) {
              return (1);
            }
            else if ((testValue001 == Logic.SYM_LOGIC_DOMAIN) ||
                ((testValue001 == Logic.SYM_LOGIC_RANGE) ||
                 ((testValue001 == Logic.SYM_STELLA_INVERSE) ||
                  ((testValue001 == Logic.SYM_PL_KERNEL_KB_INVERSE) ||
                   (testValue001 == Logic.SYM_LOGIC_COMPOSE))))) {
              return (2);
            }
            else if ((testValue001 == Logic.SYM_STELLA_g) ||
                ((testValue001 == Logic.SYM_STELLA_l) ||
                 ((testValue001 == Logic.SYM_STELLA_ge) ||
                  ((testValue001 == Logic.SYM_STELLA_le) ||
                   ((testValue001 == Logic.SYM_LOGIC_lg) ||
                    (testValue001 == Logic.SYM_STELLA_e)))))) {
              return (tree000.rest.length());
            }
            else if (testValue001 == Logic.SYM_LOGIC_RELATES) {
              return (tree000.rest.rest.length());
            }
            else if (testValue001 == Logic.SYM_LOGIC_SATISFIES) {
              { Stella_Object variables = tree000.rest.value;

                if (Stella_Object.consP(variables)) {
                  return (((Cons)(variables)).length());
                }
                else {
                  return (1);
                }
              }
            }
            else {
            }
          }
        }
      }
      else {
      }
    }
    return (-1);
  }

  public static Stella_Object eliminateLoomKeywords(Stella_Object tree) {
    { Surrogate testValue000 = Stella_Object.safePrimaryType(tree);

      if (Surrogate.subtypeOfKeywordP(testValue000)) {
        { Keyword tree000 = ((Keyword)(tree));

          return (Symbol.internSymbolInModule(tree000.symbolName, Logic.$LOGIC_MODULE$, false));
        }
      }
      else if (Surrogate.subtypeOfSymbolP(testValue000)) {
        { Symbol tree000 = ((Symbol)(tree));

          if ((tree000 == Logic.SYM_LOGIC_SUPERRELATIONS) ||
              (tree000 == Logic.SYM_LOGIC_SUPERCONCEPTS)) {
            return (Logic.SYM_PL_KERNEL_KB_SUBSET_OF);
          }
          else {
          }
          if (Stella.stringEqlP(tree000.symbolName, "/=")) {
            return (Logic.SYM_LOGIC_lg);
          }
        }
      }
      else if (testValue000 == Logic.SGT_STELLA_CONS) {
        { Cons tree000 = ((Cons)(tree));

          { ConsIterator it = tree000.allocateIterator();

            while (it.nextP()) {
              it.valueSetter(Logic.eliminateLoomKeywords(it.value));
            }
          }
          if ((tree000.value == null) ||
              (!Stella_Object.symbolP(tree000.value))) {
            return (tree000);
          }
          { Symbol operator = ((Symbol)(tree000.value));

            if (operator == Logic.SYM_STELLA_QUOTE) {
              return (tree000.rest.value);
            }
            else {
            }
          }
        }
      }
      else {
      }
    }
    return (tree);
  }

  public static Cons yieldImplicitVariables(int arity) {
    { Cons variables = Stella.NIL;

      { IntegerIntervalIterator i = Stella.interval(1, arity);
        Symbol v = null;
        Cons iter000 = Logic.SYSTEM_DEFINED_ARGUMENT_NAMES;
        Cons collect000 = null;

        for (;i.nextP() &&
                  (!(iter000 == Stella.NIL)); iter000 = iter000.rest) {
          v = ((Symbol)(iter000.value));
          if (collect000 == null) {
            {
              collect000 = Cons.cons(v, Stella.NIL);
              if (variables == Stella.NIL) {
                variables = collect000;
              }
              else {
                Cons.addConsToEndOfConsList(variables, collect000);
              }
            }
          }
          else {
            {
              collect000.rest = Cons.cons(v, Stella.NIL);
              collect000 = collect000.rest;
            }
          }
        }
      }
      return (variables);
    }
  }

  public static Cons helpTranslateLoomDescriptionToKif(Stella_Object tree, Cons implicitvariables) {
    return (Logic.loomDescriptionToKif(Logic.eliminateLoomKeywords(tree), implicitvariables));
  }

  public static Cons translateLoomDescriptionToKif(Stella_Object tree) {
    try {
      { int arity = Logic.computeLoomDescriptionArity(tree);
        Cons implicitvariables = Logic.yieldImplicitVariables(((arity > 0) ? arity : 1));

        return (Cons.list$(Cons.cons(Logic.SYM_LOGIC_KAPPA, Cons.cons(implicitvariables, Cons.cons(Cons.cons(Logic.helpTranslateLoomDescriptionToKif(tree, implicitvariables), Stella.NIL), Stella.NIL)))));
      }
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
      return (null);
    }
  }

  public static Stella_Object translateLoomSentenceToKif(Stella_Object tree) {
    try {
      return (Logic.loomSentenceToKif(Logic.eliminateLoomKeywords(tree)));
    } catch (LogicException e) {
      Stella.STANDARD_ERROR.nativeStream.print(Stella.exceptionMessage(e));
      return (null);
    }
  }

  public static Cons translateLoomAssertions(Cons tree, boolean retractP) {
    if (tree.rest == Stella.NIL) {
      tree = ((Cons)(tree.value));
    }
    else {
      tree = Cons.cons(Logic.SYM_STELLA_AND, tree);
    }
    { Symbol verb = (retractP ? Logic.SYM_STELLA_RETRACT : Logic.SYM_STELLA_ASSERT);
      Stella_Object proposition = Logic.translateLoomSentenceToKif(tree);

      if (tree != null) {
        return (Cons.cons(verb, Cons.cons(proposition, Stella.NIL)));
      }
      else {
        return (null);
      }
    }
  }

  public static Cons translateLoomAsk(Cons tree) {
    { Stella_Object sentence = Logic.translateLoomSentenceToKif(tree.rest.value);

      { PropertyList self000 = PropertyList.newPropertyList();

        self000.thePlist = tree.rest.rest;
        { PropertyList options = self000;

          { Stella_Object keyword = null;
            Stella_Object value = null;
            Cons iter000 = options.thePlist;

            for (;!(iter000 == Stella.NIL); iter000 = iter000.rest.rest) {
              keyword = iter000.value;
              value = iter000.rest.value;
              if (((GeneralizedSymbol)(keyword)) == Logic.KWD_3_VALUED_P) {
                value = value;
                {
                  Stella.STANDARD_OUTPUT.nativeStream.println("Sorry, 3-valued 'ask' not yet implemented in PowerLoom.");
                  Stella.STANDARD_OUTPUT.nativeStream.println("Please complain to your PowerLoom dealer.");
                  Stella.STANDARD_OUTPUT.nativeStream.println();
                }
;
              }
              else {
                Stella.STANDARD_OUTPUT.nativeStream.println("Illegal or unimplemented option to 'ask': `" + keyword + "'");
              }
            }
          }
          if (sentence != null) {
            return (Cons.list$(Cons.cons(Logic.SYM_STELLA_ASK, Cons.cons(sentence, Cons.cons(Stella.NIL, Stella.NIL)))));
          }
          else {
            return (null);
          }
        }
      }
    }
  }

  public static Cons translateLoomRetrieve(Cons tree) {
    { Stella_Object variables = tree.rest.value;
      Stella_Object querybody = Logic.translateLoomSentenceToKif(tree.rest.rest.value);

      { PropertyList self000 = PropertyList.newPropertyList();

        self000.thePlist = tree.nthRest(3);
        { PropertyList options = self000;
          Cons nulls = Stella.NIL;

          if (!options.emptyP()) {
            Stella.STANDARD_OUTPUT.nativeStream.println("'loom::retrieve' options not yet implemented");
          }
          { ConsIterator i = ((Cons)(variables)).allocateIterator();

            while (i.nextP()) {
              nulls = Cons.cons(Logic.SYM_STELLA_NULL, nulls);
            }
          }
          return (Cons.list$(Cons.cons(Logic.SYM_STELLA_CONSIFY, Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_RETRIEVE, Cons.cons(Logic.SYM_LOGIC_ALL, Cons.cons(variables, Cons.cons(Cons.cons(querybody, Stella.NIL), Stella.NIL))))), Cons.cons(Stella.NIL, Stella.NIL)))));
        }
      }
    }
  }

  public static Cons translateOneLoomForm(Stella_Object tree) {
    if (Stella_Object.safePrimaryType(tree) == Logic.SGT_STELLA_CONS) {
      { Cons tree000 = ((Cons)(tree));

        { GeneralizedSymbol testValue000 = ((GeneralizedSymbol)(tree000.value));

          if ((testValue000 == Logic.SYM_STELLA_PROGN) ||
              (testValue000 == Logic.SYM_LOGIC_EVAL_WHEN)) {
            { Cons forms = Stella.NIL;
              Cons translation = null;

              { Stella_Object item = null;
                Cons iter000 = tree000.rest;

                for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                  item = iter000.value;
                  translation = Logic.translateOneLoomForm(item);
                  if (translation != null) {
                    if (Stella_Object.isaP(translation.value, Logic.SGT_STELLA_CONS)) {
                      { Stella_Object subform = null;
                        Cons iter001 = translation;

                        for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                          subform = iter001.value;
                          forms = Cons.cons(subform, forms);
                        }
                      }
                    }
                    else {
                      forms = Cons.cons(translation, forms);
                    }
                  }
                }
              }
              return (forms.reverse());
            }
          }
          else if ((testValue000 == Logic.SYM_STELLA_ASK) ||
              ((testValue000 == Logic.SYM_STELLA_RETRIEVE) ||
               ((testValue000 == Logic.SYM_LOGIC_TELL) ||
                ((testValue000 == Logic.SYM_LOGIC_FORGET) ||
                 ((testValue000 == Logic.SYM_LOGIC_TELLM) ||
                  (testValue000 == Logic.SYM_LOGIC_FORGETM)))))) {
            return (Logic.translateLoomStatement(tree000));
          }
          else if ((testValue000 == Logic.SYM_LOGIC_CREATE) ||
              (testValue000 == Logic.SYM_LOGIC_CREATEM)) {
            Logic.destructivelyUnquoteTopLevel(tree000);
            return (Logic.translateLoomStatement(tree000));
          }
          else if ((testValue000 == Logic.SYM_LOGIC_DEFCONCEPT) ||
              ((testValue000 == Logic.SYM_LOGIC_DEFSET) ||
               ((testValue000 == Logic.SYM_LOGIC_DEFRELATION) ||
                (testValue000 == Logic.SYM_LOGIC_DEFPROPERTY)))) {
            return (Logic.translateLoomDefinition(tree000));
          }
          else if ((testValue000 == Logic.SYM_LOGIC_DEFCONTEXT) ||
              ((testValue000 == Logic.SYM_LOGIC_ADD_VALUE) ||
               ((testValue000 == Logic.SYM_LOGIC_SET_VALUE) ||
                (testValue000 == Logic.SYM_LOGIC_FADD_VALUE)))) {
            Stella.STANDARD_WARNING.nativeStream.println("Warning: Translation of `" + tree000.value + "' is not implemented yet!");
            return (null);
          }
          else if (testValue000 == Logic.SYM_STELLA_CHANGE_CONTEXT) {
            return (Logic.translateLoomContextChange(tree000, true));
          }
          else if ((testValue000 == Logic.SYM_LOGIC_IN_CONTEXT) ||
              (testValue000 == Logic.SYM_LOGIC_IN_KB)) {
            return (Logic.translateLoomContextChange(tree000, false));
          }
          else if (testValue000 == Logic.SYM_STELLA_CC) {
            if (tree000.rest.value != null) {
              return (Logic.translateLoomContextChange(tree000, false));
            }
            else {
              return (null);
            }
          }
          else {
            return (null);
          }
        }
      }
    }
    else {
      return (null);
    }
  }

  public static Stella_Object safeGetNextSExpression(SExpressionIterator iter) {
    { boolean continueP = true;
      Stella_Object result = null;

      while (continueP) {
        try {
          if (iter.nextP()) {
            result = iter.value;
          }
          continueP = false;
        } catch (ReadException e) {
          {
            Stella.STANDARD_WARNING.nativeStream.println("Warning: Read Exception `" + Stella.exceptionMessage(e) + "'");
            Stella.STANDARD_WARNING.nativeStream.println();
          }
;
        }
      }
      return (result);
    }
  }

  public static void destructivelyUnquoteTopLevel(Cons tree) {
    while (!(tree == Stella.NIL)) {
      if (Stella_Object.isaP(tree.value, Logic.SGT_STELLA_CONS) &&
          (Logic.SYM_STELLA_QUOTE == ((Cons)(tree.value)).value)) {
        tree.firstSetter(((Cons)(tree.value)).rest.value);
        if (tree.value == Logic.SYM_STELLA_NIL) {
          tree.firstSetter(Stella.NIL);
        }
      }
      tree = tree.rest;
    }
  }

  /** Translate the Loom file <code>input</code> to PowerLoom and write the
   * translation to the file <code>output</code>.  Note that this will only
   * work for fairly vanilla Loom files that do not contain any
   * Lisp-isms.  It might require to clean the Loom file manually
   * before this translation will work.
   * @param input
   * @param output
   */
  public static void translateLoomFile(String input, String output) {
    { Object old$PrintreadablyP$000 = Stella.$PRINTREADABLYp$.get();
      Object old$PrintprettyP$000 = Stella.$PRINTPRETTYp$.get();

      try {
        Native.setBooleanSpecial(Stella.$PRINTREADABLYp$, true);
        Native.setBooleanSpecial(Stella.$PRINTPRETTYp$, true);
        { InputFileStream in = null;

          try {
            in = Stella.openInputFile(input, Stella.NIL);
            { OutputFileStream out = null;

              try {
                out = Stella.openOutputFile(output, Stella.NIL);
                { Cons translation = Stella.NIL;
                  SExpressionIterator iter = InputStream.sExpressions(in);
                  Stella_Object form = Logic.safeGetNextSExpression(iter);
                  boolean dialectEmittedP = false;

                  {
                    out.nativeStream.println(";; Automatic Translation for file " + input);
                    out.nativeStream.println();
                  }
;
                  while (form != null) {
                    translation = Logic.translateOneLoomForm(form);
                    if (translation == null) {
                    }
                    else if (translation == Stella.NIL) {
                    }
                    else if (Stella_Object.isaP(translation.value, Logic.SGT_STELLA_CONS)) {
                      dialectEmittedP = true;
                      {
                        out.nativeStream.println(Cons.list$(Cons.cons(Logic.SYM_LOGIC_IN_DIALECT, Cons.cons(Logic.KWD_KIF, Cons.cons(Stella.NIL, Stella.NIL)))).toString());
                        out.nativeStream.println();
                      }
;
                      { Stella_Object subform = null;
                        Cons iter000 = translation;

                        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
                          subform = iter000.value;
                          {
                            out.nativeStream.println(subform.toString());
                            out.nativeStream.println();
                          }
;
                        }
                      }
                    }
                    else {
                      if ((!dialectEmittedP) &&
                          (!(translation.value == Logic.SYM_STELLA_IN_MODULE))) {
                        dialectEmittedP = true;
                        {
                          out.nativeStream.println(Cons.list$(Cons.cons(Logic.SYM_LOGIC_IN_DIALECT, Cons.cons(Logic.KWD_KIF, Cons.cons(Stella.NIL, Stella.NIL)))).toString());
                          out.nativeStream.println();
                        }
;
                      }
                      {
                        out.nativeStream.println(translation.toString());
                        out.nativeStream.println();
                      }
;
                    }
                    form = Logic.safeGetNextSExpression(iter);
                  }
                }

              } finally {
                if (out != null) {
                  out.free();
                }
              }
            }

          } finally {
            if (in != null) {
              in.free();
            }
          }
        }

      } finally {
        Stella.$PRINTPRETTYp$.set(old$PrintprettyP$000);
        Stella.$PRINTREADABLYp$.set(old$PrintreadablyP$000);
      }
    }
  }

  public static void translateLoomFileEvaluatorWrapper(Cons arguments) {
    Logic.translateLoomFile(((StringWrapper)(arguments.value)).wrapperValue, ((StringWrapper)(arguments.rest.value)).wrapperValue);
  }

  public static Cons translateLoomStatement(Cons tree) {
    { GeneralizedSymbol testValue000 = ((GeneralizedSymbol)(tree.value));

      if (testValue000 == Logic.SYM_STELLA_ASK) {
        return (Logic.translateLoomAsk(tree));
      }
      else if (testValue000 == Logic.SYM_STELLA_RETRIEVE) {
        return (Logic.translateLoomRetrieve(tree));
      }
      else if ((testValue000 == Logic.SYM_LOGIC_TELL) ||
          (testValue000 == Logic.SYM_LOGIC_TELLM)) {
        return (Logic.translateLoomAssertions(tree.rest, false));
      }
      else if ((testValue000 == Logic.SYM_LOGIC_FORGET) ||
          (testValue000 == Logic.SYM_LOGIC_FORGETM)) {
        return (Logic.translateLoomAssertions(tree.rest, true));
      }
      else if ((testValue000 == Logic.SYM_LOGIC_CREATE) ||
          (testValue000 == Logic.SYM_LOGIC_CREATEM)) {
        return (Logic.translateLoomAssertions(Cons.consList(Cons.cons(Logic.translateLoomCreateClause(tree.rest), Stella.NIL)), true));
      }
      else {
        { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

          stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
          throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
        }
      }
    }
  }

  public static Cons translateLoomCreateClause(Cons tree) {
    if (tree.rest.value == Stella.NIL) {
      return (Cons.list$(Cons.cons(Logic.SYM_STELLA_THING, Cons.cons(tree.value, Cons.cons(Stella.NIL, Stella.NIL)))));
    }
    else {
      return (Cons.cons(tree.rest.value, Cons.cons(tree.value, Stella.NIL)));
    }
  }

  public static int guessLoomDefinitionArity(int arity, Stella_Object definition, Cons constraints) {
    if ((arity == -1) &&
        (definition != null)) {
      arity = Logic.computeLoomDescriptionArity(definition);
    }
    if (arity == -1) {
      { Stella_Object c = null;
        Cons iter000 = constraints;

        loop000 : for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          c = iter000.value;
          arity = Logic.computeLoomDescriptionArity(c);
          if (arity > 0) {
            break loop000;
          }
        }
      }
    }
    if (arity == -1) {
      arity = 2;
    }
    return (arity);
  }

  public static Stella_Object conjoinSentences(Cons sentences) {
    sentences = sentences.remove(Stella.NIL);
    if (sentences == Stella.NIL) {
      return (Stella.NIL);
    }
    else if (sentences.rest == Stella.NIL) {
      return (sentences.value);
    }
    else {
      sentences = Cons.cons(Logic.SYM_STELLA_AND, sentences);
      return (sentences);
    }
  }

  public static Cons translateLoomPartitions(Stella_Object partitions, boolean exhaustiveP, Symbol parentconcept) {
    { Cons axioms = Stella.NIL;
      Cons partitionList = Stella.NIL;

      if (!Stella_Object.consP(partitions)) {
        partitions = Cons.consList(Cons.cons(partitions, Stella.NIL));
      }
      if (Stella_Object.consP(((Cons)(partitions)).value)) {
        partitionList = ((Cons)(partitions));
      }
      else {
        { Stella_Object clause = null;
          Cons iter000 = ((Cons)(partitions));

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            clause = iter000.value;
            partitionList = Cons.cons(Cons.consList(Cons.cons(clause, Stella.NIL)), partitionList);
          }
        }
      }
      { Cons clause = null;
        Cons iter001 = partitionList;

        for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
          clause = ((Cons)(iter001.value));
          { Stella_Object name = clause.value;
            Cons concepts = ((Cons)(clause.rest.value));
            Cons localaxioms = Stella.NIL;

            localaxioms = Cons.cons(Cons.list$(Cons.cons(edu.isi.powerloom.pl_kernel_kb.loom_api.LoomApi.SYM_PL_KERNEL_KB_MUTUALLY_DISJOINT_COLLECTION, Cons.cons(name, Cons.cons(Stella.NIL, Stella.NIL)))), localaxioms);
            if (concepts != null) {
              localaxioms = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_STELLA_e, Cons.cons(name, Cons.cons(Cons.cons(Cons.cons(Logic.SYM_PL_KERNEL_KB_SETOF, concepts.concatenate(Stella.NIL, Stella.NIL)), Stella.NIL), Stella.NIL)))), localaxioms);
            }
            if (exhaustiveP) {
              localaxioms = Cons.cons(Cons.list$(Cons.cons(edu.isi.powerloom.pl_kernel_kb.loom_api.LoomApi.SYM_PL_KERNEL_KB_COVERING, Cons.cons(name, Cons.cons(Cons.cons(parentconcept, Stella.NIL), Stella.NIL)))), localaxioms);
            }
            axioms = Cons.cons(Logic.conjoinSentences(localaxioms.reverse()), axioms);
          }
        }
      }
      return (axioms);
    }
  }

  public static Cons translateLoomCharacteristics(Stella_Object characteristics, Symbol name) {
    { Cons axioms = Stella.NIL;

      if (!Stella_Object.consP(characteristics)) {
        characteristics = Cons.consList(Cons.cons(characteristics, Stella.NIL));
      }
      { Stella_Object ch = null;
        Cons iter000 = ((Cons)(characteristics));

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          ch = iter000.value;
          { GeneralizedSymbol testValue000 = ((GeneralizedSymbol)(ch));

            if (testValue000 == Logic.KWD_SINGLE_VALUED) {
            }
            else if (testValue000 == Logic.KWD_CLOSED_WORLD) {
              axioms = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_PL_KERNEL_KB_CLOSED, Cons.cons(name, Cons.cons(Stella.NIL, Stella.NIL)))), axioms);
            }
            else if (testValue000 == Logic.KWD_COMMUTATIVE) {
              axioms = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_PL_KERNEL_KB_COMMUTATIVE, Cons.cons(name, Cons.cons(Stella.NIL, Stella.NIL)))), axioms);
            }
            else if (testValue000 == Logic.KWD_SYMMETRIC) {
              axioms = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_PL_KERNEL_KB_SYMMETRIC, Cons.cons(name, Cons.cons(Stella.NIL, Stella.NIL)))), axioms);
            }
            else if ((testValue000 == Logic.KWD_CLOS_CLASS) ||
                ((testValue000 == Logic.KWD_MULTIPLE_VALUED) ||
                 ((testValue000 == Logic.KWD_HASH_ON_DOMAINS) ||
                  ((testValue000 == Logic.KWD_NON_EXPORTED) ||
                   ((testValue000 == Logic.KWD_PERFECT) ||
                    ((testValue000 == Logic.KWD_CLOSED_ON_CONSTANTS) ||
                     ((testValue000 == Logic.KWD_BACKWARD_CHAINING) ||
                      ((testValue000 == Logic.KWD_MONOTONIC) ||
                       (testValue000 == Logic.KWD_TEMPORAL))))))))) {
            }
            else {
              {
                Stella.STANDARD_OUTPUT.nativeStream.println("Skipping unimplemented relation characteristic: `" + ch + "'");
                Stella.STANDARD_OUTPUT.nativeStream.println("   in Loom definition of: `" + name + "'");
                Stella.STANDARD_OUTPUT.nativeStream.println();
              }
;
            }
          }
        }
      }
      return (((Cons)(Logic.conjoinSentences(axioms))));
    }
  }

  public static Cons translateLoomAnnotations(Stella_Object annotations, Symbol name) {
    if (!Stella_Object.consP(annotations)) {
      annotations = Cons.consList(Cons.cons(annotations, Stella.NIL));
    }
    { Cons axioms = Stella.NIL;

      { Stella_Object term = null;
        Cons iter000 = ((Cons)(annotations));

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
          term = iter000.value;
          if (!Stella_Object.consP(term)) {
            term = Cons.consList(Cons.cons(term, Stella.NIL));
          }
          { Cons clause = ((Cons)(term));

            axioms = Cons.cons(Cons.cons(clause.value, Cons.cons(name, clause.rest.concatenate(Stella.NIL, Stella.NIL))), axioms);
          }
        }
      }
      return (((Cons)(Logic.conjoinSentences(axioms))));
    }
  }

  public static Cons translateLoomDefaults(Stella_Object defaultTree, Cons variables) {
    return (Cons.list$(Cons.cons(Logic.SYM_LOGIC_tg, Cons.cons(Logic.helpTranslateLoomDescriptionToKif(defaultTree, variables), Cons.cons(Stella.NIL, Stella.NIL)))));
  }

  public static Keyword simplifyTopLevelLoomKeywords(Keyword keyword) {
    if (keyword == Logic.KWD_ATTRIBUTES) {
      return (Logic.KWD_CHARACTERISTICS);
    }
    else if (keyword == Logic.KWD_PARTITION) {
      return (Logic.KWD_PARTITIONS);
    }
    else if (keyword == Logic.KWD_IMPLIES) {
      return (Logic.KWD_CONSTRAINTS);
    }
    else if (keyword == Logic.KWD_EXHAUSTIVE_PARTITION) {
      return (Logic.KWD_EXHAUSTIVE_PARTITIONS);
    }
    else {
      return (keyword);
    }
  }

  public static Cons translateLoomDefinition(Cons tree) {
    { Symbol operator = ((Symbol)(tree.value));
      Symbol name = ((Symbol)(tree.rest.value));
      StringWrapper docstring = null;
      PropertyList options = null;
      int arity = -1;
      Stella_Object definition = null;
      Cons constraints = Stella.NIL;
      Cons defaults = Stella.NIL;
      Cons axioms = Stella.NIL;
      Stella_Object kifdefinition = null;
      Stella_Object kifconstraint = null;
      Stella_Object kifaxiom = null;

      if ((tree.rest.rest.value != null) &&
          Stella_Object.isaP(tree.rest.rest.value, Logic.SGT_STELLA_STRING_WRAPPER)) {
        {
          docstring = ((StringWrapper)(tree.rest.rest.value));
          { PropertyList self000 = PropertyList.newPropertyList();

            self000.thePlist = tree.rest.rest.rest;
            options = self000;
          }
        }
      }
      else {
        { PropertyList self001 = PropertyList.newPropertyList();

          self001.thePlist = tree.rest.rest;
          options = self001;
        }
      }
      if (Stella.getQuotedTree("((DEFCONCEPT DEFSET) \"/LOGIC\")", "/LOGIC").memberP(operator)) {
        arity = 1;
        operator = Logic.SYM_LOGIC_DEFCONCEPT;
      }
      if (operator == Logic.SYM_LOGIC_DEFPROPERTY) {
        operator = Logic.SYM_LOGIC_DEFRELATION;
        arity = 1;
      }
      { Stella_Object keyword = null;
        Stella_Object value = null;
        Cons iter000 = options.thePlist;

        for (;!(iter000 == Stella.NIL); iter000 = iter000.rest.rest) {
          keyword = iter000.value;
          value = iter000.rest.value;
          keyword = Logic.simplifyTopLevelLoomKeywords(((Keyword)(keyword)));
          { GeneralizedSymbol testValue000 = ((GeneralizedSymbol)(keyword));

            if (testValue000 == Logic.KWD_IS_PRIMITIVE) {
              constraints = Cons.cons(value, constraints);
            }
            else if (testValue000 == Logic.KWD_IS) {
              definition = value;
            }
            else if (testValue000 == Logic.KWD_CONSTRAINTS) {
              constraints = Cons.cons(value, constraints);
            }
            else if (testValue000 == Logic.KWD_DEFAULTS) {
              defaults = Cons.cons(value, defaults);
            }
            else if (testValue000 == Logic.KWD_DOMAIN) {
              constraints = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_DOMAIN, Cons.cons(value, Cons.cons(Stella.NIL, Stella.NIL)))), constraints);
              if (arity < 0) {
                arity = 2;
              }
            }
            else if (testValue000 == Logic.KWD_DOMAINS) {
              constraints = Cons.cons(Cons.cons(Logic.SYM_STELLA_DOMAINS, ((Cons)(value)).concatenate(Stella.NIL, Stella.NIL)), constraints);
              if (arity < 0) {
                arity = ((Cons)(value)).length() + 1;
              }
            }
            else if (testValue000 == Logic.KWD_RANGE) {
              constraints = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_LOGIC_RANGE, Cons.cons(value, Cons.cons(Stella.NIL, Stella.NIL)))), constraints);
              if (arity < 0) {
                arity = 2;
              }
            }
            else if (testValue000 == Logic.KWD_ARITY) {
              arity = ((IntegerWrapper)(value)).wrapperValue;
            }
            else if ((testValue000 == Logic.KWD_PARTITIONS) ||
                (testValue000 == Logic.KWD_EXHAUSTIVE_PARTITIONS)) {
              { Stella_Object p = null;
                Cons iter001 = Logic.translateLoomPartitions(value, keyword == Logic.KWD_EXHAUSTIVE_PARTITIONS, name);

                for (;!(iter001 == Stella.NIL); iter001 = iter001.rest) {
                  p = iter001.value;
                  axioms = Cons.cons(p, axioms);
                }
              }
            }
            else if (testValue000 == Logic.KWD_IN_PARTITION) {
              axioms = Cons.cons(Cons.list$(Cons.cons(Logic.SYM_PL_KERNEL_KB_MEMBER_OF, Cons.cons(name, Cons.cons(Cons.cons(value, Stella.NIL), Stella.NIL)))), axioms);
            }
            else if ((testValue000 == Logic.KWD_CHARACTERISTICS) ||
                (testValue000 == Logic.KWD_ATTRIBUTES)) {
              axioms = Cons.cons(Logic.translateLoomCharacteristics(value, name), axioms);
            }
            else if (testValue000 == Logic.KWD_ANNOTATIONS) {
              axioms = Cons.cons(Logic.translateLoomAnnotations(value, name), axioms);
            }
            else if (testValue000 == Logic.KWD_ROLES) {
              Stella.STANDARD_OUTPUT.nativeStream.println(":roles OPTION NOT YET IMPLEMENTED");
            }
            else if (testValue000 == Logic.KWD_NAME) {
            }
            else if (testValue000 == Logic.KWD_IDENTIFIER) {
              {
                Stella.STANDARD_OUTPUT.nativeStream.println("Note: Definition `" + name + "' is also known as `" + value + "'");
                Stella.STANDARD_OUTPUT.nativeStream.println();
              }
;
            }
            else {
              {
                Stella.STANDARD_OUTPUT.nativeStream.println("Skipping unimplemented keyword: `" + keyword + "'");
                Stella.STANDARD_OUTPUT.nativeStream.println("   in Loom definition: `" + tree + "'");
                Stella.STANDARD_OUTPUT.nativeStream.println();
              }
;
            }
          }
        }
      }
      arity = Logic.guessLoomDefinitionArity(arity, definition, constraints);
      { Cons variables = Logic.yieldImplicitVariables(arity);
        Stella_Object characteristics = options.lookup(Logic.KWD_CHARACTERISTICS);
        boolean converttofunctionP = (characteristics != null) &&
            ((characteristics == Logic.KWD_SINGLE_VALUED) ||
             (Stella_Object.consP(characteristics) &&
              ((Cons)(characteristics)).memberP(Logic.KWD_SINGLE_VALUED)));
        Cons resultclause = Stella.NIL;

        if (!(constraints == Stella.NIL)) {
          kifconstraint = Logic.helpTranslateLoomDescriptionToKif(Logic.conjoinSentences(constraints), variables);
        }
        { Stella_Object renamed_Default = null;
          Cons iter002 = defaults;

          for (;!(iter002 == Stella.NIL); iter002 = iter002.rest) {
            renamed_Default = iter002.value;
            axioms = Cons.cons(Logic.translateLoomDefaults(renamed_Default, variables), axioms);
          }
        }
        if (!(axioms == Stella.NIL)) {
          kifaxiom = Logic.conjoinSentences(axioms);
          if (kifaxiom == Stella.NIL) {
            kifaxiom = null;
          }
        }
        if (definition != null) {
          kifdefinition = Logic.helpTranslateLoomDescriptionToKif(definition, variables);
        }
        if (converttofunctionP) {
          operator = Logic.SYM_LOGIC_DEFFUNCTION;
          resultclause = Cons.list$(Cons.cons(Logic.KWD__g, Cons.cons(((Symbol)(variables.last())), Cons.cons(Stella.NIL, Stella.NIL))));
          variables = variables.butLast().consify();
        }
        return (Cons.cons(operator, Cons.cons(name, Cons.cons(variables, resultclause.concatenate((((docstring != null) ? Cons.list$(Cons.cons(edu.isi.powerloom.pl_kernel_kb.loom_api.LoomApi.KWD_DOCUMENTATION, Cons.cons(docstring, Cons.cons(Stella.NIL, Stella.NIL)))) : Stella.NIL)).concatenate((((kifdefinition != null) ? Cons.list$(Cons.cons(Logic.KWD_llegg, Cons.cons(kifdefinition, Cons.cons(Stella.NIL, Stella.NIL)))) : Stella.NIL)).concatenate((((kifconstraint != null) ? Cons.list$(Cons.cons(Logic.KWD_egg, Cons.cons(kifconstraint, Cons.cons(Stella.NIL, Stella.NIL)))) : Stella.NIL)).concatenate((((kifaxiom != null) ? Cons.list$(Cons.cons(edu.isi.powerloom.pl_kernel_kb.loom_api.LoomApi.KWD_AXIOMS, Cons.cons(kifaxiom, Cons.cons(Stella.NIL, Stella.NIL)))) : Stella.NIL)).concatenate(Stella.NIL, Stella.NIL), Stella.NIL), Stella.NIL), Stella.NIL), Stella.NIL)))));
      }
    }
  }

  public static Cons translateLoomContextChange(Cons tree, boolean needsquoteP) {
    { Stella_Object contextform = tree.rest.value;

      { Surrogate testValue000 = Stella_Object.safePrimaryType(contextform);

        if (Surrogate.subtypeOfStringP(testValue000)) {
          { StringWrapper contextform000 = ((StringWrapper)(contextform));

            return (Cons.list$(Cons.cons(Logic.SYM_STELLA_IN_MODULE, Cons.cons(contextform000, Cons.cons(Stella.NIL, Stella.NIL)))));
          }
        }
        else if (Surrogate.subtypeOfSymbolP(testValue000)) {
          { Symbol contextform000 = ((Symbol)(contextform));

            if (needsquoteP) {
              {
                if (!(Stella.stringEqlP(contextform000.symbolName, "SAVEDCONTEXT"))) {
                  Stella.STANDARD_WARNING.nativeStream.println("Warning: Can't translate `" + tree + "' with a non-constant argument");
                }
                return (null);
              }
            }
            else {
              return (Cons.list$(Cons.cons(Logic.SYM_STELLA_IN_MODULE, Cons.cons(StringWrapper.wrapString(contextform000.symbolName), Cons.cons(Stella.NIL, Stella.NIL)))));
            }
          }
        }
        else if (testValue000 == Logic.SGT_STELLA_CONS) {
          { Cons contextform000 = ((Cons)(contextform));

            return (Logic.translateLoomContextChange(contextform000, false));
          }
        }
        else {
          { OutputStringStream stream000 = OutputStringStream.newOutputStringStream();

            stream000.nativeStream.print("`" + testValue000 + "' is not a valid case option");
            throw ((StellaException)(StellaException.newStellaException(stream000.theStringReader()).fillInStackTrace()));
          }
        }
      }
    }
  }

  public static boolean classNamesNextP(AllPurposeIterator self) {
    if (self.firstIterationP) {
      self.firstIterationP = false;
      self.value = ((Stella_Class)(self.iteratorObject)).classType;
      return (true);
    }
    { boolean nextP = self.iteratorNestedIterator.nextP();

      if (nextP) {
        self.value = self.iteratorNestedIterator.value;
      }
      return (nextP);
    }
  }

  public static boolean allPropositionsNextP(AllPurposeIterator self) {
    for (;;) {
      { Iterator iterator = self.iteratorNestedIterator;
        Module module = null;

        if (iterator.nextP()) {
          self.value = iterator.value;
          return (true);
        }
        module = ((Module)(((List)(self.iteratorObject)).pop()));
        if (module == null) {
          self.value = null;
          return (false);
        }
        self.iteratorNestedIterator = Logic.locallyConceivedPropositions(module).allocateIterator();
      }
    }
  }

  /** Iterate over all conceived propositions visible from <code>module</code>.
   * Only propositions that haven't been deleted will be considered.
   * If <code>localP</code>, only return propositions conceived locally in <code>module</code>.
   * @param module
   * @param localP
   * @return Iterator
   */
  public static Iterator allPropositions(Module module, boolean localP) {
    { AllPurposeIterator self000 = AllPurposeIterator.newAllPurposeIterator();

      self000.iteratorObject = (localP ? List.list(Stella.NIL) : Cons.copyConsList(Module.visibleModules(module).rest).reverse().listify());
      self000.iteratorNestedIterator = Logic.locallyConceivedPropositions(module).allocateIterator();
      self000.iteratorNextCode = Native.find_java_method("edu.isi.powerloom.logic.Logic", "allPropositionsNextP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.AllPurposeIterator")});
      { AllPurposeIterator value000 = self000;

        return (value000);
      }
    }
  }

  public static boolean filterInconsistentPropositionP(Stella_Object self, AllPurposeIterator iterator) {
    { Module module = ((Module)(iterator.iteratorObject));

      { Object old$Context$000 = Stella.$CONTEXT$.get();
        Object old$Module$000 = Stella.$MODULE$.get();

        try {
          Native.setSpecial(Stella.$CONTEXT$, null);
          Native.setSpecial(Stella.$MODULE$, null);
          { World temp000 = Logic.bestInferenceCache(module);

            Native.setSpecial(Stella.$CONTEXT$, ((temp000 != null) ? ((Context)(temp000)) : ((Context)(module))));
          }
          Native.setSpecial(Stella.$MODULE$, ((Context)(Stella.$CONTEXT$.get())).baseModule);
          return (Proposition.inconsistentP(((Proposition)(self))));

        } finally {
          Stella.$MODULE$.set(old$Module$000);
          Stella.$CONTEXT$.set(old$Context$000);
        }
      }
    }
  }

  /** Iterate over all conceived propositions visible from <code>module</code>
   * that have an inconsistent truth value.  If <code>localP</code>, only return
   * inconsistent propositions conceived locally in <code>module</code>.
   * @param module
   * @param localP
   * @return Iterator
   */
  public static Iterator allInconsistentPropositions(Module module, boolean localP) {
    { Iterator propositionsIterator = Logic.allPropositions(module, localP);
      AllPurposeIterator iterator = AllPurposeIterator.newAllPurposeIterator();

      iterator.iteratorObject = module;
      iterator.firstIterationP = true;
      iterator.iteratorNestedIterator = propositionsIterator;
      iterator.iteratorNextCode = Native.find_java_method("edu.isi.stella.AllPurposeIterator", "filteredNestedIteratorNextP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.AllPurposeIterator")});
      iterator.iteratorFilterCode = Native.find_java_method("edu.isi.powerloom.logic.Logic", "filterInconsistentPropositionP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.AllPurposeIterator")});
      return (iterator);
    }
  }

  public static boolean filterLocallyModifiedPropositionP(Stella_Object self, AllPurposeIterator iterator) {
    return (Proposition.locallyModifiedPropositionP(((Proposition)(self)), ((Module)(iterator.iteratorObject))));
  }

  /** Iterate over all conceived propositions visible from <code>module</code> that had their
   * truth value locally modified (initialized, asserted, retracted).  Note, that this
   * will always include all locally conceived propositions.
   * @param module
   * @return Iterator
   */
  public static Iterator allLocallyModifiedPropositions(Module module) {
    { Iterator propositionsIterator = Logic.allPropositions(module, false);
      AllPurposeIterator iterator = AllPurposeIterator.newAllPurposeIterator();

      iterator.iteratorObject = module;
      iterator.firstIterationP = true;
      iterator.iteratorNestedIterator = propositionsIterator;
      iterator.iteratorNextCode = Native.find_java_method("edu.isi.stella.AllPurposeIterator", "filteredNestedIteratorNextP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.AllPurposeIterator")});
      iterator.iteratorFilterCode = Native.find_java_method("edu.isi.powerloom.logic.Logic", "filterLocallyModifiedPropositionP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.AllPurposeIterator")});
      return (iterator);
    }
  }

  /** Iterate over all unnamed terms visible from <code>module</code>.  A term can be
   * an instance (or individual) as well as a description.  Only terms that
   * haven't been deleted will be considered.  If <code>localP</code>, only return
   * terms created locally in <code>module</code>.
   * @param module
   * @param localP
   * @return Iterator
   */
  public static Iterator allUnnamedTerms(Module module, boolean localP) {
    { Cons terms = Stella.NIL;
      Cons termswithduplicates = Stella.NIL;
      LogicObject term = null;

      { Proposition proposition = null;
        Iterator iter000 = Logic.allPropositions(module, localP);

        while (iter000.nextP()) {
          proposition = ((Proposition)(iter000.value));
          { Stella_Object arg = null;
            Vector vector000 = proposition.arguments;
            int index000 = 0;
            int length000 = vector000.length();

            loop001 : for (;index000 < length000; index000 = index000 + 1) {
              arg = (vector000.theArray)[index000];
              if ((arg != null) &&
                  (Stella_Object.isaP(arg, Logic.SGT_LOGIC_LOGIC_OBJECT) &&
                   (!arg.deletedP()))) {
                term = ((LogicObject)(arg));
                if ((!LogicObject.visibleTermP(term, module, localP)) ||
                    (term.surrogateValueInverse != null)) {
                  continue loop001;
                }
                { Surrogate testValue000 = Stella_Object.safePrimaryType(term);

                  if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
                    { PatternVariable term000 = ((PatternVariable)(term));

                    }
                  }
                  else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_SKOLEM)) {
                    { Skolem term000 = ((Skolem)(term));

                      if (term000.definingProposition != null) {
                        if (term000.definingProposition == proposition) {
                          terms = Cons.cons(term000, terms);
                        }
                      }
                      else {
                        termswithduplicates = Cons.cons(term000, termswithduplicates);
                      }
                    }
                  }
                  else {
                    termswithduplicates = Cons.cons(term, termswithduplicates);
                  }
                }
              }
            }
          }
        }
      }
      return (terms.concatenate(termswithduplicates.removeDuplicates(), Stella.NIL).allocateIterator());
    }
  }

  public static boolean namedTermP(Stella_Object term, AllPurposeIterator iter) {
    iter = iter;
    { Surrogate testValue000 = Stella_Object.safePrimaryType(term);

      if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_NAMED_DESCRIPTION)) {
        { NamedDescription term000 = ((NamedDescription)(term));

          return (!term000.deletedP());
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_DESCRIPTION)) {
        { Description term000 = ((Description)(term));

          return (false);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_PATTERN_VARIABLE)) {
        { PatternVariable term000 = ((PatternVariable)(term));

          return (false);
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_LOGIC_LOGIC_OBJECT)) {
        { LogicObject term000 = ((LogicObject)(term));

          return (!term000.deletedP());
        }
      }
      else if (Surrogate.subtypeOfP(testValue000, Logic.SGT_STELLA_THING)) {
        { Thing term000 = ((Thing)(term));

          return (!term000.deletedP());
        }
      }
      else {
        return (false);
      }
    }
  }

  /** Iterate over all named terms visible from <code>module</code>.  A term can be an
   * instance (or individual) as well as a description.  Only terms that
   * haven't been deleted will be considered.  If <code>localP</code>, only return 
   * terms created locally in <code>module</code>.
   * @param module
   * @param localP
   * @return Iterator
   */
  public static Iterator allNamedTerms(Module module, boolean localP) {
    if (localP) {
      { AllPurposeIterator self000 = AllPurposeIterator.newAllPurposeIterator();

        self000.iteratorNestedIterator = Logic.locallyConceivedInstances(module).allocateIterator();
        self000.iteratorNextCode = Native.find_java_method("edu.isi.stella.AllPurposeIterator", "filteredNestedIteratorNextP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.AllPurposeIterator")});
        self000.iteratorFilterCode = Native.find_java_method("edu.isi.powerloom.logic.Logic", "namedTermP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.AllPurposeIterator")});
        { AllPurposeIterator value000 = self000;

          return (value000);
        }
      }
    }
    else {
      { Iterator iterator1 = Logic.allNamedTerms(module, true);
        Cons iteratorlist = Stella.NIL;

        { Context renamed_Super = null;
          Cons iter000 = module.allSuperContexts;
          Cons collect000 = null;

          for (;!(iter000 == Stella.NIL); iter000 = iter000.rest) {
            renamed_Super = ((Context)(iter000.value));
            if (collect000 == null) {
              {
                collect000 = Cons.cons(Logic.allNamedTerms(((Module)(renamed_Super)), true), Stella.NIL);
                if (iteratorlist == Stella.NIL) {
                  iteratorlist = collect000;
                }
                else {
                  Cons.addConsToEndOfConsList(iteratorlist, collect000);
                }
              }
            }
            else {
              {
                collect000.rest = Cons.cons(Logic.allNamedTerms(((Module)(renamed_Super)), true), Stella.NIL);
                collect000 = collect000.rest;
              }
            }
          }
        }
        if (iteratorlist == Stella.NIL) {
          return (iterator1);
        }
        else {
          { AllPurposeIterator self001 = AllPurposeIterator.newAllPurposeIterator();

            self001.iteratorNestedIterator = iterator1;
            self001.iteratorConsList = iteratorlist;
            self001.iteratorNextCode = Native.find_java_method("edu.isi.stella.AllPurposeIterator", "filteredConcatenatedIteratorNextP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.AllPurposeIterator")});
            { AllPurposeIterator value001 = self001;

              return (value001);
            }
          }
        }
      }
    }
  }

  /** Return a list of all terms visible from <code>module</code>.  A term can be an
   * instance (or individual) as well as a description.  Only terms that
   * haven't been deleted will be considered.  If <code>localP</code>, only return 
   * terms created locally in <code>module</code>.
   * @param module
   * @param localP
   * @return Iterator
   */
  public static Iterator allTerms(Module module, boolean localP) {
    if (localP) {
      {
        Logic.locallyConceivedInstances(module).removeDeletedMembers();
        return (Logic.locallyConceivedInstances(module).allocateIterator());
      }
    }
    else {
      return (Logic.allNamedTerms(module, false).concatenate(Logic.allUnnamedTerms(module, false), Stella.NIL));
    }
  }

  /** Iterate over all named instances (or individuals) visible from <code>module</code>.
   * Only instances that haven't been deleted will be considered.  If <code>localP</code>,
   * only return instances created locally in <code>module</code>.
   * @param module
   * @param localP
   * @return Iterator
   */
  public static Iterator allNamedInstances(Module module, boolean localP) {
    { AllPurposeIterator self000 = AllPurposeIterator.newAllPurposeIterator();

      self000.iteratorNestedIterator = Logic.allNamedTerms(module, localP);
      self000.iteratorNextCode = Native.find_java_method("edu.isi.stella.AllPurposeIterator", "filteredNestedIteratorNextP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.AllPurposeIterator")});
      self000.iteratorFilterCode = Native.find_java_method("edu.isi.powerloom.logic.LogicObject", "filterInstanceP", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.AllPurposeIterator")});
      { AllPurposeIterator value000 = self000;

        return (value000);
      }
    }
  }

  /** Iterate over all instances (or individuals) visible from <code>module</code>.
   * Only instances that haven't been deleted will be considered.  If <code>localP</code>,
   * only return instances created locally in <code>module</code>.
   * @param module
   * @param localP
   * @return Iterator
   */
  public static Iterator allInstances(Module module, boolean localP) {
    { Iterator iterator = Logic.allTerms(module, localP);
      AllPurposeIterator allpurposeiterator = null;

      if (localP) {
        { AllPurposeIterator self000 = AllPurposeIterator.newAllPurposeIterator();

          self000.iteratorNestedIterator = iterator;
          self000.iteratorNextCode = Native.find_java_method("edu.isi.stella.AllPurposeIterator", "filteredNestedIteratorNextP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.AllPurposeIterator")});
          allpurposeiterator = self000;
        }
      }
      else {
        allpurposeiterator = ((AllPurposeIterator)(iterator));
      }
      allpurposeiterator.iteratorFilterCode = Native.find_java_method("edu.isi.powerloom.logic.LogicObject", "filterInstanceP", new java.lang.Class [] {Native.find_java_class("edu.isi.powerloom.logic.LogicObject"), Native.find_java_class("edu.isi.stella.AllPurposeIterator")});
      return (allpurposeiterator);
    }
  }

  public static LogicObject stringToLogicObject(String string) {
    { Surrogate sgt = null;
      Iterator iter000 = Module.allSurrogates(null, false);

      while (iter000.nextP()) {
        sgt = ((Surrogate)(iter000.value));
        if (Stella.stringEqlP(sgt.symbolName, string) &&
            ((sgt.surrogateValue != null) &&
             Stella_Object.isaP(sgt.surrogateValue, Logic.SGT_LOGIC_LOGIC_OBJECT))) {
          return (((LogicObject)(sgt.surrogateValue)));
        }
      }
    }
    return (null);
  }

  public static void plLog(Keyword loglevel, Cons message) {
    Stella.logMessage("PowerLoom", loglevel, message);
  }

  /** Returns information about the current PowerLoom implementation.
   * Useful when reporting problems.
   * @return String
   */
  public static String powerloomInformation() {
    { OutputStringStream ss = OutputStringStream.newOutputStringStream();

      {
        ss.nativeStream.println(Logic.$POWERLOOM_VERSION_STRING$);
        ss.nativeStream.print(Stella.stellaInformation());
      }
;
      return (ss.theStringReader());
    }
  }

  public static StringWrapper powerloomInformationEvaluatorWrapper(Cons arguments) {
    arguments = arguments;
    { String result = Logic.powerloomInformation();

      if (result != null) {
        return (StringWrapper.wrapString(result));
      }
      else {
        return (null);
      }
    }
  }

  public static String powerloomCopyrightHeader() {
    { String logicsystemfile = Stella.makeSystemDefinitionFileName("logic");
      SystemDefinition logicsystem = (Stella.probeFileP(logicsystemfile) ? Stella.getSystemDefinition("logic") : ((SystemDefinition)(null)));
      KeyValueList substitutionList = KeyValueList.newKeyValueList();

      KeyValueList.fillInDateSubstitution(substitutionList);
      if (logicsystem != null) {
        return (Stella.substituteTemplateVariablesInString(logicsystem.banner, substitutionList));
      }
      else {
        return ("---------------------------- BEGIN LICENSE BLOCK ---------------------------+\n |                                                                            |\n | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |\n |                                                                            |\n | The contents of this file are subject to the Mozilla Public License        |\n | Version 1.1 (the \"License\"); you may not use this file except in           |\n | compliance with the License. You may obtain a copy of the License at       |\n | http://www.mozilla.org/MPL/                                                |\n |                                                                            |\n | Software distributed under the License is distributed on an \"AS IS\" basis, |\n | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |\n | for the specific language governing rights and limitations under the       |\n | License.                                                                   |\n |                                                                            |\n | The Original Code is the PowerLoom KR&R System.                            |\n |                                                                            |\n | The Initial Developer of the Original Code is                              |\n | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |\n | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |\n |                                                                            |\n | Portions created by the Initial Developer are Copyright (C) 1997-2010      |\n | the Initial Developer. All Rights Reserved.                                |\n |                                                                            |\n | Contributor(s):                                                            |\n |                                                                            |\n | Alternatively, the contents of this file may be used under the terms of    |\n | either the GNU General Public License Version 2 or later (the \"GPL\"), or   |\n | the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),   |\n | in which case the provisions of the GPL or the LGPL are applicable instead |\n | of those above. If you wish to allow use of your version of this file only |\n | under the terms of either the GPL or the LGPL, and not to allow others to  |\n | use your version of this file under the terms of the MPL, indicate your    |\n | decision by deleting the provisions above and replace them with the notice |\n | and other provisions required by the GPL or the LGPL. If you do not delete |\n | the provisions above, a recipient may use your version of this file under  |\n | the terms of any one of the MPL, the GPL or the LGPL.                      |\n |                                                                            |\n +----------------------------- END LICENSE BLOCK ----------------------------");
      }
    }
  }

  /** Print detailed PowerLoom copyright information.
   */
  public static void copyright() {
    Stella.STANDARD_OUTPUT.nativeStream.println(" +" + Logic.powerloomCopyrightHeader() + "+");
  }

  public static String copyrightYears() {
    { String copyright = Logic.powerloomCopyrightHeader();
      int start = Native.stringSearch(copyright, "1997", 0);
      int end = Native.stringSearch(copyright, "  ", start);

      return (Native.string_subsequence(copyright, start, end));
    }
  }

  /** Run the PowerLoom listener.  Read logic commands from the
   * standard input, evaluate them, and print their results.  Exit if the user
   * entered <code>bye</code>, <code>exit</code>, <code>halt</code>, <code>quit</code>, or <code>stop</code>.
   */
  public static void powerloom() {
    {
      Stella.STANDARD_OUTPUT.nativeStream.println();
      Stella.STANDARD_OUTPUT.nativeStream.println("    Welcome to " + Logic.$POWERLOOM_VERSION_STRING$);
      Stella.STANDARD_OUTPUT.nativeStream.println();
      Stella.STANDARD_OUTPUT.nativeStream.println("Copyright (C) USC Information Sciences Institute, " + Logic.copyrightYears() + ".");
      Stella.STANDARD_OUTPUT.nativeStream.println("PowerLoom is a trademark of the University of Southern California.");
      Stella.STANDARD_OUTPUT.nativeStream.println("PowerLoom comes with ABSOLUTELY NO WARRANTY!");
      Stella.STANDARD_OUTPUT.nativeStream.println("Type `(copyright)' for detailed copyright information.");
      Stella.STANDARD_OUTPUT.nativeStream.println("Type `(help)' for a list of available commands.");
      Stella.STANDARD_OUTPUT.nativeStream.println("Type `(demo)' for a list of example applications.");
      Stella.STANDARD_OUTPUT.nativeStream.println("Type `bye', `exit', `halt', `quit', or `stop', to exit.");
      Stella.STANDARD_OUTPUT.nativeStream.println();
    }
;
    try {
      Logic.logicCommandLoop(null);
      {
        Stella.STANDARD_OUTPUT.nativeStream.println("Bye.");
        Stella.STANDARD_OUTPUT.nativeStream.println();
      }
;
    } catch (java.lang.Exception e) {
      Stella.STANDARD_ERROR.nativeStream.println("Caught native non-STELLA exception " + e + " at top level.");
      Stella.printExceptionContext(e, Stella.STANDARD_ERROR);
      {
        Stella.STANDARD_ERROR.nativeStream.println("Exiting PowerLoom.");
        Stella.STANDARD_ERROR.nativeStream.println();
      }
;
    }
  }

}
