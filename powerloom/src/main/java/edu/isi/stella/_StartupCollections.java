//  -*- Mode: Java -*-
//
// _StartupCollections.java

/*
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2017      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
*/

package edu.isi.stella;

import edu.isi.stella.javalib.*;

public class _StartupCollections {
  static void helpStartupCollections1() {
    {
      Stella.SYM_STELLA_VECTOR = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("VECTOR", null, 0)));
      Stella.SGT_STELLA_HEAP = ((Surrogate)(GeneralizedSymbol.internRigidSymbolWrtModule("HEAP", null, 1)));
      Stella.SYM_STELLA_PREDICATE = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("PREDICATE", null, 0)));
      Stella.SYM_STELLA_FILL_POINTER = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("FILL-POINTER", null, 0)));
      Stella.SYM_STELLA_SIZE = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("SIZE", null, 0)));
      Stella.SYM_STELLA_INITIAL_SIZE = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("INITIAL-SIZE", null, 0)));
      Stella.SYM_STELLA_FREE_ELEMENTS = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("FREE-ELEMENTS", null, 0)));
      Stella.SYM_STELLA_EQUAL_TESTp = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("EQUAL-TEST?", null, 0)));
      Stella.SGT_STELLA_STELLA_HASH_TABLE_ITERATOR = ((Surrogate)(GeneralizedSymbol.internRigidSymbolWrtModule("STELLA-HASH-TABLE-ITERATOR", null, 1)));
      Stella.SYM_STELLA_BUCKET_INDEX = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("BUCKET-INDEX", null, 0)));
      Stella.SYM_STELLA_BUCKET_CURSOR = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("BUCKET-CURSOR", null, 0)));
      Stella.SYM_STELLA_THE_MAP = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("THE-MAP", null, 0)));
      Stella.SYM_STELLA_CROSSOVER_POINT = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("CROSSOVER-POINT", null, 0)));
      Stella.SGT_STELLA_HASH_SET = ((Surrogate)(GeneralizedSymbol.internRigidSymbolWrtModule("HASH-SET", null, 1)));
      Stella.SGT_STELLA_1D_ARRAY = ((Surrogate)(GeneralizedSymbol.internRigidSymbolWrtModule("1D-ARRAY", null, 1)));
      Stella.SYM_STELLA_OBJECT_ARRAY = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("OBJECT-ARRAY", null, 0)));
      Stella.SGT_STELLA_1D_FLOAT_ARRAY = ((Surrogate)(GeneralizedSymbol.internRigidSymbolWrtModule("1D-FLOAT-ARRAY", null, 1)));
      Stella.SYM_STELLA_FLOAT_ARRAY = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("FLOAT-ARRAY", null, 0)));
      Stella.SGT_STELLA_2D_ARRAY = ((Surrogate)(GeneralizedSymbol.internRigidSymbolWrtModule("2D-ARRAY", null, 1)));
      Stella.SGT_STELLA_2D_FLOAT_ARRAY = ((Surrogate)(GeneralizedSymbol.internRigidSymbolWrtModule("2D-FLOAT-ARRAY", null, 1)));
      Stella.SYM_STELLA_STARTUP_COLLECTIONS = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("STARTUP-COLLECTIONS", null, 0)));
    }
  }

  static void helpStartupCollections2() {
    {
      { Stella_Class renamed_Class = Stella.defineClassFromStringifiedSource("HEAP", "(DEFCLASS HEAP (VECTOR) :DOCUMENTATION \"Implements a Min or Max heap depending on the semantics\nof `predicate' (Min if `predicate' has a `<' semantics).  This is useful\nfor in-place sorting (even though we have specialzed sort routines for that)\nor to maintain top-N lists with log(N) insertion time.  We place this under\nVECTOR instead of VECTOR-SEQUENCE for now, since sequential order isn't\nreally maintained or accessible until we sort the heap.\" :PUBLIC? TRUE :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((PREDICATE :TYPE FUNCTION-CODE :REQUIRED? TRUE) (FILL-POINTER :TYPE INTEGER :INITIALLY 0)) :INITIALIZER INITIALIZE-HEAP)");

        renamed_Class.classConstructorCode = Native.find_java_method("edu.isi.stella.Heap", "newHeap", new java.lang.Class [] {Native.find_java_class("java.lang.reflect.Method"), java.lang.Integer.TYPE});
        renamed_Class.classSlotAccessorCode = Native.find_java_method("edu.isi.stella.Heap", "accessHeapSlotValue", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Heap"), Native.find_java_class("edu.isi.stella.Symbol"), Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Boolean.TYPE});
      }
      { Stella_Class renamed_Class = Stella.defineClassFromStringifiedSource("STELLA-HASH-TABLE", "(DEFCLASS STELLA-HASH-TABLE (ABSTRACT-HASH-TABLE) :PARAMETERS ((ANY-KEY :TYPE OBJECT) (ANY-VALUE :TYPE OBJECT)) :SLOTS ((THE-TABLE :TYPE (ARRAY () OF KV-CONS)) (SIZE :TYPE INTEGER) (INITIAL-SIZE :TYPE INTEGER :INITIALLY 50 :PUBLIC? TRUE :DOCUMENTATION \"If supplied, the initial hash table\nwill be sized to hold at least that many elements.\") (FREE-ELEMENTS :TYPE INTEGER) (EQUAL-TEST? :TYPE BOOLEAN :INITIALLY FALSE :PUBLIC? TRUE :DOCUMENTATION \"If true use `equal?' as the\nequality test and `equal-hash-code' as the hash function, otherwise,\nuse `eql?' and `hash-code' (the default).\")))");

        renamed_Class.classConstructorCode = Native.find_java_method("edu.isi.stella.StellaHashTable", "newStellaHashTable", new java.lang.Class [] {});
        renamed_Class.classSlotAccessorCode = Native.find_java_method("edu.isi.stella.StellaHashTable", "accessStellaHashTableSlotValue", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.StellaHashTable"), Native.find_java_class("edu.isi.stella.Symbol"), Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Boolean.TYPE});
      }
      { Stella_Class renamed_Class = Stella.defineClassFromStringifiedSource("STELLA-HASH-TABLE-ITERATOR", "(DEFCLASS STELLA-HASH-TABLE-ITERATOR (DICTIONARY-ITERATOR) :DOCUMENTATION \"Iterator class for STELLA-HASH-TABLE's.  The only modifying\noperations allowed during iteration are removal of the current element or\nchanging its value.  All other removal or insertion operations might lead\nto corruption or undefined results.\" :SLOTS ((SIZE :TYPE INTEGER) (BUCKET-TABLE :TYPE (ARRAY () OF KV-CONS)) (BUCKET-INDEX :TYPE INTEGER :INITIALLY 0) (BUCKET-CURSOR :TYPE KV-CONS)))");

        renamed_Class.classConstructorCode = Native.find_java_method("edu.isi.stella.StellaHashTableIterator", "newStellaHashTableIterator", new java.lang.Class [] {});
        renamed_Class.classSlotAccessorCode = Native.find_java_method("edu.isi.stella.StellaHashTableIterator", "accessStellaHashTableIteratorSlotValue", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.StellaHashTableIterator"), Native.find_java_class("edu.isi.stella.Symbol"), Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Boolean.TYPE});
      }
      { Stella_Class renamed_Class = Stella.defineClassFromStringifiedSource("KEY-VALUE-MAP", "(DEFCLASS KEY-VALUE-MAP (DICTIONARY) :DOCUMENTATION \"Full-featured dictionary class that supports `eql?' or\n`equal?' equality tests, O(1) access operations even for large numbers\nof entries by using a hash table, light-weight KV-CONS representation for\nsmall tables and iteration even if the dictionary is represented by a\nhash table.\" :PUBLIC? TRUE :SLOTS ((THE-MAP :TYPE OBJECT) (EQUAL-TEST? :TYPE BOOLEAN :INITIALLY FALSE :PUBLIC? TRUE :DOCUMENTATION \"If true use `equal?' as the\nequality test (and `equal-hash-code' as the hash function), otherwise,\nuse `eql?' (and `hash-code') (the default).\") (INITIAL-SIZE :TYPE INTEGER :INITIALLY *KEY-VALUE-MAP-CROSSOVER-POINT* :PUBLIC? TRUE :DOCUMENTATION \"If supplied, the initial table\nwill be sized to hold at least that many elements.\") (CROSSOVER-POINT :TYPE INTEGER :INITIALLY *KEY-VALUE-MAP-CROSSOVER-POINT*)))");

        renamed_Class.classConstructorCode = Native.find_java_method("edu.isi.stella.KeyValueMap", "newKeyValueMap", new java.lang.Class [] {});
        renamed_Class.classSlotAccessorCode = Native.find_java_method("edu.isi.stella.KeyValueMap", "accessKeyValueMapSlotValue", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.KeyValueMap"), Native.find_java_class("edu.isi.stella.Symbol"), Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Boolean.TYPE});
      }
      { Stella_Class renamed_Class = Stella.defineClassFromStringifiedSource("HASH-SET", "(DEFCLASS HASH-SET (KEY-VALUE-MAP SET-MIXIN) :DOCUMENTATION \"Full-featured set class that supports `eql?' or `equal?'\nequality tests, O(1) insert and `member?' operations & O(N) `intersection'\netc. operations even for large numbers of entries by using a hash table,\nlight-weight KV-CONS representation for small sets and iteration even if the\nset is represented by a hash table.  The only minor drawback right now is that\nthis wastes a value slot per entry, since we piggy-back off KEY-VALUE-MAP's,\nhowever, that wastes at most 25% space.\" :PUBLIC? TRUE)");

        renamed_Class.classConstructorCode = Native.find_java_method("edu.isi.stella.HashSet", "newHashSet", new java.lang.Class [] {});
      }
      Stella.defineClassFromStringifiedSource("DIMENSIONAL-ARRAY-MIXIN", "(DEFCLASS DIMENSIONAL-ARRAY-MIXIN () :MIXIN? TRUE :PARAMETERS ((ANY-VALUE :TYPE UNKNOWN)) :SLOTS ((DIM1 :TYPE INTEGER :REQUIRED? TRUE) (THE-ARRAY :TYPE (ARRAY () OF (LIKE (ANY-VALUE SELF))))) :INITIALIZER INITIALIZE-DIMENSIONAL-ARRAY)");
      Stella.defineClassFromStringifiedSource("2-DIMENSIONAL-ARRAY-MIXIN", "(DEFCLASS 2-DIMENSIONAL-ARRAY-MIXIN (DIMENSIONAL-ARRAY-MIXIN) :MIXIN? TRUE :PUBLIC? TRUE :SLOTS ((DIM2 :TYPE INTEGER :REQUIRED? TRUE)))");
      Stella.defineClassFromStringifiedSource("ABSTRACT-DIMENSIONAL-ARRAY", "(DEFCLASS ABSTRACT-DIMENSIONAL-ARRAY (ABSTRACT-COLLECTION) :DOCUMENTATION \"Array objects that are aware of their dimensions.\" :PUBLIC? TRUE :ABSTRACT? TRUE :PARAMETERS ((ANY-VALUE :TYPE UNKNOWN)))");
      { Stella_Class renamed_Class = Stella.defineClassFromStringifiedSource("1D-ARRAY", "(DEFCLASS 1D-ARRAY (ABSTRACT-DIMENSIONAL-ARRAY DIMENSIONAL-ARRAY-MIXIN) :DOCUMENTATION \"1-dimensional array with OBJECT values.  This is more or\nless equivalent to VECTOR (fewer methods) but kept here for symmetry.\" :PUBLIC? TRUE :SYNONYMS (OBJECT-ARRAY) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)))");

        renamed_Class.classConstructorCode = Native.find_java_method("edu.isi.stella.oneDArray", "new1DArray", new java.lang.Class [] {java.lang.Integer.TYPE});
      }
      { Stella_Class renamed_Class = Stella.defineClassFromStringifiedSource("1D-FLOAT-ARRAY", "(DEFCLASS 1D-FLOAT-ARRAY (ABSTRACT-DIMENSIONAL-ARRAY DIMENSIONAL-ARRAY-MIXIN) :DOCUMENTATION \"1-dimensional array with float values.\" :PUBLIC? TRUE :SYNONYMS (FLOAT-ARRAY) :PARAMETERS ((ANY-VALUE :TYPE FLOAT)))");

        renamed_Class.classConstructorCode = Native.find_java_method("edu.isi.stella.oneDFloatArray", "new1DFloatArray", new java.lang.Class [] {java.lang.Integer.TYPE});
      }
      { Stella_Class renamed_Class = Stella.defineClassFromStringifiedSource("2D-ARRAY", "(DEFCLASS 2D-ARRAY (ABSTRACT-DIMENSIONAL-ARRAY 2-DIMENSIONAL-ARRAY-MIXIN) :DOCUMENTATION \"2-dimensional array with object values.\" :PUBLIC? TRUE :PARAMETERS ((ANY-VALUE :TYPE OBJECT)))");

        renamed_Class.classConstructorCode = Native.find_java_method("edu.isi.stella.twoDArray", "new2DArray", new java.lang.Class [] {java.lang.Integer.TYPE, java.lang.Integer.TYPE});
      }
      { Stella_Class renamed_Class = Stella.defineClassFromStringifiedSource("2D-FLOAT-ARRAY", "(DEFCLASS 2D-FLOAT-ARRAY (ABSTRACT-DIMENSIONAL-ARRAY 2-DIMENSIONAL-ARRAY-MIXIN) :DOCUMENTATION \"2-dimensional array with float values.\" :PUBLIC? TRUE :PARAMETERS ((ANY-VALUE :TYPE FLOAT)))");

        renamed_Class.classConstructorCode = Native.find_java_method("edu.isi.stella.twoDFloatArray", "new2DFloatArray", new java.lang.Class [] {java.lang.Integer.TYPE, java.lang.Integer.TYPE});
      }
    }
  }

  static void helpStartupCollections3() {
    {
      Stella.defineMethodObject("(DEFMETHOD (MEMBER? BOOLEAN) ((SELF COLLECTION) (OBJECT OBJECT)) :DOCUMENTATION \"Return true iff `object' is a member of the collection `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Collection", "memberP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (REMOVE-DUPLICATES (LIKE SELF)) ((SELF COLLECTION)) :DOCUMENTATION \"Return `self' with duplicates removed.  Preserves the\noriginal order of the remaining members.\" :PUBLIC? TRUE :ABSTRACT? TRUE)", ((java.lang.reflect.Method)(null)), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("STELLA-COLLECTION?", "(DEFUN (STELLA-COLLECTION? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return `true' if `self' is a native collection.\")", Native.find_java_method("edu.isi.stella.Stella_Object", "stellaCollectionP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineMethodObject("(DEFMETHOD (NO-DUPLICATES? BOOLEAN) ((SELF COLLECTION)) :PUBLIC? TRUE :DOCUMENTATION \"Return `true' if the collection `self' forbids duplicate values.\")", Native.find_java_method("edu.isi.stella.Collection", "noDuplicatesP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (NO-DUPLICATES? BOOLEAN) ((SELF SET)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Set", "noDuplicatesP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (ORDERED? BOOLEAN) ((SELF COLLECTION)) :PUBLIC? TRUE :DOCUMENTATION \"Return `true' if the collection `self' is ordered.\")", Native.find_java_method("edu.isi.stella.Collection", "orderedP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (ORDERED? BOOLEAN) ((SELF SEQUENCE)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Sequence", "orderedP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (ORDERED? BOOLEAN) ((SELF SET)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Set", "orderedP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD INSERT ((SELF SET) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :DOCUMENTATION \"Add `value' to the set `self' unless it is already a member.\")", Native.find_java_method("edu.isi.stella.Set", "insert", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD PUSH ((SELF SET) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :DOCUMENTATION \"Add `value' to the front of set `self' unless it is already a member.\")", Native.find_java_method("edu.isi.stella.Set", "push", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD INSERT-LAST ((SELF SET) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Add `value' to the end of set `self' unless it is already a member.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Set", "insertLast", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (REMOVE-DUPLICATES (LIKE SELF)) ((SELF SET)))", Native.find_java_method("edu.isi.stella.Set", "removeDuplicates", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (SUBSTITUTE (LIKE SELF)) ((SELF SET) (NEW OBJECT) (OLD OBJECT)) :DOCUMENTATION \"Destructively replace `old' with `new' in the set `self'\nunless `new' is already a member.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Set", "substitute", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (CONCATENATE SET) ((SET1 SET) (SET2 LIST) |&REST| (OTHERSETS LIST)) :DOCUMENTATION \"Union `set2' and all `otherSets' onto the end of `set1'.\nThe operation is destructive wrt `set1', but leaves all other sets intact.\nThe two mandatory parameters allow us to optimize the common binary case by\nnot relying on the somewhat less efficient variable arguments mechanism.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Set", "concatenate", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.List"), Native.find_java_class("edu.isi.stella.Cons")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X SET) (Y OBJECT)) :DOCUMENTATION \"Return TRUE iff `x' and `y' are SET's with equivalent members.\nUses `equal?' to test equality of elements.  This is more general than\n`equivalent-sets?', since that only uses an `eql?' test.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Set", "objectEqualP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (EQUAL-HASH-CODE INTEGER) ((SELF SET)) :DOCUMENTATION \"Return an `equal?' hash code for `self'.  Note that this\nis O(N) in the number of elements of `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Set", "equalHashCode", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("SET", "(DEFUN (SET SET) (|&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return a set containing `values', in order.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "set", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineMethodObject("(DEFMETHOD PRINT-VECTOR ((SELF VECTOR) (STREAM NATIVE-OUTPUT-STREAM)))", Native.find_java_method("edu.isi.stella.Vector", "printVector", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.javalib.NativeOutputStream")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (EMPTY? BOOLEAN) ((SELF VECTOR)) :DOCUMENTATION \"Return `true' if `self' has length 0.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Vector", "emptyP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF VECTOR)) :DOCUMENTATION \"Return `true' if `self' has length > 0.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Vector", "nonEmptyP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (FIRST (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 0)))", Native.find_java_method("edu.isi.stella.Vector", "first", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (SECOND (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 1)))", Native.find_java_method("edu.isi.stella.Vector", "second", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (THIRD (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 2)))", Native.find_java_method("edu.isi.stella.Vector", "third", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (FOURTH (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 3)))", Native.find_java_method("edu.isi.stella.Vector", "fourth", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (FIFTH (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 4)))", Native.find_java_method("edu.isi.stella.Vector", "fifth", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (POSITION INTEGER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH (THE-ARRAY SELF) POSITION)))", Native.find_java_method("edu.isi.stella.Vector", "nth", new java.lang.Class [] {java.lang.Integer.TYPE}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ((SELF VECTOR)) :PUBLIC? TRUE :DOCUMENTATION \"Return the last item in the vector `self'.\")", Native.find_java_method("edu.isi.stella.Vector", "last", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (FIRST-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 0) VALUE)))", Native.find_java_method("edu.isi.stella.Vector", "firstSetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (SECOND-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 1) VALUE)))", Native.find_java_method("edu.isi.stella.Vector", "secondSetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (THIRD-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 2) VALUE)))", Native.find_java_method("edu.isi.stella.Vector", "thirdSetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (FOURTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 3) VALUE)))", Native.find_java_method("edu.isi.stella.Vector", "fourthSetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (FIFTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH SELF 4) VALUE)))", Native.find_java_method("edu.isi.stella.Vector", "fifthSetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF))) (POSITION INTEGER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (NTH (THE-ARRAY SELF) POSITION) VALUE)))", Native.find_java_method("edu.isi.stella.Vector", "nthSetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Integer.TYPE}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (LAST-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Vector", "lastSetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (LENGTH INTEGER) ((SELF VECTOR)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Vector", "length", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (MEMBER? BOOLEAN) ((SELF VECTOR) (OBJECT OBJECT)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Vector", "memberP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (POSITION INTEGER) ((SELF VECTOR) (OBJECT OBJECT) (START INTEGER)) :DOCUMENTATION \"Return the position of `object' within the vector\n`self' (counting from zero); or return `null' if `object' does not occur within \n`self' (uses an `eql?' test).  If `start' was supplied as non-`null', only \nconsider the portion starting at `start', however, the returned position \nwill always be relative to the entire vector.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Vector", "position", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Integer.TYPE}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (LAST-POSITION INTEGER) ((SELF VECTOR) (OBJECT OBJECT) (END INTEGER)) :DOCUMENTATION \"Return the position of `object' within the vector\n`self' (counting from zero); or return `null' if `object' does not occur within \n`self' (uses an `eql?' test).  If `end' was supplied as non-`null', only \nconsider the portion ending at index `end', however, the returned position \nwill always be relative to the entire vector.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Vector", "lastPosition", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Integer.TYPE}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD INSERT-AT ((SELF VECTOR) (OFFSET INTEGER) (VALUE (LIKE (ANY-VALUE SELF)))))", Native.find_java_method("edu.isi.stella.Vector", "insertAt", new java.lang.Class [] {java.lang.Integer.TYPE, Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (COPY (VECTOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR)) :DOCUMENTATION \"Return a copy of the vector `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Vector", "copy", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD CLEAR ((SELF VECTOR)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Vector", "clear", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("VECTOR", "(DEFUN (VECTOR VECTOR) (|&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return a vector containing `values', in order.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "vector", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineMethodObject("(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X VECTOR) (Y OBJECT)) :DOCUMENTATION \"Return TRUE iff the vectors `x' and `y' are structurally\nequivalent.  Uses `equal?' to test equality of elements.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Vector", "objectEqualP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (EQUAL-HASH-CODE INTEGER) ((SELF VECTOR)) :DOCUMENTATION \"Return an `equal?' hash code for `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Vector", "equalHashCode", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-VECTOR) (OFFSET INTEGER) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.ExtensibleVector", "insertAt", new java.lang.Class [] {java.lang.Integer.TYPE, Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD INSERT-AT ((SELF EXTENSIBLE-SYMBOL-ARRAY) (OFFSET INTEGER) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.ExtensibleSymbolArray", "insertAt", new java.lang.Class [] {java.lang.Integer.TYPE, Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (EMPTY? BOOLEAN) ((SELF VECTOR-SEQUENCE)) :DOCUMENTATION \"Return `true' if `self' has length 0.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (EQL? (LENGTH SELF) 0)))", Native.find_java_method("edu.isi.stella.VectorSequence", "emptyP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF VECTOR-SEQUENCE)) :DOCUMENTATION \"Return `true' if `self' has length > 0.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (> (LENGTH SELF) 0)))", Native.find_java_method("edu.isi.stella.VectorSequence", "nonEmptyP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (LENGTH INTEGER) ((SELF VECTOR-SEQUENCE)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SEQUENCE-LENGTH SELF)))", Native.find_java_method("edu.isi.stella.VectorSequence", "length", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ((SELF VECTOR-SEQUENCE)) :PUBLIC? TRUE :DOCUMENTATION \"Return the last item in the vector `self'.\")", Native.find_java_method("edu.isi.stella.VectorSequence", "last", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (LAST-SETTER (LIKE (ANY-VALUE SELF))) ((SELF VECTOR-SEQUENCE) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.VectorSequence", "lastSetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD INSERT ((SELF VECTOR-SEQUENCE) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Append `value' to the END of the sequence `self'.  \nResize the array if necessary.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.VectorSequence", "insert", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD INSERT ((SELF CUSTOM-VECTOR-SEQUENCE) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Append `value' to the END of the sequence `self'.  \nResize the array if necessary.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.CustomVectorSequence", "insert", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (REMOVE VECTOR-SEQUENCE) ((SELF VECTOR-SEQUENCE) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Remove `value' from the sequence `self', and left shift\nthe values after it to close the gap.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.VectorSequence", "remove", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (REVERSE (LIKE SELF)) ((SELF VECTOR-SEQUENCE)) :DOCUMENTATION \"Reverse the order of elements in the active portion of `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.VectorSequence", "reverse", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("COPY-VECTOR-SEQUENCE", "(DEFUN COPY-VECTOR-SEQUENCE ((SOURCE VECTOR-SEQUENCE) (COPY VECTOR-SEQUENCE)))", Native.find_java_method("edu.isi.stella.VectorSequence", "copyVectorSequence", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.VectorSequence"), Native.find_java_class("edu.isi.stella.VectorSequence")}), null);
      Stella.defineMethodObject("(DEFMETHOD (COPY (VECTOR-SEQUENCE OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR-SEQUENCE)) :DOCUMENTATION \"Return a copy of the vector sequence `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.VectorSequence", "copy", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (COPY (CUSTOM-VECTOR-SEQUENCE OF (LIKE (ANY-VALUE SELF)))) ((SELF CUSTOM-VECTOR-SEQUENCE)) :DOCUMENTATION \"Return a copy of the vector sequence `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.CustomVectorSequence", "copy", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD CLEAR ((SELF VECTOR-SEQUENCE)) :DOCUMENTATION \"Clear `self' by setting its active length to zero.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.VectorSequence", "clear", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X VECTOR-SEQUENCE) (Y OBJECT)) :DOCUMENTATION \"Return TRUE iff the sequences `x' and `y' are structurally\nequivalent.  Uses `equal?' to test equality of elements.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.VectorSequence", "objectEqualP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
    }
  }

  static void helpStartupCollections4() {
    {
      Stella.defineMethodObject("(DEFMETHOD (ALLOCATE-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR)))", Native.find_java_method("edu.isi.stella.Vector", "allocateIterator", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("VECTOR-NEXT?", "(DEFUN (VECTOR-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)))", Native.find_java_method("edu.isi.stella.AllPurposeIterator", "vectorNextP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.AllPurposeIterator")}), null);
      Stella.defineMethodObject("(DEFMETHOD (BUT-LAST (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR)) :DOCUMENTATION \"Generate all but the last element of the vector `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Vector", "butLast", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (SORT (VECTOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR) (PREDICATE FUNCTION-CODE)) :PUBLIC? TRUE :DOCUMENTATION \"Perform a destructive sort of `self' according to\n`predicate', and return the result.  If `predicate' has a '<' semantics, the\nresult will be in ascending order.  If `predicate' is `null', a\nsuitable '<' predicate is chosen depending on the first element of `self',\nand it is assumed that all elements of `self' have the same type (supported\nelement types are GENERALIZED-SYMBOL, STRING, INTEGER, and FLOAT).\")", Native.find_java_method("edu.isi.stella.Vector", "sort", new java.lang.Class [] {Native.find_java_class("java.lang.reflect.Method")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (SORT-TUPLES (VECTOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR) (N INTEGER) (PREDICATE FUNCTION-CODE)) :PUBLIC? TRUE :DOCUMENTATION \"Just like `sort' but assumes each element of `self' is a tuple (a cons)\nwhose `n'-th element (0-based) will be used for comparison.\")", Native.find_java_method("edu.isi.stella.Vector", "sortTuples", new java.lang.Class [] {java.lang.Integer.TYPE, Native.find_java_class("java.lang.reflect.Method")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (SORT-OBJECTS (VECTOR OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR) (SLOT STORAGE-SLOT) (PREDICATE FUNCTION-CODE)) :DOCUMENTATION \"Just like `sort' but assumes each element of `self' has a `slot'\nwhose value will be used for comparison.  Elements must be descendants of\nSTANDARD OBJECT.  Note that while this will work with literal-valued slots,\nit will cause value wrapping everytime `slot' is read.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Vector", "sortObjects", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.StorageSlot"), Native.find_java_class("java.lang.reflect.Method")}), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("HEAP-SORT-NATIVE-VECTOR", "(DEFUN HEAP-SORT-NATIVE-VECTOR ((VECTOR NATIVE-VECTOR) (SIZE INTEGER) (PREDICATE FUNCTION-CODE)))", Native.find_java_method("edu.isi.stella.Stella", "heapSortNativeVector", new java.lang.Class [] {Native.find_java_class("[Ledu.isi.stella.Stella_Object;"), java.lang.Integer.TYPE, Native.find_java_class("java.lang.reflect.Method")}), null);
      Stella.defineFunctionObject("HEAP-SORT-HEAPIFY", "(DEFUN HEAP-SORT-HEAPIFY ((VECTOR NATIVE-VECTOR) (SIZE INTEGER) (PREDICATE FUNCTION-CODE)))", Native.find_java_method("edu.isi.stella.Stella", "heapSortHeapify", new java.lang.Class [] {Native.find_java_class("[Ledu.isi.stella.Stella_Object;"), java.lang.Integer.TYPE, Native.find_java_class("java.lang.reflect.Method")}), null);
      Stella.defineFunctionObject("HEAP-SORT-SIFT-DOWN", "(DEFUN HEAP-SORT-SIFT-DOWN ((VECTOR NATIVE-VECTOR) (START INTEGER) (END INTEGER) (PREDICATE FUNCTION-CODE)))", Native.find_java_method("edu.isi.stella.Stella", "heapSortSiftDown", new java.lang.Class [] {Native.find_java_class("[Ledu.isi.stella.Stella_Object;"), java.lang.Integer.TYPE, java.lang.Integer.TYPE, Native.find_java_class("java.lang.reflect.Method")}), null);
      Stella.defineFunctionObject("QUICK-SORT-PICK-SPLIT-ELEMENT", "(DEFUN (QUICK-SORT-PICK-SPLIT-ELEMENT OBJECT) ((VECTOR NATIVE-VECTOR) (START INTEGER) (END INTEGER) (PREDICATE FUNCTION-CODE)))", Native.find_java_method("edu.isi.stella.Stella", "quickSortPickSplitElement", new java.lang.Class [] {Native.find_java_class("[Ledu.isi.stella.Stella_Object;"), java.lang.Integer.TYPE, java.lang.Integer.TYPE, Native.find_java_class("java.lang.reflect.Method")}), null);
      Stella.defineFunctionObject("QUICK-SORT-NATIVE-VECTOR", "(DEFUN QUICK-SORT-NATIVE-VECTOR ((VECTOR NATIVE-VECTOR) (START INTEGER) (END INTEGER) (PREDICATE FUNCTION-CODE)))", Native.find_java_method("edu.isi.stella.Stella", "quickSortNativeVector", new java.lang.Class [] {Native.find_java_class("[Ledu.isi.stella.Stella_Object;"), java.lang.Integer.TYPE, java.lang.Integer.TYPE, Native.find_java_class("java.lang.reflect.Method")}), null);
      Stella.defineMethodObject("(DEFMETHOD INITIALIZE-HEAP ((SELF HEAP)))", Native.find_java_method("edu.isi.stella.Heap", "initializeHeap", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (COPY (HEAP OF (LIKE (ANY-VALUE SELF)))) ((SELF HEAP)) :DOCUMENTATION \"Return a copy of the heap `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Heap", "copy", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD CLEAR ((SELF HEAP)) :DOCUMENTATION \"Clear `self' by setting its active length to zero.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Heap", "clear", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (LENGTH INTEGER) ((SELF HEAP)) :DOCUMENTATION \"Return the length of the currently filled portion of `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Heap", "length", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (EMPTY? BOOLEAN) ((SELF HEAP)) :DOCUMENTATION \"Return TRUE if `self' is empty.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Heap", "emptyP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ((SELF HEAP)) :DOCUMENTATION \"Return the last item in the heap `self' which will be the\nlargest or best item if `self' is a sorted min-heap with a '<' predicate.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Heap", "last", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (HEAP-ROOT (LIKE (ANY-VALUE SELF))) ((SELF HEAP)) :DOCUMENTATION \"Return the root of `self' (NULL if `self' is empty).\nThe root contains the minimum element of a min-heap with '<' predicate.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Heap", "heapRoot", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (FAST-HEAP-ROOT (LIKE (ANY-VALUE SELF))) ((SELF HEAP)) :DOCUMENTATION \"Return the root of `self' which is assumed to be non-empty.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NTH SELF 0)))", Native.find_java_method("edu.isi.stella.Heap", "fastHeapRoot", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("HEAP-SIFT-UP", "(DEFUN HEAP-SIFT-UP ((HEAP NATIVE-VECTOR) (START INTEGER) (END INTEGER) (VALUE (LIKE (ANY-VALUE SELF))) (PREDICATE FUNCTION-CODE)))", Native.find_java_method("edu.isi.stella.Stella", "heapSiftUp", new java.lang.Class [] {Native.find_java_class("[Ledu.isi.stella.Stella_Object;"), java.lang.Integer.TYPE, java.lang.Integer.TYPE, Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("java.lang.reflect.Method")}), null);
      Stella.defineFunctionObject("HEAP-SIFT-DOWN", "(DEFUN HEAP-SIFT-DOWN ((HEAP NATIVE-VECTOR) (START INTEGER) (END INTEGER) (VALUE (LIKE (ANY-VALUE SELF))) (PREDICATE FUNCTION-CODE)))", Native.find_java_method("edu.isi.stella.Stella", "heapSiftDown", new java.lang.Class [] {Native.find_java_class("[Ledu.isi.stella.Stella_Object;"), java.lang.Integer.TYPE, java.lang.Integer.TYPE, Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("java.lang.reflect.Method")}), null);
      Stella.defineMethodObject("(DEFMETHOD INSERT ((SELF HEAP) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Insert `value' into `self' and restore the heap property.\nSignal an error if there is no more room in `self'.  Maintains `self' as\na Min-heap if `self's `predicate' has `<' semantics; otherwise as a Max-heap.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Heap", "insert", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD REPLACE-HEAP-ROOT ((SELF HEAP) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Replace the current root of `self' with `value' and restore\nthe heap property.  Signal an error if `self' is empty.  Maintains `self' as\na Min-heap if `self's `predicate' has `<' semantics; otherwise as a Max-heap.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Heap", "replaceHeapRoot", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD INSERT-IF-BETTER ((SELF HEAP) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Insert `value' into `self' and restore the heap property.\nIf `self' has available room, simply insert `value'.  If the heap is full, only\ninsert `value' if it is better than the current root (i.e., if `value' is\ngreater than the minimum of `self' for the case of a min-heap where `self's\n`predicate' has `<' semantics).  In that case, replace the root of `self'\nand restore the heap property.  This is useful to build and maintain a\nheap with some top-N elements (relative to `predicate') where the root (or\nminimum) of `self' is the currently weakest element at the end of the list.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Heap", "insertIfBetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD HEAPIFY ((SELF HEAP)) :DOCUMENTATION \"Restore the heap property of `self' according to its\n`predicate'.  Normally, this is not needed, since insert operations\npreserve the heap property.  However, this can be useful after bulk\ninsertion of values or if `predicate' has been changed.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Heap", "heapify", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (SORT (HEAP OF (LIKE (ANY-VALUE SELF)))) ((SELF HEAP) (PREDICATE FUNCTION-CODE)) :DOCUMENTATION \"Sort the heap `self' according to `predicate' (in\nascending order if `predicate' has `<' semantics).  If `predicate'\nis NULL simply use `self's internal predicate (the normal case).\nIf it is different from `self's internal predicate, heapify `self' first\naccording to the new predicate, store the new predicate in `self' and\nthen sort the heap.  Note that a sorted array automatically satisfies\nthe heap property.  This is slightly different than a regular heap\nsort due to the way HEAP's are maintained; however, the complexity is\nthe same.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Heap", "sort", new java.lang.Class [] {Native.find_java_class("java.lang.reflect.Method")}), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("INITIALIZE-STELLA-HASH-TABLE", "(DEFUN INITIALIZE-STELLA-HASH-TABLE ((SELF STELLA-HASH-TABLE)))", Native.find_java_method("edu.isi.stella.StellaHashTable", "initializeStellaHashTable", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.StellaHashTable")}), null);
      Stella.defineMethodObject("(DEFMETHOD INITIALIZE-HASH-TABLE ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Initialize the STELLA hash table `self'.  This is a\nno-op and primarily exists to shadow the standard initializer inherited\nfrom ABSTRACT-HASH-TABLE.  STELLA hash tables are initialized at the\nfirst insertion operation.\")", Native.find_java_method("edu.isi.stella.StellaHashTable", "initializeHashTable", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("REHASH-STELLA-HASH-TABLE", "(DEFUN REHASH-STELLA-HASH-TABLE ((SELF STELLA-HASH-TABLE) (NEWSIZE INTEGER)))", Native.find_java_method("edu.isi.stella.StellaHashTable", "rehashStellaHashTable", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.StellaHashTable"), java.lang.Integer.TYPE}), null);
      Stella.defineFunctionObject("STELLA-HASH-TABLE-INSERT-AT", "(DEFUN STELLA-HASH-TABLE-INSERT-AT ((SELF STELLA-HASH-TABLE) (KEY OBJECT) (VALUE OBJECT)))", Native.find_java_method("edu.isi.stella.StellaHashTable", "stellaHashTableInsertAt", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.StellaHashTable"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("STELLA-HASH-TABLE-REMOVE-AT", "(DEFUN STELLA-HASH-TABLE-REMOVE-AT ((SELF STELLA-HASH-TABLE) (KEY OBJECT)))", Native.find_java_method("edu.isi.stella.StellaHashTable", "stellaHashTableRemoveAt", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.StellaHashTable"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("STELLA-HASH-TABLE-LOOKUP", "(DEFUN (STELLA-HASH-TABLE-LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF STELLA-HASH-TABLE) (KEY OBJECT)))", Native.find_java_method("edu.isi.stella.StellaHashTable", "stellaHashTableLookup", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.StellaHashTable"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineFunctionObject("STELLA-STRING-HASH-TABLE-LOOKUP", "(DEFUN (STELLA-STRING-HASH-TABLE-LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF STELLA-HASH-TABLE) (KEY STRING)))", Native.find_java_method("edu.isi.stella.StellaHashTable", "stellaStringHashTableLookup", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.StellaHashTable"), Native.find_java_class("java.lang.String")}), null);
      Stella.defineMethodObject("(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF STELLA-HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))) :DOCUMENTATION \"Lookup the entry identified by `key' in `self' and\nreturn its value, or NULL if no such entry exists.    Uses an `eql?'\ntest by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.StellaHashTable", "lookup", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD INSERT-AT ((SELF STELLA-HASH-TABLE) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Set the value of the entry identified by `key' in `self'\nto `value' or add a new entry if no entry with `key' exists yet.  Uses an\n`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.StellaHashTable", "insertAt", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD REMOVE-AT ((SELF STELLA-HASH-TABLE) (KEY (LIKE (ANY-KEY SELF)))) :DOCUMENTATION \"Remove the entry identified by `key' from `self'.  Uses an\n`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.StellaHashTable", "removeAt", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (LENGTH INTEGER) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Return the number of entries in `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.StellaHashTable", "length", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (EMPTY? BOOLEAN) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Return TRUE if `self' has zero entries.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.StellaHashTable", "emptyP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Return TRUE if `self' has at least 1 entry.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.StellaHashTable", "nonEmptyP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (COPY (LIKE SELF)) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Return a copy of the hash table `self'.  The bucket table\nand buckets are freshly allocated, however, the keys and values of entries\nare not copied themselves (similar to what we do for lists, etc.).\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.StellaHashTable", "copy", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD CLEAR ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Remove all entries from `self'.  This will result in a\nre-initialization of the table upon the first insertion into `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.StellaHashTable", "clear", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (CONSIFY (CONS OF CONS)) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Collect all entries of `self' into a cons list of\n`(<key> <value>)' pairs and return the result.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.StellaHashTable", "consify", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X STELLA-HASH-TABLE) (Y OBJECT)) :DOCUMENTATION \"Return TRUE if `x' and `y' represent the same set of key/value pairs.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.StellaHashTable", "objectEqualP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (EQUAL-HASH-CODE INTEGER) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Return an `equal?' hash code for `self'.  Note that this\nis O(N) in the number of entries of `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.StellaHashTable", "equalHashCode", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (ALLOCATE-ITERATOR (STELLA-HASH-TABLE-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))) ((SELF STELLA-HASH-TABLE)) :DOCUMENTATION \"Allocate an iterator for `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.StellaHashTable", "allocateIterator", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (NEXT? BOOLEAN) ((SELF STELLA-HASH-TABLE-ITERATOR)))", Native.find_java_method("edu.isi.stella.StellaHashTableIterator", "nextP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (VALUE-SETTER (LIKE (ANY-VALUE SELF))) ((SELF STELLA-HASH-TABLE-ITERATOR) (VALUE (LIKE (ANY-VALUE SELF)))))", Native.find_java_method("edu.isi.stella.StellaHashTableIterator", "valueSetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (KEY-SETTER (LIKE (ANY-KEY SELF))) ((SELF STELLA-HASH-TABLE-ITERATOR) (KEY (LIKE (ANY-KEY SELF)))))", Native.find_java_method("edu.isi.stella.StellaHashTableIterator", "keySetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (LOOKUP (LIKE (ANY-VALUE SELF))) ((SELF KEY-VALUE-MAP) (KEY (LIKE (ANY-KEY SELF)))) :DOCUMENTATION \"Lookup the entry identified by `key' in `self' and\nreturn its value, or NULL if no such entry exists.    Uses an `eql?'\ntest by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.KeyValueMap", "lookup", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD INSERT-AT ((SELF KEY-VALUE-MAP) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Set the value of the entry identified by `key' in `self'\nto `value' or add a new entry if no entry with `key' exists yet.  Uses an\n`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.KeyValueMap", "insertAt", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD REMOVE-AT ((SELF KEY-VALUE-MAP) (KEY (LIKE (ANY-KEY SELF)))) :DOCUMENTATION \"Remove the entry identified by `key' from `self'.  Uses an\n`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.KeyValueMap", "removeAt", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (LENGTH INTEGER) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Return the number of entries in `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.KeyValueMap", "length", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (EMPTY? BOOLEAN) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Return TRUE if `self' has zero entries.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.KeyValueMap", "emptyP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Return TRUE if `self' has at least 1 entry.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.KeyValueMap", "nonEmptyP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (COPY (LIKE SELF)) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Return a copy of the map `self'.  All entries are freshly\nallocated, however, the keys and values of entries are not copied themselves\n (similar to what we do for lists, etc.).\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.KeyValueMap", "copy", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD CLEAR ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Reset `self' to have zero entries.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.KeyValueMap", "clear", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (ALLOCATE-ITERATOR (DICTIONARY-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Allocate an iterator for `self'.  The only modifying\noperations allowed during iteration are removal of the current element or\nchanging its value.  All other removal or insertion operations might lead\nto corruption or undefined results.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.KeyValueMap", "allocateIterator", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (CONSIFY CONS) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Collect all entries of `self' into a cons list of\n`(<key> <value>)' pairs and return the result.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.KeyValueMap", "consify", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X KEY-VALUE-MAP) (Y OBJECT)) :DOCUMENTATION \"Return TRUE if `x' and `y' represent the same set of key/value pairs.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.KeyValueMap", "objectEqualP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (EQUAL-HASH-CODE INTEGER) ((SELF KEY-VALUE-MAP)) :DOCUMENTATION \"Return an `equal?' hash code for `self'.  Note that this\nis O(N) in the number of entries of `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.KeyValueMap", "equalHashCode", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
    }
  }

  public static void startupCollections() {
    { Object old$Module$000 = Stella.$MODULE$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setSpecial(Stella.$MODULE$, Stella.$STELLA_MODULE$);
        Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
        if (Stella.currentStartupTimePhaseP(2)) {
          _StartupCollections.helpStartupCollections1();
        }
        if (Stella.currentStartupTimePhaseP(4)) {
          Stella.$KEY_VALUE_MAP_CROSSOVER_POINT$ = Stella.$REMOVE_DUPLICATES_CROSSOVER_POINT$;
        }
        if (Stella.currentStartupTimePhaseP(5)) {
          _StartupCollections.helpStartupCollections2();
        }
        if (Stella.currentStartupTimePhaseP(6)) {
          Stella.finalizeClasses();
        }
        if (Stella.currentStartupTimePhaseP(7)) {
          _StartupCollections.helpStartupCollections3();
          _StartupCollections.helpStartupCollections4();
          Stella.defineFunctionObject("HASH-SET", "(DEFUN (HASH-SET HASH-SET) (|&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return an `eql?' HASH-SET containing `values'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella", "hashSet", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), null);
          Stella.defineFunctionObject("COERCE-TO-HASH-SET", "(DEFUN (COERCE-TO-HASH-SET HASH-SET) ((SELF OBJECT) (EQUALTEST? BOOLEAN)) :DOCUMENTATION \"Coerce the collection `self' into a HASH-SET.  Use an\nequal test if `equalTest?' is TRUE (`equalTest?' will be ignored if `self'\nalready is a HASH-SET).\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "coerceToHashSet", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Boolean.TYPE}), null);
          Stella.defineMethodObject("(DEFMETHOD (MEMBER? BOOLEAN) ((SELF HASH-SET) (OBJECT OBJECT)) :DOCUMENTATION \"Return TRUE iff `object' is a member of the set `self'.\nUses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.HashSet", "memberP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD INSERT ((SELF HASH-SET) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Add `value' to the set `self' unless it is already a member.\nUses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.HashSet", "insert", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (REMOVE (LIKE SELF)) ((SELF HASH-SET) (VALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Destructively remove `value' from the set `self' if it is a member and\nreturn `self'.  Uses an `eql?' test by default or `equal?' if `equal-test?' of\n`self' is TRUE.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.HashSet", "remove", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (REMOVE-IF (LIKE SELF)) ((SELF HASH-SET) (TEST? FUNCTION-CODE)) :DOCUMENTATION \"Destructively remove all elements of the set `self' for which\n'test?' evaluates to TRUE.  `test?' takes a single argument of type OBJECT and\nreturns TRUE or FALSE.  Returns `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.HashSet", "removeIf", new java.lang.Class [] {Native.find_java_class("java.lang.reflect.Method")}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (POP (LIKE (ANY-VALUE SELF))) ((SELF HASH-SET)) :DOCUMENTATION \"Remove and return an arbitrary element of the set `self'.\nReturn NULL if the set is empty.  Performance note: for large sets implemented\nvia hash tables it takes O(N) to empty out the set with repeated calls to `pop',\nsince the emptier the table gets, the longer it takes to find an element.\nTherefore, it is usually better to use iteration with embedded removals for\nsuch cases.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.HashSet", "pop", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (SUBSTITUTE (LIKE SELF)) ((SELF HASH-SET) (NEW OBJECT) (OLD OBJECT)) :DOCUMENTATION \"Destructively replace `old' with `new' in the set `self'\nunless `new' is already a member.  Uses an `eql?' test by default or `equal?'\nif `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.HashSet", "substitute", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (COPY (LIKE SELF)) ((SELF HASH-SET)) :DOCUMENTATION \"Return a copy of the set `self'.  All entries are freshly\nallocated, however, the values are not copied themselves (similar to what we\ndo for lists, etc.).\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.HashSet", "copy", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (CONSIFY (CONS OF (LIKE (ANY-VALUE SELF)))) ((SELF HASH-SET)) :DOCUMENTATION \"Collect all entries of `self' into a cons list and return the result.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.HashSet", "consify", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (SUBSET? BOOLEAN) ((SELF HASH-SET) (OTHERSET HASH-SET)) :DOCUMENTATION \"Return true if every element of `self' also occurs in `otherSet'.\nUses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.HashSet", "subsetP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.HashSet")}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (EQUIVALENT-SETS? BOOLEAN) ((SELF HASH-SET) (OTHERSET HASH-SET)) :DOCUMENTATION \"Return true if every element of `self' occurs in `otherSet' and vice versa.\nUses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.HashSet", "equivalentSetsP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.HashSet")}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (INTERSECTION HASH-SET) ((SELF HASH-SET) (OTHERSET HASH-SET)) :DOCUMENTATION \"Return the set intersection of `self' and `otherSet' as a new set.\nUses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.HashSet", "intersection", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.HashSet")}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (UNION HASH-SET) ((SELF HASH-SET) (OTHERSET HASH-SET)) :DOCUMENTATION \"Return the set union of `self' and `otherSet' as a new set.\nUses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.HashSet", "union", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.HashSet")}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (DIFFERENCE HASH-SET) ((SELF HASH-SET) (OTHERSET HASH-SET)) :DOCUMENTATION \"Return the set difference of `self' and `otherSet' as a new set (i.e.,\nall elements that are in `self' but not in `otherSet').  Uses an `eql?' test\nby default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.HashSet", "difference", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.HashSet")}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (SUBTRACT HASH-SET) ((SELF HASH-SET) (OTHERSET HASH-SET)) :DOCUMENTATION \"Return the set difference of `self' and `otherSet' by destructively\nremoving elements from `self' that also occur in `otherSet'.  Uses an `eql?'\ntest by default or `equal?' if `equal-test?' of `self' is TRUE.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.HashSet", "subtract", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.HashSet")}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((X HASH-SET) (Y OBJECT)) :DOCUMENTATION \"Return TRUE iff sets `x' and `y' are HASH-SET's with equivalent members.\nUses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.\nThis is equivalent to calling `equivalent-sets?'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.HashSet", "objectEqualP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (EQUAL-HASH-CODE INTEGER) ((SELF HASH-SET)) :DOCUMENTATION \"Return an `equal?' hash code for `self'.  Note that this\nis O(N) in the number of elements of `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.HashSet", "equalHashCode", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD INITIALIZE-DIMENSIONAL-ARRAY ((SELF DIMENSIONAL-ARRAY-MIXIN)) (SETF (THE-ARRAY SELF) (NEW (ARRAY () OF (LIKE (ANY-VALUE SELF))) :SIZE (LENGTH SELF))))", ((java.lang.reflect.Method)(null)), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (LENGTH INTEGER) ((SELF DIMENSIONAL-ARRAY-MIXIN)) :DOCUMENTATION \"Return the total number of elements in `self'.\" :PUBLIC? TRUE (RETURN (DIM1 SELF)))", ((java.lang.reflect.Method)(null)), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD INITIALIZE-ARRAY ((SELF DIMENSIONAL-ARRAY-MIXIN) (INITIALVALUE (LIKE (ANY-VALUE SELF)))) :DOCUMENTATION \"Initialize the elements of `self' with `initialValue'.\" :PUBLIC? TRUE (LET ((ARRAY (THE-ARRAY SELF))) (FOREACH I IN (INTERVAL 0 (1- (LENGTH SELF))) DO (SETF (AREF ARRAY I) INITIALVALUE))))", ((java.lang.reflect.Method)(null)), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (1D-AREF (LIKE (ANY-VALUE SELF))) ((SELF DIMENSIONAL-ARRAY-MIXIN) (I INTEGER)) :DOCUMENTATION \"Return the element of `self' at position `[i]'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (AREF (THE-ARRAY SELF) I)))", ((java.lang.reflect.Method)(null)), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (1D-AREF-SETTER (LIKE (ANY-VALUE SELF))) ((SELF DIMENSIONAL-ARRAY-MIXIN) (VALUE (LIKE (ANY-VALUE SELF))) (I INTEGER)) :DOCUMENTATION \"Set the element of `self' at position `[i]' to `value'\nand return the result.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (AREF (THE-ARRAY SELF) I) VALUE)))", ((java.lang.reflect.Method)(null)), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (1D-AREF-ADDRESS INTEGER) ((SELF DIMENSIONAL-ARRAY-MIXIN) (I INTEGER)) :DOCUMENTATION \"Return the 1D address of the element at position `[i]'.\nThis is useful for fast element-wise iteration that doesn't need arithmetic.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN I))", ((java.lang.reflect.Method)(null)), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (LENGTH INTEGER) ((SELF 2-DIMENSIONAL-ARRAY-MIXIN)) :DOCUMENTATION \"Return the total number of elements in `self'.\" :PUBLIC? TRUE (RETURN (* (DIM1 SELF) (DIM2 SELF))))", ((java.lang.reflect.Method)(null)), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (2D-AREF (LIKE (ANY-VALUE SELF))) ((SELF 2-DIMENSIONAL-ARRAY-MIXIN) (I INTEGER) (J INTEGER)) :DOCUMENTATION \"Return the element of `self' at position `[i, j]'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (AREF (THE-ARRAY SELF) (+ (* I (DIM2 SELF)) J))))", ((java.lang.reflect.Method)(null)), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (2D-AREF-SETTER (LIKE (ANY-VALUE SELF))) ((SELF 2-DIMENSIONAL-ARRAY-MIXIN) (VALUE (LIKE (ANY-VALUE SELF))) (I INTEGER) (J INTEGER)) :DOCUMENTATION \"Set the element of `self' at position `[i, j]' to `value'\nand return the result.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (SETF (AREF (THE-ARRAY SELF) (+ (* I (DIM2 SELF)) J)) VALUE)))", ((java.lang.reflect.Method)(null)), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (2D-AREF-ADDRESS INTEGER) ((SELF 2-DIMENSIONAL-ARRAY-MIXIN) (I INTEGER) (J INTEGER)) :DOCUMENTATION \"Return the 1D address of the element at position `[i, j]'.\nThis is useful for fast element-wise iteration that doesn't need arithmetic.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (+ (* I (DIM2 SELF)) J)))", ((java.lang.reflect.Method)(null)), ((java.lang.reflect.Method)(null)));
          Stella.defineFunctionObject("STARTUP-COLLECTIONS", "(DEFUN STARTUP-COLLECTIONS () :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella._StartupCollections", "startupCollections", new java.lang.Class [] {}), null);
          { MethodSlot function = Symbol.lookupFunction(Stella.SYM_STELLA_STARTUP_COLLECTIONS);

            KeyValueList.setDynamicSlotValue(function.dynamicSlots, Stella.SYM_STELLA_METHOD_STARTUP_CLASSNAME, StringWrapper.wrapString("_StartupCollections"), Stella.NULL_STRING_WRAPPER);
          }
        }
        if (Stella.currentStartupTimePhaseP(8)) {
          Stella.finalizeSlots();
          Stella.cleanupUnfinalizedClasses();
        }
        if (Stella.currentStartupTimePhaseP(9)) {
          Stella_Object.inModule(((StringWrapper)(Stella_Object.copyConsTree(StringWrapper.wrapString("/STELLA")))));
          Symbol.registerNativeName(Stella.SYM_STELLA_VECTOR, Stella.KWD_CPP, Stella.KWD_FUNCTION);
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFGLOBAL *USE-STELLA-HASH-TABLES?* BOOLEAN (VERBATIM :COMMON-LISP \"CL-USER::*use-stella-hash-tables?*\" :CPP \"\n#ifndef HAVE_SGI_HASH_MAPS\n  TRUE\n#else\n  FALSE\n#endif\n\" :OTHERWISE FALSE))");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFGLOBAL *STELLA-HASH-TABLE-AVG-BUCKET-LENGTH* FLOAT 1.0)");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFGLOBAL *KEY-VALUE-MAP-CROSSOVER-POINT* INTEGER *REMOVE-DUPLICATES-CROSSOVER-POINT* :DOCUMENTATION \"Point where we switch from using a KV-CONS table\nrepresentation to a STELLA hash table to preserve O(1) access.\")");
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Stella.$MODULE$.set(old$Module$000);
      }
    }
  }

}
