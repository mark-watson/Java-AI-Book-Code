//  -*- Mode: Java -*-
//
// _StartupConses.java

/*
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2017      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
*/

package edu.isi.stella;

import edu.isi.stella.javalib.*;

public class _StartupConses {
  static void helpStartupConses1() {
    {
      Stella.$SORT_TUPLE_COMPARE_PREDICATE$.setDefaultValue(null);
      Stella.$SORT_TUPLE_COMPARE_INDEX$.setDefaultValue(new Integer(0));
      Stella.$SORT_OBJECTS_COMPARE_SLOT$.setDefaultValue(null);
      Stella.$PRINTPRETTYp$.setDefaultValue(new Boolean(true));
      Stella.$PRINTREADABLYp$.setDefaultValue(new Boolean(false));
      Stella.$PRINTLENGTH$.setDefaultValue(new Integer(Stella.NULL_INTEGER));
      Stella.ELIPSIS = Stella.SYM_STELLA_ddd;
      Stella.$PRINTPRETTYCODEp$.setDefaultValue(new Boolean(true));
      Stella.$DEPTHEXCEEDEDp$.setDefaultValue(new Boolean(false));
    }
  }

  static void helpStartupConses2() {
    {
      Stella.defineMethodObject("(DEFMETHOD (EMPTY? BOOLEAN) ((SELF CONS)) :DOCUMENTATION \"Return `true' iff `self' equals `nil'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (EQ? SELF NIL)))", Native.find_java_method("edu.isi.stella.Cons", "emptyP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF CONS)) :DOCUMENTATION \"Return `true' iff `self' is not equal to `nil'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NOT (EQ? SELF NIL))))", Native.find_java_method("edu.isi.stella.Cons", "nonEmptyP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("NIL?", "(DEFUN (NIL? BOOLEAN) ((X OBJECT)) :DOCUMENTATION \"Return `true' iff `x' equals `nil'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (EQ? X NIL)))", Native.find_java_method("edu.isi.stella.Stella_Object", "nilP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
      Stella.defineMethodObject("(DEFMETHOD (LENGTH INTEGER) ((SELF CONS)) :DOCUMENTATION \"Return the length of the CONS list `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "length", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (POSITION INTEGER) ((SELF CONS) (OBJECT OBJECT) (START INTEGER)) :DOCUMENTATION \"Return the position of `object' within the cons-list\n`self' (counting from zero); or return `null' if `object' does not occur within \n`self' (uses an `eql?' test).  If `start' was supplied as non-`null', only \nconsider the sublist starting at `start', however, the returned position \nwill always be relative to the entire list.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "position", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Integer.TYPE}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (LAST-POSITION INTEGER) ((SELF CONS) (OBJECT OBJECT) (END INTEGER)) :DOCUMENTATION \"Return the position of `object' within the cons-list\n`self' (counting from zero); or return `null' if `object' does not occur within \n`self' (uses an `eql?' test).  If `start' was supplied as non-`null', only \nconsider the sublist ending at `end', however, the returned position \nwill always be relative to the entire list.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "lastPosition", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Integer.TYPE}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (MEMBER? BOOLEAN) ((SELF CONS) (OBJECT OBJECT)) :DOCUMENTATION \"Return `true' iff `object' is a member of the cons list\n`self' (uses an `eql?' test).\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "memberP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (MEMB? BOOLEAN) ((SELF CONS) (OBJECT OBJECT)) :DOCUMENTATION \"Return `true' iff `object' is a member of the cons list\n`self' (uses an `eq?' test).\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "membP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("CONS", "(DEFUN (CONS CONS) ((VALUE OBJECT) (REST CONS)) :DOCUMENTATION \"Return a cons record that points to `value' and `rest'.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "cons", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineMethodObject("(DEFMETHOD (REMOVE (LIKE SELF)) ((SELF CONS) (VALUE OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Destructively remove all entries in the cons list `self' that\nmatch `value'.  Unless the remaining list is `nil', insure that the cons that\nheads the list is unchanged.\")", Native.find_java_method("edu.isi.stella.Cons", "remove", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (REMOVE-IF (LIKE SELF)) ((SELF CONS) (TEST? FUNCTION-CODE)) :PUBLIC? TRUE :DOCUMENTATION \"Destructively removes all members of the cons list\n`self' for which `test?' evaluates to `true'.  `test' takes a single \nargument of type OBJECT and returns `true' or `false'.  Returns a cons list.\nIn case the first element is removed, the return result should be\nassigned to a variable.\")", Native.find_java_method("edu.isi.stella.Cons", "removeIf", new java.lang.Class [] {Native.find_java_class("java.lang.reflect.Method")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (REMOVE-DUPLICATES (LIKE SELF)) ((SELF CONS)) :PUBLIC? TRUE :DOCUMENTATION \"Destructively remove duplicates from `self' and return the\nresult.  Removes all but the first occurrence of items in the list.\nPreserves the original order of the remaining members.  Runs in linear time.\")", Native.find_java_method("edu.isi.stella.Cons", "removeDuplicates", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (REMOVE-DUPLICATES-EQUAL (LIKE SELF)) ((SELF CONS)) :DOCUMENTATION \"`remove-duplicates' (which see) using an `equal?' test.\nIMPORTANT: since this uses hashing to speed things up, an `equal-hash-code'\nmethod needs to be defined for this to work.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "removeDuplicatesEqual", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("REMOVE-DUPLICATES-FROM-LONG-LIST", "(DEFUN (REMOVE-DUPLICATES-FROM-LONG-LIST (LIKE SELF)) ((SELF CONS) (EQUALTEST? BOOLEAN)))", Native.find_java_method("edu.isi.stella.Cons", "removeDuplicatesFromLongList", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons"), java.lang.Boolean.TYPE}), null);
      Stella.defineMethodObject("(DEFMETHOD (CONCATENATE CONS) ((LIST1 CONS) (LIST2 CONS) |&REST| (OTHERLISTS CONS)) :PUBLIC? TRUE :DOCUMENTATION \"Return a cons list consisting of the concatenation of \n`list1', `list2', and `otherLists'.  The operation is destructive wrt all\nbut the last list argument which is left intact.  The two mandatory\nparameters allow us to optimize the common binary case by not relying on\nthe somewhat less efficient variable arguments mechanism.\")", Native.find_java_method("edu.isi.stella.Cons", "concatenate", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons"), Native.find_java_class("edu.isi.stella.Cons")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (PREPEND CONS) ((SELF CONS) (LIST1 CONS)) :DOCUMENTATION \"Return a cons list consisting of the concatenation of\n`list1' and `self'.  A copy of `list1' is prepended to `self'.  This\noperation results in structure sharing of `self'; to avoid this, `self'\nshould not be pointed to by anything other than the tail of the prepended\ncopy.\")", Native.find_java_method("edu.isi.stella.Cons", "prepend", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (REVERSE (LIKE SELF)) ((SELF CONS)) :DOCUMENTATION \"Destructively reverse the members of the cons list `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "reverse", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (SUBSTITUTE CONS) ((SELF CONS) (INVALUE OBJECT) (OUTVALUE OBJECT)) :DOCUMENTATION \"Destructively replace each appearance of `outValue' by\n`inValue' in the cons list `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "substitute", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("MAP-NULL-TO-NIL", "(DEFUN (MAP-NULL-TO-NIL (LIKE SELF)) ((SELF CONS)) :DOCUMENTATION \"Return `nil' iff `self' is `null' or `self' otherwise.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (CHOOSE (NULL? SELF) NIL SELF)))", Native.find_java_method("edu.isi.stella.Cons", "mapNullToNil", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineMethodObject("(DEFMETHOD (FIRST (LIKE (ANY-VALUE SELF))) ((SELF CONS)) :DOCUMENTATION \"Return the first element of `self'.  The first element\nof `self' can be set with `setf'.  Note that '(first NIL)' = `null'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VALUE SELF)))", Native.find_java_method("edu.isi.stella.Cons", "first", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (SECOND (LIKE (ANY-VALUE SELF))) ((SELF CONS)) :DOCUMENTATION \"Return the second element of `self'.  The second element\nof `self' can be set with `setf'.  Note that '(second NIL)' = `null'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VALUE (REST SELF))))", Native.find_java_method("edu.isi.stella.Cons", "second", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (THIRD (LIKE (ANY-VALUE SELF))) ((SELF CONS)) :DOCUMENTATION \"Return the third element of `self'.  The third element\nof `self' can be set with `setf'.  Note that '(third NIL)' = `null'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VALUE (REST (REST SELF)))))", Native.find_java_method("edu.isi.stella.Cons", "third", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (FOURTH (LIKE (ANY-VALUE SELF))) ((SELF CONS)) :DOCUMENTATION \"Return the fourth element of `self'.  The fourth element\nof `self' can be set with `setf'.  Note that '(fourth NIL)' = `null'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "fourth", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (FIFTH (LIKE (ANY-VALUE SELF))) ((SELF CONS)) :DOCUMENTATION \"Return the fifth element of `self'.  The fifth element\nof `self' can be set with `setf'.  Note, that '(fifth NIL)' = `null'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "fifth", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (NTH (LIKE (ANY-VALUE SELF))) ((SELF CONS) (POSITION INTEGER)) :DOCUMENTATION \"Return the element of `self' at `position'.  The nth element\nof `self' can be set with `setf'.  Note, that '(nth NIL <pos>)' = `null'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "nth", new java.lang.Class [] {java.lang.Integer.TYPE}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (NTH-REST (LIKE SELF)) ((SELF CONS) (POSITION INTEGER)) :DOCUMENTATION \"Apply `rest' `position' times to `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "nthRest", new java.lang.Class [] {java.lang.Integer.TYPE}), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("LAST-CONS", "(DEFUN (LAST-CONS (CONS OF (LIKE (ANY-VALUE SELF)))) ((SELF CONS)) :DOCUMENTATION \"Return the last cons of `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "lastCons", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineMethodObject("(DEFMETHOD (LAST (LIKE (ANY-VALUE SELF))) ((SELF CONS)) :DOCUMENTATION \"Return the last element of `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "last", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (FIRST-SETTER (LIKE (ANY-VALUE SELF))) ((SELF CONS) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "firstSetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (SECOND-SETTER (LIKE (ANY-VALUE SELF))) ((SELF CONS) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "secondSetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (THIRD-SETTER (LIKE (ANY-VALUE SELF))) ((SELF CONS) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "thirdSetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (NTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF CONS) (VALUE (LIKE (ANY-VALUE SELF))) (POSITION INTEGER)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "nthSetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Integer.TYPE}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (FOURTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF CONS) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "fourthSetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (FIFTH-SETTER (LIKE (ANY-VALUE SELF))) ((SELF CONS) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "fifthSetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (NTH-REST-SETTER OBJECT) ((SELF CONS) (VALUE OBJECT) (POSITION INTEGER)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "nthRestSetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), java.lang.Integer.TYPE}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (ALLOCATE-ITERATOR (CONS-ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF CONS)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "allocateIterator", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("TERMINATE-CONS-ITERATOR?", "(DEFUN (TERMINATE-CONS-ITERATOR? BOOLEAN) ((SELF CONS-ITERATOR)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.ConsIterator", "terminateConsIteratorP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.ConsIterator")}), null);
      Stella.defineMethodObject("(DEFMETHOD (NEXT? BOOLEAN) ((SELF CONS-ITERATOR)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.ConsIterator", "nextP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (EMPTY? BOOLEAN) ((SELF CONS-ITERATOR)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.ConsIterator", "emptyP", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (LENGTH INTEGER) ((SELF CONS-ITERATOR)) :DOCUMENTATION \"Iterate over 'self', and count how many items there are.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.ConsIterator", "length", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (MEMBER? BOOLEAN) ((SELF CONS-ITERATOR) (VALUE OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Iterate over values of `self' and return TRUE\nif one of them is `eql?' to 'value.\")", Native.find_java_method("edu.isi.stella.ConsIterator", "memberP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (VALUE-SETTER OBJECT) ((SELF CONS-ITERATOR) (VALUE (LIKE (ANY-VALUE SELF)))) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.ConsIterator", "valueSetter", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("ADD-CONS-TO-END-OF-CONS-LIST", "(DEFUN ADD-CONS-TO-END-OF-CONS-LIST ((SELF CONS) (LASTCONS CONS)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "addConsToEndOfConsList", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons"), Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineFunctionObject("BUT-LAST-NEXT?", "(DEFUN (BUT-LAST-NEXT? BOOLEAN) ((SELF ALL-PURPOSE-ITERATOR)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.AllPurposeIterator", "butLastNextP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.AllPurposeIterator")}), null);
      Stella.defineMethodObject("(DEFMETHOD (BUT-LAST (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF CONS)) :DOCUMENTATION \"Generate all but the last element of the cons list `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "butLast", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (CONSIFY (CONS OF (LIKE (ANY-VALUE SELF)))) ((SELF CONS)) :DOCUMENTATION \"Return `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "consify", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (CONSIFY (CONS OF (LIKE (ANY-VALUE SELF)))) ((SELF LIST)) :DOCUMENTATION \"Return a list of elements in `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.List", "consify", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (CONSIFY (CONS OF (LIKE (ANY-VALUE SELF)))) ((SELF KEY-VALUE-LIST)) :DOCUMENTATION \"Return a list of key-value pairs in `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.KeyValueList", "consify", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (CONSIFY (CONS OF (LIKE (ANY-VALUE SELF)))) ((SELF VECTOR)) :DOCUMENTATION \"Return a list of elements in `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Vector", "consify", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (CONSIFY (CONS OF (LIKE (ANY-VALUE SELF)))) ((SELF ITERATOR)) :DOCUMENTATION \"Return a list of elements generated by `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Iterator", "consify", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (CONSIFY CONS) ((SELF OBJECT)) :DOCUMENTATION \"If `object' is a CONS, return it.  Otherwise, return\na singleton cons list containing it.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "consify", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (REMOVE-DELETED-MEMBERS (LIKE SELF)) ((SELF CONS)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "removeDeletedMembers", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
      Stella.defineFunctionObject("COPY-CONS-LIST", "(DEFUN (COPY-CONS-LIST (LIKE SELF)) ((SELF CONS)) :DOCUMENTATION \"Return a copy of the cons list `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "copyConsList", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineFunctionObject("CONS-LIST", "(DEFUN (CONS-LIST CONS) (|&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return a cons list containing `values', in order.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "consList", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineFunctionObject("LIST*", "(DEFUN (LIST* CONS) (|&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return a list of conses that make up the list `values',\nterminated by the last value rather than by `nil'.  Assumes that\nat least one value is passed in.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "list$", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineFunctionObject("APPEND", "(DEFUN (APPEND CONS) ((CONSLIST1 CONS) (CONSLIST2 CONS)) :DOCUMENTATION \"Return a cons list representing the concatenation\nof `consList1' and `consList2'.  The concatenation is NOT destructive.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "append", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons"), Native.find_java_class("edu.isi.stella.Cons")}), null);
      Stella.defineMethodObject("(DEFMETHOD (SUBSET? BOOLEAN) ((SELF CONS) (OTHERLIST CONS)) :DOCUMENTATION \"Return true if every element of `self' also occurs in `otherList'.\nUses an `eql?' test and a simple quadratic-time algorithm.  Note that\nthis does not check whether `self' and `otherList' actually are sets.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "subsetP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (EQUIVALENT-SETS? BOOLEAN) ((SELF CONS) (OTHERLIST CONS)) :DOCUMENTATION \"Return true if every element of `self' occurs in `otherList' and vice versa.\nUses an `eql?' test and a simple quadratic-time algorithm.  Note that\nthis does not check whether `self' and `otherList' actually are sets.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "equivalentSetsP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (DISJOINT-SETS? BOOLEAN) ((SELF CONS) (OTHERLIST CONS)) :DOCUMENTATION \"Return true if the intersection of `self' and `otherList' is empty.\nThis is always true if at least one of the two sets is the empty set.\nUses an `eql?' test and a simple quadratic-time algorithm.  Note that\nthis does not check whether `self' and `otherList' actually are sets.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "disjointSetsP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), ((java.lang.reflect.Method)(null)));
      Stella.defineMethodObject("(DEFMETHOD (INTERSECTION CONS) ((SELF CONS) (OTHERLIST CONS)) :DOCUMENTATION \"Return the set intersection of `self' and `otherList'.  Uses an `eql?'\ntest and a simple quadratic-time algorithm.  Note that the result is only\nguaranteed to be a set if both `self' and `otherList' are sets.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "intersection", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), ((java.lang.reflect.Method)(null)));
    }
  }

  public static void startupConses() {
    if (Stella.currentStartupTimePhaseP(0)) {
      if (!(Stella.NIL != null)) {
        Stella.NIL = new Cons();
        Stella.NIL.value = null;
        Stella.NIL.rest = Stella.NIL;
      }
    }
    { Object old$Module$000 = Stella.$MODULE$.get();
      Object old$Context$000 = Stella.$CONTEXT$.get();

      try {
        Native.setSpecial(Stella.$MODULE$, Stella.$STELLA_MODULE$);
        Native.setSpecial(Stella.$CONTEXT$, ((Module)(Stella.$MODULE$.get())));
        if (Stella.currentStartupTimePhaseP(2)) {
          Stella.SYM_STELLA_p = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("?", null, 0)));
          Stella.SYM_STELLA_ddd = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("...", null, 0)));
          Stella.SYM_STELLA_STARTUP_CONSES = ((Symbol)(GeneralizedSymbol.internRigidSymbolWrtModule("STARTUP-CONSES", null, 0)));
        }
        if (Stella.currentStartupTimePhaseP(4)) {
          _StartupConses.helpStartupConses1();
        }
        if (Stella.currentStartupTimePhaseP(6)) {
          Stella.finalizeClasses();
        }
        if (Stella.currentStartupTimePhaseP(7)) {
          _StartupConses.helpStartupConses2();
          Stella.defineMethodObject("(DEFMETHOD (UNION CONS) ((SELF CONS) (OTHERLIST CONS)) :DOCUMENTATION \"Return the set union of `self' and `otherList'.  Uses an `eql?' test\nand a simple quadratic-time algorithm.  Note that the result is only\nguaranteed to be a set if both `self' and `otherList' are sets.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "union", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (DIFFERENCE CONS) ((SELF CONS) (OTHERLIST CONS)) :DOCUMENTATION \"Return the set difference of `self' and `otherList' (i.e., all elements\nthat are in `self' but not in `otherSet').  Uses an `eql?' test and a simple\nquadratic-time algorithm.  Note that the result is only guaranteed to be a\nset if both `self' and `otherList' are sets.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "difference", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (SUBTRACT CONS) ((SELF CONS) (OTHERLIST CONS)) :DOCUMENTATION \"Return the set difference of `self' and `otherList' by destructively\nremoving elements from `self' that also occur in `otherList'.  Uses an `eql?'\ntest and a simple quadratic-time algorithm.  Note that the result is only\nguaranteed to be a set if `self' is a set.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "subtract", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons")}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (SORT (CONS OF (LIKE (ANY-VALUE SELF)))) ((SELF CONS) (PREDICATE FUNCTION-CODE)) :PUBLIC? TRUE :DOCUMENTATION \"Perform a stable, destructive sort of `self' according to\n`predicate', and return the result.  If `predicate' has a '<' semantics, the\nresult will be in ascending order.  It is not guaranteed that `self' will\npoint to the beginning of the sorted result.  If `predicate' is `null', a\nsuitable '<' predicate is chosen depending on the first element of `self',\nand it is assumed that all elements of `self' have the same type (supported\nelement types are GENERALIZED-SYMBOL, STRING, INTEGER, and FLOAT).\")", Native.find_java_method("edu.isi.stella.Cons", "sort", new java.lang.Class [] {Native.find_java_class("java.lang.reflect.Method")}), ((java.lang.reflect.Method)(null)));
          Stella.defineFunctionObject("HELP-SORT-CONS-LIST", "(DEFUN (HELP-SORT-CONS-LIST CONS) ((LIST CONS) (LENGTH INTEGER) (PREDICATE FUNCTION-CODE)))", Native.find_java_method("edu.isi.stella.Cons", "helpSortConsList", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons"), java.lang.Integer.TYPE, Native.find_java_class("java.lang.reflect.Method")}), null);
          Stella.defineFunctionObject("MERGE-CONS-LISTS", "(DEFUN (MERGE-CONS-LISTS CONS) ((LIST1 CONS) (LIST2 CONS) (PREDICATE FUNCTION-CODE)))", Native.find_java_method("edu.isi.stella.Cons", "mergeConsLists", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons"), Native.find_java_class("edu.isi.stella.Cons"), Native.find_java_class("java.lang.reflect.Method")}), null);
          Stella.defineFunctionObject("GENERALIZED-SYMBOL-LESS-THAN?", "(DEFUN (GENERALIZED-SYMBOL-LESS-THAN? BOOLEAN) ((X GENERALIZED-SYMBOL) (Y GENERALIZED-SYMBOL)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.GeneralizedSymbol", "generalizedSymbolLessThanP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.GeneralizedSymbol"), Native.find_java_class("edu.isi.stella.GeneralizedSymbol")}), null);
          Stella.defineFunctionObject("WRAPPED-INTEGER-LESS-THAN?", "(DEFUN (WRAPPED-INTEGER-LESS-THAN? BOOLEAN) ((X INTEGER-WRAPPER) (Y INTEGER-WRAPPER)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.IntegerWrapper", "wrappedIntegerLessThanP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.IntegerWrapper"), Native.find_java_class("edu.isi.stella.IntegerWrapper")}), null);
          Stella.defineFunctionObject("WRAPPED-LONG-INTEGER-LESS-THAN?", "(DEFUN (WRAPPED-LONG-INTEGER-LESS-THAN? BOOLEAN) ((X LONG-INTEGER-WRAPPER) (Y LONG-INTEGER-WRAPPER)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.LongIntegerWrapper", "wrappedLongIntegerLessThanP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.LongIntegerWrapper"), Native.find_java_class("edu.isi.stella.LongIntegerWrapper")}), null);
          Stella.defineFunctionObject("WRAPPED-FLOAT-LESS-THAN?", "(DEFUN (WRAPPED-FLOAT-LESS-THAN? BOOLEAN) ((X FLOAT-WRAPPER) (Y FLOAT-WRAPPER)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.FloatWrapper", "wrappedFloatLessThanP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.FloatWrapper"), Native.find_java_class("edu.isi.stella.FloatWrapper")}), null);
          Stella.defineFunctionObject("WRAPPED-STRING-LESS-THAN?", "(DEFUN (WRAPPED-STRING-LESS-THAN? BOOLEAN) ((X STRING-WRAPPER) (Y STRING-WRAPPER)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.StringWrapper", "wrappedStringLessThanP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.StringWrapper"), Native.find_java_class("edu.isi.stella.StringWrapper")}), null);
          Stella.defineFunctionObject("WRAPPED-MUTABLE-STRING-LESS-THAN?", "(DEFUN (WRAPPED-MUTABLE-STRING-LESS-THAN? BOOLEAN) ((X MUTABLE-STRING-WRAPPER) (Y MUTABLE-STRING-WRAPPER)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.MutableStringWrapper", "wrappedMutableStringLessThanP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.MutableStringWrapper"), Native.find_java_class("edu.isi.stella.MutableStringWrapper")}), null);
          Stella.defineFunctionObject("NUMBER-LESS-THAN?", "(DEFUN (NUMBER-LESS-THAN? BOOLEAN) ((X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)) :DOCUMENTATION \"Generic number comparison that works with integers, longs and floats.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.NumberWrapper", "numberLessThanP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.NumberWrapper"), Native.find_java_class("edu.isi.stella.NumberWrapper")}), null);
          Stella.defineFunctionObject("CHOOSE-SORT-PREDICATE", "(DEFUN (CHOOSE-SORT-PREDICATE FUNCTION-CODE) ((FIRSTELEMENT OBJECT)))", Native.find_java_method("edu.isi.stella.Stella_Object", "chooseSortPredicate", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
          Stella.defineFunctionObject("SORT-TUPLE-COMPARE?", "(DEFUN (SORT-TUPLE-COMPARE? BOOLEAN) ((X CONS) (Y CONS)))", Native.find_java_method("edu.isi.stella.Cons", "sortTupleCompareP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons"), Native.find_java_class("edu.isi.stella.Cons")}), null);
          Stella.defineMethodObject("(DEFMETHOD (SORT-TUPLES (CONS OF (LIKE (ANY-VALUE SELF)))) ((SELF CONS) (N INTEGER) (PREDICATE FUNCTION-CODE)) :PUBLIC? TRUE :DOCUMENTATION \"Just like `sort' but assumes each element of `self' is a tuple (a cons)\nwhose `n'-th element (0-based) will be used for comparison.\")", Native.find_java_method("edu.isi.stella.Cons", "sortTuples", new java.lang.Class [] {java.lang.Integer.TYPE, Native.find_java_class("java.lang.reflect.Method")}), ((java.lang.reflect.Method)(null)));
          Stella.defineFunctionObject("SORT-OBJECTS-COMPARE?", "(DEFUN (SORT-OBJECTS-COMPARE? BOOLEAN) ((X OBJECT) (Y OBJECT)))", Native.find_java_method("edu.isi.stella.Stella_Object", "sortObjectsCompareP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
          Stella.defineMethodObject("(DEFMETHOD (SORT-OBJECTS (CONS OF (LIKE (ANY-VALUE SELF)))) ((SELF CONS) (SLOT STORAGE-SLOT) (PREDICATE FUNCTION-CODE)) :DOCUMENTATION \"Just like `sort' but assumes each element of `self' has a `slot'\nwhose value will be used for comparison.  Elements must be descendants of\nSTANDARD OBJECT.  Note that while this will work with literal-valued slots,\nit will cause value wrapping everytime `slot' is read.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "sortObjects", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.StorageSlot"), Native.find_java_class("java.lang.reflect.Method")}), ((java.lang.reflect.Method)(null)));
          Stella.defineFunctionObject("SEARCH-CONS-TREE?", "(DEFUN (SEARCH-CONS-TREE? BOOLEAN) ((TREE OBJECT) (VALUE OBJECT)) :DOCUMENTATION \"Return `true' iff the value `value' is embedded within\nthe cons tree `tree'.  Uses an `eql?' test.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "searchConsTreeP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
          Stella.defineFunctionObject("SEARCH-CONS-TREE-WITH-FILTER?", "(DEFUN (SEARCH-CONS-TREE-WITH-FILTER? BOOLEAN) ((TREE OBJECT) (VALUE OBJECT) (FILTER CONS)) :DOCUMENTATION \"Return `true' iff the value `value' is embedded within\nthe cons tree `tree'.  Uses an `eql?' test.  Does not descend into any\ncons whose first element matches an element of `filter'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "searchConsTreeWithFilterP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Cons")}), null);
          Stella.defineFunctionObject("COPY-CONS-TREE", "(DEFUN (COPY-CONS-TREE (LIKE SELF)) ((SELF OBJECT)) :DOCUMENTATION \"Return a copy of the cons tree `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "copyConsTree", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
          Stella.defineFunctionObject("EQUAL-CONS-TREES?", "(DEFUN (EQUAL-CONS-TREES? BOOLEAN) ((TREE1 OBJECT) (TREE2 OBJECT)) :DOCUMENTATION \"Return `true' iff the cons trees `tree1' and `tree2' are\nstructurally equivalent.  Uses an `eql?' test.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "equalConsTreesP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
          Stella.defineMethodObject("(DEFMETHOD (OBJECT-EQUAL? BOOLEAN) ((TREE1 CONS) (TREE2 OBJECT)) :DOCUMENTATION \"Return `true' iff the cons trees `tree1' and `tree2' are\nstructurally equivalent.  Uses `equal?' to test equality of subtrees.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "objectEqualP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), ((java.lang.reflect.Method)(null)));
          Stella.defineMethodObject("(DEFMETHOD (EQUAL-HASH-CODE INTEGER) ((SELF CONS)) :DOCUMENTATION \"Return an `equal?' hash code for `self'.  Note that this\nis O(N) in the number of elements of `self'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "equalHashCode", new java.lang.Class [] {}), ((java.lang.reflect.Method)(null)));
          Stella.defineFunctionObject("SUBSTITUTE-CONS-TREE", "(DEFUN (SUBSTITUTE-CONS-TREE OBJECT) ((TREE OBJECT) (NEWVALUE OBJECT) (OLDVALUE OBJECT)) :DOCUMENTATION \"Destructively replace each appearance of `oldValue' by\n`newValue' in the cons tree `tree'.  Return the tree.  Uses an `eql?' test.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "substituteConsTree", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
          Stella.defineFunctionObject("CONS-TREE-NTH", "(DEFUN (CONS-TREE-NTH OBJECT) ((TREE CONS) |&REST| (INDEX INTEGER)) :DOCUMENTATION \"Access an arbitrary element of `tree' identified by a path\nspecified as a list of `index' values.  The first `index' specifies the\n`index'-th element of `tree', the second `index' the `index'-th subelement\nof that element, etc.  Example:\n	 \n  (cons-tree-nth (quote (a (b (c d e) f) g)) 1 1 2) => e\n	\n\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "consTreeNth", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons"), Native.find_java_class("edu.isi.stella.Cons")}), null);
          Stella.defineFunctionObject("CONS-TREE-NTH-REST", "(DEFUN (CONS-TREE-NTH-REST CONS) ((TREE CONS) |&REST| (INDEX INTEGER)) :DOCUMENTATION \"Access an arbitrary sublist of `tree' identified by a path\nspecified as a list of `index' values.  The first `index' specifies the\n`index'-th element of `tree', the second `index' the `index'-th subelement\nof that element, ..., the last index specifies the `nth-rest' of the previous\nelement (different from `cons-tree-nth').  Example:\n	 \n  (cons-tree-nth-rest (quote (a (b (c d e) f) g)) 1 1 1) => (d e)\n	\n\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Cons", "consTreeNthRest", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons"), Native.find_java_class("edu.isi.stella.Cons")}), null);
          Stella.defineFunctionObject("MATCH-CONS-TREE", "(DEFUN (MATCH-CONS-TREE KEY-VALUE-LIST) ((TREE OBJECT) (PATTERN OBJECT) (BINDINGS KEY-VALUE-LIST)) :DOCUMENTATION \"Match `pattern' against `tree' and return a list of\nvariable bindings if they match, or NULL otherwise.  `bindings' can\nbe NULL or an initial list of bindings to consider.  Pattern variables\nuse KIF syntax, i.e., they need to start with a `?' character.  A\nsingle question mark is interpreted as the anonymous variable. Example:\n	 \n  (match-cons-tree (quote (a (b (a d) e) (a d) f g))\n                   (quote (a (?x ?y ?) ?y ? g))\n                   NULL)\n  => |kv|(<?Y,(A D)> <?X,B>)\n	\nVariables can't be quoted but quoting can effectively be achieved by\ninserting to-be-quoted variables bound to themselves into `bindings'.\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "matchConsTree", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.KeyValueList")}), null);
          Stella.defineFunctionObject("CONS-TREE-MATCH?", "(DEFUN (CONS-TREE-MATCH? BOOLEAN) ((TREE OBJECT) (PATTERN OBJECT)) :DOCUMENTATION \"Predicate version of `match-cons-tree' (which see).\" :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "consTreeMatchP", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
          Stella.defineFunctionObject("PRINT-CONS", "(DEFUN PRINT-CONS ((TREE CONS) (STREAM NATIVE-OUTPUT-STREAM) (LPAREN STRING) (RPAREN STRING)))", Native.find_java_method("edu.isi.stella.Cons", "printCons", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons"), Native.find_java_class("edu.isi.stella.javalib.NativeOutputStream"), Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
          Stella.defineFunctionObject("PPRINT-CONS", "(DEFUN PPRINT-CONS ((TREE CONS) (STREAM NATIVE-OUTPUT-STREAM) (LPAREN STRING) (RPAREN STRING)))", Native.find_java_method("edu.isi.stella.Cons", "pprintCons", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons"), Native.find_java_class("edu.isi.stella.javalib.NativeOutputStream"), Native.find_java_class("java.lang.String"), Native.find_java_class("java.lang.String")}), null);
          Stella.defineFunctionObject("PRINT-STELLA-CODE", "(DEFUN PRINT-STELLA-CODE ((TREE OBJECT) (STREAM NATIVE-OUTPUT-STREAM)))", Native.find_java_method("edu.isi.stella.Stella_Object", "printStellaCode", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.javalib.NativeOutputStream")}), null);
          Stella.defineFunctionObject("PRINT-STELLA-DEFINITION", "(DEFUN PRINT-STELLA-DEFINITION ((TREE OBJECT) (STREAM NATIVE-OUTPUT-STREAM)) :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella.Stella_Object", "printStellaDefinition", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object"), Native.find_java_class("edu.isi.stella.javalib.NativeOutputStream")}), null);
          Stella.defineFunctionObject("TREE-SIZE", "(DEFUN (TREE-SIZE INTEGER) ((SELF OBJECT)))", Native.find_java_method("edu.isi.stella.Stella_Object", "treeSize", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Stella_Object")}), null);
          Stella.defineFunctionObject("SAFELY-COMPUTE-TREE-SIZE", "(DEFUN (SAFELY-COMPUTE-TREE-SIZE INTEGER) ((TREE CONS) (DEPTHCOUNT INTEGER) (CUTOFF INTEGER)))", Native.find_java_method("edu.isi.stella.Cons", "safelyComputeTreeSize", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons"), java.lang.Integer.TYPE, java.lang.Integer.TYPE}), null);
          Stella.defineFunctionObject("SAFE-TREE-SIZE", "(DEFUN (SAFE-TREE-SIZE INTEGER STRING) ((TREE CONS)))", Native.find_java_method("edu.isi.stella.Cons", "safeTreeSize", new java.lang.Class [] {Native.find_java_class("edu.isi.stella.Cons"), Native.find_java_class("[Ljava.lang.Object;")}), null);
          Stella.defineFunctionObject("STARTUP-CONSES", "(DEFUN STARTUP-CONSES () :PUBLIC? TRUE)", Native.find_java_method("edu.isi.stella._StartupConses", "startupConses", new java.lang.Class [] {}), null);
          { MethodSlot function = Symbol.lookupFunction(Stella.SYM_STELLA_STARTUP_CONSES);

            KeyValueList.setDynamicSlotValue(function.dynamicSlots, Stella.SYM_STELLA_METHOD_STARTUP_CLASSNAME, StringWrapper.wrapString("_StartupConses"), Stella.NULL_STRING_WRAPPER);
          }
        }
        if (Stella.currentStartupTimePhaseP(8)) {
          Stella.finalizeSlots();
          Stella.cleanupUnfinalizedClasses();
        }
        if (Stella.currentStartupTimePhaseP(9)) {
          Stella_Object.inModule(((StringWrapper)(Stella_Object.copyConsTree(StringWrapper.wrapString("/STELLA")))));
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFGLOBAL NIL CONS NULL :PUBLIC? TRUE)");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFGLOBAL *REMOVE-DUPLICATES-CROSSOVER-POINT* INTEGER 20 :DOCUMENTATION \"Point where we switch from using a quadratic remove\nduplicates algorithm to a linear one using a hash table.  For\nan unoptimized Common Lisp, 20 is a good crossover point.\")");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFSPECIAL *SORT-TUPLE-COMPARE-PREDICATE* FUNCTION-CODE NULL)");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFSPECIAL *SORT-TUPLE-COMPARE-INDEX* INTEGER 0)");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFSPECIAL *SORT-OBJECTS-COMPARE-SLOT* STORAGE-SLOT NULL)");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFSPECIAL *PRINTPRETTY?* BOOLEAN TRUE :DOCUMENTATION \"If `true' conses will be pretty printed.\" :PUBLIC? TRUE)");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFSPECIAL *PRINTREADABLY?* BOOLEAN FALSE :DOCUMENTATION \"If `true' conses will be printed as readable Stella code.\" :PUBLIC? TRUE)");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFSPECIAL *PRINTLENGTH* INTEGER NULL :DOCUMENTATION \"If non-NULL list-like data structures will print at most\nthat many elements.\" :PUBLIC? TRUE)");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFGLOBAL ELIPSIS SYMBOL (QUOTE ...) :DOCUMENTATION \"Generates an elipsis '...' when found in a\npretty-printed parse tree.\" :PUBLIC? TRUE)");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFSPECIAL *PRINTPRETTYCODE?* BOOLEAN TRUE :DOCUMENTATION \"When `true' pretty-print Stella and translated code.\nSince (Lisp) pretty-printing is somewhat slow, turning this off speeds up\nfile translation, but it also makes translated output very unreadable.\" :PUBLIC? TRUE)");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFSPECIAL *DEPTHEXCEEDED?* BOOLEAN FALSE)");
          Stella.defineStellaGlobalVariableFromStringifiedSource("(DEFGLOBAL *DEPTHCUTOFF* INTEGER 33)");
        }

      } finally {
        Stella.$CONTEXT$.set(old$Context$000);
        Stella.$MODULE$.set(old$Module$000);
      }
    }
  }

}
