;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; Version: test-suite.plm,v 1.49 2012/04/30 23:20:10 hans Exp

;;; Various PowerLoom tests
;;; =======================

;;; Still pending bugs are annotated with `<<< FIX >>>'.


;; Standard demo preamble:

(in-package "STELLA")

(defmodule "PL-KERNEL/PL-USER/TEST")

(in-module "TEST")
(in-dialect :KIF)
(reset-features)


;;; BUILDING ODD-BALL PROPOSITIONS:

(clear-module "TEST")

(conceive (not (= 5 6)))


;;; PROPER ADDING OF SKOLEMS TO EXTENSIONS:

(clear-module "TEST")

(defconcept PERSON (?p) 
  :documentation "The class of PERSON beings.")
(defrelation happy ((?p PERSON)))
(deffunction age ((?p PERSON)) :-> (?age INTEGER))
(deffunction father ((?p PERSON)) :-> (?f PERSON))


(assert (PERSON fred))
(assert (exists (?x PERSON) (= (father fred) ?x)))
(retrieve all ?x (PERSON ?x))

;;; PROPER ADDING OF FORWARD INFERENCE (FUNCTION OUTPUT) SKOLEMS TO EXTENSIONS:

(clear-module "TEST")

(defconcept PERSON (?p))
(defconcept dog (?d)
    :=> (exists (?p PERSON) (owner ?d ?p)))
(deffunction owner ((?d DOG)) :-> (?o PERSON))
(defrelation loves ((?p PERSON) (?d dog)))

(assert (forall (?d dog) (exists (?p PERSON) (loves ?p ?d))))

(assert (dog rex))
(retrieve all (?x PERSON) (owner rex ?x))
(retrieve all (?x PERSON) (loves ?x rex))
(retrieve all (?x PERSON))

;;; PROPER RETRACTION OF SKOLEMS INFERRED DURING FORWARD INFERENCE:

(clear-module "TEST")

(defconcept bridge (?b))

(defconcept bridge-workaround (?bw)
   :=> (exists (?b bridge) (bridge-of ?bw ?b)))
(deffunction bridge-of ((?bw bridge-workaround)) :-> (?b BRIDGE))

;(propagate-constraints)
(assert (bridge-workaround bwa1))
(retrieve (?x bridge) (bridge-of bwa1 ?x))
(retrieve (?x bridge))
(retract (bridge-workaround bwa1))
;; NOW IT SHOULD DISAPPEAR:
(retrieve (?x bridge) (bridge-of bwa1 ?x))
(retrieve (?x bridge))
(propagate-constraints)
(assert (bridge-workaround bwa1))
(retrieve (?x bridge) (bridge-of bwa1 ?x))
;; <<< FIX >>> NOW IT SHOULD REAPPEAR:
(retrieve (?x bridge))


;;; DON'T BREAK ON FAILING `SUBSET' QUERIES:

(clear-module "TEST")

(defconcept bridge (?b))

(ask (subset-of bridge thing))
(ask (subset-of thing bridge))
(ask (not (subset-of bridge thing)))
(ask (not (subset-of thing bridge)))


;;; EXPOSED A PROBLEM WITH ROOT-TYPES AND QUERIES ON ABSTRACT CLASSES:

(clear-module "TEST")

(defconcept animal (?a)
  :axioms (ABSTRACT ANIMAL))
(defconcept PERSON (?p animal))

(assert (PERSON fred))
(ask (animal fred))
(ask (not (animal fred)))


;;; USING THE CONTRAPOSITIVE

(clear-module "TEST")

(defconcept boat (?b))
(deffunction max-current ((?b BOAT)) :-> (?mc FLOAT))

(defconcept river (?r))
(deffunction current ((?r RIVER)) :-> (?c FLOAT))
(defrelation current-too-strong ((?x boat) (?y river))
 :<=> (> (current ?y) (max-current ?x)))

(assert (river nile))
(assert (boat raft1))
(assert (max-current raft1 3.0))
(assert (current nile 2.0))

(ask (current-too-strong raft1 nile))

;;;; PROBLEM: `natural-deduction-mode?' KILLS THIS!!!!!!!!!!!!!!!!!

;; THIS MUST RETURN TRUE:
(ask (not (current-too-strong raft1 nile)))

;; TEST SYMMETRIE: CONTRAPOSITIVE DERIVED FROM A `NEGATIVE' RULE:
(defrelation current-too-strong2 ((?x boat) (?y river)))

(assert (forall ((?x boat) (?y river))
          (=> (not (> (current ?y) (max-current ?x)))
              (not (current-too-strong2 ?x ?y)))))

(assert (forall ((?x boat) (?y river))
          (=> (not (current-too-strong2 ?x ?y))
              (not (> (current ?y) (max-current ?x))))))

(ask (current-too-strong2 raft1 nile))
;; THIS MUST RETURN TRUE:
(ask (not (current-too-strong2 raft1 nile)))


;;; PROVING DISJUNCTIONS:

(clear-module "TEST")

(defconcept PERSON (?p)
  :documentation "The class of PERSON beings.")
(defrelation happy ((?p PERSON)))
(defrelation married ((?p PERSON)))

(assert (forall (?x person)
                (=> (married ?x) (happy ?x))))

(assert (person fred))

(ask (or (not (married fred))
         (happy fred)))

(ask (or (not (married fred))
         (happy fred))
     :inference-level :refutation)

(clear-module "TEST")

(defconcept PERSON (?p)
  :documentation "The class of PERSON beings.")

(defrelation happy ((?p PERSON)))
(defrelation rich ((?p PERSON)))
(defrelation married ((?p PERSON)))

(assert (forall (?x PERSON)
          (=> (or (rich ?x)
                  (and (married ?x)
                       (not (rich ?x))))
              (happy ?x))))

(assert (PERSON fred))
(assert (married fred))

(ask (happy fred))

(clear-caches)
(ask (happy fred)
     :inference-level :refutation)


;;; STRESS DUPLICATE SUBGOAL MECHANISM:

(clear-module "TEST")

(defconcept partially-tangible (?pt))

(defrelation between
    ((?a partially-tangible) (?b partially-tangible) (?c partially-tangible)))

(defrule Commutative-Between
  (forall ((?a Partially-Tangible)
           (?b Partially-Tangible)
           (?c Partially-Tangible))
    (=> (Between ?a ?b ?c)
        (Between ?a ?c ?b))))

(defrule Transitive-Between 
  (forall ((?a Partially-Tangible)
           (?b Partially-Tangible)
	   (?c Partially-Tangible)
           (?d Partially-Tangible))
    (=> (and (Between ?a ?d ?c)
             (Between ?b ?a ?c))
	(Between ?a ?d ?b))))

(assert (partially-tangible city1))
(assert (partially-tangible city2))
(assert (partially-tangible city3))
(assert (partially-tangible city4))

;; THIS NEEDS TO FAIL AFTER TRYING ALL POSSIBILITES:
(ask (between city1 city2 city3))

(assert (between city1 city3 city2))

;; TEST COMMUTATIVITY:
(ask (between city1 city2 city3))

(assert (between city4 city3 city1))

;; TEST TRANSITIVITY (THIS IS SLOW):
(ask (between city1 city4 city2))


;;; CLOSED RELATIONS:

(clear-module "TEST")

(defconcept PERSON (?p))
(defrelation nobel-prize-winner ((?p PERSON)))

(assert (PERSON fred))
(assert (PERSON einstein))
(assert (nobel-prize-winner einstein))

(ask (not (nobel-prize-winner fred)))
(ask (not (nobel-prize-winner einstein)))

(assert (closed nobel-prize-winner))

(ask (not (nobel-prize-winner fred)))
(ask (not (nobel-prize-winner einstein)))


;;; FORWARD INFERENCE WITH EQUAL FUNCTION TERMS

(clear-module "TEST")

(defconcept PERSON (?p))
(deffunction nof-brothers ((?p PERSON)) :-> (?n INTEGER))
(deffunction nof-sisters ((?p PERSON)) :-> (?n INTEGER))
(defrelation balanced-siblings ((?p PERSON)))

(assert (forall (?x PERSON)
          (=> (balanced-siblings ?x)
              (= (nof-brothers ?x) (nof-sisters ?x)))))

(assert (PERSON fred))

(assert (balanced-siblings fred))

(retrieve (?x integer) (= (NOF-BROTHERS fred) ?x))
(retrieve (?x integer) (= (NOF-SISTERS fred) ?x))

(assert (= (NOF-BROTHERS fred) 5))

(retrieve (?x integer) (= (NOF-SISTERS fred) ?x))
(retrieve (?x integer) (= (NOF-BROTHERS fred) ?x))


;;; INEQUALITY FUN:

(clear-module "TEST")

(defconcept PERSON (?p))
(deffunction height ((?p PERSON)) :-> (?h FLOAT))

;; THIS RULE ISN'T NEEDED ANYMORE:
;; BUG: CAN'T DEFINE A BICONDITIONAL:
;(defrule greater-implies-less
;    (forall ((?x NUMBER) (?y NUMBER))
;      (<=> (> ?x ?y) (< ?y ?x))))

(assert (PERSON fred))
(assert (> (height fred) 20.0))
(assert (PERSON joe))
(assert (< (height joe) 20.0))
(ask (< 20.0 (height fred)))
(ask (> 20.0 (height joe)))

(defconcept avlb (?avlb)
  :=> (< (traffic-class ?avlb) 17))
(deffunction traffic-class ((?avlb avlb)) :-> (?i INTEGER))

(assert (avlb b1))
(ask (< (traffic-class b1) 17))

;;; ENFORCING VARIABLE TYPES DURING FORWARD INFERENCE:

(clear-module "TEST")

(defconcept animal (?a))
(defconcept PERSON (?p))
(deffunction loved-by ((?a ANIMAL)) :-> (?p PERSON))

(defconcept dog (?d animal))
(defconcept cat (?c animal))

(defrelation loves ((?p PERSON) (?a animal)))

;; BELOW WE INTENTIONALLY DUPLICATE THE VARIABLE TYPE RESTRICTION `(cat ?c)',
;;    SINCE THAT EXPOSED A BUG IN THE SIMPLIFIER WHERE IT COMPLETELY LOST THEM:
(defrule cat-lover-rule
    (forall ((?p PERSON) (?c cat))
      (=> (and (cat ?c)
               (loves ?p ?c))
          (= (loved-by ?c) ?p))))

(assert (PERSON fred))
(assert (dog fido))
(assert (cat garfield))
(assert (loves fred garfield))

;;; THIS FAILS AS IT SHOULD:
(ask (loved-by fido fred))
;;; THIS SUCCEEDS:
(ask (loved-by garfield fred))

(propagate-constraints)

;;; AFTER CONSTRAINT PROPAGATION THIS MUST STILL FAIL:
(ask (loved-by fido fred))


;;; STATE MACHINE FUN:

(clear-module "TEST")

(defconcept a)

(defrelation r1 ((?a1 a) (?a2 a)))
(defrelation r2 ((?a1 a) (?a2 a)))

(assert (forall ((?a1 a) (?a2 a))
          (=> (r2 ?a1 ?a2)
              (r2 ?a2 ?a1))))

(assert (a a1))
(assert (a a2))
(assert (r2 a1 a2))

;; THIS EXPOSED A BUG IN THE STATE MACHINE:
(ask (or (r1 a2 a1)
         (r2 a2 a1)))


;;; FUNCTION INVERSES:

(clear-module "TEST")

(defconcept person (?p))
(deffunction boss ((?p PERSON)) :-> (?f PERSON))

(assert (person fred))
(assert (person john))
(assert (person susi))
(assert (person otto))

(assert (= (boss fred) otto))
(assert (= (boss john) otto))
(assert (= (boss otto) susi))

(retrieve all (?x person) (= (boss ?x) otto))
(retrieve all ((?x person) (?y person)) (= (boss ?x) ?y))


;;; ITERATIVE FORALL (SHOULD BECOME A STANDARD DEMO)

(clear-module "TEST")

(defconcept house (?h))
(defconcept person (?p))
(defrelation crazy ((?p PERSON)))
(deffunction lives-in ((?p PERSON)) :-> (?f HOUSE))

(defconcept nuthouse (?h house))

(defrule nuthouse-rule
    (forall (?h house)
      (=> (forall (?p person)
	    (=> (lives-in ?p ?h)
		(crazy ?p)))
	  (nuthouse ?h))))

(assert (closed person))

(assert (person fred))
(assert (person mary))
(assert (not (crazy fred)))
(assert (crazy mary))
(assert (house h1))
(assert (lives-in fred h1))
(assert (lives-in mary h1))

(ask (nuthouse h1))

(retract (not (crazy fred)))
(assert (crazy fred))

(ask (nuthouse h1))


;;; CONSTRAINT PROPAGATION BUG DURING HYPOTHETICAL REASONING:

(clear-module "TEST")

(defconcept person (?p))
(defrelation happy ((?p PERSON)))
(defrelation rich ((?p PERSON)))


(defrelation sibling ((?x person) (?y person)))

(assert (forall (?x person)
          (=> (happy ?x)
              (exists (?y person)
                (sibling ?x ?y)))))

(assert (person fred))

;; THIS NEEDS TO FAIL, BUT IT USED TO BREAK `mapped-value-of', SINCE
;; `*queryIterator*' WAS STILL VISIBLE DURING THE CONSTRAINT PROPAGATION
;; CAUSED BY THE ASSERTION IN THE HYPOTHETICAL WORLD:
(ask (or (rich fred)
         (not (happy fred))))


;;; EQUALITY REASONING BUG WITH NESTED FUNCTIONS:

(clear-module "TEST")

(defconcept person (?p))
(deffunction age ((?p PERSON)) :-> (?age INTEGER))
(deffunction golf-handicap ((?p PERSON)) :-> (?age INTEGER))
(deffunction son ((?p PERSON)) :-> (?f PERSON))

(assert (person fred))
(assert (person joe))
(assert (= (son Fred) Joe))
(assert (= (age Joe) 12))
(assert (= (golf-handicap Fred) (age (son Fred))))

(propagate-constraints)

;; THIS MUST RETURN 12:
(retrieve all (?x integer) (= (golf-handicap Fred) ?x))

;; TRY AGAIN WITH DIFFERENT ORDER:
(clear-module "TEST")

(defconcept person (?p))
(deffunction age ((?p PERSON)) :-> (?age INTEGER))
(deffunction golf-handicap ((?p PERSON)) :-> (?age INTEGER))
(deffunction son ((?p PERSON)) :-> (?f PERSON))

(assert (person fred))
(assert (person joe))
(assert (= (age Joe) 12))
(assert (= (golf-handicap Fred) (age (son Fred))))
(assert (= (son Fred) Joe))

(propagate-constraints)

;; THIS MUST RETURN 12:
(retrieve all (?x integer) (= (golf-handicap Fred) ?x))


;; TRY AGAIN WITH DIFFERENT ORDER:
(clear-module "TEST")

(defconcept person (?p))
(deffunction age ((?p PERSON)) :-> (?age INTEGER))
(deffunction golf-handicap ((?p PERSON)) :-> (?age INTEGER))
(deffunction son ((?p PERSON)) :-> (?f PERSON))

(assert (person fred))
(assert (person joe))
(assert (= (golf-handicap Fred) (age (son Fred))))
(assert (= (age Joe) 12))
(assert (= (son Fred) Joe))

(propagate-constraints)

;; THIS MUST RETURN 12:
(retrieve all (?x integer) (= (golf-handicap Fred) ?x))


;;; CONSTANT INTRODUCTION BUG:

(clear-module "TEST")

(defconcept person (?p))
(deffunction age ((?p PERSON)) :-> (?age INTEGER))
(deffunction golf-handicap ((?p PERSON)) :-> (?age INTEGER))
(deffunction son ((?p PERSON)) :-> (?f PERSON))

;; THIS USED TO BREAK BECAUSE OF MISSING TYPE INFERENCE:
(assert (and (person Mary)
             (= (age Mary) 3)))


;;; PROPOSITION ARGUMENTS BUG:

(clear-module "TEST")

(defconcept person (?p))
(deffunction age ((?p PERSON)) :-> (?age INTEGER))
(deffunction golf-handicap ((?p PERSON)) :-> (?age INTEGER))
(deffunction son ((?p PERSON)) :-> (?f PERSON))

(defrelation believes ((?x person) (?y proposition)))

(assert (person fred))
(assert (person joe))

(assert (believes fred (son fred joe)))

(retrieve (?x proposition) (believes fred ?x))
(retrieve ?x (believes fred ?x))

;;; TESTING RELATION HIERARCHY LOOKUP:

(clear-module "TEST")

(defconcept person (?p))
(defrelation happy ((?p person)))
(defrelation rich ((?p person)))
(assert (person fred))
(assert (forall (?x person) (=> (rich ?x) (happy ?x))))
(assert (rich fred))
(ask (happy fred))

;;; COMPLEMENT TEST

(clear-module "TEST")

(defconcept person (?P))
(defrelation parent ((?p1 person) (?p2 person)))
(defrelation grandparent ((?p person)))
(defrelation retired ((?p person)))
(assert (person fred))
(assert (not (grandparent fred)))
(assert (=> (AND (RETIRED ?X) (FAIL (PARENT ?X1 ?X))) (GRANDPARENT ?X)))
(assert (=> (AND (RETIRED ?X) (PARENT ?X1 ?X)) (NOT (GRANDPARENT ?X))))
(ask (not (grandparent fred)))

;;; HANDLING CLUSTERED OF CONJUNCTIONS:

(clear-module "TEST")

(set-feature trace-subgoals)

(defconcept person (?p))
(defrelation loves ((?x person) (?y person)))
(defrelation hates ((?x person) (?y person)))

(assert (person fred))
(assert (person john))
(assert (person susi))
(assert (person debbie))

(assert (loves fred susi))
(assert (hates john debbie))

;; MUST FAIL WITHOUT BACKTRACKING:
(retrieve all (?x ?y ?z ?zz)
          (and (loves ?x ?y)
               (loves ?y ?x)
               (hates ?z ?zz)
               (hates ?zz ?z)))

(assert (hates debbie john))

;; MUST FAIL WITHOUT BACKTRACKING:
(retrieve all (?x ?y ?z ?zz)
          (and (loves ?x ?y)
               (loves ?y ?x)
               (hates ?z ?zz)
               (hates ?zz ?z)))

(assert (loves susi fred))

;; 4 SOLUTIONS:
(retrieve all (?x ?y ?z ?zz)
          (and (loves ?x ?y)
               (loves ?y ?x)
               (hates ?z ?zz)
               (hates ?zz ?z)))

(unset-feature trace-subgoals)

;;; CLUSTERED CONJUNCTION BUG

(clear-module "TEST")

(defconcept project)
(defconcept person)
(defconcept research-area)
(defrelation works-on ((?u person) (?l project)))
(defrelation topic ((?p project) (?a thing)))
(defrelation related ((?t1 research-area) (?t2 research-area)))

(assert (project electric-elves))
(assert (project powerloom))
(assert (project sims))

(assert (topic electric-elves intelligent-agents))
(assert (topic powerloom knowledge-representation))
(assert (topic sims automated-planning))

(assert (related intelligent-agents knowledge-representation))
(assert (related automated-planning intelligent-agents))

(assert (works-on craig-knoblock electric-elves))
(assert (works-on craig-knoblock sims))

(assert (works-on hans-chalupsky electric-elves))
(assert (works-on hans-chalupsky powerloom))

(defrelation overlapping-interests
    ((?visitor PERSON) (?visitor-interest RESEARCH-AREA)
     (?staff PERSON) (?staff-interest RESEARCH-AREA))
  :<= (and (exists (?project)
	     (and (works-on ?visitor ?project)
		  (topic ?project ?visitor-interest)))
	   (exists (?project)
	     (and (works-on ?staff ?project)
		  (topic ?project ?staff-interest)))
           ;; THIS WOULD PREVENT CLUSTERING:
           ;(not (= ?visitor ?staff))
           ;; RESIDUE GOAL, DO BACKTRACK IF WE FAIL HERE:
	   (or (related ?visitor-interest ?staff-interest)
               (related ?staff-interest ?visitor-interest))))

;;; 8 SOLUTIONS:
(retrieve all (?v ?vi ?s ?si) (overlapping-interests ?v ?vi ?s ?si))

;;; LAZY SATELITES PROBLEM:

(clear-module "TEST")
(defconcept person (?x))
(defrelation happy ((?x person)))
(defrelation rich ((?x person)))
(assert (forall (?x person)
           (=> (rich ?x) (happy ?x))))

(assert (person fred))
(assert (not (happy fred)))

;;;THIS SHOULD RETURN FRED EVEN IF WE USE LAZY SATELLITES
(retrieve all ?x (and (person ?x) (not (rich ?x))))

;;; ASSERTION LOOKUP WITH EQUALITY AND SPECIALIZING RELATIONS

(clear-module "TEST")
(defconcept person (?x))
(deffunction boss ((?x person)) :-> (?b person))
(deffunction father ((?x person)) :-> (?f person))
(deffunction mother ((?x person)) :-> (?m person))
(defrelation rich ((?x person)))
(defrelation happy ((?x person)))

(assert (forall (?x person) (=> (rich ?x) (happy ?x))))
(assert (person fred))
(assert (person frank))
(assert (person susi))
(assert (rich (father frank)))
(assert (= (father frank) (boss fred)))

(ask (happy (father frank)))
(ask (happy (boss fred)))
(retrieve all (?x person) (happy ?x))

;;; DON'T PICK UP DUPLICATE PROPOSITIONS/DESCRIPTIONS FROM UNRELATED CONTEXTS

(clear-module "TEST")
(defmodule "TEST/TEMP-A")
(defmodule "TEST/TEMP-B")

(defconcept person (?x))
(defrelation parent ((?x person) (?y person)))
(defrelation child ((?x person) (?y person)))
(deffunction age ((?x person)) :-> (?a INTEGER))
(assert (person fred))
(assert (person susi))

(cc "TEST/TEMP-A")
(assert (parent fred susi))
(assert (= (age fred) 42))
(assert (forall (?x ?y) (=> (parent ?x ?y) (child ?y ?x))))
(cc "TEST/TEMP-B")
(assert (parent fred susi))
(assert (= (age fred) 42))
(assert (forall (?x ?y) (=> (parent ?x ?y) (child ?y ?x))))
(clear-module "TEST/TEMP-A")
;;; NOW THESE MUST STILL RETURN TRUE:
(ask (parent fred susi))
(ask (= (age fred) 42))
(ask (child susi fred))
(cc test)

;;; EQUALITY/FORWARD-INFERENCE PROBLEMS

(clear-module "TEST")
(defconcept person (?x))
(deffunction boss ((?x person)) :-> (?f person))
(defrelation employee-of ((?emp person) (?boss person)))

(assert (forall (?emp ?boss)
          (=> (employee-of ?emp ?boss)
              (= (boss ?emp) ?boss))))

(assert (person fred))
(assert (person frank))
(assert (person susi))

(assert (= (boss fred) (boss susi)))
(assert (employee-of fred frank))
;;; FIX: SHOULD RETURN FRANK
(retrieve ?x (= (boss susi) ?x))
;;; FIX: SHOULD RETURN FRANK
(retrieve ?x (= (boss fred) ?x))
;;; FIX: SHOULD RETURN FRANK
(retrieve ?x (= (boss susi) ?x))

;;; VARIANT: FIX DIFFERENT FORWARD-INF BEHAVIOR BETWEEN RULES THAT TURN
;;;    INTO IMPLIES PROPOSITIONS AND OTHER RULES:
(clear-module "TEST")
(defconcept person (?x))
(deffunction boss ((?x person)) :-> (?f person))
;;; THIS DOESN'T TURN INTO AN IMPLIES:
(defrelation has-employee ((?boss person) (?emp person)))

(assert (forall (?emp ?boss)
          (=> (has-employee ?boss ?emp)
              (= (boss ?emp) ?boss))))

(assert (person fred))
(assert (person frank))
(assert (person susi))

(assert (= (boss fred) (boss susi)))
(assert (has-employee frank fred))
;;; FIX: STILL DOESN'T RETURN FRANK
(retrieve ?x (= (boss susi) ?x))
(retrieve ?x (= (boss fred) ?x))
;;; BUT NOW IT DOES (ELABORATION ABOVE WASN'T GOOD ENOUGH)
(retrieve ?x (= (boss susi) ?x))

;;; INCREMENTAL RE-ELABORATION FOR META-ASSERTIONS:

(clear-module "TEST")
(defrelation foo (?x ?y))
(assert (symmetric foo))
(assert (reflexive foo))
(assert (foo a b))
;; THESE MUST BOTH BE TRUE:
(ask (foo b a))
(ask (foo b b))

(defrelation foo2 (?x ?y))
(assert (reflexive foo2))
;; THIS STILL WORKS:
(ask (foo2 a a))
(assert (symmetric foo2))
(assert (foo2 a b))
;; THIS MUST STILL BE TRUE (IT WASN'T ALWAYS):
(ask (foo2 b a))

;;; USING NON-ATOMIC RELATION TERMS:

(clear-module "TEST")
(deffunction rfn (?x) :-> (?v relation))
(deffunction ffn (?x) :-> (?v function))
(deffunction cfn (?x) :-> (?v class))

(assert ((rfn a) b))
(ask (relation (rfn a)))
(ask (class (rfn a)))
(ask (function (rfn a)))
(retrieve ?x (arity (rfn a) ?x))
(retrieve all ?x ((rfn a) ?x))

(assert ((ffn a) b c))
(ask (relation (ffn a)))
(ask (class (ffn a)))
(ask (function (ffn a)))
(retrieve ?x (arity (ffn a) ?x))
(retrieve all ?x ((ffn a) b ?x))

(assert ((cfn a) b))
(ask (relation (cfn a)))
(ask (class (cfn a)))
(ask (function (cfn a)))
(retrieve ?x (arity (cfn a) ?x))
(retrieve all ?x ((cfn a) ?x))

(assert (exists (?x) (= (rfn b) ?x)))
(ask (exists (?x) (= (rfn b) ?x)))
(assert (holds (rfn b) c))
(ask (exists (?x) (= (rfn b) ?x)))
(retrieve all ?x ((rfn b) ?x))

;;; DIFFERENT FUNCTION VALUES CAN HAVE DIFFERENT ARITIES:
(assert ((rfn c) d))
(retrieve ?x (arity (rfn c) ?x))
(assert ((rfn d) e f g))
(retrieve ?x (arity (rfn d) ?x))
;;; FIX: WE SHOULD GET AN ARITY VIOLATION HERE:
(assert ((rfn d) e f))
(retrieve ?x (arity (rfn d) ?x))

;;; PRIOR ASSERTION CAN CONTROL THE NATURE OF THE RELATION DESCRIPTION:
(assert (function (rfn e)))
(assert (variable-arity (rfn e)))
(assert ((rfn e) f g))
(ask (function (rfn e)))
(ask (variable-arity (rfn e)))
(retrieve ?x (arity (rfn e) ?x))
(retrieve all ?x ((rfn e) f ?x))

;;; DON'T LOSE ASSERTIONS DURING SURROGATIFICATION:
(assert ((cfn b) (rfn f)))
(assert ((rfn f) g))
(ask ((cfn b) (rfn f)))

;;; DIFFERENT SYNTAXES, MAKE SURE WE PROPERLY PICK UP DUPLICATES:
(assert (function (rfn g)))
(assert (= ((rfn g) h) x))
(assert ((rfn g) h x))
(assert (= (value (rfn g) h) x))
(assert (value (rfn g) h x))
;;; WE SHOULD ONLY SEE ONE FUNCTION PROP HERE:
(all-facts-of "X")

(assert (= ((ffn g) h) y))
(assert ((ffn g) h y))
(assert (= (value (ffn g) h) y))
(assert (value (ffn g) h y))
;;; WE SHOULD ONLY SEE ONE FUNCTION PROP HERE:
(all-facts-of "Y")

(assert (= ((ffn h) i) j))
(assert (= (value (ffn h) i) j))
(assert ((ffn i) j ((ffn h) i)))
(assert ((ffn i) j (value (ffn h) i)))
;;; THIS MUST ONLY RETURN ONE SOLUTION:
(retrieve all ?x ((ffn i) j ?x))

;;; RULES:
(assert (forall (?x ?y)
          (=> ((rfn h) ?x ?y)
              ((rfn i) ?y ?x))))
(assert ((rfn h) i j))
(ask ((rfn i) j i))

(assert (forall (?x ?y)
          (=> (= ((ffn j) ?x) ?y)
              (= ((ffn k) ?y) ?x))))
(assert (= ((ffn j) a) b))
(assert (= ((ffn j) c) d))
(ask (= ((ffn k) b) a))
(retrieve all (?x ?y) (= ((ffn k) ?x) ?y))

;;; GENERATING `SETOF' ELEMENTS FROM EQUIVALENT SKOLEMS:

(clear-module "TEST")

(defconcept person)
(deffunction friends ((?p person)) :-> (?f set))

(assert (= (setof hans franz) (friends fred)))
(assert (= (friends hans) (setof fred franz)))

;;; TRY BOTH ARGUMENT ORDERS:
(retrieve all ?f (member-of ?f (friends fred)))
(retrieve all ?f (member-of ?f (friends hans)))

;;; PROPER HANDLING OF FULLY GROUND FUNCTION TERMS IN `INHERIT-DESCRIPTION':

(clear-module "TEST")

(defconcept person)
(deffunction friends ((?p person)) :-> (?f set))

;;; USES FULLY GROUND TERM `(friends hans)', WE DON'T WANT ITS OUTPUT TO
;;;    BECOME SKOLEMIZED, INSTEAD WE WANT TO USE THE FUNCTION OUTPUT SKOLEM:
(defconcept friend-of-hans (?x)
            :<<=>> (member-of ?x (friends hans)))

(defconcept has-hans-as-friend (?x)
            :<<=>> (member-of hans (friends ?x)))

(assert (person hans))
(assert (person otto))
(assert (person karl))
(assert (friend-of-hans otto))
(assert (has-hans-as-friend karl))

(ask (friend-of-hans otto))
(ask (has-hans-as-friend karl))

;;; THIS MUST RETURN `(FRIENDS HANS)', NOT AN ANONYMOUS SKOLEM:
(retrieve all ?x (member-of otto ?x))
(retrieve all ?x (member-of hans ?x))

;;; PROPER COMBINATION OF SUBRELATION LINKS AND RULES:

(clear-module "TEST")

(defrelation sibling-of (?x ?y))
(defrelation brother-of (?x ?y))
(defrelation son-of (?x ?y))

(assert (forall (?x ?y)
          (=> (brother-of ?x ?y)
              (sibling-of ?x ?y))))

(assert (forall (?x ?y ?f)
          (=> (and (son-of ?x ?f)
                   (son-of ?y ?f)
                   (not (= ?x ?y)))
              (brother-of ?x ?y))))

(assert (son-of hans dad))
(assert (son-of franz dad))

;;; THIS SHOULD RETURN TRUE:
(ask (sibling-of hans franz))

;;; SUBSUMPTION TESTS AND INTERVAL UNIFICATION:

(clear-module "TEST")

(defconcept person)
(deffunction age ((?x person)) :-> (?y integer))
(defconcept teenager ((?x person)) :<=> (and (person ?x)
                                             (< (age ?x) 20)
                                             (> (age ?x) 12)))

(assert (and (person mike) (age mike 15)))
(ask (teenager mike))

;;; SHOULD BE TRUE - CURRENTLY FAILS BECAUSE OF A STUPID ANTECEDENT
;;; TYPE CHECK FAILURE; SETTING `*type-check-strategy*' TO :NONE FIXES IT:
(ask (forall ?x (=> (and (person ?x)
                         (< (age ?x) 20)
                         (> (age ?x) 12))
                    (teenager ?x))))
;;; SHOULD BE TRUE:
(ask (subset-of (kappa (?x)
                  (and (person ?x)
                       (< (age ?x) 20)
                       (> (age ?x) 12)))
                teenager))

;;; SHOULD BE TRUE:
(ask (forall ?x (=> (and (person ?x)
                         (< (age ?x) 20)
                         (> (age ?x) 15))
                    (teenager ?x))))
;;; SHOULD BE TRUE:
(ask (subset-of (kappa (?x)
                  (and (person ?x)
                       (< (age ?x) 20)
                       (> (age ?x) 15)))
                teenager))

;;; THIS SHOULD RETURN FALSE OR AT LEAST UNKNOWN:
(ask (forall ?x (=> (and (person ?x)
                         (< (age ?x) 23)
                         (> (age ?x) 15))
                    (teenager ?x))))
;;; THIS SHOULD RETURN FALSE OR AT LEAST UNKNOWN:
(ask (subset-of (kappa (?x)
                  (and (person ?x)
                       (< (age ?x) 23)
                       (> (age ?x) 15)))
                teenager))

;;; INVERSE VALUE CLASH:

(clear-module "TEST")

(defconcept person)
(deffunction age ((?x Person)) :-> (?y number))

(assert (age Jeff 42))

(ask (age Jeff 21))
;;; FIX: THIS SHOULD BE TRUE:
(ask (not (age Jeff 21)))

;;; PROPER OPTIMIZATION OF HOLDS GOALS:

(clear-module "TEST")

(defconcept meta-property)
(defconcept extensional)
(defconcept entity)

(defconcept extensional-p (?p)
            :<=> (and (meta-property ?p)        
                      (forall ?x
                        (=> (and (entity ?x)
                                 (?p ?x))
                            (extensional ?x)))))

(defconcept test-class (?x entity)
            :axioms (extensional-p test-class))

(assert (test-class fred))

;;; THESE SHOULD ALL RETURN TRUE:
(ask (extensional fred))
(ask (holds test-class fred))
(ask (extensional fred))

;;; PROPER HANDLING OF INEQUALITY RETRACTION

(clear-module "TEST")

(deffunction age (?p) :-> (?a integer))

(assert (< (age bill) 12))
(assert (> (age bill) 10))

;;; SHOULD RETURN 11:
(retrieve ?x (= (age bill) ?x))

(retract (< (age bill) 12))

;;; SHOULD RETURN THE SKOLEM ONLY:
(retrieve ?x (= (age bill) ?x))

;;; TEST CLASH WITH ENUMERATED SETS VIA MEMBER-OF EVALUATOR:

(clear-module "TEST")

(defconcept Primary-Color (?c)
  :<<=>> (member-of ?c (setof Red Green Blue)))

(deffunction favorite-color (?x ?y))

(assert (primary-color red))
(assert (primary-color (favorite-color joe)))

;;; SHOULD GENERATE 4 SOLUTIONS:
(retrieve all (?x) (Primary-Color ?x))

(assert (primary-color pink))

;;; SHOULD GENERATE 5 SOLUTIONS AND A CLASH:
(retrieve all (?x) (Primary-Color ?x))

;;; REDEFINITION TESTS

(clear-module "TEST")

(defconcept A
  :documentation "doc"
  :synonym A-SYN)

(defrelation r (?x))
(assert (r a))
(assert (synonym a a-syn2))

(retrieve all ?x (documentation a ?x))
(retrieve all ?x (documentation a-syn ?x))
(retrieve all ?x (documentation a-syn2 ?x))
(ask (r a))

(defconcept A
  :documentation "doc2")

(retrieve all ?x (documentation a ?x))
(retrieve all ?x (documentation a-syn ?x))
(retrieve all ?x (documentation a-syn2 ?x))
(ask (r a))

(defproposition P (r foo)
  :documentation "doc"
  :synonym P-SYN)

(assert (r p))
(assert (synonym p p-syn2))

(retrieve all ?x (documentation p ?x))
(retrieve all ?x (documentation p-syn ?x))
(retrieve all ?x (documentation p-syn2 ?x))
(ask (r p))

(defproposition P (r foo)
  :documentation "doc2")

(retrieve all ?x (documentation p ?x))
(retrieve all ?x (documentation p-syn ?x))
(retrieve all ?x (documentation p-syn2 ?x))
(ask (r p))

;;; TEST AGAIN BUT BEFORE A's AXIOMS ARE FINALIZED:

(clear-module "TEST")

(defconcept A
  :documentation "doc"
  :synonym A-SYN)

(defrelation r (?x))
(assert (r a))
(assert (synonym a a-syn2))

(defconcept A
  :documentation "doc2")

(retrieve all ?x (documentation a ?x))
(retrieve all ?x (documentation a-syn ?x))
(retrieve all ?x (documentation a-syn2 ?x))
(ask (r a))

(defproposition P (r foo)
  :documentation "doc"
  :synonym P-SYN)

(assert (r p))
(assert (synonym p p-syn2))

(defproposition P (r foo)
  :documentation "doc2")

(retrieve all ?x (documentation p ?x))
(retrieve all ?x (documentation p-syn ?x))
(retrieve all ?x (documentation p-syn2 ?x))
(ask (r p))

;;; TEST PROPER REDEFINITION OF SATELLITE RULES:

(clear-module "TEST")

(defrelation r (?x ?y))
(defrelation s (?x ?y))

(defproposition p1 (=> (r ?x ?y) (s ?y ?x))
  :backward-only? true)

(assert (r a b))
(ask (s b a))

(unset-feature just-in-time-inference)

(defproposition p1 (=> (r ?x ?y) (s ?y ?x))
  :forward-only? true)

;;; SHOULD BE UNKNOWN:
(ask (s b a))

(set-feature just-in-time-inference)

;;; SHOULD BE TRUE:
(ask (s b a))

;;; TEST INSTANTIATION OF DESCRIPTIONS WITH EXTERNAL VARIABLES:

(clear-module "TEST")

(defrelation brother (?x ?y)
  :closed true)

(assert (and (brother fred joe)
             (brother fred john)
             (brother susi fred)))

;;; SHOULD RETURN FRED AND 2:
(retrieve all (?x ?c)
          (and (brother susi ?x)
               (= (cardinality (setofall (?f) (brother ?x ?f))) ?c)))
;;; SHOULD RETURN FRED AND 2:
(retrieve all (?c ?x)
          (and (brother susi ?x)
               (= (cardinality (setofall (?f) (brother ?x ?f))) ?c)))

;;; FORWARD-INSTANTIATING FUNCTION RULES:

(clear-module "TEST")

(deffunction r (?x ?y) :<=> (s ?y ?x))
(deffunction s (?x ?y) :<=> (r ?y ?x))

(assert (r fred wilma))
(assert (r barney betty))

;;; SHOULD GENERATE 2 SOLUTIONS AND NOT BREAK WITH EVER GROWING FN TERMS
;;; BY PROPERLY INSTANTIATING ON THE VALUES INSTEAD OF THE OUTPUT SKOLEMS:
(retrieve all (s ?x ?y))

;;; TEST MEMBER-OF ON DESCRIPTION ARGUMENTS:

(clear-module "TEST")

;;; SHOULD GENERATE 3 SOLUTIONS EACH:
(retrieve 3 (member-of ?super
                       (setofall ?x
                         (superrelation concept ?x))))

(retrieve all (member-of ?x (kappa (?y) (member-of ?y (setof "a" "b" "c")))))

;;; TEST CASES FOR UNASSERT & RETRACT:

(clear-module "TEST")

(defrelation happy (?x))
(deffunction father (?x ?y))

(assert (happy fred))
(unassert (happy fred))
(ask (happy fred))

(assert (not (happy fred)))
(unassert (happy fred))
(ask (not (happy fred)))

(assert (happy fred))
(unassert (not (happy fred)))
(ask (happy fred))

(assert (happy fred))
(assert (happy joe))
(unassert (and (happy fred) (happy joe)))
(ask (happy fred))
(ask (happy joe))

(assert (not (happy fred)))
(assert (happy joe))
(unassert (and (happy fred) (happy joe)))
(ask (not (happy fred)))
(ask (happy joe))

;;; UNASSERTING CONTRADICTIONS:
(assert (happy fred))
(assert (not (happy fred)))
(ask (happy fred))
(unassert (happy fred))
(ask (happy fred))
(assert (happy fred))
(ask (happy fred))
(assert (not (happy fred)))
(ask (happy fred))
(unassert (not (happy fred)))
(ask (happy fred))
(assert (happy fred))
(ask (happy fred))

(assert (= (father fred) dad))
(unassert (= (father fred) dad))
(ask (= (father fred) dad))

;;; FIXED RETRACTION BUG WITH TWO FUNCTION PROPOSITION WITH SAME VALUE:
(assert (= (father fred) dad))
(assert (= (father joe) dad))
(retract (= (father fred) dad))
(ask (= (father fred) dad))

(assert (= (father fred) dad))
(assert (= (father joe) dad))
(retract (= (father joe) dad))
(ask (= (father joe) dad))

(assert (= (father fred) dad))
(assert (= (father joe) dad))
(unassert (= (father fred) dad))
(ask (= (father fred) dad))

(assert (= (father fred) dad))
(assert (= (father joe) dad))
(unassert (= (father joe) dad))
(ask (= (father joe) dad))

;;; TESTS A BUG WITH PARTIAL-MATCHED OR'S IF THE LAST SUBGOAL WAS
;;; A COMPOUND GOAL (SUCH AS AN AND) THAT FAILED:

(clear-module "TEST")

(defconcept a)
(defconcept b)
(assert (and (a b1) (a b2) (a b3)))

(ask-partial
 (OR (b a1)
     (and (b a2)
          (b a3)))
 :match-mode :whynot-deep :minimum-score 0.0)

;;; 3-VALUED TRUTH-VALUE PROPAGATION

(clear-module "TEST")

(defrelation happy (?x))

(assert (not (happy joe)))
(assert (not (happy susi)))

(ask (and (happy joe) (happy fred)))
;; UNKNOWN OK:
(ask (and (happy fred) (happy joe)))
;; SHOULD BOTH BE TRUE:
(ask (not (and (happy fred) (happy joe))))
(ask (and (happy fred) (happy joe)) :three-valued? true)

;; SHOULD ALL BE UNKNOWN:
(ask (or (happy fred) (happy joe)))
(ask (or (happy fred) (happy joe)) :inference-level :refutation)
(ask (or (happy joe) (happy fred)))
(ask (or (happy joe) (happy fred)) :inference-level :refutation)
;; SHOULD BE FALSE:
(ask (or (happy joe) (happy susi)))

;;; SIMPLE REASONING BY CASES

(clear-module "TEST")

(defconcept person)
(defconcept man (person))
(defconcept woman (person))

(assert (or (man fred) (woman fred)))

;;; SHOULD RETURN TRUE:
(ask (person fred) :inference-level :refutation)

;;; SHOULD RETURN FRED:
(retrieve (person ?x) :inference-level :refutation)

;;; DISJUNCTIONS, REASONING BY CASES

(clear-module "TEST")

(defconcept human)
(defconcept male)
(defconcept female)
(defconcept person(?x)
  :<=> (AND (human ?x) (OR (male ?x) (female ?x))))
(defconcept man(?x)
  :<=> (AND (human ?x) (male ?x)))
(defconcept woman(?x)
  :<=> (AND (human ?x) (female ?x)))
(defconcept gender(?x)
  :<=> (OR (male ?x)(female ?x)))

;;; NEED NATURAL DEDUCTION MODE TURNED OFF TO MAKE THESE
;;; WORK, SINCE WE NEED THE CONTRAPOSITIVE RULES:

(ask (subset-of person (kappa ?o (OR (man ?o) (woman ?o))))
     :inference-level :refutation)

;;; SHOULD RETURN TRUE BUT DOESN'T, SINCE WE CAN'T REASON BY
;;; CASES TO FIGURE OUT (HUMAN ?O):
(ask (subset-of (kappa ?o (OR (man ?o) (woman ?o))) person)
     :inference-level :refutation)

(ask (subset-of (kappa ?o (AND (human ?o) (OR (man ?o) (woman ?o)))) person)
     :inference-level :refutation)

(ask (subset-of person gender)
     :inference-level :refutation)

;;; QUERIES ON SUBTYPES OF LITERALS
;;; (ONLY WORKS WITH `*backlink-all-proposition-arguments?*' TURNED ON!!):

(clear-module "TEST")

(defconcept nice-integer (integer))
(defrelation nice-integer-pair ((?x nice-integer) (?y nice-integer)))

(assert (nice-integer 13))
(assert (nice-integer 15))

(ask (nice-integer 13))
(ask (nice-integer 15))
(retrieve all (nice-integer ?x))

(assert
  (=> (and (nice-integer ?x)
           (nice-integer ?y))
      (nice-integer-pair ?x ?y)))

(ask (nice-integer-pair 13 15))
(retrieve all (nice-integer-pair ?x ?y))

;;; HOLDS PROPOSITIONS WITH KAPPA ARGUMENTS

(clear-module "TEST")

(defconcept a)
(defconcept b)
(defrelation r (?x ?y))

(assert (holds (kappa (?x) (and (a ?x) (b ?x))) fred))
(ask (and (a fred) (b fred)))

(assert (holds (kappa (?x ?y) (and (a ?x) (b ?y) (r ?x ?y))) joe susi))
(ask (and (a joe) (b susi) (r joe susi)))

(assert (=> (r ?x ?y) (holds (kappa (?s ?t) (and (a ?s) (b ?t))) ?x ?y)))
(assert (r foo bar))
(ask (and (a foo) (b bar)))

;;; SUBSUMPTION WITH CONSTANT-ARG RELATIONS (ARGOS BUG)

(clear-module "TEST")

(defconcept GEO)

(assert (GEO g_LA))
(assert (GEO g_LACMSA))
(assert (GEO g_CA))

(defrelation geoPartOf ((?x GEO) (?y GEO))
  :transitive TRUE)

(assert (geopartof g_LA g_LACMSA))
(assert (geopartof g_LACMSA g_CA))

(defrelation r1 ((?point_id GEO) (?county_id GEO) (?taz GEO))  :<=>
  (and 
   (geoPartOf ?point_id ?taz)
   (geoPartOf ?taz ?county_id)
   (geoPartOf ?county_id g_LACMSA)))

(defrelation r2 ((?point_id GEO) (?county_id GEO) (?taz GEO)) :<=>
  (and 
   (geoPartOf ?point_id ?taz)
   (geoPartOf ?taz ?county_id)
   (= ?county_id g_LA)))

(defrelation r3 ((?point_id GEO) (?county_id GEO) (?taz GEO)) :<=>
  (and 
   (geoPartOf ?point_id ?taz)
   (geoPartOf ?taz ?county_id)
   (member-of ?county_id (setof g_LA))))

(ask (subset-of r2 r1))
;;; THIS SHOULD ALSO RETURN TRUE, BUT WE ARE NOT QUITE SMART ENOUGH TO
;;; INFER THE EQUALITY CONSTRAINT FROM THE SINGLETON SET - MAYBE LATER:
(ask (subset-of r3 r1))

;;; OCT-13-2005 EQUALITY REASONING BUG

(clear-module "TEST")

(deffunction f (?x ?y))
(defconcept a)
(defconcept b)
(defconcept c (?x) :<=> (and (a ?x) (b ?x)))

(assert (a (f x)))
(assert (b (f y)))
(assert (= (f x) (f y)))

(retrieve all (c ?x))
;;; THIS SHOULD RETRIEVE THE SAME NUMBER OF ANSWERS AS THE PREVIOUS
;;; QUERY:
(retrieve all (c ?x))

;;; SKOLEMS IN ASSERTED DESCRIPTIVE PROPOSITIONS

(clear-module "TEST")

(defrelation r (?x ?y))
(defrelation s (?x ?y))
(defrelation t (?x ?y))

(assert (=> (r ?x ?y) (exists ?z (s ?x ?z))))
(assert (=> (s ?x ?z) (forall ?e (=> (t ?e ?z) (t ?z ?e)))))
(assert (r a b))

;;; THIS WILL GENERATE A SKOLEM WHICH WILL BECOME PART OF A FORALL
;;; PROPOSITION; THIS SHOULD NOT CREATE ANY ERRORS OR WARNINGS:
(run-forward-rules "TEST")

(retrieve all (s ?x ?y))

;;; TESTS A BUG IN LOGICAL-TYPE WITH CONSTANTS THAT ARE STELLA CLASSES

(clear-module "TEST")

(defrelation r (?x (?y string)))
(defconcept c (?self) :=> (range-type r ?self string))

;;; THIS SHOULD NOT GENERATE ANY ERRORS OR WARNINGS:
(process-definitions)

;;; NEW BUG IN FORARD INFERENCE WITH PSYASE AND NEW FIXES:
;;; THE PROBLEM IS THAT WE ARE NOW INVERTING THE PREDICATE
;;; ASSERTION, SINCE DURING INHERITANCE WE ARE PICKING UP
;;; AN EXISTING PROPOSITION WITH FIND-SIMILAR-PROPOSITION
;;; WHICH LATER ON WITH OUR IMPROVED NORMALIZATION GETS
;;; INVERTED WHICH IS BAD...
;;; ALSO, ONCE WE FIX THIS, THESE RIDICULOUS RULES ALSO NEED
;;; TO GET ELIMINATED...

(clear-module "TEST")

(deffunction predicate (?self ?value))

(deffunction myarity (?self (?value integer)))

(assert
  (forall (?v7134 ?v)
    (=>> (= (myarity ?v7134) ?v)
         (or (not (= ?v7134 Phychsim6_Instance_10020))
             (integer ?v)))))

(assert (myarity Phychsim6_Instance_10020 2))
(assert (predicate Phychsim6_Instance_1 Phychsim6_Instance_10020))

(run-forward-rules TEST :force)

;;; NORMALIZATION TEST CASES:

(clear-module "TEST")

(conceive (and))
(conceive (or))
(conceive (not))

(conceive (and (relation relation)))
(conceive (or (relation relation)))

(defrelation r1 ((?x relation) (?y relation)))
(defrelation r2 (?x ?y) :<=> (r1 ?y ?x))
(defrelation r3 (?x ?y) :<=> (and (r1 ?y ?x) (= ?x ?y)))

(process-definitions)

(print-rules r1)
(print-rules r2)
(print-rules r3)

;;; THIS SHOULD NOT PICK UP `r1':
(conceive
 (kappa (?x ?y)
   (and (r1 ?x ?y) (= ?x ?y))))

;;; THIS SHOULD:
(conceive
 (kappa (?x  ?y)
   (and (r1 ?x ?y))))

;;; THIS SHOULD:
(conceive
 (kappa ((?x relation) (?y relation))
   (and (r1 ?x ?y))))

;;; THIS SHOULD NOT PICK UP `not-r1':
(conceive
 (kappa (?x ?y)
   (and (not (r1 ?x ?y)) (= ?x ?y))))

;;; THIS SHOULD:
(conceive
 (kappa (?x  ?y)
   (and (not (r1 ?x ?y)))))

;;; THIS SHOULD:
(conceive
 (kappa ((?x relation) (?y relation))
   (and (not (r1 ?x ?y)))))

;;; FORWARD INFERENCE BUG:

(clear-module "TEST")

(defrelation r1 (?x ?y))
(defrelation r2 (?x ?y))

(assert (=>> (and (= ?x ?y)
                  (r1 ?x ?y))
             (r2 ?x ?y)))

(assert (r1 a b))

;;; THIS SHOULD NOT CONTAIN `(r2 a a)':
(all-facts-of a)

;;; FUNCTION SINGLE-VALUEDNESS ISSUE WHEN WE COULD RETRIEVE
;;; A SECOND VALUE THAT IS EQUATABLE TO AN ASSERTED ONE:

(clear-module "TEST")

(deffunction father (?x ?y))
(defrelation parent (?x ?y))
(defrelation male (?x))

(assert
  (=> (and (parent ?c ?p)
           (male ?p))
      (father ?c ?p)))

(assert (father fred (father joe)))
(assert (parent fred fritz))
(assert (male fritz))

;;; SHOULD GET FRITZ BUT DOESN'T BECAUSE WE STOP AT THE ASSERTED VALUE:
(retrieve all (father fred ?f))

;;; GETS FRITZ BECAUSE WE DON'T SHORTCUT, SINCE NOT ALL KEY ARGS ARE BOUND:
(retrieve all (father ?c ?f))

;;; SAME AS ABOVE BUT SWITCH ASSERTED INDIVIDUALS:

(clear-module "TEST")

(deffunction father (?x ?y))
(defrelation parent (?x ?y))
(defrelation male (?x))

(assert
  (=> (and (parent ?c ?p)
           (male ?p))
      (father ?c ?p)))

(assert (father fred fritz))
(assert (parent fred (father joe)))
(assert (male (father joe)))

;;; SAME ISSUE, JUST THE OTHER WAY ROUND:
(retrieve all (father fred ?f))
(retrieve all (father ?c ?f))

;;; BUG WHERE WE BROKE ON CALLING `ARGUMENT-BOUND-TO'
;;; ON AN INTERNAL VARIABLE THAT DIDN'T HAVE AN OFFSET:

(clear-module "TEST")

(defrelation v1 (?student ?number ?year))
(defrelation v2 (?student ?dept ?course))

(ask (subset-of (kappa (?s ?d)
                  (exists (?n ?y ?c)
                    (and (v1 ?s ?n ?y)
                         (v2 ?s ?d ?c)
                         (>= ?y 1995))))
                (kappa (?s ?d)
                  (exists (?n ?y ?c)
                    (and (v1 ?s ?n ?y)
                         (v2 ?s ?d ?c)
                         (>= ?y 1990))))))

;;; FIX: INCORRECT NORMALIZATION OF FUNCTION-INDUCED EXISTENTIALS
;;; KNOWN BUG (SEE `invert-proposition'):

(clear-module "TEST")

(defrelation happy (?x))
(defrelation poor (?x))
(deffunction boss (?x ?y))

(assert (=>> (poor ?x) (not (happy ?x))))

;;; THIS RETURNS FALSE AS IT SHOULD - NOT ANYMORE, SINCE WE "FIXED" OR-INTRODUCTION
;;; TO NOT PROPAGATE UP FALSITY OF THE TO-BE-PROVEN DISJUNCT:
(ask (=> (poor fred)
         (happy fred))
     :inference-level :refutation)

;;; THIS FAILS DUE TO INCORRECT NORMALIZATION:
(ask (=> (poor (boss fred))
         (happy (boss fred)))
     :inference-level :refutation)

;;; THIS IS HOW IT SHOULD NORMALIZE BUT POWERLOOM'S NORMALIZATION
;;; OF FUNCTION-INDUCED EXISTENTIALS SCREWS US UP REGARDLESS:

(ask (=> (exists (?b)
           (and (= (boss fred) ?b)
                (poor ?b)))
         (exists (?b)
           (and (= (boss fred) ?b)
                (happy ?b))))
     :inference-level :refutation)

;;; "PROVING" THE IMPLICATION VIA EXPLICIT ASSERTION DOES DO THE RIGHT THING:
(assert (exists (?b)
          (and (= (boss fred) ?b)
               (poor ?b))))
;;; RETURNS FALSE AS IT SHOULD:
(ask (exists (?b)
           (and (= (boss fred) ?b)
                (happy ?b)))
     :inference-level :refutation)

;;; DUPLICATE RULE DETECTION DEFICIENCY, SINCE WE ARE CURRENTLY ONLY
;;; SUCCEEDING IF THE QUANTIFIED VARIABLES IN THE TWO RULES LINE UP.
;;; TO FIX THIS WE HAVE TO DO SOMETHING MORE LIKE UNIFICATION AND ALSO
;;; ALLOW BACKTRACKING, SINCE ESTABLISHING A BINDING MIGHT MAKE US
;;; FAIL LATER - IN THE WORST CASE WE ARE DOING SUBGRAPH ISOMORPHISM HERE:

(clear-module "TEST")

(assert
  (forall (?x ?y)
    (=> (and (relation ?x)
             (relation ?y))
        (bound-variables ?x ?y))))

;;; THIS SHOULD RETURN THE PREVIOUS RULE BUT DOESN'T:

(assert
  (forall (?t ?s)
    (=> (and (relation ?s)
             (relation ?t))
        (bound-variables ?s ?t))))

;;; IMPROVED HOLDS SPECIALIST:

(clear-module "TEST")

(defrelation r (?x ?y))
(defrelation s (?x ?y))

(assert (r a b))
(assert (s a c))

(retrieve all (holds ?r a ?x))
(retrieve all (holds ?r a b))
(retrieve all (holds ?r a c))

;;; SHALLOW DISPROOF OF FUNCTION PROPOSITIONS AND SINGLE-VALUED RELATIONS

(clear-module "TEST")

(deffunction f (?x ?y))
(defrelation r (?x ?y))

(assert (f a b))
(assert (not (f c d)))

(assert (r a b))
(assert (not (r c d)))

(ask (f a b))
(ask (not (f a b)))
(ask (f a c))
(ask (not (f a c)))
(ask (f c d))
(ask (not (f c d)))
(ask (f c e))
(ask (not (f c e)))

(ask (r a b))
(ask (not (r a b)))
(ask (r a c))
(ask (not (r a c)))
(ask (r c d))
(ask (not (r c d)))
(ask (r c e))
(ask (not (r c e)))

(assert (single-valued r))

(ask (r a b))
(ask (not (r a b)))
(ask (r a c))
(ask (not (r a c)))
(ask (r c d))
(ask (not (r c d)))
(ask (r c e))
(ask (not (r c e)))

;;; AVOID FORWARD INFERENCE OF REDUNDANT EXISTENTIALS AND SKOLEMS:

(clear-module "TEST")

(defconcept parent)
(defrelation happy (?p))
(deffunction father (?c ?f))
(deffunction mother (?c ?m))

(assert (=>> (parent ?p)
             (exists (?c ?m ?f)
               (and (father ?c ?f)
                    (mother ?c ?m)
                    (or (= ?p ?f)
                        (= ?p ?m))
                    (happy ?p)
                    (happy (mother ?p))
                    (happy (father ?f))))))

;; TRIGGERS THE RULE:
(assert (parent mom))
;; implies the existential:
(assert (and (father fred dad)
             (mother fred mom)
             (happy (father dad))))

;;; TRIGGER FORWARD INFERENCE:
(process-definitions)
(all-facts-of mom)

;;; WE SHOULD ONLY GET ONE SOLUTION HERE AND NO SKOLEM:
(retrieve all (father fred ?x))

;;; ADDITIONAL FACTS WE INFERRED:
(retrieve all (and (happy ?p)
                   (happy (mother ?p)))
          :inference-level :assertion)


;;; FORWARD EXISTENTIALS AND SINGLE-VALUEDNESS

(clear-module "TEST")

(deffunction father (?c ?f))
(deffunction mother (?c ?m))
(deffunction husband (?w ?h))

(assert (=>> (and (mother ?c ?m)
                  (husband ?m ?f))
             (father ?c ?f)))

(assert (exists ?f (father fred ?f)))
(assert (mother fred mom))
(assert (husband mom dad))

;; WE SHOULD NOT GET ANY CLASHES HERE AND RETRIEVE DAD,
;; NOT THE SKOLEM WHICH SHOULD BE POINTING AT DAD INSTEAD:
(retrieve all (father fred ?x))

;;; NOW TRY THE SAME WITH SINGLE-VALUED RELATIONS:

(clear-module "TEST")

(defrelation father (?c ?f) :single-valued TRUE)
(defrelation mother (?c ?m) :single-valued TRUE)
(defrelation husband (?w ?h) :single-valued TRUE)

(assert (=>> (and (mother ?c ?m)
                  (husband ?m ?f))
             (father ?c ?f)))

(assert (exists ?f (father fred ?f)))
(assert (mother fred mom))
(assert (husband mom dad))

;; WE SHOULD NOT GET ANY CLASHES HERE AND RETRIEVE DAD,
;; NOT THE SKOLEM WHICH SHOULD BE POINTING AT DAD INSTEAD:
(retrieve all (father fred ?x))


;;; GOAL CACHING BUG WITH DESCRIPTION ARGUMENTS THAT HAVE EXTERNAL VARIABLES:

(clear-module "TEST")

(defconcept person)

(defrelation friend-of ((?p person) (?f person))
  :closed TRUE)

(defconcept person-with-at-most-one-friend ((?p person))
  :<=> (exists (?f ?c)
         (and (friend-of ?p ?f)
              (bound-variables ?p)
              ;; if we cache this without taking the particular binding of
              ;; ?p into account, we get additional incorrect solutions:
              (cardinality (setofall (?p2) (friend-of ?p ?p2)) ?c)
              (=< ?c 1))))

(assert
  (and (friend-of fred f1)
       (friend-of fred f2)
       (friend-of susi f1)
       (friend-of otto f1)
       (friend-of otto f2)))

;;; THIS SHOULD ONLY RETRIEVE ONE SOLUTION:
(retrieve all (person-with-at-most-one-friend ?p))


;;; COLLECT-INTO-SET THAT RUNS INTO CUTOFFS SHOULD FAIL JUST LIKE FAIL:

(clear-module "TEST")

;;; THIS SHOULD FAIL AND NOT DERIVE THE EMPTY SET:
(retrieve (cardinality (collect-into-set relation) ?c) :maximum-depth 5)

;;; THIS SHOULD SUCCEED:
(retrieve (cardinality (collect-into-set relation) ?c))


;;; FORK CONTINUATION ISSUES

(clear-module "TEST")

(defconcept y)
(defconcept n)

(assert (y y1))
(assert (y y2))
(assert (n n1))
(assert (n n2))

;;; SHOULD GENERATE FOUR SOLUTIONS:
(retrieve all (and (member-of ?r (setof relation minimum-value))
                   (bound-variables ?r)
                   (fork (concept ?r)
                         (y ?value)
                         (n ?value))))

;;; SHOULD GENERATE TWO SOLUTIONS (USED TO LOOP INDEFINITELY):
(retrieve all (and (member-of ?r (setof relation minimum-value))
                   (bound-variables ?r)
                   (fork (concept ?r)
                         (= ?value "yes")
                         (= ?value "no"))))


;;; DUPLICATE DESCRIPTION LOOKUP WITH EQUIVALENCED VARIABLES:

(clear-module "TEST")

;;; SHOULD GENERATE TWO SOLUTIONS:
(retrieve all (member-of ?d (setof (kappa (?x ?y ?z) true)
                                   (kappa (?a ?b ?a) true)
                                   (kappa (?c ?d ?c) true))))

;;; COLLAPSING OF EQUIVALENCES IN RULES:

(clear-module "TEST")

(deffunction f1 (?x ?y))
(deffunction f2 (?x ?y))
(deffunction tf1 (?x ?y) :total true)
(deffunction tf2 (?x ?y) :total true)

(defrelation r (?x))

(assert (= (tf1 a) (tf1 a)))
(assert (= (tf2 a) (tf2 a)))

(retrieve all (tf1 ?x ?y))
(retrieve all (tf2 ?x ?y))
(ask (= (tf1 a) (tf2 a)))

(assert
  (=>> (and (r ?x)
            (tf1 ?x ?y))
       (= ?y (tf2 ?x))))

(assert (r b))
(all-facts-of b)

(retrieve all (tf1 ?x ?y))
(retrieve all (tf2 ?x ?y))
(ask (= (tf1 b) (tf2 b)))

;;; THIS RULE USED TO BREAK DURING PARSING:
(assert
  (=>> (and (tf1 ?x ?v1)
            (tf2 ?x ?v2))
       (= ?v1 ?v2)))

(assert (tf1 c c))
(all-facts-of c)
(retrieve (tf2 c ?x))
;;; SHOULD RETURN TRUE:
(ask (= (tf1 c) (tf2 c)))

;;; A VARIANT OF THE BALANCED-SIBLINGS RULE THAT SHOULD
;;; COLLAPSE THE INTERNAL VARIABLES IN THE CONSEQUENT:

(assert
  (=>> (r ?x)
       (= (f1 ?x) (f2 ?x))))

(retrieve all (= (f1 b) ?x))

;;; THESE SHOULD ALL NORMALIZE TO THE SAME RULE:
(assert
  (=> (f2 ?x ?y)
      (exists (?z)
        (and (f2 ?y ?z)
             (= ?x ?z)))))
(assert
  (=> (f2 ?x ?y)
      (exists (?z)
        (and (f2 ?y ?z)
             (= ?z ?x)))))
(assert
  (=> (exists (?z)
        (and (f2 ?y ?z)
             (= ?x ?z)))
      (f2 ?x ?y)))
(assert
  (=> (exists (?z)
        (and (f2 ?y ?z)
             (= ?z ?x)))
      (f2 ?x ?y)))
;;; SHOULD RETURN ONE FORWARD AND ONE BACKWARD RULE:
(get-rules f2)

;;; HANDLING FUNCTIONS AND RELATIONS WITH PROPOSITION ARGUMENTS

(clear-module "TEST")

(deffunction age (?x ?y))

(deffunction f1 (?x (?p proposition)))
(deffunction f2 ((?p proposition) ?x))
(deffunction f3 (?x (?p proposition) ?y))

(assert (f1 a (age a 10)))
(assert (f2 (age b 12) b))
(assert (f3 c (age c 15) d))

;;; THESE SHOULDN'T BREAK, NOT CAUSE ANY ARGUMENT VIOLATIONS AND NOT
;;; RETURN ANY UNFASTENED PROPOSITIONS:
(retrieve all (f1 ?x ?y))
(retrieve all (f2 ?x ?y))
(retrieve all (f3 ?x ?y ?z))

;;; THIS SHOULD NOT BREAK:
(conceive (exists (?r)
            (fork (bound-variables ?r)
                  (relation ?r)
                  (relation (setofall ?s (listof ?r ?s))))))

;;; TOTAL FUNCTIONS ARE NOT NECESSARILY CLOSED

(clear-module "TEST")

(deffunction f (?x ?y) :total true)

;;; BOTH OF THESE NEED TO RETURN UNKNOWN:
(ask (f hans tom))
(ask (not (f hans tom)))

;;; CLOSED COLLECTIONS AND ITERATIVE FORALL

(clear-module "TEST")

;;; SHOULD BE TRUE:
(ask (forall ?n (=> (member-of ?n (setof 1 2 3)) (number ?n))))
;;; SHOULD BE TRUE:
(ask (forall ?r
       (=> (member-of ?r (setofall ?r (or (function ?r) (concept ?r))))
           (relation ?r))))
;;; SHOULD BE TRUE:
(ask (closed (setofall ?n (member-of ?n (setof 1 2 3)))))
;;; SHOULD BE FALSE:
(ask (closed (setofall ?n
               (exists (?e1 ?e2)
                 (and (member-of ?e1 ?n)
                      (member-of ?e2 ?n))))))

(defconcept person)
(deffunction siblings ((?p person) (?sibs SET))
  :closed true)

(assert (person fred))
(assert (person joe))
(assert (person susi))
(assert (siblings fred (setof joe susi)))

;;; CONCEIVABLY, THIS SHOULD RETURN TRUE, BUT IT WOULD REQUIRE US TO
;;; POTENTIALLY RUN FULL INFERENCE TO FIRST DETERMINE FRED'S SIBLINGS:
(ask (closed (setofall ?p (member-of ?p (siblings fred)))))

;;; WE CAN WORK AROUND THIS BY EXPLICITLY ASSERTING CLOSURE:
(assert (closed (setofall ?p (member-of ?p (siblings fred)))))
(ask (closed (setofall ?p (member-of ?p (siblings fred)))))

;;; FOR THE SAME REASONS AS ABOVE, THIS SHOULD RETURN TRUE, BUT IT
;;; CURRENTLY DOESN'T, SINCE WE DON'T FIND THE ANTECEDENT TO BE CLOSED:
(ask (forall ?p
       (=> (member-of ?p (siblings fred))
           (person ?p))))

;;; THIS FORMULATION, HOWEVER, DOES THE TRICK SINCE IT EXTRACTS THE
;;; GOAL NECESSARY TO INFER FRED'S SIBLINGS:
(ask (exists ?sibs
       (and (siblings fred ?sibs)
            (forall ?p
              (=> (member-of ?p ?sibs)
                  (person ?p))))))

;;; VARIABLE ARITY BUG IN `COPY-PATTERN-ARGUMENTS':

(clear-module "TEST")

(defconcept c)
(defconcept d (?x)
  :<=> (and (c ?x)
            (bound-variables ?x)))

;;; THIS SHOULD NOT BREAK, THE WARNING SHOULD ALSO EVENTUALLY GO AWAY:
(retrieve all (not (d ?x)))

;;; IMPROVED JIT CONTEXT AND NESTED FUNCTION TERM EVALUATION:

(clear-module "TEST")

(deffunction age (?p ?a))

(assert (age fred 10))
(assert (age joe 15))
(assert (age susi (+ (age fred) (age joe))))

(ask (< (age fred) (age susi)))

(assert (age joe 0))
(ask (< (age fred) (age susi)))

;;; THIS SHOULD TRIGGER A CLASH, NOT SURE WHY IT STILL DOESN'T:
(assert (+ 1 2 4))

;;; LIMITED DEPTH FORWARD SKOLEMIZATION:

(clear-module "TEST")

(defconcept c1)
(defconcept c2)
(defrelation r1 (?x ?y))
(defrelation r2 (?x ?y))

(assert (=>> (c1 ?x) (exists (?y) (and (r1 ?x ?y) (c2 ?y)))))
(assert (=>> (c2 ?x) (exists (?y) (and (r2 ?x ?y) (c1 ?y)))))

(assert (c1 fred))

(run-forward-rules pl-user)

;;; EACH SHOULD RETRIEVE 2 RESULTS; WE GET 3 SKOLEMS TOTAL AFTER
;;; WHICH FORWARD SKOLEMIZATION IS CUT OFF (BY DEFAULT):
(retrieve all (c1 ?x))
(retrieve all (c2 ?x))
(retrieve all (c1 ?x))
(retrieve all (c2 ?x))

;;; AN ARGOS KB AND QUERIES THAT WOULD CAUSE PROBLEMS IN THE PAST:

(clear-module "TEST")

(defconcept BASEOBJ)

(defconcept UNIT)
(ASSERT (UNIT MILES))
(ASSERT (UNIT KM))

(defconcept DISTANCE_MILES (?X NUMBER))
(defconcept DISTANCE_KM (?X NUMBER))

(defconcept PLACE)

(deffunction hasStartAddr ((?X BASEOBJ) (?Y PLACE)))
(deffunction hasEndAddr ((?X BASEOBJ) (?Y PLACE)))
(deffunction hasValue ((?X BASEOBJ) (?Y NUMBER)))
(deffunction hasUnit ((?X BASEOBJ) (?Y UNIT)))

(defconcept OBJ_MILES (?O) :<=>
  (EXISTS ((?S PLACE) (?E PLACE) (?V DISTANCE_MILES))
	  (AND (BASEOBJ ?O)
	       (hasStartAddr ?O ?S)
	       (hasEndAddr ?O ?E)
	       (hasUnit ?O MILES)
	       (hasValue ?O ?V))))

(defrelation REL_OBJ_MILES ((?S PLACE) (?E PLACE) (?V DISTANCE_MILES)) :<=>
  (EXISTS (?O)
	  (AND (OBJ_MILES ?O)
	       (hasStartAddr ?O ?S) (PLACE ?S)
	       (hasEndAddr ?O ?E) (PLACE ?E)
	       (hasValue ?O ?V) (DISTANCE_MILES ?V))))

(defconcept OBJ_KM (?O) :<=>
  (EXISTS ((?S PLACE) (?E PLACE) (?V DISTANCE_KM))
	  (AND (BASEOBJ ?O)
	       (hasStartAddr ?O ?S)
	       (hasEndAddr ?O ?E)
	       (hasUnit ?O KM)
	       (hasValue ?O ?V))))

(defrelation REL_OBJ_KM ((?S PLACE) (?E PLACE) (?V DISTANCE_KM)) :<=>
  (EXISTS (?O)
	  (AND (OBJ_KM ?O)
	       (hasStartAddr ?O ?S) (PLACE ?S)
	       (hasEndAddr ?O ?E) (PLACE ?E)
	       (hasValue ?O ?V) (DISTANCE_KM ?V))))

(defrelation DISTANCES ((?S PLACE) (?E PLACE)
			(?V1 DISTANCE_MILES) (?V2 DISTANCE_KM)) :<=>
  (EXISTS (?O1 ?O2)
	  (AND (OBJ_MILES ?O1)
	       (hasStartAddr ?O1 ?S) (PLACE ?S)
	       (hasEndAddr ?O1 ?E) (PLACE ?E)
	       (hasValue ?O1 ?V1) (DISTANCE_MILES ?V1)
	       (OBJ_KM ?O2)
	       (hasStartAddr ?O2 ?S)
	       (hasEndAddr ?O2 ?E)
	       (hasValue ?O2 ?V2) (DISTANCE_KM ?V2))))

(ASSERT (forall (?o ?s ?e ?v_miles)
           (<= (exists (?v_km)
                  (DISTANCES ?s ?e ?v_miles ?v_km))
               (and (OBJ_MILES ?o)
                    (= (hasStartAddr ?o) ?s)
                    (= (hasEndAddr ?o) ?e)
                    (= (hasValue ?o) ?v_miles)))))

(ASSERT (forall (?o ?s ?e ?v_km)
           (<= (exists (?v_miles)
                  (DISTANCES ?s ?e ?v_miles ?v_km))
               (and (OBJ_KM ?o)
                    (= (hasStartAddr ?o) ?s)
                    (= (hasEndAddr ?o) ?e)
                    (= (hasValue ?o) ?v_km)))))

(defrelation PROJ_MILES ((?S PLACE) (?E PLACE) (?V DISTANCE_MILES)) :<=>
  (EXISTS (?V2 DISTANCE_KM)
	  (DISTANCES ?S ?E ?V ?V2)))

;;; THIS SHOULD NOT CAUSE INFINITE FORWARD SKOLEMIZATION:
(retrieve all (and (subset-of ?x BASEOBJ) (subset-of OBJ_MILES ?x)))

;; THESE SHOULD BOTH RETURN TRUE:
(ask (subset-of proj_miles REL_OBJ_MILES))
(ask (subset-of REL_OBJ_MILES proj_miles))

;;; BUGS DUE TO INCONSISTENT LITERAL ARGUMENT BACKLINKING/REWRAPPING

(clear-module "TEST")

(defconcept individual)

(deffunction individual-fn ((?namespace STRING) (?localname STRING)) :-> (?i individual))

(defrelation name ((?i INDIVIDUAL) (?n STRING)))

(assert (name (individual-fn "saso" "doctor") "Dr. Perez"))
(assert (= (individual-fn "saso" "doctor") (individual-fn "saso" "perez")))

(retrieve all (name (individual-fn "saso" "perez") ?n))
;; => There is 1 solution:
;;      #1: ?N="Dr. Perez"

(retrieve all (name (individual-fn "saso" "doctor") ?n))
;; => There is 1 solution:
;;      #1: ?N="Dr. Perez"

;;; BUG WITH CONTEXT SWITCHING OF IST OPERATOR WHERE SUBGOAL HAS
;;; MULTIPLE SOLUTIONS - EXTRACT OF THE BUSINESS DEMO

(clear-module "TEST")

(defconcept company)

(defrelation company-name ((?c company) (?name STRING)))

(assert (company-name ACME-cleaners "ACME Cleaners, LTD"))
(assert (company-name megasoft "MegaSoft, Inc."))

(defrelation fictitious-business-name ((?c company) (?name STRING))
  :=> (company-name ?c ?name))

(assert (fictitious-business-name megasoft "MegaSoft"))

(defmodule "ALTERNATE-TEST"
  :includes "TEST")

(cc ALTERNATE-TEST)

(assert (and (company web-phantoms)
             (company-name web-phantoms "Web Phantoms, Inc.")))

(retract (company-name megasoft "MegaSoft, Inc."))
(assert (company-name megasoft "MegaZorch, Inc."))

(cc TEST)
(retrieve all (company-name ?x ?y))

(cc ALTERNATE-TEST)
(retrieve all (company-name ?x ?y))

(cc TEST)

(retrieve all (ist ALTERNATE-TEST (company-name ?x ?y)))
(retrieve all (and (ist TEST (company-name ?x ?y))
                   (fail (ist ALTERNATE-TEST (company-name ?x ?y)))))

(cc ALTERNATE-TEST)

(retrieve all (ist TEST (company-name ?x ?y)))
(retrieve all (and (ist TEST (company-name ?x ?y))
                   (fail (ist ALTERNATE-TEST (company-name ?x ?y)))))

(clear-module "ALTERNATE-TEST")

;;; BUG WITH CONCEPT-PROTOTYPE SPECIALIST

(clear-module "TEST")
(cc TEST)

;;; NEED TO GET THE SAME `proto-concept-XYZ' OBJECT EVERY TIME (NOT A FUNCTION TERM):
(retrieve all (and (= (concept-prototype concept) ?p1)
                   (= (concept-prototype concept) ?p2)))

(assert (relation foo))

(retrieve all (and (= (concept-prototype concept) ?p1)
                   (= (concept-prototype concept) ?p2)))

;;;;
;;;;  Testing of forward rule justifications
;;;;

(clear-module "TEST")
(cc TEST)

(set-feature :justifications)

(defconcept person)
(defrelation happy ((?x person)))
(defrelation jolly ((?x person)))
(defrelation busy ((?x person)))
(defrelation has-kids ((?x person)))
(defrelation has-job ((?x person)))
(defrelation married ((?x person) (?y person)))
(defrelation friends ((?x person) (?y person)))

(assert (=>> (married ?x ?y) (happy ?x)))
(assert (=>> (happy ?x) (jolly ?x)))
(assert (=>> (and (married ?x ?y) (has-kids ?x) (has-job ?x))
             (busy ?x)))
(assert (<<= (friends ?y ?x) (married ?x ?y)))
(assert (=>> (and (query (friends ?x ?y) :inference-level :normal)
                  (has-kids ?x)
                  (has-job ?x))
             (busy ?x)))

(assert (married fred ginger))
(assert (has-job fred))
(assert (has-kids fred))
(assert (has-job ginger))

;; Simple, one-step inference.  Works
 (ask (happy fred))
 (why)

;; Simple, chained inference.  Works
 (ask (jolly fred))
 (why)

;; More complicated rule with forward inference.  Works
 (ask (busy fred))
 (why)

;; Mixed forward & backward inference with more effort for the backward part.
 (ask (busy ginger))
 (assert (has-kids ginger))
 (ask (busy ginger))
 (why)

;; Now just do a straight-forward subsumption justification 
(defrelation r (?x))
(defrelation p (?x) :=> (r ?x))

(assert (p fred))
(ask (r fred))
(why)

(unset-feature :justifications)

;;; HOLDS ON INFERABLE DESCRIPTION TERMS

(clear-module "TEST")

(defrelation r (?x ?y))

(deffunction par-r (?par (?rel RELATION))
  :<= (= ?rel (kappa (?x)
                (r ?par ?x))))

(assert (and (r a 1)
             (r a 2)
             (r b 1)
             (r b 2)))

;;; THIS SHOULD SUCCEED:
(retrieve all (par-r a ?r))

;;; THIS SHOULD FAIL, SINCE ?r WILL BE AN "UNBOUND/OPEN" DESCRIPTION:
(retrieve all (par-r ?p ?r))

(retrieve all (and (par-r a ?r)
                   (holds ?r ?x)))

(retrieve all (exists ?p
                (and (= ?p a)
                     (par-r ?p ?r)
                     (holds ?r ?x))))

(retrieve all (exists ?p
                (and (= ?p a)
                     (holds (kappa (?x)
                              (r ?p ?x))
                            ?x))))

(retrieve all (and (= ?p a)
                   (holds (kappa (?x)
                            (r ?p ?x))
                          ?x)))

;;; FIX: THIS FAILS BUT SHOULDN'T, THE BUILD-TIME EVALUATION OF THE
;;; FUNCTION TERM PASSED TO THE HOLDS TRIPS US UP:
(retrieve all (holds (par-r a) ?x))

;;; NOW WHAT WORKED BEFORE ALSO FAILS, SINCE WE FIND A RELATION TERM
;;; AND `PAR-R' IS SINGLE VALUED:
(retrieve all (and (par-r a ?r)
                   (holds ?r ?x)))

;;; CHECKING AGAIN WITH A DIFFERENT PARAMETER, EVERYTHING IS FINE:
(retrieve all (and (par-r b ?r)
                   (holds ?r ?x)))

;;; BUT NOW WE FAIL AGAIN:
(retrieve all (holds (par-r b) ?x))

;;; AND NOW THIS FAILS ALSO:
(retrieve all (and (par-r b ?r)
                   (holds ?r ?x)))


;;; VARIABLE UNBINDING BUG IN NESTED OR EXPRESSION

(clear-module "TEST")

(defrelation primary-organization (?e ?o))
(defrelation affiliation (?p ?o))
(defrelation participant (?e ?p))
(defrelation connected-person (?e ?p))

(assert (primary-organization e1 the-cell))
(assert (and (affiliation p1 the-cell)
             (participant e2 p1)))
(assert (participant e2 p2))
(assert (connected-person e3 p3))

;;; THIS DOES THE RIGHT THING (RETURNING E2):
(retrieve all (exists ?p
                (and (affiliation ?p the-cell)
                     (or (participant ?e ?p)
                         (connected-person ?e ?p))))
          :sort-by :values)

;;; THIS SHOULD RETURN E1 AND E2 ONLY:
(retrieve all (or (primary-organization ?e the-cell)
                  (exists ?p
                    (and (affiliation ?p the-cell)
                         (or (participant ?e ?p)
                             (connected-person ?e ?p)))))
          :sort-by :values)

;;; HOLDS HANDLING IN UPDATE-TUPLE

(clear-module "TEST")

(deffunction sense-instance ((?s concept) ?i)
   :total true
   ;; this creates a rule that makes `holds' a superrelation to `sense-instance', and
   ;; which is instantiated via named-description inheritance using update-tuple;
   ;; hence, we have to make sure `update-tuple' can handle HOLDS relations:
   :=>> (holds ?s ?i))

(defconcept s1)
(assert (sense-instance s1 s1-inst))

;;; SHOULD RETURN TRUE:
(ask (s1 s1-inst))

;;; SORTED COLLECTION UTILITIES:

(clear-module "TEST")

(retrieve all (minimum-element relation (kappa (?r ?v) (- 10 (arity ?r) ?v)) ?e))
(retrieve all (minimum-element relation (kappa (?r ?v) (- (arity ?r) 10 ?v)) ?e))
(retrieve all (maximum-element relation (kappa (?r ?v) (- 10 (arity ?r) ?v)) ?e))
(retrieve all (maximum-element relation (kappa (?r ?v) (- (arity ?r) 10 ?v)) ?e))

;;; CLASHES ON INEQUALITIES

(clear-module "TEST")

(assert (< 9 6))

;;; THIS NEEDS TO REPORT A CLASH:
(run-forward-rules :force? true)
(list-inconsistent-propositions)

(clear-module "TEST")

(deffunction start (?x (?s INTEGER)))
(deffunction end (?x (?e INTEGER)))

(assert
  (=>> (and (start ?x ?s)
            (end ?x ?e))
       (=< ?s ?e)))

(assert (start myint 10))
(assert (end myint 6))

;;; THIS NEEDS TO REPORT A CLASH:
(run-forward-rules :force? true)
(list-inconsistent-propositions)


;;; IMPROVED SUBSTRING SPECIALIST

(clear-module "TEST")

(ask (substring "shoobedoobedoo" 2 6 "oobe"))
(retrieve all (substring "shoobedoobedoo" 2 6 ?sub))
(retrieve all (substring "shoobedoobedoo" 2 -1 ?sub))
(retrieve all (substring "shoobedoobedoo" ?s 6 "oobe"))
(retrieve all (substring "shoobedoobedoo" 2 ?e "oobe"))
(retrieve all (substring "shoobedoobedoo" ?s ?e "oobe"))
;; like 'starts-with?':
(retrieve all (substring "shoobedoobedoo" 0 ?e "shoo"))
;; like 'ends-with?':
(retrieve all (substring "shoobedoobedoo" ?s -1 "doo"))
;; computes length:
(retrieve all (substring "shoobedoobedoo" ?s -1 ""))
;; argument coercion:
(retrieve all (substring 121314 ?s ?e 1))

;; failure cases:
(ask (substring "shoobedoobedoo" 2 6 "uube"))
(retrieve all (substring "shoobedoobedoo" -2 6 ?sub))
(retrieve all (substring "shoobedoobedoo" 2 16 ?sub))
(retrieve all (substring "shoobedoobedoo" 4 2 ?sub))
(retrieve all (substring "shoobedoobedoo" "2" 6 ?sub))
(retrieve all (substring "shoobedoobedoo" 2 "6" ?sub))
(retrieve all (substring ?any 0 3 "shoo"))
(retrieve all (substring "shoobedoobedoo" ?s 6 ?sub))
(retrieve all (substring "shoobedoobedoo" 2 ?e ?sub))


;;; CONSOLIDATED LENGTH FOR LISTS, IMPROVED SET NORMALIZATION

(clear-module "TEST")

(retrieve all (length (listof 3 2 1 2 3 4) ?l))
(retrieve all (length-of-list (listof 3 2 1 2 3 4) ?l))
(retrieve all (length (setof 3 2 1 2 3 4) ?l))


;;; FIXED IRR/REFLEXIVE SPECIALISTS

(clear-module "TEST")

(defrelation reflexive-r (?x ?y) :reflexive true)
(defrelation irreflexive-r (?x ?y) :irreflexive true)

(assert (reflexive-r c d))
(assert (irreflexive-r c d))

(ask (reflexive-r a a))
(ask (reflexive-r a b))
(retrieve all (reflexive-r a ?x))
(retrieve all (reflexive-r ?x a))
(retrieve all (reflexive-r ?x ?y))

(ask (irreflexive-r a a))
(ask (irreflexive-r a b))
(retrieve all (irreflexive-r a ?x))
(retrieve all (irreflexive-r ?x a))
(retrieve all (irreflexive-r ?x ?y))


;;; GENERALIZED COMPUTATIONS TO ALLOW SKOLEM ARGUMENTS IF SUPPORTED

(clear-module "TEST")

(deffunction boss (?x ?y))

(assert (= (boss fred) (boss joe)))

(retrieve all (insert-element (listof 1 2 3) -1 (boss fred) ?list))


;;; LIST/SET SKOLEM AND TYPE-PROP IN WRONG CONTEXT BUG

(defmodule "TEST/TEST2")
(clear-module "TEST")

(retrieve (length (nth-rest (listof 1 2 3) 2) ?l))

(cc TEST2)
(retrieve (length (nth-rest (listof 1 2 3) 2) ?l))
(cc TEST)


;;;;
;;;; EOF
;;;;
